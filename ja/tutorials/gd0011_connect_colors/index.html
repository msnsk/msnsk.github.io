<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム | Peanuts Code</title>
<meta name=keywords content="GodotEngine,GameDev,2D,PuzzleGame,MobileGame,Match3"><meta name=description content="このチュートリアルでは、スマホゲームで大人気の ディズニーツムツムのような同じ色のドロップをなぞってつなげて消すタイプのゲームの作り方を説明する。ちなみにディズニーツムツムを知らない方は以下のリンク先を一度ご覧いただきたい。
LINE：ディズニー ツムツム



Other Tutorials

「パズル＆ドラゴンズ」のようなゲームを作ってみたい場合：
Godot で作る進化形マッチ 3 パズルゲーム

「キャンディークラッシュ」のようなゲームを作ってみたい場合：
Godot で作るマッチ 3 パズルゲーム
"><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/"><meta property="og:site_name" content="Peanuts Code"><meta property="og:title" content="🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム"><meta property="og:description" content="このチュートリアルでは、スマホゲームで大人気の ディズニーツムツムのような同じ色のドロップをなぞってつなげて消すタイプのゲームの作り方を説明する。ちなみにディズニーツムツムを知らない方は以下のリンク先を一度ご覧いただきたい。
LINE：ディズニー ツムツム Other Tutorials 「パズル＆ドラゴンズ」のようなゲームを作ってみたい場合：
Godot で作る進化形マッチ 3 パズルゲーム 「キャンディークラッシュ」のようなゲームを作ってみたい場合：
Godot で作るマッチ 3 パズルゲーム "><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-06-14T22:43:45+09:00"><meta property="article:modified_time" content="2022-06-20T00:00:00+00:00"><meta property="article:tag" content="GodotEngine"><meta property="article:tag" content="GameDev"><meta property="article:tag" content="2D"><meta property="article:tag" content="PuzzleGame"><meta property="article:tag" content="MobileGame"><meta property="article:tag" content="Match3"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0011_connect_colors/img36.gif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0011_connect_colors/img36.gif"><meta name=twitter:title content="🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム"><meta name=twitter:description content="このチュートリアルでは、スマホゲームで大人気の ディズニーツムツムのような同じ色のドロップをなぞってつなげて消すタイプのゲームの作り方を説明する。ちなみにディズニーツムツムを知らない方は以下のリンク先を一度ご覧いただきたい。
LINE：ディズニー ツムツム



Other Tutorials

「パズル＆ドラゴンズ」のようなゲームを作ってみたい場合：
Godot で作る進化形マッチ 3 パズルゲーム

「キャンディークラッシュ」のようなゲームを作ってみたい場合：
Godot で作るマッチ 3 パズルゲーム
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"🤖 チュート","item":"https://www.peanuts-code.com/ja/tutorials/"},{"@type":"ListItem","position":2,"name":"🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム","item":"https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム","name":"🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム","description":"このチュートリアルでは、スマホゲームで大人気の ディズニーツムツムのような同じ色のドロップをなぞってつなげて消すタイプのゲームの作り方を説明する。ちなみにディズニーツムツムを知らない方は以下のリンク先を一度ご覧いただきたい。\nLINE：ディズニー ツムツム Other Tutorials 「パズル＆ドラゴンズ」のようなゲームを作ってみたい場合：\nGodot で作る進化形マッチ 3 パズルゲーム 「キャンディークラッシュ」のようなゲームを作ってみたい場合：\nGodot で作るマッチ 3 パズルゲーム ","keywords":["GodotEngine","GameDev","2D","PuzzleGame","MobileGame","Match3"],"articleBody":"このチュートリアルでは、スマホゲームで大人気の ディズニーツムツムのような同じ色のドロップをなぞってつなげて消すタイプのゲームの作り方を説明する。ちなみにディズニーツムツムを知らない方は以下のリンク先を一度ご覧いただきたい。\nLINE：ディズニー ツムツム Other Tutorials 「パズル＆ドラゴンズ」のようなゲームを作ってみたい場合：\nGodot で作る進化形マッチ 3 パズルゲーム 「キャンディークラッシュ」のようなゲームを作ってみたい場合：\nGodot で作るマッチ 3 パズルゲーム なお、このチュートリアルで最後にできあがるプロジェクトのファイルは GitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.4\n・コンピュータのOS: macOS 11.6.5\nMemo: ゲームを作り始めるのに以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 新規プロジェクトを作成する まずは Godot Engine を立ち上げて、新規プロジェクトを作成してほしい。プロジェクトの名前は「Connect Colors Start」としておこう。\nプロジェクト設定を更新する エディタが表示されたら、先にプロジェクト全体に関わる設定を更新しておこう。\nまずはゲームのディスプレイサイズを設定する。今回はスマホの縦向きの画面を想定して、縦横の比率を16:9とした。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。 「Size」セクションで以下の項目の値を変更する。 Width: 144 Height: 256 Test Width: 288 Test Height: 512\n「Stretch」セクションで以下の項目の値を変更する。 Mode: 2d Aspect: keep\nそのまま「プロジェクト設定」ウインドウを開いた状態で、デバッグパネルでスマホのタッチ操作をマウスで代用するための設定をする。\n「一般」タブで「mouse」で検索し、サイドバーの「Input Devices」＞「Pointing」を選択する。 「Emulate Touch From Mouse」の On のチェックを入れる。\nさらに「プロジェクト設定」ウインドウを開いた状態で、インプットマップにスマホのタッチ操作の相当するアクションを追加しよう。\n「インプットマップ」タブに切り替え、アクションに「tap」を追加する。 「tap」の操作にマウスの左クリックを追加する。\nアセットをダウンロードしてインポートする 次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは Pixel Platformer というアセットパックだ。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「Tilemap」フォルダ内の「characters_packed.png」ファイルをエディタのファイルシステムドックへドラッグ\u0026ドロップしてプロジェクトにインポートしよう。\nファイルをインポートした直後は画像がぼやけた感じになっているので、これを以下の手順で修正しておく。\nファイルシステムドックでインポートしたアセットファイルを選択した状態にする\nインポートドックで「プリセット」＞「2D Pixel」を選択する\n一番下にある「再インポート」ボタンをクリックする。\nこれでピクセルアート特有のエッジの効いた画像になる。\nWorld シーンを作る まず最初のシーンとして、ゲームの舞台を用意する。「World」という名前のシーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Node2D」クラスのノードをルートノードとして選択。 ルートノードの名前を「World」に変更する。 一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://World/World.tscn」としてシーンを保存する。\nWorld シーンにノードを追加する World シーンが以下のシーンツリーになるようにノードを追加しよう。なお、それぞれのプロパティ編集は後で順番にやっていくので一旦そのままで良い。\nWorld (Node2D) Bin (StaticBody2D) CollisionPolygon2D SpawnPath (Path2D) Spawner (PathFollow2D) AnimationPlayer Drops (Node2D) DropsLine (Line2D) Pointer (Area2D) CollisionShape2D シーンツリードックの表示は以下のようになったはずだ。\nWorld シーンのノードを編集する Bin (StaticBody2D) ノード このノードの編集は不要だ。「StaticBody2D」は 2D ゲームにおいて、移動しない障害物や壁などに利用される。今回は落ちてくるドロップ（なぞって消すオブジェクト）を画面内にとどめるための入れ物（ビン）として利用する。\nCollisionPolygon2D ノード このノードは親ノードの「Bin」にコリジョン形状を付与するための利用する。コリジョン形状は 2D ワークスペース上で点を打って作る。\n2D ワークスペースのツールバーでグリッドスナップを有効にする。\n基本的に、ウインドウ枠の外側を囲むように点を打ってコリジョン形状を成形する。ただし、上部は、ディスプレイサイズの y 座標 0 より -64px ずらして成形する。理由は、ウインドウ枠上部外側でドロップを生成して落下させるためだ。また、コリジョンポリゴン下部はディスプレイサイズよりやや内側まで配置し、ドロップが転がるように少し斜めにしている。\nSpawnPath (Path2D) ノード このノードはドロップの生成位置を x 軸方向に常に移動させるために使う。これは、ドロップが毎回画面上部の同じ位置から落ちてくるのを防ぐ役割だ。これをウインドウ枠の上部外側に配置する。\n2D ワークスペース上で (16, -32) と (128, -32) の２つの点を打って x 軸に並行な直線のパスを作る。\nSpawner (PathFollow2D) ノード このノードは先に編集した「SpawnPath」ノードのパス上を移動するノードだ。このノードを常にパスに沿って往復させ、このノードの位置からドロップを生成するようにする。これによりドロップの落下位置が「SpawnPath」ノードのパスの範囲で常に変化する\nプロパティ「Rotate」をオフにする。\nAnimationPlayer ノード このノードは「Spawner」を「SpawnPath」のパスに沿って常に往復移動させるために利用する。「Spawner」のプロパティ「Unit Offset」は、親ノード「SpawnPath」のパスの開始位置を 0、終点を 1 で表す。つまりこのプロパティを常に 0 ⇄ 1 で変化させれば、パス上を往復させることができる。\n以下の通りにアニメーションを一つ作成する。 アニメーション名: move_spawn_pos 読み込み後、自動再生: 有効 アニメーションの長さ(秒): 0.4\n*0.4 秒でパスを往復する アニメーションループ: 有効 トラック: Spawner ノード - unit_offset プロパティ Time: 0 / Value: 0 / Easing: 1.00 Time: 0.2 / Value: 1 / Easing: 1.00\n*0.2秒時点でパスの終点から折り返す\nDrops (Node2D) ノード このノードのプロパティ編集は不要だ。役割は、ドロップシーン（後ほど作成）から複数生成するインスタンスをまとめるただの入れ物だ。\nDropLine (Line2D) ノード このノードは同じ色のドロップをなぞった時に、そのドロップとドロップをつなぐ線を描画するために利用する。これにより、どのドロップをなぞってきたのか、いくつつながっているのか、が視覚的に確認しやすくなる。\nプロパティ「Width」を 2 に変更する。これは線の太さだ。\nプロパティ「Capping」＞「Joint Mode」、「Begin Cap Mode」、「End Cap Mode」をそれぞれ「Round」に変更する。これにより、線の繋ぎ目、先端、終端の形状を丸くすることができる。\nPointer (Area2D) ノード このノードの編集は不要だ。目的としては、スマホなら指、PCならマウスカーソルにこのノードを追随させて、ドロップに触っていることを検知するために利用する。のちほど、このノードの位置を常に指またはマウスカーソルの位置と同じにするためのコードをスクリプトに記述する。\nCollisionShape2D ノード このノードは、親ノード「Pointer」にコリジョン形状を付与する。指やマウスカーソルでのドロップをタッチする操作を考慮して、コリジョンはできるだけ小さい形状にする。\nプロパティ「Shape」にリソース「新規 CircleShape2D」を適用する。 適用したリソース「CircleShape2D」のプロパティ「Radius」の値を 1 にする。\n以上で各ノードの編集は完了だ。\nDrop シーンを作る ここからは同じ色をなぞって消す対象となる「Drop」シーンを作っていく。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「RigidBody2D」クラスのノードをルートノードとして選択。 ルートノードの名前を「Drop」に変更する。 一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Drops/Drop.tscn」としてシーンを保存する。\nDrop シーンにノードを追加する Drop シーンが以下のシーンツリーになるようにノードを追加しよう。なお、それぞれのプロパティ編集は後で順番にやっていくので一旦そのままで良い。\nDrop (RigidBody2D) Sprite CollisionShape2D PointableArea (Area2D) CollisionShape2D AnimationPlayer StickableArea (Area2D) CollisionShape2D シーンツリードックの表示は以下のようになったはずだ。\nDrop シーンのノードを編集する Drop (RigidBody2D) ルートノード 「Drop」シーンには、そのインスタンスを「World」シーンに追加した時、自動的に重力に従って落下したり、バウンドしたりしてもらいたい。そのような物理演算による動きをノードのプロパティに合わせて自動的に再現してくれるのが RigidBody2D クラスだ。\nインスペクタードックにて、プロパティ「Physics Material Override」に新規「PhysicsMaterial」リソースを適用する。\nプロパティ「Gravity Scale」の値を 2 にする。ドロップの落下速度を少し速くするのが目的だ。\nノードドック＞グループタブを開き、「Drops」という名前のグループを作って追加する。これはスクリプトでの条件分岐処理で重要だ。\nSprite ノード このノードで「Drop」にテクスチャ（見た目）を付与する。冒頭でインポートしたたくさんのテクスチャをまとめた1枚のスプライトシートから使いたいテクスチャの範囲を指定してスプライトのテクスチャを設定する方法を採用する。\nインスペクターにて、プロパティ「Texture」にファイルシステムからリソース「res://characters_packed.png」をドラッグして適用する。\n「Region」＞「Enabled」をオンにする。\nエディタ下部のテクスチャ領域パネルを開く。ここで行うのはスプライトシートの中の利用したいテクスチャの領域を指定する作業だ。\n作業しやすいように、展開アイコンをクリックしてパネルを広げる。\nパネル上部の「snapモード」で「グリッドスナップ」を選択する。\nパネル上部の「ステップ」を 24px 24px にする。これでグリッドのサイズがスプライトシートのテクスチャ 1 つ分と同じサイズになる。\nスプライトシート上でドラッグ操作により緑色のドロップ（見た目はエイリアンだが）の2種類のテクスチャを範囲選択する。\nインスペクターに戻り、「Animation」＞「Hframes」プロパティの値を 2 に変更する。\nCollisionShape2D ノード (ルートノード Drop の子) このノードはルートノード「Drop」にコリジョン形状を提供する。ルートノードは「RigidBody2D」クラスで、物理ボディの１つだ。物理ボディ同士の衝突判定にはコリジョン設定が必須だ。このコリジョン形状により、複数の「Drop」シーンのインスタンスが画面上でお互いにぶつかり合って、積み上がっていくことを想定している。\nプロパティ「Shape」に新規「CircleShape2D」リソースを適用する。 さらにそのリソースのプロパティ「Radius」の値を 12 に変更する。これで半径 12 px の円形のコリジョン形状ができた。2D ワークスペースで直感的にサイズ調整しても構わない。\nPointableArea (Area2D) ノード このノードは、指またはマウスカーソルがそのドロップに触れたことや離れたことを検知するために利用する。プロパティの編集は不要だが、グループの追加が必要だ。\nノードドック＞グループタブを開き、「Pointable」という名前のグループを作って追加する。これは指またはマウスカーソルがドロップに触れているかどうかを判定する際に利用する。\nCollisionShape2D (PointableArea の子)ノード このノードは、親の「PointableArea」にコリジョン形状を提供する。指やマウスカーソルがドロップの端に触っただけでは反応しないように、ルートノード「Drop」のコリジョン形状よりやや内側に収まるようにする。\nプロパティ「Shape」に新規「CircleShape2D」リソースを適用する。 さらにそのリソースのプロパティ「Radius」の値を 10 に変更する。ルートノード「Drop」のコリジョン形状よりひと回り小さくした。隣接するドロップ同士でこのコリジョン形状と重なってしまうと、ドロップから指が離れたことを検出される前に隣のドロップとの接触が検出されるため、スクリプトでの制御が難しくなってしまうのだ。2D ワークスペースで直感的にサイズ調整しても構わない。\n*このノードのコリジョン形状は内側の円 AnimationPlayer ノード ここではまず先に、指やマウスカーソルが触れていない時のドロップの待機中のアニメーションと、触れた後にそれがわかるように点滅するアニメーションを作成する。このノードは、作成したそれらのアニメーションリソースを再生するのに利用する。\n以下の通りに、ドロップの待機中のアニメーションを作成する。 アニメーション名: idle 読み込み後、自動再生: 有効 アニメーションの長さ(秒): 1 アニメーションループ: 有効 トラック: Sprite ノード - frame プロパティ Time: 0 / Value: 0 / Easing: 1.00 Time: 0.5 / Value: 1 / Easing: 1.00 Sprite ノード - modulate プロパティ Time: 0 / Value: #ffffff / Easing: 1.00\n*「flash」アニメーションでmodulateが変更された後、「idle」アニメーション再生時に確実に初期値に戻すためのトラック\n以下の通りに、ドロップの待機中のアニメーションを作成する。 アニメーション名: flash 読み込み後、自動再生: 無効 アニメーションの長さ(秒): 0.2 アニメーションループ: 有効 トラック: Sprite ノード - frame プロパティ Time: 0 / Value: 0 / Easing: 1.00 Time: 0.1 / Value: 1 / Easing: 1.00 Sprite ノード - modulate プロパティ Time: 0 / Value: #ffffff / Easing: 1.00 Time: 0.1 / Value: #64ffffff / Easing: 1.00\nStickableArea (Area2D) ノード このノードは、ドロップが他のドロップと接触しているかどうかを検知するために利用する。プロパティの編集は不要だが、グループの追加が必要だ。\nノードドック＞グループタブを開き、「Stickable」という名前のグループを作って追加する。これはドロップを指でなぞった時に「隣接している」 = 「つなげるか」かどうかを判定するのに重要だ。\nCollisionShape2D ノード このノードは、親の「StickableArea」にコリジョン形状を提供する。隣接しているドロップを検知するのに利用する。隣り合っているドロップ同士の接触を検知させるために、ルートノード「Drop」のコリジョン形状よりやや大きめにする。\nプロパティ「Shape」に新規「CircleShape2D」リソースを適用する。 さらにそのリソースのプロパティ「Radius」の値を 18 に変更する。これで半径 18 px の円形のコリジョン形状ができた。2D ワークスペースで直感的にサイズ調整しても構わない。\n*このノードのコリジョン形状は一番外側の円 以上で各ノードの編集は完了だ。\nDrop シーンをスクリプトで制御する それではルートノード「Drop」に新規スクリプトをアタッチしよう。ファイルパスを「res://Drops/Drop.gd」としてスクリプトファイルを作成する。\nひとまずスクリプトを以下のように編集してほしい。\n###Drop.gd### extends RigidBody2D # Drop シーンを継承するシーンにそれぞれの色の名前を割り当てるプロパティ # 今はブランクの文字列 export var color = \"\" # 隣接するドロップを入れる配列を stuck_drop と定義 var stuck_drops = [] # AnimationPlayerノードへの参照 # Drop のインスタンスを World シーンに追加してから利用する onready var anim_player = $AnimationPlayer 次に、「StickableArea」ノードの Area2D ノードのシグナルを利用する。隣接するドロップと接触した時に発信されるシグナル「area_entered」と、接触していたドロップが離れた時に発信されるシグナル「area_exited」をスクリプトに接続しよう。\nそれぞれのシグナルを接続したときに生成されるメソッドを以下のように編集してほしい。\n###Drop.gd### # StickableArea に他の area (Area2D クラスのノード)が当たった時に呼ばれるメソッド func _on_StickableArea_area_entered(area): # もし当たった area が Stickable グループのノードだったら if area.is_in_group(\"Stickable\"): # その親ノードを drop と定義 var drop = area.get_parent() # 配列 stuck_drops に drop を追加 stuck_drops.append(drop) # StickableArea から他の area (Area2D クラスのノード) が離れた時に呼ばれるメソッド func _on_StickableArea_area_exited(area): # もし当たった area が Stickable グループのノードだったら if area.is_in_group(\"Stickable\"): # その親ノードを drop と定義 var drop = area.get_parent() # 配列 stuck_drops の中の drop の index を調べる var index = stuck_drops.find(drop) # 配列 stuck_drops から index に該当する要素（隣接していた Drop）を削除 stuck_drops.remove(index) これで「Drop.gd」の編集は完了だ。\nDrop シーンを継承したシーンを作る さっき作った「Drop」シーンはこれから作るシーンの雛形だ。これから「Drop」シーンを継承したシーンをドロップの色の数だけ作成する。ドロップの色は、青、緑、オレンジ、赤、黄の 5 色だ。まずは青のドロップを例に手順を進めてみよう。\n「シーン」メニュー＞「新しい継承シーン」を選択する。 継承元のシーンとして「Drops.tscn」を選択する。 シーンが生成されたら、ルートノードの名前を「Blue」に変更する。\n*このルートノードの名前はそれぞれのドロップの色に合わせること。 シーンを一旦保存しておこう。ファイルパスを「res://Drops/BlueDrop.tscn」として保存する。 シーンツリードックでルートノード「BlueDrop」を選択した状態で、インスペクターで Script Variables の「Color」の値を「Blue」とする。\nシーンツリードックで「Sprite」ノードを選択する。エディタ下部の「テクスチャ領域」パネルを開き、青いエイリアンのテクスチャ２つ分を選択しよう。\n以上で、「BlueDrop」シーンは完成だ。同じ手順で残りの 4 色のシーンも作成してほしい。なお、シーンのルートノードの名前とそのプロパティ「Color」の値は以下の通りだ。\nルートノード: GreenDrop / Color: Green ルートノード: OrangeDrop / Color: Orange ルートノード: RedDrop / Color: Red ルートノード: YellowDrop / Color: Yellow 全部で 5 色のドロップの継承シーンができたら作業完了だ。\nWorld シーンをスクリプトで制御する いよいよ今回のチュートリアルも終盤に差し掛かった。では「World」シーンのルートノードにスクリプトをアタッチしよう。ファイルパスは「res://World/World.tscn」として作成する。\nスクリプトエディタが開いたら、まずは以下の通りにプロパティを定義する。\n###World.gd### extends Node2D # preloadした5色のドロップシーンを要素にもつ配列を drop_scenes として定義 const drop_scenes = [ preload(\"res://Drops/BlueDrop.tscn\"), preload(\"res://Drops/GreenDrop.tscn\"), preload(\"res://Drops/OrangeDrop.tscn\"), preload(\"res://Drops/RedDrop.tscn\"), preload(\"res://Drops/YellowDrop.tscn\") ] # つなげて消せる最小ドロップ数 export (int) var min_erasable = 3 # プレイ画面に表示される最大ドロップ数 export (int) var max_drops = 50 # 現在ゲームをプレイ中の場合は true になる var is_playing = false # 指を画面に当てたまま or マウス左クリックを押したままの場合 true になる var is_holding = false # 現在指またはマウスカーソルが当たっているドロップの参照用 var pointed_drop # 現在つなげているドロップの色 var active_color = \"\" # ホールド中の（なぞってつながっている）ドロップのリスト用の配列 var held_drops = [] # Spawnerノードへの参照 onready var spawner = $SpawnPath/Spawner # Dropsノードへの参照 onready var drops = $Drops # DropsLineノードへの参照 onready var drops_line = $DropsLine # Pointerノードへの参照 onready var pointer = $Pointer 次にゲーム開始直後に画面外上部からドロップが最大ドロップ数の 50 個落ちてくるようコーディングしていこう。\n###World.gd### # World シーンのノードが全て読み込まれたら呼ばれるメソッド func _ready(): # ランダム系のメソッドの出力結果を毎回ランダムにしてくれる組み込みメソッド randomize() # max_drops の数 (50) だけループする for _i in range(max_drops): # ドロップを生成するメソッド（このあと定義）を呼び出す spawn_drop() # 一つのドロップが生成されたら0.025秒待機して次のドロップ生成 yield(get_tree().create_timer(0.025), \"timeout\") # ドロップを生成するメソッド func spawn_drop(): # 配列 drop_scenes からランダムで選ばれた色のドロップのシーンファイルの参照 var drop_scene = drop_scenes[randi() % drop_scenes.size()] # 選択された色のドロップシーンをインスタンス化する var drop = drop_scene.instance() # ドロップのインスタンスの位置を Spawner ノードの位置と同じにする drop.position = spawner.global_position # ドロップのインスタンスを World シーンに追加する drops.add_child(drop) それではプロジェクトを実行して、ゲーム開始時のランダムに決定された色のドロップが50個降ってくる挙動を見ておこう。なお、初めてプロジェクトを実行する際はメインシーンを「World.tscn」としておこう。\n「Pointer (Area2D)」ノードの位置は、指、またはマウスカーソルの位置に追随させるようにこのあとコーディングするのだが、その時、指やマウスカーソルが「Drop」インスタンスの「PointableArea (Area2D)」と重なった時とそのあと離れた時に「Pointer」ノードがそれを検知してシグナルを発信する。それを利用して、ドロップをなぞった時の処理をコーディングしていこう。\nシーンツリードックで「Pointer」を選択し、ノードドック＞シグナルタブにて、シグナル「area_entered(area: Area2D)」とシグナル「area_exited(area: Area2D)」をスクリプトに接続する。\n自動的に生成されたメソッドを以下のように編集しよう。\n###World.gd### # Pointer ノードが他の area(Area2D オブジェクト)に触れたら呼ばれるメソッド func _on_Pointer_area_entered(area): # area が「Pointable」グループのノードだったら if area.is_in_group(\"Pointable\"): # pointed_drop に area の親ノード（Drop ノード）の参照を渡す pointed_drop = area.get_parent() # ホールド中のドロップが 0 ではなく.. # かつホールド中の最後のドロップが pointed_drop と隣接していたら if not held_drops.empty() and held_drops[-1] in pointed_drop.stuck_drops: # ドロップのつながりを更新するメソッドを呼ぶ（あとで定義） update_drops_connection() # Pointer ノードが触れていた area(Area2D オブジェクト)が離れたら呼ばれるメソッド func _on_Pointer_area_exited(area): # area が「Pointable」グループのノードだったら if area.is_in_group(\"Pointable\"): # pointed_drop を null にする pointed_drop = null 次は組み込み関数_processを利用して、毎フレーム（60FPS）呼び出したいメソッドを実行する。\n###World.gd### # 組み込み関数: 60FPSで呼び出される func _process(_delta): # DropsLine　ノードの Points プロパティを更新する update_drops_line() # 指またはマウスカーソルの操作を受けつる get_input() # DropsLine ノードの Points プロパティを更新するメソッド # ドロップが転がったり落ちたりして位置が変わるため func update_drops_line(): # ホールド中のドロップが 1 つでもある場合 if not held_drops.empty(): # テンポラリのVector2配列を作成 var temp_array = PoolVector2Array() # ホールド中のドロップに対してループ for drop in held_drops: # テンポラリの配列にホールド中のドロップの位置を追加 temp_array.append(drop.position) # DropsLine ノードの points プロパティを現在ホールド中のドロップの位置に更新 drops_line.points = temp_array # 指またはマウスの入力があったら処理するメソッド func get_input(): # Pointer ノードの位置を常に指またはマウスカーソルの位置にする pointer.position = get_global_mouse_position() # もし指で画面を押したら、もしくはマウス左ボタンを押したら if Input.is_action_just_pressed(\"tap\"): # ドロップをホールドするメソッド（あとで定義）を呼び出す hold_drop() # ホールド中のドロップのつながりを更新するメソッド（あとで定義）を呼び出す update_drops_connection() # もし指が画面から離れたら、もしくはマウス左ボタンが上がったら if Input.is_action_just_released(\"tap\"): # ホールド中のドロップを消すメソッド（あとで定義）を呼び出す erase_drops() # ホールドを解除するメソッド（あとで定義）を呼び出す release_drops() 上のコードで定義したメソッドget_input内で呼び出している以下のメソッドはこの後順番に定義していく。\nhold_drop update_drops_connection erase_drops release_drops まずはドロップを押さえた時に呼び出されるメソッドhold_dropとupdate_drops_connectionを定義していこう。\n###World.gd### # ドロップをホールド中にするメソッド func hold_drop(): # もし指またはマウスカーソルがドロップに触れていたら if pointed_drop: # ホールド中とする is_holding = true # ドロップのつながりを更新するメソッド func update_drops_connection(): # もしドロップをホールド中かつ.. # 指またはマウスカーソルがドロップに重なっていたら if is_holding and pointed_drop: # もしホールド中のドロップが 0 だったら if held_drops.empty(): # これからつなぐドロップの色を現在指または.. # マウスカーソルが触れているドロップの色とする active_color = pointed_drop.color # ドロップをつなぐメソッド（あとで定義）を呼ぶ connect_drop() # もし現在指またはマウスカーソルが触れているドロップの色が.. # つないでいるドロップの色と同じだったら elif pointed_drop.color == active_color: # ホールド中のドロップの数が 2 以上かつ現在触れている.. # ドロップがホールド中のドロップの最後から2番目と同じだったら if held_drops.size() \u003e= 2 and pointed_drop == held_drops[-2]: # つながりを解除するメソッド（あとで定義）を呼ぶ disconnect_drop() # ホールド中のドロップの中に現在指またはマウスカーソルが.. # 触れているドロップがなければ elif not pointed_drop in held_drops: # ドロップをつなぐメソッド（あとで定義）を呼ぶ connect_drop() ここで定義したメソッドupdate_drops_connection内を見ると、さらに未定義のconnect_dropメソッドとdisconnect_dropメソッドが呼ばれている。\n続けてこれらのメソッドを定義しよう。\n###World.gd### # ドロップをつなぐメソッド func connect_drop(): # 現在指またはマウスカーソルが触れているドロップのAnimationPlayerで.. # アニメーション\"flash\"を再生する pointed_drop.anim_player.play(\"flash\") # ホールド中のドロップリストに現在触れているドロップを追加する held_drops.append(pointed_drop) # DropsLine ノードの Points プロパティに現在触れているドロップの位置を追加する drops_line.add_point(pointed_drop.position) # ドロップのつながりを解除するメソッド func disconnect_drop(): # ホールド中のドロップのリストの最後のドロップを canceled_drop とする var canceled_drop = held_drops.pop_back() # canceled_drop の AnimationPlayer でアニメーション（\"flash\"）を停止する canceled_drop.anim_player.stop() # canceled_drop の AnimationPlayer でアニメーション（\"idle\"）を再生する canceled_drop.anim_player.play(\"idle\") # DropsLineノードの Points プロパティから最後の点を削除する drops_line.remove_point(drops_line.get_point_count() - 1) get_inputメソッド内で、指が画面から離れたら、またはマウス左ボタンが上がった時に呼び出される２つのメソッドerase_drops、release_dropsをこれから定義していく。\n###World.gd### # ドロップを消すメソッド func erase_drops(): # もしホールド中のドロップの数がつなげて消せる最小ドロップ数未満だったら if held_drops.size() \u003c min_erasable: # メソッドを即時終了する return # ホールド中のドロップの配列を変数 erased の値として複製 var erased = held_drops.duplicate() # 配列 erased の要素に対してループ処理 for drop in erased: # 配列 erased に含まれるドロップを解放する drop.queue_free() # 消した分、新しいドロップを生成する spawn_drop() # 0.1 秒待機（それから次のループ） yield(get_tree().create_timer(0.1), \"timeout\")\t# ドロップからホールドを解放するメソッド func release_drops(): # ホールド中ステータスを解除 is_holding = false # ホールド中のドロップの配列の要素対してループ for drop in held_drops: # 配列から取り出したドロップの AnimationPlayer で.. # アニメーションを停止する drop.anim_player.stop() # 配列から取り出したドロップの AnimationPlayer で.. # アニメーション\"idle\"を再生する drop.anim_player.play(\"idle\") # ホールド中のドロップの配列を空っぽにする held_drops.clear() # DropsLine ノードの Points プロパティを空っぽにする drops_line.clear_points() 以上で「World.gd」スクリプトの編集は完了だ。\nシーンを実行して動作確認する 最後にシーンを実行して思った通りの動きが再現できるか確認してみよう。\n以下について想定通りであることが確認できただろうか。\nマウスカーソルがドロップの中央付近にある状態でマウス左ボタンを押すとドロップがホールド状態になり「flash」アニメーションが再生される マウス左ボタンを押したまま、隣接するドロップをなぞっていくと「DropsLine」の線がつながっていく なぞってきたドロップを戻ってなぞり直すとホールドが解除され「idle」アニメーションの再生に戻る なぞったドロップが3つ以上だとマウス左ボタンを離したときにホールド中のドロップが全て消える なぞったドロップが3つ未満だとマウス左ボタンを離してもドロップは消えずホールド解除のみされる サンプルゲーム 今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。\nYour browser does not support the video tag. プロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。\nおわりに 今回のチュートリアルでは同じ色をなぞって消すパズルゲームを作った。ゲームの中毒性を感じずにはいられない種類のゲームだ。最後に作成におけるポイントをまとめておこう。\nドロップは RigidBody2D にして、エンジンに物理演算を任せる。 ドロップに、指やカーソルを検知するための Area2D クラスのノードと、隣接するドロップを検知するための Area2D クラスのノードを追加して、それらのシグナルを利用する。 指やマウスカーソルには Area2D クラスのノードを常に追随させ、ドロップとの接触にはこのノードのシグナルを利用する。 参照 KENNEY Godot Docs: 物理の紹介 Godot Docs: RigidBody2D Godot Docs: Area2Dの使用 Godot Docs: Area2D Godot Docs: CollisionShape2D Godot Docs: CollisionPolygon2D Godot Docs: Path2D Godot Docs: PathFollow2D Zenn:【Godot Engine】Path2D/PathFollow2Dを使って決まった経路で動かす方法 | syun77 Godot Docs: Line2D Qiita:【Godot】Line2Dを使ったトレイルの実装方法 | @2dgames_jp Godot Docs: Introduction to the animation features Godot Docs: AnimationPlayer UPDATE\n2022/06/20 変数holded_dropsのスペルをheld_dropsに修正（GitHubリポジトリ上のコードも修正）\n","wordCount":"11912","inLanguage":"ja","image":"https://www.peanuts-code.com/images/tutorials/gd0011_connect_colors/img36.gif","datePublished":"2022-06-14T22:43:45+09:00","dateModified":"2022-06-20T00:00:00Z","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/ja/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/en/ title=English aria-label=🇬🇧English>🇬🇧English</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/ja/ title=ホーム><span>ホーム</span></a></li><li><a href=https://www.peanuts-code.com/ja/portfolio/ title=ゲーム><span>ゲーム</span></a></li><li><a href=https://www.peanuts-code.com/ja/posts/ title=ブログ><span>ブログ</span></a></li><li><a href=https://www.peanuts-code.com/ja/tutorials/ title=チュート><span>チュート</span></a></li><li><a href=https://www.peanuts-code.com/ja/about/ title=サイト紹介><span>サイト紹介</span></a></li><li><a href=https://www.peanuts-code.com/ja/search/ title="サイト内検索 (Alt + /)" accesskey=/><span>サイト内検索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/ja/>ホーム</a>&nbsp;»&nbsp;<a href=https://www.peanuts-code.com/ja/tutorials/>🤖 チュート</a></div><h1 class="post-title entry-hint-parent">🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム</h1><div class=post-meta><span title='2022-06-14 22:43:45 +0900 +0900'>2022-06-14</span>&nbsp;·&nbsp;24 分&nbsp;|&nbsp;言語:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/>🇬🇧English</a></li></ul></div><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Godot3%20%e3%81%a7%e4%bd%9c%e3%82%8b%e5%90%8c%e3%81%98%e8%89%b2%e3%82%92%e3%81%a4%e3%81%aa%e3%81%92%e3%81%a6%e6%b6%88%e3%81%99%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0011_connect_colors%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cPuzzleGame%2cMobileGame%2cMatch3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0011_connect_colors%2f&title=%f0%9f%a4%96%20Godot3%20%e3%81%a7%e4%bd%9c%e3%82%8b%e5%90%8c%e3%81%98%e8%89%b2%e3%82%92%e3%81%a4%e3%81%aa%e3%81%92%e3%81%a6%e6%b6%88%e3%81%99%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0011_connect_colors%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/ja/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/ja/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/ja/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/ja/tags/puzzlegame/>PuzzleGame</a></li><li><a href=https://www.peanuts-code.com/ja/tags/mobilegame/>MobileGame</a></li><li><a href=https://www.peanuts-code.com/ja/tags/match3/>Match3</a></li></ul></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0011_connect_colors/img36.gif alt="Godot で作る同じ色をつなげて消すパズルゲーム"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目次</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#新規プロジェクトを作成する>新規プロジェクトを作成する</a><ul><li><a href=#プロジェクト設定を更新する>プロジェクト設定を更新する</a></li><li><a href=#アセットをダウンロードしてインポートする>アセットをダウンロードしてインポートする</a></li></ul></li><li><a href=#world-シーンを作る>World シーンを作る</a><ul><li><a href=#world-シーンにノードを追加する>World シーンにノードを追加する</a></li><li><a href=#world-シーンのノードを編集する>World シーンのノードを編集する</a></li></ul></li><li><a href=#drop-シーンを作る>Drop シーンを作る</a><ul><li><a href=#drop-シーンにノードを追加する>Drop シーンにノードを追加する</a></li><li><a href=#drop-シーンのノードを編集する>Drop シーンのノードを編集する</a></li><li><a href=#drop-シーンをスクリプトで制御する>Drop シーンをスクリプトで制御する</a></li></ul></li><li><a href=#drop-シーンを継承したシーンを作る>Drop シーンを継承したシーンを作る</a></li><li><a href=#world-シーンをスクリプトで制御する>World シーンをスクリプトで制御する</a></li><li><a href=#シーンを実行して動作確認する>シーンを実行して動作確認する</a></li><li><a href=#サンプルゲーム>サンプルゲーム</a></li><li><a href=#おわりに>おわりに</a></li><li><a href=#参照>参照</a></li></ul></nav></div></details></div><div class=post-content><p>このチュートリアルでは、スマホゲームで大人気の ディズニーツムツムのような同じ色のドロップをなぞってつなげて消すタイプのゲームの作り方を説明する。ちなみにディズニーツムツムを知らない方は以下のリンク先を一度ご覧いただきたい。</p><p><a href=https://www.disney.co.jp/games/dtt.html target=_blank>LINE：ディズニー ツムツム</a></p><br><blockquote><p><em><strong><span style=color:salmon>Other Tutorials</span></strong><br>「パズル＆ドラゴンズ」のようなゲームを作ってみたい場合：<br><a href=https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/ title="Godot で作る進化形マッチ 3 パズルゲーム">Godot で作る進化形マッチ 3 パズルゲーム</a><br>「キャンディークラッシュ」のようなゲームを作ってみたい場合：<br><a href=https://www.peanuts-code.com/ja/tutorials/gd0012_match3/ title="Godot で作るマッチ 3 パズルゲーム">Godot で作るマッチ 3 パズルゲーム</a></em></p></blockquote><br><p>なお、このチュートリアルで最後にできあがるプロジェクトのファイルは <a href=https://github.com/msnsk/ConnectColors.git target=_blank>GitHubリポジトリ</a>
に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。<br><br></p><blockquote><p><em><strong><span style=color:salmon>Environment</span></strong><br>このチュートリアルは以下の環境で作成しました。</em><br>・<em>Godot のバージョン: <strong>3.4.4</strong></em><br>・<em>コンピュータのOS: <strong>macOS 11.6.5</strong></em></p></blockquote><blockquote><p><em><strong><span style=color:salmon>Memo:</span></strong><br>ゲームを作り始めるのに以下の記事もお役立てください。<br><a href=https://www.peanuts-code.com/ja/tutorials/gd0001_download/ title="Godot をダウンロードする">Godot をダウンロードする</a><br><a href=https://www.peanuts-code.com/ja/tutorials/gd0002_project_manager/ title="Godot のプロジェクトマネージャー">Godot のプロジェクトマネージャー</a><br><a href=https://www.peanuts-code.com/ja/tutorials/gd0003_change_language/ title="Godot の言語設定">Godot の言語設定</a></em></p></blockquote><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=新規プロジェクトを作成する>新規プロジェクトを作成する</h2><p>まずは Godot Engine を立ち上げて、新規プロジェクトを作成してほしい。プロジェクトの名前は「Connect Colors Start」としておこう。</p><br><h3 id=プロジェクト設定を更新する>プロジェクト設定を更新する</h3><p>エディタが表示されたら、先にプロジェクト全体に関わる設定を更新しておこう。</p><p>まずはゲームのディスプレイサイズを設定する。今回はスマホの縦向きの画面を想定して、縦横の比率を16:9とした。</p><ol><li>「プロジェクト」メニュー＞「プロジェクト設定」を開く。</li><li>「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。</li><li>「Size」セクションで以下の項目の値を変更する。<ul><li>Width: 144</li><li>Height: 256</li><li>Test Width: 288</li><li>Test Height: 512<br><img alt="Display - Window - Size" loading=lazy src=/images/tutorials/gd0011_connect_colors/img1.png></li></ul></li><li>「Stretch」セクションで以下の項目の値を変更する。<ul><li>Mode: 2d</li><li>Aspect: keep<br><img alt="Display - Window - Stretch" loading=lazy src=/images/tutorials/gd0011_connect_colors/img2.png></li></ul></li></ol><br><p>そのまま「プロジェクト設定」ウインドウを開いた状態で、デバッグパネルでスマホのタッチ操作をマウスで代用するための設定をする。</p><ol><li>「一般」タブで「mouse」で検索し、サイドバーの「Input Devices」＞「Pointing」を選択する。</li><li>「Emulate Touch From Mouse」の On のチェックを入れる。<br><img alt="Input Devices - Pointing - Emulate Touch From Mouse" loading=lazy src=/images/tutorials/gd0011_connect_colors/img2.1.png></li></ol><br><p>さらに「プロジェクト設定」ウインドウを開いた状態で、インプットマップにスマホのタッチ操作の相当するアクションを追加しよう。</p><ol><li>「インプットマップ」タブに切り替え、アクションに「tap」を追加する。</li><li>「tap」の操作にマウスの左クリックを追加する。<br><img alt="Inputmap - action - tap" loading=lazy src=/images/tutorials/gd0011_connect_colors/img2.2.png></li></ol><br><h3 id=アセットをダウンロードしてインポートする>アセットをダウンロードしてインポートする</h3><p>次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは <strong><a href=https://www.kenney.nl/assets/pixel-platformer target=_blank>Pixel Platformer</a>
</strong>というアセットパックだ。この素晴らしすぎる無料の素材に感謝せずにはいられない。</p><p>ダウンロードしたら「Tilemap」フォルダ内の「characters_packed.png」ファイルをエディタのファイルシステムドックへドラッグ&ドロップしてプロジェクトにインポートしよう。</p><p>ファイルをインポートした直後は画像がぼやけた感じになっているので、これを以下の手順で修正しておく。</p><ol><li>ファイルシステムドックでインポートしたアセットファイルを選択した状態にする<br><img alt="select the asset" loading=lazy src=/images/tutorials/gd0011_connect_colors/img3.png></li><li>インポートドックで「プリセット」＞「2D Pixel」を選択する<br><img alt="select 2D Pixel" loading=lazy src=/images/tutorials/gd0011_connect_colors/img4.png></li><li>一番下にある「再インポート」ボタンをクリックする。<br><img alt="click reinport" loading=lazy src=/images/tutorials/gd0011_connect_colors/img5.png></li></ol><p>これでピクセルアート特有のエッジの効いた画像になる。<br><br></p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=world-シーンを作る>World シーンを作る</h2><p>まず最初のシーンとして、ゲームの舞台を用意する。「World」という名前のシーンを作成しよう。</p><ol><li>「シーン」メニュー＞「新規シーン」を選択する。</li><li>「ルートノードを生成」にて「その他のノード」を選択する。</li><li>「Node2D」クラスのノードをルートノードとして選択。</li><li>ルートノードの名前を「World」に変更する。</li><li>一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://World/World.tscn」としてシーンを保存する。<br><br></li></ol><h3 id=world-シーンにノードを追加する>World シーンにノードを追加する</h3><p>World シーンが以下のシーンツリーになるようにノードを追加しよう。なお、それぞれのプロパティ編集は後で順番にやっていくので一旦そのままで良い。</p><ul><li>World (Node2D)<ul><li>Bin (StaticBody2D)<ul><li>CollisionPolygon2D</li></ul></li><li>SpawnPath (Path2D)<ul><li>Spawner (PathFollow2D)</li></ul></li><li>AnimationPlayer</li><li>Drops (Node2D)</li><li>DropsLine (Line2D)</li><li>Pointer (Area2D)<ul><li>CollisionShape2D</li></ul></li></ul></li></ul><p>シーンツリードックの表示は以下のようになったはずだ。<br><img alt="scene tree dock" loading=lazy src=/images/tutorials/gd0011_connect_colors/img6.png><br><br></p><h3 id=world-シーンのノードを編集する>World シーンのノードを編集する</h3><h4 id=bin-staticbody2d-ノード>Bin (StaticBody2D) ノード</h4><p>このノードの編集は不要だ。「StaticBody2D」は 2D ゲームにおいて、移動しない障害物や壁などに利用される。今回は落ちてくるドロップ（なぞって消すオブジェクト）を画面内にとどめるための入れ物（ビン）として利用する。<br><br></p><h4 id=collisionpolygon2d-ノード>CollisionPolygon2D ノード</h4><p>このノードは親ノードの「Bin」にコリジョン形状を付与するための利用する。コリジョン形状は 2D ワークスペース上で点を打って作る。</p><ol><li><p>2D ワークスペースのツールバーでグリッドスナップを有効にする。<br><img alt="enable grid snap" loading=lazy src=/images/tutorials/gd0011_connect_colors/img7.png></p></li><li><p>基本的に、ウインドウ枠の外側を囲むように点を打ってコリジョン形状を成形する。ただし、上部は、ディスプレイサイズの y 座標 0 より -64px ずらして成形する。理由は、ウインドウ枠上部外側でドロップを生成して落下させるためだ。また、コリジョンポリゴン下部はディスプレイサイズよりやや内側まで配置し、ドロップが転がるように少し斜めにしている。<br><img alt="create collisoin shape" loading=lazy src=/images/tutorials/gd0011_connect_colors/img8.png><br><br></p></li></ol><h4 id=spawnpath-path2d-ノード>SpawnPath (Path2D) ノード</h4><p>このノードはドロップの生成位置を x 軸方向に常に移動させるために使う。これは、ドロップが毎回画面上部の同じ位置から落ちてくるのを防ぐ役割だ。これをウインドウ枠の上部外側に配置する。</p><ol><li>2D ワークスペース上で (16, -32) と (128, -32) の２つの点を打って x 軸に並行な直線のパスを作る。<br><img alt="create path2d path" loading=lazy src=/images/tutorials/gd0011_connect_colors/img9.png><br><br></li></ol><h4 id=spawner-pathfollow2d-ノード>Spawner (PathFollow2D) ノード</h4><p>このノードは先に編集した「SpawnPath」ノードのパス上を移動するノードだ。このノードを常にパスに沿って往復させ、このノードの位置からドロップを生成するようにする。これによりドロップの落下位置が「SpawnPath」ノードのパスの範囲で常に変化する</p><ol><li>プロパティ「Rotate」をオフにする。<br><img alt="disable property rotate" loading=lazy src=/images/tutorials/gd0011_connect_colors/img10.png><br><br></li></ol><h4 id=animationplayer-ノード>AnimationPlayer ノード</h4><p>このノードは「Spawner」を「SpawnPath」のパスに沿って常に往復移動させるために利用する。「Spawner」のプロパティ「Unit Offset」は、親ノード「SpawnPath」のパスの開始位置を 0、終点を 1 で表す。つまりこのプロパティを常に 0 ⇄ 1 で変化させれば、パス上を往復させることができる。</p><ol><li>以下の通りにアニメーションを一つ作成する。<ul><li>アニメーション名: move_spawn_pos</li><li>読み込み後、自動再生: 有効</li><li>アニメーションの長さ(秒): 0.4<br>*0.4 秒でパスを往復する</li><li>アニメーションループ: 有効</li><li>トラック:<ul><li>Spawner ノード - unit_offset プロパティ<ul><li>Time: 0 / Value: 0 / Easing: 1.00</li><li>Time: 0.2 / Value: 1 / Easing: 1.00<br>*0.2秒時点でパスの終点から折り返す<br><img alt="create animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img11.png><br><br></li></ul></li></ul></li></ul></li></ol><h4 id=drops-node2d-ノード>Drops (Node2D) ノード</h4><p>このノードのプロパティ編集は不要だ。役割は、ドロップシーン（後ほど作成）から複数生成するインスタンスをまとめるただの入れ物だ。<br><br></p><h4 id=dropline-line2d-ノード>DropLine (Line2D) ノード</h4><p>このノードは同じ色のドロップをなぞった時に、そのドロップとドロップをつなぐ線を描画するために利用する。これにより、どのドロップをなぞってきたのか、いくつつながっているのか、が視覚的に確認しやすくなる。</p><ol><li><p>プロパティ「Width」を 2 に変更する。これは線の太さだ。<br><img alt="Line2D Width property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img12.png></p></li><li><p>プロパティ「Capping」＞「Joint Mode」、「Begin Cap Mode」、「End Cap Mode」をそれぞれ「Round」に変更する。これにより、線の繋ぎ目、先端、終端の形状を丸くすることができる。<br><img alt="Line2D Capping each property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img13.png><br><br></p></li></ol><h4 id=pointer-area2d-ノード>Pointer (Area2D) ノード</h4><p>このノードの編集は不要だ。目的としては、スマホなら指、PCならマウスカーソルにこのノードを追随させて、ドロップに触っていることを検知するために利用する。のちほど、このノードの位置を常に指またはマウスカーソルの位置と同じにするためのコードをスクリプトに記述する。<br><br></p><h4 id=collisionshape2d-ノード>CollisionShape2D ノード</h4><p>このノードは、親ノード「Pointer」にコリジョン形状を付与する。指やマウスカーソルでのドロップをタッチする操作を考慮して、コリジョンはできるだけ小さい形状にする。</p><ol><li>プロパティ「Shape」にリソース「新規 CircleShape2D」を適用する。</li><li>適用したリソース「CircleShape2D」のプロパティ「Radius」の値を 1 にする。<br><img alt="CollisionShape2D Shape, Radius" loading=lazy src=/images/tutorials/gd0011_connect_colors/img14.png></li></ol><br><p>以上で各ノードの編集は完了だ。<br><br></p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=drop-シーンを作る>Drop シーンを作る</h2><p>ここからは同じ色をなぞって消す対象となる「Drop」シーンを作っていく。</p><ol><li>「シーン」メニュー＞「新規シーン」を選択する。</li><li>「ルートノードを生成」にて「その他のノード」を選択する。</li><li>「RigidBody2D」クラスのノードをルートノードとして選択。</li><li>ルートノードの名前を「Drop」に変更する。</li><li>一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Drops/Drop.tscn」としてシーンを保存する。<br><br></li></ol><h3 id=drop-シーンにノードを追加する>Drop シーンにノードを追加する</h3><p>Drop シーンが以下のシーンツリーになるようにノードを追加しよう。なお、それぞれのプロパティ編集は後で順番にやっていくので一旦そのままで良い。</p><ul><li>Drop (RigidBody2D)<ul><li>Sprite</li><li>CollisionShape2D</li><li>PointableArea (Area2D)<ul><li>CollisionShape2D</li></ul></li><li>AnimationPlayer</li><li>StickableArea (Area2D)<ul><li>CollisionShape2D</li></ul></li></ul></li></ul><p>シーンツリードックの表示は以下のようになったはずだ。<br><img alt="Drop scene tree" loading=lazy src=/images/tutorials/gd0011_connect_colors/img15.png></p><br><h3 id=drop-シーンのノードを編集する>Drop シーンのノードを編集する</h3><h4 id=drop-rigidbody2d-ルートノード>Drop (RigidBody2D) ルートノード</h4><p>「Drop」シーンには、そのインスタンスを「World」シーンに追加した時、自動的に重力に従って落下したり、バウンドしたりしてもらいたい。そのような物理演算による動きをノードのプロパティに合わせて自動的に再現してくれるのが RigidBody2D クラスだ。</p><ol><li>インスペクタードックにて、プロパティ「Physics Material Override」に新規「PhysicsMaterial」リソースを適用する。<br><img alt="Physics Material Override" loading=lazy src=/images/tutorials/gd0011_connect_colors/img16.png></li><li>プロパティ「Gravity Scale」の値を 2 にする。ドロップの落下速度を少し速くするのが目的だ。<br><img alt="Gravity Scale" loading=lazy src=/images/tutorials/gd0011_connect_colors/img17.png></li><li>ノードドック＞グループタブを開き、「Drops」という名前のグループを作って追加する。これはスクリプトでの条件分岐処理で重要だ。<br><img alt="Node dock - groups - Drops" loading=lazy src=/images/tutorials/gd0011_connect_colors/img17.1.png></li></ol><br><h4 id=sprite-ノード>Sprite ノード</h4><p>このノードで「Drop」にテクスチャ（見た目）を付与する。冒頭でインポートしたたくさんのテクスチャをまとめた1枚のスプライトシートから使いたいテクスチャの範囲を指定してスプライトのテクスチャを設定する方法を採用する。</p><ol><li>インスペクターにて、プロパティ「Texture」にファイルシステムからリソース「res://characters_packed.png」をドラッグして適用する。<br><img alt="Sprite node Texture property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img18.png></li><li>「Region」＞「Enabled」をオンにする。<br><img alt="Region > Enabled = on" loading=lazy src="/images/tutorials/gd_common/node/Sprite/property/Region%3EEnabled=On.png"></li><li>エディタ下部の<strong>テクスチャ領域</strong>パネルを開く。ここで行うのはスプライトシートの中の利用したいテクスチャの領域を指定する作業だ。<br><img alt="Region panel" loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/tab_name.png><ol><li>作業しやすいように、展開アイコンをクリックしてパネルを広げる。<br><img alt="Expand Region pannel" loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/expand_icon.png></li><li>パネル上部の「snapモード」で「グリッドスナップ」を選択する。<br><img alt="Region pannel > choose grid snap" loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/snap_mode=grid_snap.png"></li><li>パネル上部の「ステップ」を 24px 24px にする。これでグリッドのサイズがスプライトシートのテクスチャ 1 つ分と同じサイズになる。<br><img alt="Region pannel > input grid step" loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/step=24x24.png"></li><li>スプライトシート上でドラッグ操作により緑色のドロップ（見た目はエイリアンだが）の2種類のテクスチャを範囲選択する。<br><img alt="Select region" loading=lazy src=/images/tutorials/gd0011_connect_colors/img19.png></li></ol></li><li>インスペクターに戻り、「Animation」＞「Hframes」プロパティの値を 2 に変更する。<br><img alt="animation - hframes property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img20.png></li></ol><br><h4 id=collisionshape2d-ノード-ルートノード-drop-の子>CollisionShape2D ノード (ルートノード Drop の子)</h4><p>このノードはルートノード「Drop」にコリジョン形状を提供する。ルートノードは「RigidBody2D」クラスで、物理ボディの１つだ。物理ボディ同士の衝突判定にはコリジョン設定が必須だ。このコリジョン形状により、複数の「Drop」シーンのインスタンスが画面上でお互いにぶつかり合って、積み上がっていくことを想定している。</p><ol><li>プロパティ「Shape」に新規「CircleShape2D」リソースを適用する。</li><li>さらにそのリソースのプロパティ「Radius」の値を 12 に変更する。これで半径 12 px の円形のコリジョン形状ができた。2D ワークスペースで直感的にサイズ調整しても構わない。<br><img alt="CollisionShape2D - Shape - CircleShape2D" loading=lazy src=/images/tutorials/gd0011_connect_colors/img21.png> <img alt="CollisionShape2D - 2DWrokSpace" loading=lazy src=/images/tutorials/gd0011_connect_colors/img22.png></li></ol><br><h4 id=pointablearea-area2d-ノード>PointableArea (Area2D) ノード</h4><p>このノードは、指またはマウスカーソルがそのドロップに触れたことや離れたことを検知するために利用する。プロパティの編集は不要だが、グループの追加が必要だ。</p><ol><li>ノードドック＞グループタブを開き、「Pointable」という名前のグループを作って追加する。これは指またはマウスカーソルがドロップに触れているかどうかを判定する際に利用する。<br><img alt="Node dock - Groups - Pointable" loading=lazy src=/images/tutorials/gd0011_connect_colors/img23.png></li></ol><br><h4 id=collisionshape2d-pointablearea-の子ノード>CollisionShape2D (PointableArea の子)ノード</h4><p>このノードは、親の「PointableArea」にコリジョン形状を提供する。指やマウスカーソルがドロップの端に触っただけでは反応しないように、ルートノード「Drop」のコリジョン形状よりやや内側に収まるようにする。</p><ol><li>プロパティ「Shape」に新規「CircleShape2D」リソースを適用する。</li><li>さらにそのリソースのプロパティ「Radius」の値を 10 に変更する。ルートノード「Drop」のコリジョン形状よりひと回り小さくした。隣接するドロップ同士でこのコリジョン形状と重なってしまうと、ドロップから指が離れたことを検出される前に隣のドロップとの接触が検出されるため、スクリプトでの制御が難しくなってしまうのだ。2D ワークスペースで直感的にサイズ調整しても構わない。<br><img alt="CollisionShape2D - Shape - CircleShape2D" loading=lazy src=/images/tutorials/gd0011_connect_colors/img24.png><img alt="CollisionShape2D - 2DWrokSpace" loading=lazy src=/images/tutorials/gd0011_connect_colors/img25.png>*このノードのコリジョン形状は内側の円</li></ol><br><h4 id=animationplayer-ノード-1>AnimationPlayer ノード</h4><p>ここではまず先に、指やマウスカーソルが触れていない時のドロップの待機中のアニメーションと、触れた後にそれがわかるように点滅するアニメーションを作成する。このノードは、作成したそれらのアニメーションリソースを再生するのに利用する。</p><ol><li>以下の通りに、ドロップの待機中のアニメーションを作成する。<ul><li>アニメーション名: idle</li><li>読み込み後、自動再生: 有効</li><li>アニメーションの長さ(秒): 1</li><li>アニメーションループ: 有効</li><li>トラック:<ul><li>Sprite ノード - frame プロパティ<ul><li>Time: 0 / Value: 0 / Easing: 1.00</li><li>Time: 0.5 / Value: 1 / Easing: 1.00</li></ul></li><li>Sprite ノード - modulate プロパティ<ul><li>Time: 0 / Value: #ffffff / Easing: 1.00<br>*「flash」アニメーションでmodulateが変更された後、「idle」アニメーション再生時に確実に初期値に戻すためのトラック<br><img alt="2D Workspace - idle animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img26.gif><img alt="Animation panel - idle animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img26.png></li></ul></li></ul></li></ul></li><li>以下の通りに、ドロップの待機中のアニメーションを作成する。<ul><li>アニメーション名: flash</li><li>読み込み後、自動再生: 無効</li><li>アニメーションの長さ(秒): 0.2</li><li>アニメーションループ: 有効</li><li>トラック:<ul><li>Sprite ノード - frame プロパティ<ul><li>Time: 0 / Value: 0 / Easing: 1.00</li><li>Time: 0.1 / Value: 1 / Easing: 1.00</li></ul></li><li>Sprite ノード - modulate プロパティ<ul><li>Time: 0 / Value: #ffffff / Easing: 1.00</li><li>Time: 0.1 / Value: #64ffffff / Easing: 1.00<br><img alt="2D Workspace - flash animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img27.gif><img alt="Animation panel - flash animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img27.png></li></ul></li></ul></li></ul></li></ol><br><h4 id=stickablearea-area2d-ノード>StickableArea (Area2D) ノード</h4><p>このノードは、ドロップが他のドロップと接触しているかどうかを検知するために利用する。プロパティの編集は不要だが、グループの追加が必要だ。</p><ol><li>ノードドック＞グループタブを開き、「Stickable」という名前のグループを作って追加する。これはドロップを指でなぞった時に「隣接している」 = 「つなげるか」かどうかを判定するのに重要だ。<br><img alt="Node dock - Groups - Stickable" loading=lazy src=/images/tutorials/gd0011_connect_colors/img28.png></li></ol><br><h4 id=collisionshape2d-ノード-1>CollisionShape2D ノード</h4><p>このノードは、親の「StickableArea」にコリジョン形状を提供する。隣接しているドロップを検知するのに利用する。隣り合っているドロップ同士の接触を検知させるために、ルートノード「Drop」のコリジョン形状よりやや大きめにする。</p><ol><li>プロパティ「Shape」に新規「CircleShape2D」リソースを適用する。</li><li>さらにそのリソースのプロパティ「Radius」の値を 18 に変更する。これで半径 18 px の円形のコリジョン形状ができた。2D ワークスペースで直感的にサイズ調整しても構わない。<br><img alt="CollisionShape2D - Shape - CircleShape2D" loading=lazy src=/images/tutorials/gd0011_connect_colors/img29.png><img alt="CollisionShape2D - 2DWrokSpace" loading=lazy src=/images/tutorials/gd0011_connect_colors/img30.png>*このノードのコリジョン形状は一番外側の円</li></ol><br><p>以上で各ノードの編集は完了だ。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><h3 id=drop-シーンをスクリプトで制御する>Drop シーンをスクリプトで制御する</h3><p>それではルートノード「Drop」に新規スクリプトをアタッチしよう。ファイルパスを「res://Drops/Drop.gd」としてスクリプトファイルを作成する。</p><p>ひとまずスクリプトを以下のように編集してほしい。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Drop.gd###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>RigidBody2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Drop シーンを継承するシーンにそれぞれの色の名前を割り当てるプロパティ</span>
</span></span><span class=line><span class=cl><span class=c1># 今はブランクの文字列</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>color</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 隣接するドロップを入れる配列を stuck_drop と定義</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>stuck_drops</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># AnimationPlayerノードへの参照</span>
</span></span><span class=line><span class=cl><span class=c1># Drop のインスタンスを World シーンに追加してから利用する</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>anim_player</span> <span class=o>=</span> <span class=nx>$AnimationPlayer</span>
</span></span></code></pre></div><br><p>次に、「StickableArea」ノードの Area2D ノードのシグナルを利用する。隣接するドロップと接触した時に発信されるシグナル「area_entered」と、接触していたドロップが離れた時に発信されるシグナル「area_exited」をスクリプトに接続しよう。<br><img alt="StickableArea - signals" loading=lazy src=/images/tutorials/gd0011_connect_colors/img31.png></p><p>それぞれのシグナルを接続したときに生成されるメソッドを以下のように編集してほしい。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Drop.gd###</span>
</span></span><span class=line><span class=cl><span class=c1># StickableArea に他の area (Area2D クラスのノード)が当たった時に呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_StickableArea_area_entered</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># もし当たった area が Stickable グループのノードだったら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Stickable&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># その親ノードを drop と定義</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>drop</span> <span class=o>=</span> <span class=n>area</span><span class=o>.</span><span class=nf>get_parent</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># 配列 stuck_drops に drop を追加</span>
</span></span><span class=line><span class=cl>		<span class=n>stuck_drops</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=n>drop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># StickableArea から他の area (Area2D クラスのノード) が離れた時に呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_StickableArea_area_exited</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># もし当たった area が Stickable グループのノードだったら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Stickable&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># その親ノードを drop と定義</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>drop</span> <span class=o>=</span> <span class=n>area</span><span class=o>.</span><span class=nf>get_parent</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># 配列 stuck_drops の中の drop の index を調べる</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>index</span> <span class=o>=</span> <span class=n>stuck_drops</span><span class=o>.</span><span class=nf>find</span><span class=p>(</span><span class=n>drop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># 配列 stuck_drops から index に該当する要素（隣接していた Drop）を削除</span>
</span></span><span class=line><span class=cl>		<span class=n>stuck_drops</span><span class=o>.</span><span class=nf>remove</span><span class=p>(</span><span class=n>index</span><span class=p>)</span>
</span></span></code></pre></div><br><p>これで「Drop.gd」の編集は完了だ。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=drop-シーンを継承したシーンを作る>Drop シーンを継承したシーンを作る</h2><p>さっき作った「Drop」シーンはこれから作るシーンの雛形だ。これから「Drop」シーンを継承したシーンをドロップの色の数だけ作成する。ドロップの色は、青、緑、オレンジ、赤、黄の 5 色だ。まずは<strong>青</strong>のドロップを例に手順を進めてみよう。</p><ol><li>「シーン」メニュー＞「新しい継承シーン」を選択する。</li><li>継承元のシーンとして「Drops.tscn」を選択する。</li><li>シーンが生成されたら、ルートノードの名前を「Blue」に変更する。<br>*このルートノードの名前はそれぞれのドロップの色に合わせること。</li><li>シーンを一旦保存しておこう。ファイルパスを「res://Drops/BlueDrop.tscn」として保存する。</li><li>シーンツリードックでルートノード「BlueDrop」を選択した状態で、インスペクターで Script Variables の「Color」の値を「Blue」とする。<br><img alt="BlueDrop - Color property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img32.png></li><li>シーンツリードックで「Sprite」ノードを選択する。エディタ下部の「テクスチャ領域」パネルを開き、<strong>青いエイリアン</strong>のテクスチャ２つ分を選択しよう。<br><img alt="Sprite - Texture Region" loading=lazy src=/images/tutorials/gd0011_connect_colors/img33.png></li></ol><p>以上で、「BlueDrop」シーンは完成だ。同じ手順で残りの 4 色のシーンも作成してほしい。なお、シーンのルートノードの名前とそのプロパティ「Color」の値は以下の通りだ。</p><ul><li>ルートノード: GreenDrop / Color: Green</li><li>ルートノード: OrangeDrop / Color: Orange</li><li>ルートノード: RedDrop / Color: Red</li><li>ルートノード: YellowDrop / Color: Yellow</li></ul><p>全部で 5 色のドロップの継承シーンができたら作業完了だ。</p><br><hr><h2 id=world-シーンをスクリプトで制御する>World シーンをスクリプトで制御する</h2><p>いよいよ今回のチュートリアルも終盤に差し掛かった。では「World」シーンのルートノードにスクリプトをアタッチしよう。ファイルパスは「res://World/World.tscn」として作成する。</p><p>スクリプトエディタが開いたら、まずは以下の通りにプロパティを定義する。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###World.gd###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># preloadした5色のドロップシーンを要素にもつ配列を drop_scenes として定義</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>drop_scenes</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/BlueDrop.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/GreenDrop.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/OrangeDrop.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/RedDrop.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/YellowDrop.tscn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># つなげて消せる最小ドロップ数</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kd>var</span> <span class=n>min_erasable</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=c1># プレイ画面に表示される最大ドロップ数</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kd>var</span> <span class=n>max_drops</span> <span class=o>=</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 現在ゲームをプレイ中の場合は true になる</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_playing</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># 指を画面に当てたまま or マウス左クリックを押したままの場合 true になる</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_holding</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># 現在指またはマウスカーソルが当たっているドロップの参照用</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>pointed_drop</span>
</span></span><span class=line><span class=cl><span class=c1># 現在つなげているドロップの色</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>active_color</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># ホールド中の（なぞってつながっている）ドロップのリスト用の配列</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>held_drops</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Spawnerノードへの参照</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>spawner</span> <span class=o>=</span> <span class=nx>$SpawnPath/Spawner</span>
</span></span><span class=line><span class=cl><span class=c1># Dropsノードへの参照</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>drops</span> <span class=o>=</span> <span class=nx>$Drops</span>
</span></span><span class=line><span class=cl><span class=c1># DropsLineノードへの参照</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>drops_line</span> <span class=o>=</span> <span class=nx>$DropsLine</span>
</span></span><span class=line><span class=cl><span class=c1># Pointerノードへの参照</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>pointer</span> <span class=o>=</span> <span class=nx>$Pointer</span>
</span></span></code></pre></div><br><p>次にゲーム開始直後に画面外上部からドロップが最大ドロップ数の 50 個落ちてくるようコーディングしていこう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###World.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># World シーンのノードが全て読み込まれたら呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># ランダム系のメソッドの出力結果を毎回ランダムにしてくれる組み込みメソッド</span>
</span></span><span class=line><span class=cl>	<span class=nb>randomize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># max_drops の数 (50) だけループする</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>_i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>max_drops</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># ドロップを生成するメソッド（このあと定義）を呼び出す</span>
</span></span><span class=line><span class=cl>		<span class=nf>spawn_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># 一つのドロップが生成されたら0.025秒待機して次のドロップ生成</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.025</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ドロップを生成するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>spawn_drop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 配列 drop_scenes からランダムで選ばれた色のドロップのシーンファイルの参照</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>drop_scene</span> <span class=o>=</span> <span class=n>drop_scenes</span><span class=p>[</span><span class=nb>randi</span><span class=p>()</span> <span class=o>%</span> <span class=n>drop_scenes</span><span class=o>.</span><span class=nf>size</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>    <span class=c1># 選択された色のドロップシーンをインスタンス化する</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>drop</span> <span class=o>=</span> <span class=n>drop_scene</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># ドロップのインスタンスの位置を Spawner ノードの位置と同じにする</span>
</span></span><span class=line><span class=cl>	<span class=n>drop</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>spawner</span><span class=o>.</span><span class=n>global_position</span>
</span></span><span class=line><span class=cl>    <span class=c1># ドロップのインスタンスを World シーンに追加する</span>
</span></span><span class=line><span class=cl>	<span class=n>drops</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>drop</span><span class=p>)</span>
</span></span></code></pre></div><p>それではプロジェクトを実行して、ゲーム開始時のランダムに決定された色のドロップが50個降ってくる挙動を見ておこう。なお、初めてプロジェクトを実行する際はメインシーンを「World.tscn」としておこう。<br><img alt="run project" loading=lazy src=/images/tutorials/gd0011_connect_colors/img34.gif></p><br><p>「Pointer (Area2D)」ノードの位置は、指、またはマウスカーソルの位置に追随させるようにこのあとコーディングするのだが、その時、指やマウスカーソルが「Drop」インスタンスの「PointableArea (Area2D)」と重なった時とそのあと離れた時に「Pointer」ノードがそれを検知してシグナルを発信する。それを利用して、ドロップをなぞった時の処理をコーディングしていこう。</p><p>シーンツリードックで「Pointer」を選択し、ノードドック＞シグナルタブにて、シグナル「area_entered(area: Area2D)」とシグナル「area_exited(area: Area2D)」をスクリプトに接続する。<br><img alt="connect signals" loading=lazy src=/images/tutorials/gd0011_connect_colors/img35.png></p><p>自動的に生成されたメソッドを以下のように編集しよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###World.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Pointer ノードが他の area(Area2D オブジェクト)に触れたら呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Pointer_area_entered</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># area が「Pointable」グループのノードだったら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Pointable&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># pointed_drop に area の親ノード（Drop ノード）の参照を渡す</span>
</span></span><span class=line><span class=cl>		<span class=n>pointed_drop</span> <span class=o>=</span> <span class=n>area</span><span class=o>.</span><span class=nf>get_parent</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># ホールド中のドロップが 0 ではなく..</span>
</span></span><span class=line><span class=cl>        <span class=c1># かつホールド中の最後のドロップが pointed_drop と隣接していたら</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=ow>not</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>empty</span><span class=p>()</span> <span class=ow>and</span> <span class=n>held_drops</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=ow>in</span> <span class=n>pointed_drop</span><span class=o>.</span><span class=n>stuck_drops</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># ドロップのつながりを更新するメソッドを呼ぶ（あとで定義）</span>
</span></span><span class=line><span class=cl>			<span class=nf>update_drops_connection</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Pointer ノードが触れていた area(Area2D オブジェクト)が離れたら呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Pointer_area_exited</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># area が「Pointable」グループのノードだったら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Pointable&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># pointed_drop を null にする</span>
</span></span><span class=line><span class=cl>		<span class=n>pointed_drop</span> <span class=o>=</span> <span class=kt>null</span>
</span></span></code></pre></div><br><p>次は組み込み関数<code>_process</code>を利用して、毎フレーム（60FPS）呼び出したいメソッドを実行する。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###World.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 組み込み関数: 60FPSで呼び出される</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_process</span><span class=p>(</span><span class=n>_delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># DropsLine　ノードの Points プロパティを更新する</span>
</span></span><span class=line><span class=cl>	<span class=nf>update_drops_line</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 指またはマウスカーソルの操作を受けつる</span>
</span></span><span class=line><span class=cl>	<span class=nf>get_input</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># DropsLine ノードの Points プロパティを更新するメソッド</span>
</span></span><span class=line><span class=cl><span class=c1># ドロップが転がったり落ちたりして位置が変わるため</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>update_drops_line</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># ホールド中のドロップが 1 つでもある場合</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=ow>not</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>empty</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=c1># テンポラリのVector2配列を作成</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>temp_array</span> <span class=o>=</span> <span class=nf>PoolVector2Array</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># ホールド中のドロップに対してループ</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>drop</span> <span class=ow>in</span> <span class=n>held_drops</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># テンポラリの配列にホールド中のドロップの位置を追加</span>
</span></span><span class=line><span class=cl>			<span class=n>temp_array</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=n>drop</span><span class=o>.</span><span class=n>position</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># DropsLine ノードの points プロパティを現在ホールド中のドロップの位置に更新</span>
</span></span><span class=line><span class=cl>		<span class=n>drops_line</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>temp_array</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指またはマウスの入力があったら処理するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>get_input</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Pointer ノードの位置を常に指またはマウスカーソルの位置にする</span>
</span></span><span class=line><span class=cl>	<span class=n>pointer</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=nf>get_global_mouse_position</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># もし指で画面を押したら、もしくはマウス左ボタンを押したら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;tap&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># ドロップをホールドするメソッド（あとで定義）を呼び出す</span>
</span></span><span class=line><span class=cl>		<span class=nf>hold_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># ホールド中のドロップのつながりを更新するメソッド（あとで定義）を呼び出す</span>
</span></span><span class=line><span class=cl>		<span class=nf>update_drops_connection</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># もし指が画面から離れたら、もしくはマウス左ボタンが上がったら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_released</span><span class=p>(</span><span class=s2>&#34;tap&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># ホールド中のドロップを消すメソッド（あとで定義）を呼び出す</span>
</span></span><span class=line><span class=cl>		<span class=nf>erase_drops</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># ホールドを解除するメソッド（あとで定義）を呼び出す</span>
</span></span><span class=line><span class=cl>		<span class=nf>release_drops</span><span class=p>()</span>
</span></span></code></pre></div><p>上のコードで定義したメソッド<code>get_input</code>内で呼び出している以下のメソッドはこの後順番に定義していく。</p><ul><li><code>hold_drop</code></li><li><code>update_drops_connection</code></li><li><code>erase_drops</code></li><li><code>release_drops</code></li></ul><br><p>まずはドロップを押さえた時に呼び出されるメソッド<code>hold_drop</code>と<code>update_drops_connection</code>を定義していこう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###World.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ドロップをホールド中にするメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hold_drop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># もし指またはマウスカーソルがドロップに触れていたら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>pointed_drop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># ホールド中とする</span>
</span></span><span class=line><span class=cl>		<span class=n>is_holding</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ドロップのつながりを更新するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>update_drops_connection</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># もしドロップをホールド中かつ..</span>
</span></span><span class=line><span class=cl>    <span class=c1># 指またはマウスカーソルがドロップに重なっていたら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>is_holding</span> <span class=ow>and</span> <span class=n>pointed_drop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># もしホールド中のドロップが 0 だったら</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>empty</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=c1># これからつなぐドロップの色を現在指または..</span>
</span></span><span class=line><span class=cl>            <span class=c1># マウスカーソルが触れているドロップの色とする</span>
</span></span><span class=line><span class=cl>			<span class=n>active_color</span> <span class=o>=</span> <span class=n>pointed_drop</span><span class=o>.</span><span class=n>color</span>
</span></span><span class=line><span class=cl>            <span class=c1># ドロップをつなぐメソッド（あとで定義）を呼ぶ</span>
</span></span><span class=line><span class=cl>			<span class=nf>connect_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># もし現在指またはマウスカーソルが触れているドロップの色が..</span>
</span></span><span class=line><span class=cl>        <span class=c1># つないでいるドロップの色と同じだったら</span>
</span></span><span class=line><span class=cl>		<span class=k>elif</span> <span class=n>pointed_drop</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>active_color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># ホールド中のドロップの数が 2 以上かつ現在触れている..</span>
</span></span><span class=line><span class=cl>            <span class=c1># ドロップがホールド中のドロップの最後から2番目と同じだったら</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>2</span> <span class=ow>and</span> <span class=n>pointed_drop</span> <span class=o>==</span> <span class=n>held_drops</span><span class=p>[</span><span class=o>-</span><span class=mi>2</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=c1># つながりを解除するメソッド（あとで定義）を呼ぶ</span>
</span></span><span class=line><span class=cl>				<span class=nf>disconnect_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=c1># ホールド中のドロップの中に現在指またはマウスカーソルが..</span>
</span></span><span class=line><span class=cl>            <span class=c1># 触れているドロップがなければ</span>
</span></span><span class=line><span class=cl>			<span class=k>elif</span> <span class=ow>not</span> <span class=n>pointed_drop</span> <span class=ow>in</span> <span class=n>held_drops</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># ドロップをつなぐメソッド（あとで定義）を呼ぶ</span>
</span></span><span class=line><span class=cl>				<span class=nf>connect_drop</span><span class=p>()</span>
</span></span></code></pre></div><p>ここで定義したメソッド<code>update_drops_connection</code>内を見ると、さらに未定義の<code>connect_drop</code>メソッドと<code>disconnect_drop</code>メソッドが呼ばれている。</p><p>続けてこれらのメソッドを定義しよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###World.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ドロップをつなぐメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>connect_drop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 現在指またはマウスカーソルが触れているドロップのAnimationPlayerで..</span>
</span></span><span class=line><span class=cl>    <span class=c1># アニメーション&#34;flash&#34;を再生する</span>
</span></span><span class=line><span class=cl>	<span class=n>pointed_drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;flash&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># ホールド中のドロップリストに現在触れているドロップを追加する</span>
</span></span><span class=line><span class=cl>	<span class=n>held_drops</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=n>pointed_drop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># DropsLine ノードの Points プロパティに現在触れているドロップの位置を追加する</span>
</span></span><span class=line><span class=cl>	<span class=n>drops_line</span><span class=o>.</span><span class=nf>add_point</span><span class=p>(</span><span class=n>pointed_drop</span><span class=o>.</span><span class=n>position</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ドロップのつながりを解除するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>disconnect_drop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># ホールド中のドロップのリストの最後のドロップを canceled_drop とする</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=n>canceled_drop</span> <span class=o>=</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>pop_back</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># canceled_drop の AnimationPlayer でアニメーション（&#34;flash&#34;）を停止する</span>
</span></span><span class=line><span class=cl>	<span class=n>canceled_drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># canceled_drop の AnimationPlayer でアニメーション（&#34;idle&#34;）を再生する</span>
</span></span><span class=line><span class=cl>	<span class=n>canceled_drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;idle&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># DropsLineノードの Points プロパティから最後の点を削除する</span>
</span></span><span class=line><span class=cl>	<span class=n>drops_line</span><span class=o>.</span><span class=nf>remove_point</span><span class=p>(</span><span class=n>drops_line</span><span class=o>.</span><span class=nf>get_point_count</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><br><p><code>get_input</code>メソッド内で、指が画面から離れたら、またはマウス左ボタンが上がった時に呼び出される２つのメソッド<code>erase_drops</code>、<code>release_drops</code>をこれから定義していく。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###World.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ドロップを消すメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>erase_drops</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># もしホールド中のドロップの数がつなげて消せる最小ドロップ数未満だったら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>size</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>min_erasable</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># メソッドを即時終了する</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=c1># ホールド中のドロップの配列を変数 erased の値として複製</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>erased</span> <span class=o>=</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>duplicate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># 配列 erased の要素に対してループ処理</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>drop</span> <span class=ow>in</span> <span class=n>erased</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 配列 erased に含まれるドロップを解放する</span>
</span></span><span class=line><span class=cl>		<span class=n>drop</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># 消した分、新しいドロップを生成する</span>
</span></span><span class=line><span class=cl>		<span class=nf>spawn_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># 0.1 秒待機（それから次のループ）</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.1</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>	
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ドロップからホールドを解放するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>release_drops</span><span class=p>():</span> 
</span></span><span class=line><span class=cl>    <span class=c1># ホールド中ステータスを解除</span>
</span></span><span class=line><span class=cl>	<span class=n>is_holding</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=c1># ホールド中のドロップの配列の要素対してループ</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>drop</span> <span class=ow>in</span> <span class=n>held_drops</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 配列から取り出したドロップの AnimationPlayer で..</span>
</span></span><span class=line><span class=cl>        <span class=c1># アニメーションを停止する</span>
</span></span><span class=line><span class=cl>		<span class=n>drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># 配列から取り出したドロップの AnimationPlayer で..</span>
</span></span><span class=line><span class=cl>        <span class=c1># アニメーション&#34;idle&#34;を再生する</span>
</span></span><span class=line><span class=cl>		<span class=n>drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;idle&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># ホールド中のドロップの配列を空っぽにする</span>
</span></span><span class=line><span class=cl>	<span class=n>held_drops</span><span class=o>.</span><span class=nf>clear</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># DropsLine ノードの Points プロパティを空っぽにする</span>
</span></span><span class=line><span class=cl>	<span class=n>drops_line</span><span class=o>.</span><span class=nf>clear_points</span><span class=p>()</span>
</span></span></code></pre></div><br><p>以上で「World.gd」スクリプトの編集は完了だ。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=シーンを実行して動作確認する>シーンを実行して動作確認する</h2><p>最後にシーンを実行して思った通りの動きが再現できるか確認してみよう。<br><img alt="run project finally" loading=lazy src=/images/tutorials/gd0011_connect_colors/img36.gif></p><p>以下について想定通りであることが確認できただろうか。</p><ul><li>マウスカーソルがドロップの中央付近にある状態でマウス左ボタンを押すとドロップがホールド状態になり「flash」アニメーションが再生される</li><li>マウス左ボタンを押したまま、隣接するドロップをなぞっていくと「DropsLine」の線がつながっていく</li><li>なぞってきたドロップを戻ってなぞり直すとホールドが解除され「idle」アニメーションの再生に戻る</li><li>なぞったドロップが3つ以上だとマウス左ボタンを離したときにホールド中のドロップが全て消える</li><li>なぞったドロップが3つ未満だとマウス左ボタンを離してもドロップは消えずホールド解除のみされる</li></ul><br><hr><h2 id=サンプルゲーム>サンプルゲーム</h2><p>今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。</p><div><video controls autoplay loop muted playsinline aria-label='Sample game demo' style=zgotmplz>
<source src=/images/tutorials/gd0011_connect_colors/img37.mp4 type=video/mp4>Your browser does not support the video tag.</video></div><br><p>プロジェクトファイルは、<a href=https://github.com/msnsk/ConnectColors.git target=_blank>GitHubリポジトリ</a>
に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=おわりに>おわりに</h2><p>今回のチュートリアルでは同じ色をなぞって消すパズルゲームを作った。ゲームの中毒性を感じずにはいられない種類のゲームだ。最後に作成におけるポイントをまとめておこう。</p><ul><li>ドロップは RigidBody2D にして、エンジンに物理演算を任せる。</li><li>ドロップに、指やカーソルを検知するための Area2D クラスのノードと、隣接するドロップを検知するための Area2D クラスのノードを追加して、それらのシグナルを利用する。</li><li>指やマウスカーソルには Area2D クラスのノードを常に追随させ、ドロップとの接触にはこのノードのシグナルを利用する。</li></ul><br><hr><h2 id=参照>参照</h2><ul><li><a href=https://www.kenney.nl/assets target=_blank>KENNEY</a></li><li><a href=https://docs.godotengine.org/ja/stable/tutorials/physics/physics_introduction.html target=_blank>Godot Docs: 物理の紹介</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_rigidbody2d.html target=_blank>Godot Docs: RigidBody2D</a></li><li><a href=https://docs.godotengine.org/ja/stable/tutorials/physics/using_area_2d.html target=_blank>Godot Docs: Area2Dの使用</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_area2d.html target=_blank>Godot Docs: Area2D</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_collisionshape2d.html target=_blank>Godot Docs: CollisionShape2D</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_collisionpolygon2d.html target=_blank>Godot Docs: CollisionPolygon2D</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_path2d.html target=_blank>Godot Docs: Path2D</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_pathfollow2d.html target=_blank>Godot Docs: PathFollow2D</a></li><li><a href=https://zenn.dev/syun77/articles/0ade855311ecb8 target=_blank>Zenn:【Godot Engine】Path2D/PathFollow2Dを使って決まった経路で動かす方法 | syun77</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_line2d.html target=_blank>Godot Docs: Line2D</a></li><li><a href=https://qiita.com/2dgames_jp/items/391f5d4e4b1a345b8029 target=_blank>Qiita:【Godot】Line2Dを使ったトレイルの実装方法 | @2dgames_jp</a></li><li><a href=https://docs.godotengine.org/ja/stable/tutorials/animation/introduction.html target=_blank>Godot Docs: Introduction to the animation features</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_animationplayer.html target=_blank>Godot Docs: AnimationPlayer</a></li></ul><hr><p><strong>UPDATE</strong><br>2022/06/20 変数<code>holded_drops</code>のスペルを<code>held_drops</code>に修正（GitHubリポジトリ上のコードも修正）</p><hr></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Godot3%20%e3%81%a7%e4%bd%9c%e3%82%8b%e5%90%8c%e3%81%98%e8%89%b2%e3%82%92%e3%81%a4%e3%81%aa%e3%81%92%e3%81%a6%e6%b6%88%e3%81%99%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0011_connect_colors%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cPuzzleGame%2cMobileGame%2cMatch3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0011_connect_colors%2f&title=%f0%9f%a4%96%20Godot3%20%e3%81%a7%e4%bd%9c%e3%82%8b%e5%90%8c%e3%81%98%e8%89%b2%e3%82%92%e3%81%a4%e3%81%aa%e3%81%92%e3%81%a6%e6%b6%88%e3%81%99%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0011_connect_colors%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/ja/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/ja/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/ja/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/ja/tags/puzzlegame/>PuzzleGame</a></li><li><a href=https://www.peanuts-code.com/ja/tags/mobilegame/>MobileGame</a></li><li><a href=https://www.peanuts-code.com/ja/tags/match3/>Match3</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/ja/tutorials/gd0012_match3/><span class=title>« 前へ</span><br><span>🤖 Godot3 で作るマッチ 3 パズルゲーム</span>
</a><a class=next href=https://www.peanuts-code.com/ja/tutorials/gd0008_homing_missiles/><span class=title>次へ »</span><br><span>🤖 Godot3 で作るホーミングミサイル</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/ja/>Peanuts Code</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="コピー";function s(){t.innerHTML="コピーされました!",setTimeout(()=>{t.innerHTML="コピー"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>