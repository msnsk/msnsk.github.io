<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>🤖 Godot3 で作る 2D グリッドベース移動 | Peanuts Code</title>
<meta name=keywords content="GodotEngine,GameDev,Godot3,2D,グリッドベース移動"><meta name=description content="このチュートリアルでは、2Dゲームにおける「グリッドベース移動」をどのように実装するのかを説明する。グリッドベース移動というのは、等間隔にグリッド（格子状の線）で区分されたゲームの画面上をキャラクター"><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/ja/tutorials/gd0010_2d_grid_based_movement/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0010_2d_grid_based_movement/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0010_2d_grid_based_movement/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="🤖 Godot3 で作る 2D グリッドベース移動"><meta property="og:description" content="このチュートリアルでは、2Dゲームにおける「グリッドベース移動」をどのように実装するのかを説明する。グリッドベース移動というのは、等間隔にグリッド（格子状の線）で区分されたゲームの画面上をキャラクター"><meta property="og:type" content="article"><meta property="og:url" content="https://www.peanuts-code.com/ja/tutorials/gd0010_2d_grid_based_movement/"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0010_2d_grid_based_movement/img0.gif"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-06-08T00:05:00+09:00"><meta property="article:modified_time" content="2022-06-08T00:05:00+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0010_2d_grid_based_movement/img0.gif"><meta name=twitter:title content="🤖 Godot3 で作る 2D グリッドベース移動"><meta name=twitter:description content="このチュートリアルでは、2Dゲームにおける「グリッドベース移動」をどのように実装するのかを説明する。グリッドベース移動というのは、等間隔にグリッド（格子状の線）で区分されたゲームの画面上をキャラクター"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"🤖 チュートリアル","item":"https://www.peanuts-code.com/ja/tutorials/"},{"@type":"ListItem","position":2,"name":"🤖 Godot3 で作る 2D グリッドベース移動","item":"https://www.peanuts-code.com/ja/tutorials/gd0010_2d_grid_based_movement/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"🤖 Godot3 で作る 2D グリッドベース移動","name":"🤖 Godot3 で作る 2D グリッドベース移動","description":"このチュートリアルでは、2Dゲームにおける「グリッドベース移動」をどのように実装するのかを説明する。グリッドベース移動というのは、等間隔にグリッド（格子状の線）で区分されたゲームの画面上をキャラクター","keywords":["GodotEngine","GameDev","Godot3","2D","グリッドベース移動"],"articleBody":"このチュートリアルでは、2Dゲームにおける「グリッドベース移動」をどのように実装するのかを説明する。グリッドベース移動というのは、等間隔にグリッド（格子状の線）で区分されたゲームの画面上をキャラクターなどのオブジェクトが 1 グリッド（ 1 マス）ずつ移動する動きのことだ。\n人気スマホゲーム「パズル＆ドラゴンズ」や元祖落ちゲー「テトリス」などのパズルゲームはもちろん、「ファイヤーエムブレムシリーズ」「タクティクスオウガ」などのタクティカルシミュレーションゲームで、この動きを採用しているものは多いだろう。一方、「ファイナルファンタジー」シリーズや「ドラゴンクエスト」シリーズなどの RPG も、ファミコン用やスーパーファミコン用のソフトとして登場した 2D グラフィックの時代は、キャラクターの移動をよく見ると、このグリッドベース移動を行っている。このように、グリッドベース移動はさまざまなジャンルのゲームで使用されており、その汎用性はかなり高いと言える。\nこの記事では、できるだけグリッドベース移動の実装に絞って解説していく。また、最後にグリッドベース移動を使ったサンプルゲームも紹介するので、こちらもよかったら参考にしてほしい。\nなお、このチュートリアルで最後にできあがるプロジェクトのファイルは、GitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.4\n・コンピュータのOS: macOS 11.6.5\nMemo: ゲームを作り始めるのに以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 新規プロジェクトの作成 まずは Godot Engine を立ち上げて、新規プロジェクトを作成してほしい。プロジェクトの名前は「Grid Based Movement Tutorial」とでもしておこう。\nエディタが表示されたら、先にゲームのディスプレイサイズを設定しておこう。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 「window」で検索して、サイドバーの「Display」＞「Window」を選択する。 「Size」セクションで以下の項目の値を変更する。 Width: 256 Height: 160 Test Width: 1024 Test Height: 640\n「Stretch」セクションで以下の項目の値を変更する。 Mode: 2d Aspect: keep\n続いて、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは 1-Bit Pack というアセットパックだ。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「Tilesheet」フォルダ内の「colored-transparent_packed.png」ファイルをエディタのファイルシステムドックへドラッグ\u0026ドロップしてプロジェクトにインポートしよう。\nファイルをインポートした直後は画像がぼやけた感じになっているので、これを修正する。\nファイルシステムドックでインポートしたアセットファイルを選択した状態にする\nインポートドックで「プリセット」＞「2D Pixel」を選択する\n一番下にある「再インポート」ボタンをクリックする。\nこれでピクセルアート特有のエッジの効いた画像になる。\nWorld シーンを作る まず最初のシーンとして、ゲームの世界を用意する。「World」という名前のシーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Node2D」クラスのノードをルートノードとして選択。 ルートノードの名前を「World」に変更する。 一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://World/World.tscn」としてシーンを保存する。 ルートノードに「TileMap」ノードを追加する。 これでシーンツリーは以下のようになったはずだ。\nTileMap ノードを編集する TileMap ノードのプロパティを編集する シーンツリードックで「TileMap」ノードを選択し、インスペクターでプロパティを編集しよう。\n「TileSet」プロパティに「新規 TileSet」リソースを割り当てる。\n「Cell」＞「Size」プロパティの値を(x: 16, y: 16)にする。これから利用するスプライトシートのテクスチャのサイズ（縦横 16px）に合わせて設定した。\nTileSet リソースを編集する 続けて、「TileSet」プロパティに割り当てたリソース「TileSet」を編集していく。\nインスペクターでリソースをクリックする。\nGodot エディタ下部の「TileSet」パネルが開いたら、ファイルシステムドックからスプライトシートのリソース「res://colored-transparent_packed.png」をパネル内の左サイドバーにドラッグして追加する。追加したリソースをクリックして編集モードにしよう。\n「New Single Tile」を選択する。\n「領域(Region)」タブを選択したまま、グリッドスナップを有効にする。\nインスペクターで「Snap Options」＞「Step」を (x: 16, y: 16)にして、スプライトシートのテクスチャ一つ分と同じサイズにする。\n順番に「草」と「木」のテクスチャの領域を選択して、Single Tile として登録する。\n「木」のタイルは、「コリジョン(Collision)」タブを選択して、コリジョン形状も設定する。\n以上で TileSet リソースの編集は完了だ。\nTileMap を作成する ここからは先に作成した「TileSet」リソースのタイルを配置して TileMap を作成していく。\nシーンツリードックで「TileMap」を選択した状態にする。 2D ワークスペースのツールバーからグリッドスナップを有効にする。\n同じくツールバーの「Snapping Options」をクリックし、「Configure Snap」を選択する。\n「Configure Snap」の設定パネルが開いたら、「Grid Step」を (x: 16, y: 16) にして「OK」をクリックする。\nこれで 2D ワークスペース上に、縦横 16px ごとに区切られたグリッドが表示されていることだろう。「Grid Snap」を有効にしているので、「TileMap」の編集時は、簡単にグリッドに沿ってタイルを配置できるようになっているはずだ。\nでは 2D ワークスペースにタイルを配置していく。ここではシンプルに、あとで配置するプレイヤーキャラクターが外に出ないように画面の枠を「木」のタイルで囲って、その中に「草」のタイルを敷き詰めよう。\nこれで「TileMap」の編集は完了だ。\nPlayer シーンを作る ここからはプレイヤーキャラクターのシーンを作成する。このチュートリアルで実際にグリッドベース移動させるためのオブジェクトだ。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「KinematicBody2D」クラスのノードをルートノードとして選択。 ルートノードの名前を「Player」に変更する。 一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Player/Player.tscn」としてシーンを保存する。 ルートノードに「Sprite」ノードを追加する。 ルートノードに「CollisionShape2D」ノードを追加する。 ルートノードに「RayCast2D」ノードを追加する。 これで「Player」シーンツリーは以下のようになったはずだ。\nPlayer シーンの各ノードを編集する Sprite ノード たくさんのテクスチャをまとめた1枚のスプライトシートから使いたいテクスチャの範囲を指定してスプライトのテクスチャを設定する方法を採用する。\nインスペクターにて、「Texture」プロパティにリソースファイル「res://colored-transparent_packed.png」を適用する。\n「Offset」＞「Centered」プロパティをオフにする。これにより、このノードの位置（「Position」プロパティ）がテクスチャの中央ではなく左上角になり、ちょうどグリッドのマス目に収まるようになる。\n「Region」＞「Enabled」をオンにする。\nエディタ下部の「テクスチャ領域」パネルを開く。ここで行うのはスプライトシートの中の利用したいテクスチャの領域を指定する作業だ。\n作業しやすいように、展開アイコンをクリックしてパネルを広げる。\nパネル上部の「snapモード」で「グリッドスナップ」を選択する。\nパネル上部の「ステップ」を 16px 16px にする。これでグリッドのサイズがスプライトシートのテクスチャ 1 つ分と同じサイズになる。\nスプライトシート上でドラッグ操作により「王様」のテクスチャを範囲選択する。\nCollisionShape2D ノード このノードで「KinematicBody2D」クラスのルートノードに対してコリジョン形状を設定する。\nインスペクターにて、「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。\n「Sprite」ノードのテクスチャの位置に合わせるため、 「Transform」＞「Position」プロパティの値を (x: 8, y: 8) にする。\n2Dワークスペースにて、コリジョン形状を「Sprite」ノードのテクスチャのサイズに合わせる。\nインスペクターで直接入力する場合は、「RectangleShape2D」リソースのプロパティを以下のようにする。 Extents: (x: 8, y: 8) RayCast2D ノード このノードはグリッドベース移動での衝突判定にとても役に立つ。2D ワークスペース上は矢印型のコリジョン形状として表される。その矢印とオブジェクトが重なった場合に衝突を検知する。これを利用して、プレイヤーキャラクターの前方にあるオブジェクトとの衝突を検知させ、その先には進めないようにするなど制御することができる。\nインスペクターで、「Enabled」プロパティを On にしておく。これで衝突判定が可能になる。\n「Transform」＞「Position」プロパティを (x: 8, y: 8) にしておく。これは「Sprite」のテクスチャの中央に位置を合わせるためだ。\n「Cast To」プロパティの値を (x: 16, y: 0) にしておく。これは暫定的に初期値を設定しているだけで、実際にプロジェクトを実行したら、スクリプトでプレイヤーキャラクターを移動させるたびに値を変更することになる。\n2D ワークスペース上では以下のスクリーンショットのようになったはずだ。\n「Collide With」はデフォルトのまま「Areas」は Off、「Bodies」は On にしておく。さきほど作成したタイルセットの「木」のパネルは物理ボディなので「Bodies」にチェックが入っていれば、衝突が検知される。\nPlayer ノードにグリッドベース移動を実装する インプットマップを設定する 先にキーボードのキー入力でプレイヤーキャラクターを動かせるように、プロジェクト設定のインプットマップにアクションを追加する。\n「プロジェクト」メニュー＞「プロジェクト設定」を選択したら「Input Map」タブに切り替える。 以下の４つの「Action」を追加する。 move_right: D キー move_left: A キー move_down: S キー move_up: W キー *上下左右の矢印キーを割り当ててもOK\nスクリプトをアタッチして編集する まずはルートノード「Player」にスクリプトをアタッチする。ファイルパスを「res://Player/Player.gd」としてスクリプトファイルを作成しよう。\n作成後、スクリプトエディタが開いたら、スクリプトのコードを以下のように編集してほしい。\nextends KinematicBody2D #1 const inputs = { \"move_right\": Vector2.RIGHT, \"move_left\": Vector2.LEFT, \"move_down\": Vector2.DOWN, \"move_up\": Vector2.UP } #2 var grid_size = 16 #3 onready var raycast = $RayCast2D #4 func _unhandled_input(event): for action in inputs.keys(): if event.is_action_pressed(action): move(action) #5 func move(action): var destination = inputs[action] * grid_size raycast.cast_to = destination raycast.force_raycast_update() if not raycast.is_colliding(): position += destination スクリプトには、コメントで #1 ~ #5 まで番号を振っておいた。この順番に解説していく。\n#1: 辞書型の定数inputsを定義した。先に設定しておいたインプットマップのアクションと同じ名前の Key に対して、その値にはそれぞれのアクションで移動させたい Vector2 型の方向ベクトル（長さが 1 のベクトル）を指定した形だ。ちなみにVector2クラスの組み込み定数（RIGHTやDOWNなど）の値は以下の通りだ。\nVector2.RIGHT: Vector2(1, 0) Vector2.LEFT: Vector2(-1, 0) Vector2.DOWN: Vector2(0, 1) Vector2.UP: Vector2(0, -1) #2: プロパティgrid_sizeを定義した。値は「TileMap」のタイルのサイズと同じ16としている。\n#3: プロパティraycastを定義した。これは「RayCast2D」ノードを参照するプロパティだ。\n#4: 組み込み関数_unhandled_inputをオーバーライドした。これはキーボードやマウス、ジョイスティックなどからの入力があるとすぐに呼ばれるコールバック関数だ。別の関数_inputと似ているが、ここでは細かい違いは気にしなくて大丈夫だ。\n_unhandled_inputの中で、先に定義した辞書型定数inputsに対してループ処理を行っている。もし入力されたのがinputsのキー（move_leftやmove_upなど）と同じ名前のインプットマップアクションだった場合に、そのキーに対する値（例えばキーがmove_rightならVector2.RIGHT）を引数に渡してmoveというメソッドを呼んでいる。このmoveというメソッドはこのあと定義する。\n#5: メソッドmoveを定義している。このメソッドを呼ぶときは引数actionに値を渡す必要がある。\nまず変数destinationを定義している。値には、辞書型定数inputsから引数actionとマッチするキーに対する値（例えば、actionにmove_leftが渡されている場合はVector2.LEFT）にプロパティgrid_sizeを乗算した値が入る。つまり、プレイヤーが「D」キーを入力した場合、その値は Vector2(1, 0) x 16 = Vector2(16, 0) になる。これは右方向の 1 グリッド分の長さを持つベクトルだ。\n次に「RayCast2D」ノードのプロパティcast_toに先に定義した変数destinationの値を渡している。これでプレイヤーが入力したキーに合わせて「RayCast2D」の矢印の向きと長さが置き換わる。この置き換えをただちにアップデートするのが次の行で呼んでいるforce_raycast_updateというメソッドだ。これは「RayCast2D」ノードの組み込みだ。\n次の行ではif構文が記述されている。「RayCast2D」ノードの組み込みメソッドis_collidingは、現在このノード（矢印）がオブジェクトと衝突しているかどうかを Bool 型（trueかfalse）で返してくれる。ifの後にnotがあるので、このif構文の意味としては「もし『RayCast2D』ノードがオブジェクトと衝突していなければ』となる。\n上述のif構文で「RayCast2D」が他のオブジェクトと衝突していなかった場合、「Player」ノードのプロパティpositionの値にdestinationの値が加算される。つまりdestinationの値の分だけプレイヤーキャラクターが移動する、ということになる。例えば、現在の「Player」ノードの位置がVector2(64, 32)だとして、この時プレイヤーが「S」キーを一度押すと、現在の位置からVector2(0, 16)だけ移動するので、移動先の位置はVector2(64, 48)となる。つまり、現在の位置から下方向に 1 グリッド分移動したということだ。\n以上でグリッドベース移動の制御が実装できたはずだ。\nWorld シーンに Player シーンのインスタンスを追加する 「Player」シーンが完成したので、そのインスタンスを「World」シーンに追加して、タイルマップ上を移動させてみよう。\n「World.tscn」シーンを開く ルートノード「World」に「Player.tscn」シーンのインスタンスを追加する。\n2D ワークスペースで、画面の中央あたりの適当な位置に「Player」ノードを移動する。\n以上で作業は完了だ。\nグリッドベース移動の動作確認をする 作業が完了したので、実際にグリッドベース移動が問題なくできるかどうか確認してみよう。\n特に「Player」の子ノード「RayCast2D」の矢印型コリジョン形状も確認しやすくするため、先に「デバッグ(Debug)」メニューから「Visible Collision Shapes」のチェックを入れて有効にしておこう。\n初めてプロジェクトを実行する場合は Main Scene に「res://World/World.tscn」を選択してほしい。\nそれでは、プロジェクトを実行して、大草原の中を王様がグリッドベース移動で駆け回ることができるのか見てみよう。\n一回のキー入力で、タイル 1 つ分だけ移動しているのがよくわかる。また、わざと「木」のタイルの方向に移動しようとしても移動できないことも確認できた。\n以上で、グリッドベース移動のチュートリアルは完了だ。\nサンプルゲーム 今回のグリッドベース移動を利用したサンプルゲームを用意した。プロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ OK だ。\nYour browser does not support the video tag. このサンプルは、いわゆるモグラ叩きゲームだ。ゲームの設定として、プレイヤーは王様を操り、墓から出てくる王国の兵士たちの亡霊に向かって、聖なる指輪をかざして呪われた魂を解放する、というものだ。\n操作は以下の通りだ。\nD: 右に移動 A: 左に移動 S: 下に移動 W: 上に移動 スペース: 亡霊と向かい合わせの場合のみ指輪を掲げて亡霊の魂を解放する 亡霊は 1 秒以内に指輪で成仏させないと王様に呪いをかけてくる。呪われると Life が一つ減る。Life は最初 10 用意されているが、全てなくなったら王様は呪い殺されゲームオーバーになる。\n次の亡霊が出現するまでのインターバルは、ゲーム開始時の 2 秒から徐々に短くなり、最短 1 秒まで短くなる。\nちなみに私の最高スコアは 150 だ。これがすごいのか、大したことないのかはわからない。\n補足説明 最後にこのサンプルゲームのプロジェクトについて補足しておきたい。\nゲーム中、墓石から亡霊が出現するとき、「KinematicBody2D」クラスでコリジョン形状を設定済みの「Ghost」インスタンスと「TileMap」のコリジョンを設定した墓石のタイルが重なっている状態だ。このとき「Player」インスタンスの「RayCast2D」が墓石より亡霊との衝突判定を優先させるために少し工夫している。\n「TileSet」の編集で墓石のタイルを作るときに、タイルの 1/2 のサイズのコリジョンを設定しているのだ。先にインスペクターで「Snap Options」＞「Step」を (x: 4, y: 4)にしてからコリジョン形状を設定するとスムーズだ。もちろん「Ghost」のコリジョン形状は (x: 16, y: 16) になっている。\nおわりに 今回のチュートリアルでは2Dゲームにおけるグリッドベース移動の実装について解説した。パズルゲームやシミュレーションゲームなど、これからあなたが取り組むプロジェクトに応用いただける機会があれば幸いだ。\nグリッドベース移動のポイントをまとめておこう。\n以下を正確に設定する。 リソース「TileSet」で用意したタイルの縦横のサイズ 移動させるオブジェクト（今回は「Player」）のスプライトのサイズと位置 移動させるオブジェクトのコリジョン形状のサイズと位置 2D ワークスペースの Grid Step オブジェクトのノードにアタッチしたスクリプトでの移動距離を表すプロパティの値（今回はgrid_size） 移動させるオブジェクトと他のオブジェクトとの衝突判定には「RayCast2D」を利用する。「RayCast2D」の向きとサイズはスクリプトで制御する。 プレイヤーの操作でオブジェクトを移動させるには、インプットマップのアクションを登録しておき、スクリプトでそれぞれの入力に対して移動する方向を制御する。 参照 KENNEY Godot Docs: RayCast2D Godot Docs: Using TileMaps Godot Docs: TileSet KidsCanCode: Grid-based movement YouTube: Grid-based movement Godot 3 demo overview YouTube: Make your first 2D grid-based game from scratch in Godot ","wordCount":"8194","inLanguage":"ja","image":"https://www.peanuts-code.com/images/tutorials/gd0010_2d_grid_based_movement/img0.gif","datePublished":"2022-06-08T00:05:00+09:00","dateModified":"2022-06-08T00:05:00+09:00","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/ja/tutorials/gd0010_2d_grid_based_movement/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/ja/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/ja/ title=ホーム><span>ホーム</span></a></li><li><a href=https://www.peanuts-code.com/ja/portfolio/ title=作ったゲーム><span>作ったゲーム</span></a></li><li><a href=https://www.peanuts-code.com/ja/posts/ title=ブログ><span>ブログ</span></a></li><li><a href=https://www.peanuts-code.com/ja/tutorials/ title=チュートリアル><span>チュートリアル</span></a></li><li><a href=https://www.peanuts-code.com/ja/about/ title=サイト情報><span>サイト情報</span></a></li><li><a href=https://www.peanuts-code.com/ja/search/ title="検索 (Alt + /)" accesskey=/><span>検索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/ja/>ホーム</a>&nbsp;»&nbsp;<a href=https://www.peanuts-code.com/ja/tutorials/>🤖 チュートリアル</a></div><h1 class=post-title>🤖 Godot3 で作る 2D グリッドベース移動</h1><div class=post-meta><span title='2022-06-08 00:05:00 +0900 +0900'>2022-06-08</span>&nbsp;·&nbsp;17 分&nbsp;·&nbsp;8194 文字&nbsp;|&nbsp;言語:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/en/tutorials/gd0010_2d_grid_based_movement/>En</a></li></ul></div></header><figure class=entry-cover><img loading=lazy src=https://www.peanuts-code.com/images/tutorials/gd0010_2d_grid_based_movement/img0.gif alt="Godot で作る 2D グリッドベースの移動"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目次</span></summary><div class=inner><ul><li><a href=#%e6%96%b0%e8%a6%8f%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e3%81%ae%e4%bd%9c%e6%88%90 aria-label=新規プロジェクトの作成>新規プロジェクトの作成</a></li><li><a href=#world-%e3%82%b7%e3%83%bc%e3%83%b3%e3%82%92%e4%bd%9c%e3%82%8b aria-label="World シーンを作る">World シーンを作る</a></li><li><a href=#tilemap-%e3%83%8e%e3%83%bc%e3%83%89%e3%82%92%e7%b7%a8%e9%9b%86%e3%81%99%e3%82%8b aria-label="TileMap ノードを編集する">TileMap ノードを編集する</a><ul><li><a href=#tilemap-%e3%83%8e%e3%83%bc%e3%83%89%e3%81%ae%e3%83%97%e3%83%ad%e3%83%91%e3%83%86%e3%82%a3%e3%82%92%e7%b7%a8%e9%9b%86%e3%81%99%e3%82%8b aria-label="TileMap ノードのプロパティを編集する">TileMap ノードのプロパティを編集する</a></li><li><a href=#tileset-%e3%83%aa%e3%82%bd%e3%83%bc%e3%82%b9%e3%82%92%e7%b7%a8%e9%9b%86%e3%81%99%e3%82%8b aria-label="TileSet リソースを編集する">TileSet リソースを編集する</a></li><li><a href=#tilemap-%e3%82%92%e4%bd%9c%e6%88%90%e3%81%99%e3%82%8b aria-label="TileMap を作成する">TileMap を作成する</a></li></ul></li><li><a href=#player-%e3%82%b7%e3%83%bc%e3%83%b3%e3%82%92%e4%bd%9c%e3%82%8b aria-label="Player シーンを作る">Player シーンを作る</a><ul><li><a href=#player-%e3%82%b7%e3%83%bc%e3%83%b3%e3%81%ae%e5%90%84%e3%83%8e%e3%83%bc%e3%83%89%e3%82%92%e7%b7%a8%e9%9b%86%e3%81%99%e3%82%8b aria-label="Player シーンの各ノードを編集する">Player シーンの各ノードを編集する</a><ul><li><a href=#sprite-%e3%83%8e%e3%83%bc%e3%83%89 aria-label="Sprite ノード">Sprite ノード</a></li><li><a href=#collisionshape2d-%e3%83%8e%e3%83%bc%e3%83%89 aria-label="CollisionShape2D ノード">CollisionShape2D ノード</a></li><li><a href=#raycast2d-%e3%83%8e%e3%83%bc%e3%83%89 aria-label="RayCast2D ノード">RayCast2D ノード</a></li></ul></li></ul></li><li><a href=#player-%e3%83%8e%e3%83%bc%e3%83%89%e3%81%ab%e3%82%b0%e3%83%aa%e3%83%83%e3%83%89%e3%83%99%e3%83%bc%e3%82%b9%e7%a7%bb%e5%8b%95%e3%82%92%e5%ae%9f%e8%a3%85%e3%81%99%e3%82%8b aria-label="Player ノードにグリッドベース移動を実装する">Player ノードにグリッドベース移動を実装する</a><ul><li><a href=#%e3%82%a4%e3%83%b3%e3%83%97%e3%83%83%e3%83%88%e3%83%9e%e3%83%83%e3%83%97%e3%82%92%e8%a8%ad%e5%ae%9a%e3%81%99%e3%82%8b aria-label=インプットマップを設定する>インプットマップを設定する</a></li><li><a href=#%e3%82%b9%e3%82%af%e3%83%aa%e3%83%97%e3%83%88%e3%82%92%e3%82%a2%e3%82%bf%e3%83%83%e3%83%81%e3%81%97%e3%81%a6%e7%b7%a8%e9%9b%86%e3%81%99%e3%82%8b aria-label=スクリプトをアタッチして編集する>スクリプトをアタッチして編集する</a></li></ul></li><li><a href=#world-%e3%82%b7%e3%83%bc%e3%83%b3%e3%81%ab-player-%e3%82%b7%e3%83%bc%e3%83%b3%e3%81%ae%e3%82%a4%e3%83%b3%e3%82%b9%e3%82%bf%e3%83%b3%e3%82%b9%e3%82%92%e8%bf%bd%e5%8a%a0%e3%81%99%e3%82%8b aria-label="World シーンに Player シーンのインスタンスを追加する">World シーンに Player シーンのインスタンスを追加する</a></li><li><a href=#%e3%82%b0%e3%83%aa%e3%83%83%e3%83%89%e3%83%99%e3%83%bc%e3%82%b9%e7%a7%bb%e5%8b%95%e3%81%ae%e5%8b%95%e4%bd%9c%e7%a2%ba%e8%aa%8d%e3%82%92%e3%81%99%e3%82%8b aria-label=グリッドベース移動の動作確認をする>グリッドベース移動の動作確認をする</a></li><li><a href=#%e3%82%b5%e3%83%b3%e3%83%97%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0 aria-label=サンプルゲーム>サンプルゲーム</a><ul><li><a href=#%e8%a3%9c%e8%b6%b3%e8%aa%ac%e6%98%8e aria-label=補足説明>補足説明</a></li></ul></li><li><a href=#%e3%81%8a%e3%82%8f%e3%82%8a%e3%81%ab aria-label=おわりに>おわりに</a></li><li><a href=#%e5%8f%82%e7%85%a7 aria-label=参照>参照</a></li></ul></div></details></div><div class=post-content><p>このチュートリアルでは、2Dゲームにおける「グリッドベース移動」をどのように実装するのかを説明する。グリッドベース移動というのは、等間隔にグリッド（格子状の線）で区分されたゲームの画面上をキャラクターなどのオブジェクトが 1 グリッド（ 1 マス）ずつ移動する動きのことだ。</p><p>人気スマホゲーム「パズル＆ドラゴンズ」や元祖落ちゲー「テトリス」などのパズルゲームはもちろん、「ファイヤーエムブレムシリーズ」「タクティクスオウガ」などのタクティカルシミュレーションゲームで、この動きを採用しているものは多いだろう。一方、「ファイナルファンタジー」シリーズや「ドラゴンクエスト」シリーズなどの RPG も、ファミコン用やスーパーファミコン用のソフトとして登場した 2D グラフィックの時代は、キャラクターの移動をよく見ると、このグリッドベース移動を行っている。このように、グリッドベース移動はさまざまなジャンルのゲームで使用されており、その汎用性はかなり高いと言える。</p><p>この記事では、できるだけグリッドベース移動の実装に絞って解説していく。また、最後にグリッドベース移動を使ったサンプルゲームも紹介するので、こちらもよかったら参考にしてほしい。</p><p>なお、このチュートリアルで最後にできあがるプロジェクトのファイルは、<a href=https://github.com/msnsk/GridBasedMovement.git target=_blank>GitHubリポジトリ</a>
に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。</p><br><blockquote><p><em><strong><span style=color:salmon>Environment</span></strong><br>このチュートリアルは以下の環境で作成しました。</em><br>・<em>Godot のバージョン: <strong>3.4.4</strong></em><br>・<em>コンピュータのOS: <strong>macOS 11.6.5</strong></em></p></blockquote><br><blockquote><p><em><strong><span style=color:salmon>Memo:</span></strong><br>ゲームを作り始めるのに以下の記事もお役立てください。<br><a href=https://www.peanuts-code.com/ja/tutorials/gd0001_download/ title="Godot をダウンロードする">Godot をダウンロードする</a><br><a href=https://www.peanuts-code.com/ja/tutorials/gd0002_project_manager/ title="Godot のプロジェクトマネージャー">Godot のプロジェクトマネージャー</a><br><a href=https://www.peanuts-code.com/ja/tutorials/gd0003_change_language/ title="Godot の言語設定">Godot の言語設定</a></em></p></blockquote><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=新規プロジェクトの作成>新規プロジェクトの作成<a hidden class=anchor aria-hidden=true href=#新規プロジェクトの作成>#</a></h2><p>まずは Godot Engine を立ち上げて、新規プロジェクトを作成してほしい。プロジェクトの名前は「Grid Based Movement Tutorial」とでもしておこう。</p><p>エディタが表示されたら、先にゲームのディスプレイサイズを設定しておこう。</p><ol><li>「プロジェクト」メニュー＞「プロジェクト設定」を開く。</li><li>「window」で検索して、サイドバーの「Display」＞「Window」を選択する。</li><li>「Size」セクションで以下の項目の値を変更する。<ul><li>Width: 256</li><li>Height: 160</li><li>Test Width: 1024</li><li>Test Height: 640<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.1.png alt=Display&amp;gt;Window&amp;gt;Size></li></ul></li><li>「Stretch」セクションで以下の項目の値を変更する。<ul><li>Mode: 2d</li><li>Aspect: keep<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.2.png alt=Display&amp;gt;Window&amp;gt;Stretch></li></ul></li></ol><br><p>続いて、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは <strong><a href=https://www.kenney.nl/assets/bit-pack target=_blank>1-Bit Pack</a>
</strong>というアセットパックだ。この素晴らしすぎる無料の素材に感謝せずにはいられない。</p><p>ダウンロードしたら「Tilesheet」フォルダ内の「colored-transparent_packed.png」ファイルをエディタのファイルシステムドックへドラッグ&ドロップしてプロジェクトにインポートしよう。</p><p>ファイルをインポートした直後は画像がぼやけた感じになっているので、これを修正する。</p><ol><li>ファイルシステムドックでインポートしたアセットファイルを選択した状態にする<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.3.png alt="select the asset"></li><li>インポートドックで「プリセット」＞「2D Pixel」を選択する<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.4.png alt="select 2D Pixel"></li><li>一番下にある「再インポート」ボタンをクリックする。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.5.png alt="click reinport"></li></ol><p>これでピクセルアート特有のエッジの効いた画像になる。</p><hr><h2 id=world-シーンを作る>World シーンを作る<a hidden class=anchor aria-hidden=true href=#world-シーンを作る>#</a></h2><p>まず最初のシーンとして、ゲームの世界を用意する。「World」という名前のシーンを作成しよう。</p><ol><li>「シーン」メニュー＞「新規シーン」を選択する。</li><li>「ルートノードを生成」にて「その他のノード」を選択する。</li><li>「Node2D」クラスのノードをルートノードとして選択。</li><li>ルートノードの名前を「World」に変更する。</li><li>一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://World/World.tscn」としてシーンを保存する。</li><li>ルートノードに「TileMap」ノードを追加する。</li></ol><br><p>これでシーンツリーは以下のようになったはずだ。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img1.png alt="World Scene Tree"></p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><br><hr><h2 id=tilemap-ノードを編集する>TileMap ノードを編集する<a hidden class=anchor aria-hidden=true href=#tilemap-ノードを編集する>#</a></h2><h3 id=tilemap-ノードのプロパティを編集する>TileMap ノードのプロパティを編集する<a hidden class=anchor aria-hidden=true href=#tilemap-ノードのプロパティを編集する>#</a></h3><p>シーンツリードックで「TileMap」ノードを選択し、インスペクターでプロパティを編集しよう。</p><ol><li>「TileSet」プロパティに「新規 TileSet」リソースを割り当てる。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img2.png alt="TileSet property"></li><li>「Cell」＞「Size」プロパティの値を(x: 16, y: 16)にする。これから利用するスプライトシートのテクスチャのサイズ（縦横 16px）に合わせて設定した。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img3.png alt="Cell_size property"></li></ol><br><h3 id=tileset-リソースを編集する>TileSet リソースを編集する<a hidden class=anchor aria-hidden=true href=#tileset-リソースを編集する>#</a></h3><p>続けて、「TileSet」プロパティに割り当てたリソース「TileSet」を編集していく。</p><ol><li>インスペクターでリソースをクリックする。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img4.png alt="Click TileSet resource"></li><li>Godot エディタ下部の「TileSet」パネルが開いたら、ファイルシステムドックからスプライトシートのリソース「res://colored-transparent_packed.png」をパネル内の左サイドバーにドラッグして追加する。追加したリソースをクリックして編集モードにしよう。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img5.png alt="TileSet Pannel"></li><li>「New Single Tile」を選択する。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img5.1.png alt="New Single Tile"></li><li>「領域(Region)」タブを選択したまま、グリッドスナップを有効にする。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img6.png alt="Enable grid snap"></li><li>インスペクターで「Snap Options」＞「Step」を (x: 16, y: 16)にして、スプライトシートのテクスチャ一つ分と同じサイズにする。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img7.png alt="Snap options"></li><li>順番に「草」と「木」のテクスチャの領域を選択して、Single Tile として登録する。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img8.1.png alt=Region></li><li>「木」のタイルは、「コリジョン(Collision)」タブを選択して、コリジョン形状も設定する。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img9.png alt="Collision tab">
<img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img10.png alt=Collision></li></ol><p>以上で TileSet リソースの編集は完了だ。</p><br><h3 id=tilemap-を作成する>TileMap を作成する<a hidden class=anchor aria-hidden=true href=#tilemap-を作成する>#</a></h3><p>ここからは先に作成した「TileSet」リソースのタイルを配置して TileMap を作成していく。</p><ol><li>シーンツリードックで「TileMap」を選択した状態にする。</li><li>2D ワークスペースのツールバーからグリッドスナップを有効にする。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img11.png alt="Enable Grid Snap"></li><li>同じくツールバーの「Snapping Options」をクリックし、「Configure Snap」を選択する。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img12.png alt="Snapping options"></li><li>「Configure Snap」の設定パネルが開いたら、「Grid Step」を <strong>(x: 16, y: 16)</strong> にして「OK」をクリックする。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img13.png alt="Configure Snap"></li></ol><p>これで 2D ワークスペース上に、縦横 16px ごとに区切られたグリッドが表示されていることだろう。「Grid Snap」を有効にしているので、「TileMap」の編集時は、簡単にグリッドに沿ってタイルを配置できるようになっているはずだ。</p><br><p>では 2D ワークスペースにタイルを配置していく。ここではシンプルに、あとで配置するプレイヤーキャラクターが外に出ないように画面の枠を「木」のタイルで囲って、その中に「草」のタイルを敷き詰めよう。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img14.png alt=TileMap></p><p>これで「TileMap」の編集は完了だ。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=player-シーンを作る>Player シーンを作る<a hidden class=anchor aria-hidden=true href=#player-シーンを作る>#</a></h2><p>ここからはプレイヤーキャラクターのシーンを作成する。このチュートリアルで実際にグリッドベース移動させるためのオブジェクトだ。</p><ol><li>「シーン」メニュー＞「新規シーン」を選択する。</li><li>「ルートノードを生成」にて「その他のノード」を選択する。</li><li>「KinematicBody2D」クラスのノードをルートノードとして選択。</li><li>ルートノードの名前を「Player」に変更する。</li><li>一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Player/Player.tscn」としてシーンを保存する。</li><li>ルートノードに「Sprite」ノードを追加する。</li><li>ルートノードに「CollisionShape2D」ノードを追加する。</li><li>ルートノードに「RayCast2D」ノードを追加する。</li></ol><p>これで「Player」シーンツリーは以下のようになったはずだ。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img15.png alt="Player Scene Tree"></p><br><h3 id=player-シーンの各ノードを編集する>Player シーンの各ノードを編集する<a hidden class=anchor aria-hidden=true href=#player-シーンの各ノードを編集する>#</a></h3><h4 id=sprite-ノード>Sprite ノード<a hidden class=anchor aria-hidden=true href=#sprite-ノード>#</a></h4><p>たくさんのテクスチャをまとめた1枚のスプライトシートから使いたいテクスチャの範囲を指定してスプライトのテクスチャを設定する方法を採用する。</p><ol><li>インスペクターにて、「Texture」プロパティにリソースファイル「res://colored-transparent_packed.png」を適用する。<br><img loading=lazy src="/images/tutorials/gd_common/node/Sprite/property/Texture=resource_set.png" alt="Sprite node Texture property"></li><li>「Offset」＞「Centered」プロパティをオフにする。これにより、このノードの位置（「Position」プロパティ）がテクスチャの中央ではなく左上角になり、ちょうどグリッドのマス目に収まるようになる。<br><img loading=lazy src="/images/tutorials/gd_common/node/Sprite/property/Offset%3eCentered=Off.png" alt="Offset &amp;gt; Centered = on"></li><li>「Region」＞「Enabled」をオンにする。<br><img loading=lazy src="/images/tutorials/gd_common/node/Sprite/property/Region%3eEnabled=On.png" alt="Region &amp;gt; Enabled = on"></li><li>エディタ下部の「テクスチャ領域」パネルを開く。ここで行うのはスプライトシートの中の利用したいテクスチャの領域を指定する作業だ。<br><img loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/tab_name.png alt="Region panel"><ol><li>作業しやすいように、展開アイコンをクリックしてパネルを広げる。<br><img loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/expand_icon.png alt="Expand Region pannel"></li><li>パネル上部の「snapモード」で「グリッドスナップ」を選択する。<br><img loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/snap_mode=grid_snap.png" alt="Region pannel &amp;gt; choose grid snap"></li><li>パネル上部の「ステップ」を 16px 16px にする。これでグリッドのサイズがスプライトシートのテクスチャ 1 つ分と同じサイズになる。<br><img loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/step=16x16.png" alt="Region pannel &amp;gt; input grid step"></li><li>スプライトシート上でドラッグ操作により「王様」のテクスチャを範囲選択する。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img16.png alt="Select region"></li></ol></li></ol><br><h4 id=collisionshape2d-ノード>CollisionShape2D ノード<a hidden class=anchor aria-hidden=true href=#collisionshape2d-ノード>#</a></h4><p>このノードで「KinematicBody2D」クラスのルートノードに対してコリジョン形状を設定する。</p><ol><li>インスペクターにて、「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。<br><img loading=lazy src="/images/tutorials/gd_common/node/CollisionShape2D/Shape=RectangleShape2D.png" alt="Shape property"></li><li>「Sprite」ノードのテクスチャの位置に合わせるため、 「Transform」＞「Position」プロパティの値を (x: 8, y: 8) にする。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img17.png alt="Position property"></li><li>2Dワークスペースにて、コリジョン形状を「Sprite」ノードのテクスチャのサイズに合わせる。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img18.png alt="CollisionShape in 2D workspace"><br>インスペクターで直接入力する場合は、「RectangleShape2D」リソースのプロパティを以下のようにする。<ul><li>Extents: (x: 8, y: 8)</li></ul></li></ol><br><h4 id=raycast2d-ノード>RayCast2D ノード<a hidden class=anchor aria-hidden=true href=#raycast2d-ノード>#</a></h4><p>このノードはグリッドベース移動での衝突判定にとても役に立つ。2D ワークスペース上は矢印型のコリジョン形状として表される。その矢印とオブジェクトが重なった場合に衝突を検知する。これを利用して、プレイヤーキャラクターの前方にあるオブジェクトとの衝突を検知させ、その先には進めないようにするなど制御することができる。</p><ol><li>インスペクターで、「Enabled」プロパティを On にしておく。これで衝突判定が可能になる。<br><img loading=lazy src="/images/tutorials/gd_common/node/RayCast2D/Enabled=On.png" alt="RayCast2D Enabled=on"></li><li>「Transform」＞「Position」プロパティを (x: 8, y: 8) にしておく。これは「Sprite」のテクスチャの中央に位置を合わせるためだ。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img17.png alt="Position property"></li><li>「Cast To」プロパティの値を (x: 16, y: 0) にしておく。これは暫定的に初期値を設定しているだけで、実際にプロジェクトを実行したら、スクリプトでプレイヤーキャラクターを移動させるたびに値を変更することになる。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img19.png alt="RayCast2D Cast To">
2D ワークスペース上では以下のスクリーンショットのようになったはずだ。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img20.png alt="RayCast2D 2D Workspace"></li><li>「Collide With」はデフォルトのまま「Areas」は Off、「Bodies」は On にしておく。さきほど作成したタイルセットの「木」のパネルは物理ボディなので「Bodies」にチェックが入っていれば、衝突が検知される。<br><img loading=lazy src="/images/tutorials/gd_common/node/RayCast2D/CollideWith%3eAreas=Off,Bodies=On.png" alt="RayCast2D Collide With&amp;gt;Areas=Off, Bodies=On"></li></ol><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=player-ノードにグリッドベース移動を実装する>Player ノードにグリッドベース移動を実装する<a hidden class=anchor aria-hidden=true href=#player-ノードにグリッドベース移動を実装する>#</a></h2><h3 id=インプットマップを設定する>インプットマップを設定する<a hidden class=anchor aria-hidden=true href=#インプットマップを設定する>#</a></h3><p>先にキーボードのキー入力でプレイヤーキャラクターを動かせるように、プロジェクト設定のインプットマップにアクションを追加する。</p><ol><li>「プロジェクト」メニュー＞「プロジェクト設定」を選択したら「Input Map」タブに切り替える。</li><li>以下の４つの「Action」を追加する。<ul><li>move_right: D キー</li><li>move_left: A キー</li><li>move_down: S キー</li><li>move_up: W キー</li></ul></li></ol><p>*上下左右の矢印キーを割り当ててもOK<br><img loading=lazy src=/images/tutorials/gd_common/project_settings/input_map/move_actions.png alt="Project Settings - Input Map"></p><br><h3 id=スクリプトをアタッチして編集する>スクリプトをアタッチして編集する<a hidden class=anchor aria-hidden=true href=#スクリプトをアタッチして編集する>#</a></h3><p>まずはルートノード「Player」にスクリプトをアタッチする。ファイルパスを「res://Player/Player.gd」としてスクリプトファイルを作成しよう。</p><p>作成後、スクリプトエディタが開いたら、スクリプトのコードを以下のように編集してほしい。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>KinematicBody2D</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#1</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> inputs <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;move_right&#34;</span>: <span style=color:#a6e22e>Vector2</span><span style=color:#f92672>.</span>RIGHT,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;move_left&#34;</span>: <span style=color:#a6e22e>Vector2</span><span style=color:#f92672>.</span>LEFT,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;move_down&#34;</span>: <span style=color:#a6e22e>Vector2</span><span style=color:#f92672>.</span>DOWN,
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;move_up&#34;</span>: <span style=color:#a6e22e>Vector2</span><span style=color:#f92672>.</span>UP
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#2</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> grid_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#3</span>
</span></span><span style=display:flex><span>onready <span style=color:#66d9ef>var</span> raycast <span style=color:#f92672>=</span> <span style=color:#a6e22e>$RayCast2D</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#4</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_unhandled_input</span>(event):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> action <span style=color:#f92672>in</span> inputs<span style=color:#f92672>.</span><span style=color:#a6e22e>keys</span>():
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> event<span style=color:#f92672>.</span><span style=color:#a6e22e>is_action_pressed</span>(action):
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>move</span>(action)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#5</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>move</span>(action):
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> destination <span style=color:#f92672>=</span> inputs[action] <span style=color:#f92672>*</span> grid_size
</span></span><span style=display:flex><span>	raycast<span style=color:#f92672>.</span>cast_to <span style=color:#f92672>=</span> destination
</span></span><span style=display:flex><span>	raycast<span style=color:#f92672>.</span><span style=color:#a6e22e>force_raycast_update</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> raycast<span style=color:#f92672>.</span><span style=color:#a6e22e>is_colliding</span>():
</span></span><span style=display:flex><span>		position <span style=color:#f92672>+=</span> destination
</span></span></code></pre></div><br><p>スクリプトには、コメントで #1 ~ #5 まで番号を振っておいた。この順番に解説していく。<br><br></p><p><strong>#1</strong>: 辞書型の定数<code>inputs</code>を定義した。先に設定しておいたインプットマップのアクションと同じ名前の Key に対して、その値にはそれぞれのアクションで移動させたい Vector2 型の方向ベクトル（長さが 1 のベクトル）を指定した形だ。ちなみに<code>Vector2</code>クラスの組み込み定数（<code>RIGHT</code>や<code>DOWN</code>など）の値は以下の通りだ。</p><ul><li>Vector2.RIGHT: Vector2(1, 0)</li><li>Vector2.LEFT: Vector2(-1, 0)</li><li>Vector2.DOWN: Vector2(0, 1)</li><li>Vector2.UP: Vector2(0, -1)</li></ul><br><p><strong>#2</strong>: プロパティ<code>grid_size</code>を定義した。値は「TileMap」のタイルのサイズと同じ<code>16</code>としている。<br><br></p><p><strong>#3</strong>: プロパティ<code>raycast</code>を定義した。これは「RayCast2D」ノードを参照するプロパティだ。</p><br><p><strong>#4</strong>: 組み込み関数<code>_unhandled_input</code>をオーバーライドした。これはキーボードやマウス、ジョイスティックなどからの入力があるとすぐに呼ばれるコールバック関数だ。別の関数<code>_input</code>と似ているが、ここでは細かい違いは気にしなくて大丈夫だ。</p><p><code>_unhandled_input</code>の中で、先に定義した辞書型定数<code>inputs</code>に対してループ処理を行っている。もし入力されたのが<code>inputs</code>のキー（<code>move_left</code>や<code>move_up</code>など）と同じ名前のインプットマップアクションだった場合に、そのキーに対する値（例えばキーが<code>move_right</code>なら<code>Vector2.RIGHT</code>）を引数に渡して<code>move</code>というメソッドを呼んでいる。この<code>move</code>というメソッドはこのあと定義する。<br><br></p><p><strong>#5</strong>: メソッド<code>move</code>を定義している。このメソッドを呼ぶときは引数<code>action</code>に値を渡す必要がある。</p><p>まず変数<code>destination</code>を定義している。値には、辞書型定数<code>inputs</code>から引数<code>action</code>とマッチするキーに対する値（例えば、<code>action</code>に<code>move_left</code>が渡されている場合は<code>Vector2.LEFT</code>）にプロパティ<code>grid_size</code>を乗算した値が入る。つまり、プレイヤーが「D」キーを入力した場合、その値は Vector2(1, 0) x 16 = Vector2(16, 0) になる。これは右方向の 1 グリッド分の長さを持つベクトルだ。</p><p>次に「RayCast2D」ノードのプロパティ<code>cast_to</code>に先に定義した変数<code>destination</code>の値を渡している。これでプレイヤーが入力したキーに合わせて「RayCast2D」の矢印の向きと長さが置き換わる。この置き換えをただちにアップデートするのが次の行で呼んでいる<code>force_raycast_update</code>というメソッドだ。これは「RayCast2D」ノードの組み込みだ。</p><p>次の行では<code>if</code>構文が記述されている。「RayCast2D」ノードの組み込みメソッド<code>is_colliding</code>は、現在このノード（矢印）がオブジェクトと衝突しているかどうかを Bool 型（<code>true</code>か<code>false</code>）で返してくれる。<code>if</code>の後に<code>not</code>があるので、この<code>if</code>構文の意味としては「もし『RayCast2D』ノードがオブジェクトと衝突していなければ』となる。</p><p>上述の<code>if</code>構文で「RayCast2D」が他のオブジェクトと衝突していなかった場合、「Player」ノードのプロパティ<code>position</code>の値に<code>destination</code>の値が加算される。つまり<code>destination</code>の値の分だけプレイヤーキャラクターが移動する、ということになる。例えば、現在の「Player」ノードの位置が<code>Vector2(64, 32)</code>だとして、この時プレイヤーが「S」キーを一度押すと、現在の位置から<code>Vector2(0, 16)</code>だけ移動するので、移動先の位置は<code>Vector2(64, 48)</code>となる。つまり、現在の位置から下方向に 1 グリッド分移動したということだ。</p><p>以上でグリッドベース移動の制御が実装できたはずだ。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=world-シーンに-player-シーンのインスタンスを追加する>World シーンに Player シーンのインスタンスを追加する<a hidden class=anchor aria-hidden=true href=#world-シーンに-player-シーンのインスタンスを追加する>#</a></h2><p>「Player」シーンが完成したので、そのインスタンスを「World」シーンに追加して、タイルマップ上を移動させてみよう。</p><ol><li>「World.tscn」シーンを開く</li><li>ルートノード「World」に「Player.tscn」シーンのインスタンスを追加する。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img21.png alt="Instance child scene"></li><li>2D ワークスペースで、画面の中央あたりの適当な位置に「Player」ノードを移動する。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img22.png alt="Move Player node in 2D workspace"></li></ol><p>以上で作業は完了だ。</p><br><hr><h2 id=グリッドベース移動の動作確認をする>グリッドベース移動の動作確認をする<a hidden class=anchor aria-hidden=true href=#グリッドベース移動の動作確認をする>#</a></h2><p>作業が完了したので、実際にグリッドベース移動が問題なくできるかどうか確認してみよう。</p><p>特に「Player」の子ノード「RayCast2D」の矢印型コリジョン形状も確認しやすくするため、先に「デバッグ(Debug)」メニューから「Visible Collision Shapes」のチェックを入れて有効にしておこう。<br><img loading=lazy src="/images/tutorials/gd_common/menu/debug/VisibleCollisionShapes=On.png" alt="Debug menu - Visible Collision Shapes: On"></p><p>初めてプロジェクトを実行する場合は Main Scene に「res://World/World.tscn」を選択してほしい。</p><p>それでは、プロジェクトを実行して、大草原の中を王様がグリッドベース移動で駆け回ることができるのか見てみよう。<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img23.gif alt="Run project"></p><br><p>一回のキー入力で、タイル 1 つ分だけ移動しているのがよくわかる。また、わざと「木」のタイルの方向に移動しようとしても移動できないことも確認できた。</p><p>以上で、グリッドベース移動のチュートリアルは完了だ。</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=サンプルゲーム>サンプルゲーム<a hidden class=anchor aria-hidden=true href=#サンプルゲーム>#</a></h2><p>今回のグリッドベース移動を利用したサンプルゲームを用意した。プロジェクトファイルは、<a href=https://github.com/msnsk/GridBasedMovement.git target=_blank>GitHubリポジトリ</a>
に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ OK だ。</p><p><div><video controls autoplay loop muted playsinline aria-label='Sample game demo' style=width:100%;height:auto>
<source src=/images/tutorials/gd0010_2d_grid_based_movement/img26.mp4 type=video/mp4>Your browser does not support the video tag.</video></div><br><br></p><p>このサンプルは、いわゆるモグラ叩きゲームだ。ゲームの設定として、プレイヤーは王様を操り、墓から出てくる王国の兵士たちの亡霊に向かって、聖なる指輪をかざして呪われた魂を解放する、というものだ。</p><p>操作は以下の通りだ。</p><ul><li>D: 右に移動</li><li>A: 左に移動</li><li>S: 下に移動</li><li>W: 上に移動</li><li>スペース: 亡霊と向かい合わせの場合のみ指輪を掲げて亡霊の魂を解放する</li></ul><p>亡霊は 1 秒以内に指輪で成仏させないと王様に呪いをかけてくる。呪われると Life が一つ減る。Life は最初 10 用意されているが、全てなくなったら王様は呪い殺されゲームオーバーになる。</p><p>次の亡霊が出現するまでのインターバルは、ゲーム開始時の 2 秒から徐々に短くなり、最短 1 秒まで短くなる。</p><p>ちなみに私の最高スコアは 150 だ。これがすごいのか、大したことないのかはわからない。<br><br></p><h3 id=補足説明>補足説明<a hidden class=anchor aria-hidden=true href=#補足説明>#</a></h3><p>最後にこのサンプルゲームのプロジェクトについて補足しておきたい。</p><p>ゲーム中、墓石から亡霊が出現するとき、「KinematicBody2D」クラスでコリジョン形状を設定済みの「Ghost」インスタンスと「TileMap」のコリジョンを設定した墓石のタイルが重なっている状態だ。このとき「Player」インスタンスの「RayCast2D」が墓石より亡霊との衝突判定を優先させるために少し工夫している。</p><p>「TileSet」の編集で墓石のタイルを作るときに、タイルの 1/2 のサイズのコリジョンを設定しているのだ。先にインスペクターで「Snap Options」＞「Step」を (x: 4, y: 4)にしてからコリジョン形状を設定するとスムーズだ。もちろん「Ghost」のコリジョン形状は (x: 16, y: 16) になっている。</p><p><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img24.png alt="Snap Option - Step">
<img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img25.png alt="Tomb collision setting in TileSet"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=おわりに>おわりに<a hidden class=anchor aria-hidden=true href=#おわりに>#</a></h2><p>今回のチュートリアルでは2Dゲームにおけるグリッドベース移動の実装について解説した。パズルゲームやシミュレーションゲームなど、これからあなたが取り組むプロジェクトに応用いただける機会があれば幸いだ。</p><p>グリッドベース移動のポイントをまとめておこう。</p><ol><li>以下を正確に設定する。<ul><li>リソース「TileSet」で用意したタイルの縦横のサイズ</li><li>移動させるオブジェクト（今回は「Player」）のスプライトのサイズと位置</li><li>移動させるオブジェクトのコリジョン形状のサイズと位置</li><li>2D ワークスペースの Grid Step</li><li>オブジェクトのノードにアタッチしたスクリプトでの移動距離を表すプロパティの値（今回は<code>grid_size</code>）</li></ul></li><li>移動させるオブジェクトと他のオブジェクトとの衝突判定には「RayCast2D」を利用する。「RayCast2D」の向きとサイズはスクリプトで制御する。</li><li>プレイヤーの操作でオブジェクトを移動させるには、インプットマップのアクションを登録しておき、スクリプトでそれぞれの入力に対して移動する方向を制御する。</li></ol><br><hr><h2 id=参照>参照<a hidden class=anchor aria-hidden=true href=#参照>#</a></h2><ul><li><a href=https://www.kenney.nl/assets target=_blank>KENNEY</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_raycast2d.html target=_blank>Godot Docs: RayCast2D</a></li><li><a href=https://docs.godotengine.org/ja/stable/tutorials/2d/using_tilemaps.html target=_blank>Godot Docs: Using TileMaps</a></li><li><a href=https://docs.godotengine.org/ja/stable/classes/class_tileset.html target=_blank>Godot Docs: TileSet</a></li><li><a href=https://kidscancode.org/godot_recipes/2d/grid_movement/ target=_blank>KidsCanCode: Grid-based movement</a></li><li><a href=https://youtu.be/9laHKHYNyXc target=_blank>YouTube: Grid-based movement Godot 3 demo overview</a></li><li><a href=https://youtu.be/HmnwNadwHWI target=_blank>YouTube: Make your first 2D grid-based game from scratch in Godot</a></li></ul><hr></div><footer class=post-footer><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る 2D グリッドベース移動 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Godot3%20%e3%81%a7%e4%bd%9c%e3%82%8b%202D%20%e3%82%b0%e3%83%aa%e3%83%83%e3%83%89%e3%83%99%e3%83%bc%e3%82%b9%e7%a7%bb%e5%8b%95&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0010_2d_grid_based_movement%2f&amp;hashtags=GodotEngine%2cGameDev%2cGodot3%2c2D%2c%e3%82%b0%e3%83%aa%e3%83%83%e3%83%89%e3%83%99%e3%83%bc%e3%82%b9%e7%a7%bb%e5%8b%95"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る 2D グリッドベース移動 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0010_2d_grid_based_movement%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></div><ul class=post-tags><li><a href=https://www.peanuts-code.com/ja/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/ja/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/ja/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/ja/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/ja/tags/%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%E3%83%99%E3%83%BC%E3%82%B9%E7%A7%BB%E5%8B%95/>グリッドベース移動</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/><span class=title>« 前へ</span><br><span>🤖 Godot3 で作る同じ色をつなげて消すパズルゲーム</span>
</a><a class=next href=https://www.peanuts-code.com/ja/tutorials/gd0008_homing_missiles/><span class=title>次へ »</span><br><span>🤖 Godot3 で作るホーミングミサイル</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/ja/>Peanuts Code</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="コピー";function s(){t.innerHTML="コピーされました!",setTimeout(()=>{t.innerHTML="コピー"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>