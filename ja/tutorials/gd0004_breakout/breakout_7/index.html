<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！ | Peanuts Code</title>
<meta name=keywords content="GodotEngine,GameDev,ブロック崩し,2D"><meta name=description content="Part 7 の今回は、HUD（ヘッドアップディスプレイ）を作っていく。HUD というのは、例えば、プレイヤーのライフゲージやスコア、残り時間、レベル（ステージ）の番号などのように、ゲームプレイ画面に常に表示されているもののことだ。
それでは前回に引き続きブロック崩しを開発していこう。


Memo:

過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。
Godot で作るブロック崩し
"><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/breakout_7/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/breakout_7/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/breakout_7/"><meta property="og:site_name" content="Peanuts Code"><meta property="og:title" content="Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！"><meta property="og:description" content="Part 7 の今回は、HUD（ヘッドアップディスプレイ）を作っていく。HUD というのは、例えば、プレイヤーのライフゲージやスコア、残り時間、レベル（ステージ）の番号などのように、ゲームプレイ画面に常に表示されているもののことだ。
それでは前回に引き続きブロック崩しを開発していこう。
Memo: 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。
Godot で作るブロック崩し "><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2021-11-23T23:45:05+09:00"><meta property="article:modified_time" content="2021-11-23T23:45:05+09:00"><meta property="article:tag" content="GodotEngine"><meta property="article:tag" content="GameDev"><meta property="article:tag" content="ブロック崩し"><meta property="article:tag" content="2D"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0004_breakout/breakout_7/img_35.gif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0004_breakout/breakout_7/img_35.gif"><meta name=twitter:title content="Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！"><meta name=twitter:description content="Part 7 の今回は、HUD（ヘッドアップディスプレイ）を作っていく。HUD というのは、例えば、プレイヤーのライフゲージやスコア、残り時間、レベル（ステージ）の番号などのように、ゲームプレイ画面に常に表示されているもののことだ。
それでは前回に引き続きブロック崩しを開発していこう。


Memo:

過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。
Godot で作るブロック崩し
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"🤖 チュート","item":"https://www.peanuts-code.com/ja/tutorials/"},{"@type":"ListItem","position":2,"name":"🤖 シリーズ：Godot で作るブロック崩し","item":"https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/"},{"@type":"ListItem","position":3,"name":"Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！","item":"https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/breakout_7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！","name":"Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！","description":"Part 7 の今回は、HUD（ヘッドアップディスプレイ）を作っていく。HUD というのは、例えば、プレイヤーのライフゲージやスコア、残り時間、レベル（ステージ）の番号などのように、ゲームプレイ画面に常に表示されているもののことだ。\nそれでは前回に引き続きブロック崩しを開発していこう。\nMemo: 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るブロック崩し ","keywords":["GodotEngine","GameDev","ブロック崩し","2D"],"articleBody":"Part 7 の今回は、HUD（ヘッドアップディスプレイ）を作っていく。HUD というのは、例えば、プレイヤーのライフゲージやスコア、残り時間、レベル（ステージ）の番号などのように、ゲームプレイ画面に常に表示されているもののことだ。\nそれでは前回に引き続きブロック崩しを開発していこう。\nMemo: 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るブロック崩し HUDの大まかなレイアウトをデザインする ゲーム画面のデザインを作るとき、いきなり Godot でシーンを追加していくのは得策ではない。なぜなら、大まかなレイアウトが決まっていない状態では、「ああでもない、こうでもない」とノードの追加と削除を繰り返し、なかなかゴールに辿り着けなくなる恐れがあるからだ。\nデザインの作業をする時は、まずをラフスケッチ作るところから始めよう。使う道具は紙と鉛筆でもいいし、PowerPoint や Keynote などスライド作成アプリでもいい。気軽に始められるツールで作業しよう。\n今回は、このラフスケッチを基に「Game」シーンにノードを追加していく。ちなみにこのスケッチは iPad のメモアプリに ApplePencil で書いた。\nHUD を作る さきほどのラフスケッチに、さらにノードのクラスを加筆してみたのがこれだ。\nそれでは「Game」シーンに HUD を追加していこう。\nノードを追加する まずはHUDに必要なノードを一気に追加していこう。\n「Game」ノードに「Control」ノードを追加し、名前を「HUD」に変更 「HUD」ノードに「ColorRect」ノードを追加し、名前を「Backgournd」に変更 「HUD」ノードに「VBoxContainer」ノードを追加し、名前を「LeftBox」に変更 「HUD」ノードに「HBoxContainer」ノードを追加し、名前を「RightBox」に変更 「LeftBox」ノードに「Label」ノードを2つ追加し、それぞれの名前を「Level」、「Score」に変更 「RightBox」ノードに「TextureRect」ノードを追加し、名前を「Life1」に変更 ここまでできたら、次はノードの並び順を更新しよう。\nノードの並び順を変更する 一般的に HUD はゲーム画面の最前面に表示されることが多いが、ブロック崩しでは、プレイ中に HUD の背後にボールが隠れてしまわないように、HUD を最背面に配置する。\n原則として、シーンドック内で下にあるノードほどゲーム画面では前面に表示される。ノード追加時の仕様上、「HUD」ノードを追加した直後は最前面（シーンドックでは一番下）に配置されているだろう。「HUD」ノードを「Game」ノードの最背面に配置するには、単純にシーンドック内で「Game」ノードのすぐ下に「HUD」ノードをドラッグ\u0026ドロップすれば良い。\nここまでできたら、シーンドック上の「HUD」関連ノードの並びは以下のようになったはずだ。\nシーンの背景を黒にする HUDの「Level」や「Score」の文字は白で表示したい。白を強調するために、先に「Game」シーンの背景を黒にしてしまおう。\n親の「HUD」ノードを画面いっぱいに広げるため、シーンドックで「HUD」ノードを選択して、ツールバーから「レイアウト」＞「Rect全面」を選択する。 シーンドックで「HUD」ノードの子ノード「Backgournd」を選択して、同様にツールバーから「レイアウト」＞「Rect全面」を選択する。 インスペクタで「Backgournd」ノードの「Color」プロパティを黒（000000）に設定する。\nシーンを実行して確認 以下のように表示されたら想定通りだ。\nHUD のレベルとスコアを作る 「LeftBox」ノードの編集 次に HUD の左側にレベルとスコアの表示を作っていく。「LeftBox」ノードを編集していこう。以下の手順で「LeftBox」のレイアウトを調整する。\nシーンドックで「LeftBox」ノードを選択する ツールバーで「レイアウト」＞「左上」を選択する ツールバーでグリッドスナップを有効にする 移動モードを有効にし、2D ワークスペースで右と下に 1 グリッド（8 px）分移動する 選択モードを有効にして、2D ワークスペースで枠の右側を x 座標 320 まで広げる インスペクタで「Margin」プロパティを見るとこのようになっているはずだ。もちろん上記のような 2D ワークスペースでの直感的操作ではなく、直接インスペクタ上でプロパティの数値を入力しても問題ない。\n「Level」ノードと「Score」ノードの「Text」プロパティの編集 続いて「LeftBox」ノードに追加した2つの「Label」ノードを編集していく。\n「Level」ノードの「Text」プロパティに「Level: 1」と入力する 「Score」ノードの「Text」プロパティに「Score: 0」と入力する これで HUD の左側に「Level」と「Score」が表示された。実際の数字はスクリプトでプレイ中に随時更新されるようにしていくが、一旦初期値としてこの状態にしておく。\nフォントはデフォルトのままでも違和感ないが、せっかくなので、チュートリアル Part 6 でダウンロードした「PressStart2P-Regular.ttf」を適用しよう。軽く手順をおさらいしておく。\nMemo: 「PressStart2P-Regular.ttf」のフォントがファイルシステムドックに見当たらない場合は、Google Fonts のサイト から「Press Start 2P」というフォントをダウンロードして、ファイルシステムに改めて追加してください。\n「Level」ノードの編集 シーンドックで「Level」ノードを選択し、インスペクタで「Custom Fonts」セクションを開く 「Font」プロパティ（一番上の方）で「新規 DynamicFont」を選択する。 「Font」プロパティ（四番目の方）の[空]に、ファイルシステムから「PressStart2P-Regular.ttf」をドラッグ\u0026ドロップする。 「Size」プロパティの値を12にする。\n「Score」ノードの編集 「Score」ノードも同様に設定するが、フォントファイルはインスペクタ上でコピー\u0026ペーストができるのでその方法で設定しよう。\n「Level」ノードのインスペクタで「Custom Fonts」を開き、「Font」プロパティ（四番目の方）の「Font Data」右側のプルダウンをクリックして「コピー」を選択する。\n「Score」ノードのインスペクタに切り替えて、「Custom Fonts」を開き、「Font」プロパティ（一番上の方）で「新規 DynamicFont」を選択する。 続けて「Font」プロパティ（四番目の方）の「Font Data」右側のプルダウンをクリックして「貼り付け」を選択する。\nこれでカスタムフォントの設定ができた。\nシーンを実行して確認 シーンを実行して、レベルとスコアの表示を確認しておこう。\nHUD のライフを作る 次は HUD の右側にライフを表示させる。\n「RightBox」ノードの編集 以下の手順で「RightBox」ノードのレイアウトを調整する。\nシーンドックで「RightBox」ノードを選択する ツールバーで「レイアウト」＞「右上」を選択する 移動モードを有効にして、左と下に 1 グリッド（8 px）分移動する 選択モードを有効にして、枠の左側を x 座標 320 まで広げる\nインスペクタで「Alignment」プロパティの値を「End」に変更しておく。これで子ノードが右寄せで配置される。\nインスペクタでプロパティを見るとこのようになっているはずだ。さきほどの「LeftBox」の時と同様に、「Margin」プロパティに関しては、直接インスペクタ上で数値を入力してもOKだ。\n「Life1」ノードの編集 次に「RightBox」の子ノード「Life1」ノードを編集していこう。「TextureRect」クラスは「Sprite」クラス同様、画像ファイルを割り当ててそれを表示することができる。\nシーンドックで「Life1」ノードを選択する。 ファイルシステムの「res://sprites/Heart3.png」（一番小さいハート）をインスペクタの「Texture」プロパティの[空]めがけてドラッグ\u0026ドロップする。\nこれで画像がセットされた。\n2D ワークスペースにはこのように表示されたはずだ。ただ、残念ながら、画像が元のサイズのままだと少し大きすぎる。もう少し小さく控えめにしていく。\nではインスペクタで「Life1」ノードの必要なプロパティを以下の手順で変更していこう。\nまずは「Expand」プロパティを「オン」にする。「Strech Mode」プロパティはそのまま。\n「Rect」＞「Min Size」プロパティの x, y をそれぞれ 16 にする。これはノードのサイズの最小値だ。ここを(16, 16)としておくことで、親ノードの「RightBox」のサイズは子ノードの最初値(16, 16)より小さくすることはできない。\n「RightBox」を選択モードにして枠の下側を 2 グリッド分（16 px）上げて、ちょうど「Life1」ノードにフィットするように上下幅を小さくする。一見回りくどい設定の仕方であり、「Life1」ノードだけを単に 16 px 上に移動させれば良いのでは、と思った方もいるかもしれない。しかし、「Containter」系のクラスの子ノードはそれ自体の位置を変更することができない。位置は完全に親の「Container」クラスに支配されているのだ。\n改めて「RightBox」のインスペクタでプロパティを見るとこのようになっているはずだ。\n「Life1」のプロパティ設定が終わったところで、シーンドックで「Life1」ノードを4つ複製して「Life5」まで量産しよう。このような作業はショートカットキーが便利だ（複製 \u003e Windows: Ctrl + D / macOS: Cmd + D）。\nシーンドックでこのようになっていればOKだ。\n2D ワークスペースの方で見ると、このようにHBoxContainer内で横並びに配置される。\nここまでの作業で、シーンドックはこのようになっている。\nシーンを実行して確認 実際にシーンを実行して、HUD の表示が最初のラフスケッチとだいたい同じになったか確認しておこう。\nHUD をプレイ状況と連動させる ここからはゲームプレイの状況に応じて HUD の表示が変化するように、スクリプトも使って連動させていく。連動させたい内容は以下の3つだ。\n現在のレベルを表示させる 現在のスコアを表示させる 現在のライフを表示させる では順番に作業を進めていこう。\n現在のレベルを表示させる 以下の作業が必要になるが、一つずつやっていこう。\n次のレベルのシーンを追加する 次のレベルに行く前の準備画面を作る スクリプトで HUD のレベルを変化させる 次のレベルのシーンを追加する ブロックの配置などこだわり出すと時間がかかるので、ここではひとまず仮で次のレベルのシーンである「Level2」というシーンを作成する。一番簡単な方法は、すでに作成済みの「Level1」シーンを継承して作成する方法だ。\nMemo: 継承とは、オブジェクト指向のプログラミングでは大事な概念の一つです。他のクラスのプロパティやメソッドをそのまま引き継いで新たなクラスを作成することを指します。さらに内容を上書きして更新することもでき、また親のクラスを変更すると、自動的に継承した子クラスにも変更が反映されます。\nではまず「シーン」メニュー＞「新しい継承シーン」を選択する。\n次に 「Level1.tscn」ファイルを選択すれば、「Level1」シーンをまるまま継承したシーンができる。すぐにルートノードの名前を「Level2」に変更しておこう。\nそのまま新しく作ったシーン「Level2」を「Level2.tscn」という名前で保存すればひとまず2つ目のシーンの出来上がりだ。\n次のレベルに行く前の準備画面を作る 現状、レベルごとの準備画面がない。例えば「Level1」のブロックを全て消した後「Level2」に移行する時に、このままだとすぐに次のLevel2のブロックが画面に配置され、落ち着く暇もない。一呼吸置く意味でも、準備画面を作成していこう。準備画面には HUD と同じく以下の項目を表示させるよう構成する。\n次のレベル 現在のスコア ライフ 準備画面として「NextScreen」という名前のノードを「Game」ノードに追加し、レベルの切り替え時のみ画面に表示されるようにしていく。以下の手順で作業を進めていこう。\nでは「Game」ノードに「Control」ノードを追加し、名前を「NextScreen」に変更する。 2D ワークスペースで「NextScreen」を選択モードにして、手動でサイズをプレイ画面全体に広げる。\n「NextScreen」ノードに「ColorRect」ノードを追加し、名前を「Background」に変更する。 2D ワークスペースで「Background」を「レイアウト」＞「Rect全面」で親ノードと同じだけ広げる。 インスペクタで「Background」の「Color」プロパティをお好みの色に変更する（例えば #106ed1）\n「NextScreen」ノードに「VBoxContainer」ノードを追加し、名前を「VBox」に変更する。インスペクタで「Alignment」プロパティの値を「Center」にする。さらに「Custom Constants」セクションの「Separation」プロパティの値を24にする。 「VBox」ノードに「Label」ノードを2つ追加し、名前をそれぞれ「Level」、「Score」とする。 インスペクタで「Level」ノードの「Text」プロパティの値を「Level: 1」とし、「Align」プロパティを「Center」にする。 同様に、「Score」ノードの「Text」プロパティの値を「Score: 0」とし、「Align」プロパティを「Center」にする。 「VBox」ノードに「HBoxContainer」ノードを追加し、名前を「HBox」に変更する。インスペクタで「Alignment」プロパティの値を「Center」にする。さらに「Custom Constants」セクションの「Separation」プロパティの値を12にする。 「HBox」ノードに「TextureRect」ノードを追加し、名前を「HeartImage」に変更する。インスペクタで「Texture」プロパティに、ファイルシステムから「res://sprites/Heart3.png」を割り当てる。続けて「Expand」プロパティをオンにし、「Rect」＞「Min Size」プロパティを (24, 24) にする。 「HBox」ノードに「Label」ノードを追加し、名前を「Life」に変更する。インスペクタで「Text」プロパティに「x 3」と入力する。 「Level」、「Score」、「Life」の3つの Label クラスのノードにカスタムフォントを設定する。「新規 DynamicFont」を設定し、「Font」プロパティにファイルシステムから「PressStart2P-Regular.ttf」を適用する。「Font」＞「Size」プロパティは16のままで良い。 シーンドックで「VBox」ノードを選択し、ツールバーの「レイアウト」＞「中央」を選択する。\nさて、「NextScreen」ノードを追加したあと、シーンドックはこのようになっているだろうか。\n大事なポイントとして、「Game」ノードの子ノードのうち、「NextScreen」ノードが一番下に位置している必要がある。理由はゲームプレイ中は「NextScreen」ノードを非表示にしておき、一つのレベルをクリアして次のレベルをスタートする前に準備画面として表示し、その際、他のノードを覆い隠すためだ。\nスクリプトで HUD のレベルを変化させる では、ここからスクリプトを作成していく。「NextScreen」にスクリプトをアタッチしよう。「res://scripts/NextScreen.gd」として保存する。\n「NextScreen」ノードが画面に表示されている時に、インプットマップの「ui_accept」に該当するキー（Space、Enterなど）を入力すれば、次のレベルのプレイが開始されるような仕様にしたい。\nそこでまず「NextScreen.gd」のスクリプトの中身を以下のコードで置き換えよう。\nextends Control func _input(event): if Input.is_action_just_pressed(\"ui_accept\"): yield(get_tree().create_timer(0.1), \"timeout\") hide() get_tree().paused = false まず、yieldから始まる行のコードは丸ごと「GameStartView.gd」スクリプトから移動させた。これがないと、プレイヤーがスペースキーで次に進めた場合、プレイ画面に切り替わった瞬間にボールが発射されてしまうからだ。ということで、このタイミングで、「GameStartView.gd」スクリプトからはこの一行のコードをコメントアウトするか削除しておいてほしい。\nhideという関数は、「CanvasItem」クラスに組み込みのメソッドである。この関数を実行すると、画面上そのノードは非表示になる。ちなみにこれは、下のGIF画像のように、シーンドックでノードの右側の「目」アイコンをクリックして閉じるのと同じ意味だ。\nget_tree().paused = falseは、プロジェクトの一時停止状態を解除するために実行する。後ほど、次のレベルの準備が終わったら「NextScreen」が最前面に表示された状態でプロジェクトを一時停止する処理を追加する。その時、インプットマップui_acceptの操作により一時停止を解除して、次のレベルをスタートできるようにした。\nそれでは次に「Game」ノードにスクリプトをアタッチしよう。「res://scripts/Game.gd」として保存する。\n「Game」ノードは、シーンドック上、他の全てのノードの親ノードだ。そのため、このスクリプトではノード間をまたがって処理が必要な部分をコーディングしていく。少しコード量が今までより多くなるが頑張ろう。\nまずは「Game.gd」スクリプトの内容を以下のコードで置き換えてほしい。そのあと一つずつスクリプトの内容を確認していく。\nextends Node2D var level_num = 1 onready var level = $Level1 onready var next_screen = $NextScreen onready var next_screen_level = $NextScreen/VBox/Level onready var hud_level = $HUD/LeftBox/Level onready var paddle = $Paddle onready var ball = $Ball onready var paddle_position = paddle.position onready var ball_position = ball.position func _ready(): # For debug leave_one_brick(43) for brick in level.get_children(): brick.connect(\"tree_exited\", self, \"_on_Brick_tree_exited\") get_tree().paused = true # For debug func leave_one_brick(brick_num: int): for child in level.get_children(): if child.get_name() == \"Brick\" + str(brick_num): continue child.queue_free() # Method receiving signal func _on_Brick_tree_exited(): if level.get_child_count() \u003c= 0: level.queue_free() set_next_level() func set_next_level(): print(\"set_next_level() start\") level_num += 1 # Show NextScreen node next_screen_level.text = \"Level: \" + str(level_num) next_screen.show() # Set Level of HUD the next level hud_level.text = \"Level: \" + str(level_num) # Set Paddle and Ball the first position paddle.position = paddle_position ball.position = ball_position ball.mode = 3 # Set next Level node level = load(\"res://scene/Level\" + str(level_num) + \".tscn\").instance() add_child(level) move_child(level, 5) for child in level.get_children(): child.connect(\"tree_exited\", self, \"_on_Brick_tree_exited\") # Pause game until NextScreen is hidden get_tree().paused = true それでは上から順番に見ていこう。\n最初に定義しているlevel_numは単純に、現在のレベルの数値を保持する変数だ。初期値として1を入れている。\nノードが全て読み込まれてから定義すべき変数にはonreadyキーワードをつけた。これらの変数は、ノードが全て読み込まれたあとのステップ（_ready関数を実行するタイミング）で定義されるので、変数の値にget_node()やget_parent()などの関数を含む場合に利用する。ちなみに変数の値の頭に$記号がついているものは、get_node()と同じ意味で、やや簡略化して記述できるので採用している。\n変数hud_levelからnext_screen_levelまでは、値の示す通りそれぞれのノードを保持する。paddle_positionとball_positionについては、「Paddle」ノード、「Ball」ノードの位置を保持する。\n_ready関数では、コメントでも記述しているが、デバッグ用にleave_one_brick(43)という関数を実行している。これは_ready関数のすぐ下で定義している関数だ。\n# For debug func leave_one_brick(brick_num: int): for child in level.get_children(): if child.get_name() == \"Brick\" + str(brick_num): continue child.queue_free() その内容は、「Level1」の子ノードの名前の最後が引数で指定した43の「Brick」ノードを残し、それ以外の「Brick」ノードを全て消すという処理だ。この「Brick43」というのは配置上、パドルの初期位置からボールを発射した時に最初にボールが当たるブロックなのだ。つまり、この唯一画面に残っている「Brick43」ノードにボールで当てればゲームクリアの状態が作れるようにしている。\n_ready関数内ではそのあとforループを利用して、「Level1」の子ノードである全ての「Brick–」ノードでそれぞれシグナルの接続をコードで実行している。それがbrick.connect(\"tree_exited\", self, \"_on_Brick_tree_exited\")だ。第一引数にもなっているtree_exitedというシグナルはデフォルトで用意されているもので、シーンツリーから消えたら信号を発信する。selfはこの「Game.gd」スクリプトを指す。_on_Brick_tree_exitedはこのスクリプト内の関数の名前だ。この関数にシグナルを接続している。これにより、シグナルが発信されれば_on_Brick_tree_exited関数が実行される。\nget_tree().paused = trueで、プロジェクトを一時停止している。これは_readyで全ての準備が整ったら、一旦一時停止状態にして、「NextScreen」ノードが非表示になるまで入力操作も受け付けなくするためだ。ただし、このままでは「NextScreen」ノードも含めて全ての処理が停止してしまう。そこで、インスペクタで「NextScreen」ノードの「Pause Mode」プロパティを「Inherit」から「Process」に変更しておこう。これにより「NextScreen」ノードだけはプロセスが続行されるようになる。\n# Method receiving signal func _on_Brick_tree_exited(): if level.get_child_count() \u003c= 0: level.queue_free() set_next_level() さて、シグナルを受信するメソッドがこちらの関数だ。「Level1」などの「Level」ノードの子ノード「Brick(番号)」がそれぞれボールに当たったら、消えるタイミングで、シグナルを発信し、この関数がそれを受け取る。そして、シグナルを受け取るたびに、ブロックの数がゼロになっていないかを確認している。それがif level.get_child_count() \u003c= 0:の一行だ。つまりこの if 構文で true になるのは、最後の1つのブロックが消えた時だ。\n最後のブロックが消え、if 構文が true になったら、queue_free関数によって、親の「Level」ノードそのものが消える。そしてそのあとset_next_level関数によって、次のレベルの準備作業に入る、という流れだ。ではこのset_next_level関数の中身を見ていこう。\nprint(\"set_next_level() start\")は、この関数が実行されたのを確認するために用意している。\nlevel_num += 1 これはlevel_num = level_num + 1と同じ意味である。今のレベルをクリアしたら、今現在のレベルナンバーを格納している変数level_numの値に 1 を加算し、レベルナンバーを次の数字に更新しているわけだ。\n# Show NextScreen node next_screen_level.text = \"Level: \" + str(level_num) next_screen.show() next_screen_levelという変数はこのスクリプトの冒頭で定義している「NextScreen」ノードの孫の「Level」ノードのことだ。そして、.textはその「Text」プロパティのことで画面に表示される文字列だ。その値を更新している。String 型（文字列）の値に int 型（整数）の値を格納した変数を結合したい場合、int 型はstr関数によって文字列に変換できるので、このように+記号で連結すればひと続きの文字列にすることができる。\nshow関数によって、非表示になっていた「NextScreen」ノードを表示している。このタイミングで次のレベルに行く前の準備画面に切り替わるわけだ。\n# Set Level of HUD the next level hud_level.text = \"Level: \" + str(level_num) hud_level.textも冒頭で定義している「HUD」ノードの孫「Level」ノードの「Text」プロパティだ。その値の数字部分を次のレベルナンバーに置き換えて、HUDの表示を更新している。たくさんのコードで埋もれそうだが、これが元々このチュートリアルでやろうとしていたことだ。\n# Set Paddle and Ball the first position paddle.position = paddle_position ball.position = ball_position ball.mode = 3 一つのレベルをクリアしたら次のレベルに移行するまでに、パドルとボールの位置を初期位置に戻す処理をしている。.positionはそのノードの位置情報を格納するプロパティを指している。paddle_position及びball_positionはスクリプト冒頭で「Paddle」ノード、「Ball」ノードの初期位置を代入する形で定義済みだ。\nボールは「RigidBody2D」クラスのオブジェクトなので、「Mode」プロパティを「Character」から「Kinematic」に変更しないと、次のレベルが開始してパドルを動かした瞬間、どこか意図しない方向へ流れていってしまう。「Kinematic」に割り当てられている「Mode」プロパティの番号は3なので、ball.mode = 3としている。このあたりの「Ball」ノードの内容を忘れてしまった場合は、チュートリアル Part 2 を参照のこと。\n# Set next Level node level = load(\"res://scene/Level\" + str(level_num) + \".tscn\").instance() add_child(level) move_child(level, 5) for child in level.get_children(): child.connect(\"tree_exited\", self, \"_on_Brick_tree_exited\") 「Level1」ノードの全ての「Brick-」ノードを消したあと「Level1」ノード自体もqueue_free関数で削除しているのえ、次の「Level2」シーンをノードとして「Game」シーンに追加する必要がある。\nload関数は、シーンファイルを読み込むための関数だ。引数にファイルパスを指定すれば読み込んでくれる。先にlevel_num変数は更新済みなので、それを利用してファイル名を指定している。.instance関数は読み込んだシーンファイルのインスタンスを作る。つまり設計図から実体を作っているわけだ。それを先ほどまで「Level1」ノードを格納していた変数levelに代入している。\nadd_child関数により、次の「Level2」シーンをこの「Game」シーンの子ノードとして追加している。シーンドックで「Game」ノードを選択した状態でノードを新しく追加する作業と同じ意味合いだ。\nmove_child関数は、指定したノードを「Game」ノードの何番目の子ノードにするかを設定できる。先にadd_child関数が実行された時には、 下のスクリーンショットのように「Level2」ノードがデフォルトで一番最後の順番（ここでは 6 番目）になってしまう。つまり、このままだと次のレベルのブロックが「NextScreen」ノードより全面に表示されてしまう。\nそこでこのmove_childの第一引数に変数level（「Level2」ノード）を指定し、第二引数に5を指定して、5番目に移動しているという理屈だ。\n最後に「Level2」ノードの全ての子ノード、つまり全ての「Brick-」ノードに対して、forループを利用してtree_exitedシグナルを_on_Brick_tree_exited関数に接続している。_ready関数内で最初に実行していたことと同じだ。なぜコードを使ってシグナルを接続するかというと、一つのレベルをクリアするたびに今の「Level-」ノードを削除して、次のレベルの「Level-」シーンを新たに子ノードとして追加するので、前もってノードドックから「Game」シーンのスクリプトにシグナルを接続しておくことができないからだ。\n# Pause game until NextScreen is hidden get_tree().paused = true 最後に_readyでも最後に記述していたプロジェクト全体を一時停止するのためのコードだ。次のレベルの準備が全て整ったら、プレイヤーがインプットマップ「ui_accept」の操作を行うまでは、一時停止にする。\nではプロジェクトを実行して、実際の挙動を確認してみよう。\n以下の動作に問題ないことが確認できた。\n次のレベル開始前に「NextScreen」ノードが表示されること 「NextScreen」ノードの孫ノード「Level」（Label クラス）にレベルナンバーが反映していること インプットマップ「ui_accept」のキー操作により「NextScreen」ノードが非表示になること 次のレベルのプレイ画面が表示された時に、パドルとボールが初期位置に戻っていること プレイ画面の「HUD」ノードの孫ノード「Level」（Label クラス）にもレベルナンバーが反映していること 現在のスコアを表示する では次に現在のスコアを「HUD」の孫ノード「Score」に反映するように更新していこう。併せて「NextScreen」の孫ノードの方の「Score」にも同様に反映させる。また、現状、得点のシステムが全くない状態なので、ブロックを消したらポイントを獲得できるようにしていく。\nでは「Game.gd」スクリプトを更新していこう。\nconst POINT = 100 # 追加 スコア関連の定数と変数を追加した。POINTはブロックを一つ消した時に獲得できるポイントを100として定義した。これはずっと変わらないのでconstキーワードにより定数としている。\nvar score = 0 # 追加 var bonus_rate = 1.0 # 追加 変数scoreには一旦初期値の0を代入している。この変数には、ブロックを消して獲得したポイントを毎回加算してこれまでの合計値を保持させる。また、後ほどその値を「HUD」および「NextScreen」に反映させるように調整していく。\n変数bonus_rateは、ブロックを消すたびに増加させて、ボールを落としたら初期値1.0にリセットされるようにする予定である。一つのブロックを消したときにPOINT定数の100にbonus_rateを乗じた値をポイントとして獲得できるようにする。そうすることで、うまくブロックを消し続けるほど高得点が得られるようになる。ボールを落とすとbonus_rateの値を初期値にリセットさせる予定だ。\nonready var next_screen_score = $NextScreen/VBox/Score # 追加 onready var hud_score = $HUD/LeftBox/Score # 追加 次にonreadyキーワード付きの変数について見ていこう。追加しているのは 2 行だけだ。どちらも特定のノードを変数として定義している。next_screen_scoreは「NextScreen」ノードの孫ノード「Score」を、hud_scoreは「HUD」ノードの孫ノード「Score」をそれぞれ代入している。\n# Method receiving signal func _on_Brick_tree_exited(): # Update Score score += POINT * bonus_rate # 追加 bonus_rate += 0.1 # 追加 hud_score.text = \"Level: \" + str(score) # 追加 # メソッド内の以下省略 _on_Brick_tree_exitedにいくつか処理を追加する。この関数はブロックが消された時に「Brick-」ノードからtree_exitedシグナルを受信するメソッドであることを思い出してほしい。今回、ブロックを消した時の処理に以下の3つを追加した形だ。\nscore += POINT * bonus_rateにより、変数scoreの値にボーナス率であるbonus_rateを乗じた値がポイントとして加算される。 bonus_rate += 0.1は、その時のbonus_rateの値に0.1が加算する、という意味だ。なお、このアップデートされたボーナス率は次にブロックを消した時に利用される。 hud_score.text = \"Level: \" + str(score) は、常に HUD の表示を更新するためのコードだ。「HUD」の孫ノード「Score」（Labelクラス）の「Text」プロパティの値として、ブロックが消されるたびにその時の変数scoreの値を代入している。 func set_next_level(): print(\"set_next_level() start\") level_num += 1 # Show NextScreen node next_screen_level.text = \"Level: \" + str(level_num) next_screen_score.text = \"Score: \" + str(score) # 追加 next_screen.show() # メソッド内の以下省略 set_next_level関数にも 1 行だけコードを追加した。next_screen_score.text = \"Score: \" + str(score)だ。これは「NextScreen」ノードの孫ノード「Score」（Labelクラス）の「Text」プロパティに「Score: (現在の変数scoreの値)」という文字列を代入している。これにより、次のレベルの準備画面に現在のスコアが表示されるようになるはずだ。\nではまず、ブロックを消したら HUD のスコア表示が更新されるか確認してみよう。「Level1」ノードのブロックを全て表示してテストするため、_ready内のleave_one_brickの行をコメントアウトしてから、プロジェクトを実行する。\nfunc _ready(): # For debug #leave_one_brick(43) #コメントアウト ブロックを消すたびに HUD のスコアにボーナス込みのポイントが加算されているのが確認できた。\n今度は次のレベルの前の準備画面「NextScreen」にスコアが反映するかを確認する。さっきコメントアウトした_ready内のleave_one_brickの行をアクティブにしてから、プロジェクトを実行して確認してみよう。\nfunc _ready(): # For debug leave_one_brick(43) 最後の1つを残して他のブロックを消した状態からスタートしているので、かなり高得点からの開始だが、「NextScreen」には問題なく変数scoreの値が反映されたことが確認できた。\nそれでは一旦ここまでに更新した「Game.gd」スクリプト全体を確認しておこう。\nextends Node2D const POINT = 100 var level_num = 1 var score = 0 var bonus_rate = 1.0 onready var level = $Level1 onready var next_screen = $NextScreen onready var next_screen_level = $NextScreen/VBox/Level onready var next_screen_score = $NextScreen/VBox/Score onready var hud_level = $HUD/LeftBox/Level onready var hud_score = $HUD/LeftBox/Score onready var paddle = $Paddle onready var ball = $Ball onready var paddle_position = paddle.position onready var ball_position = ball.position func _ready(): # For debug leave_one_brick(43) for brick in level.get_children(): brick.connect(\"tree_exited\", self, \"_on_Brick_tree_exited\") get_tree().paused = true # For debug func leave_one_brick(brick_num: int): for child in level.get_children(): if child.get_name() == \"Brick\" + str(brick_num): continue child.queue_free() # Method receiving signal func _on_Brick_tree_exited(): # Update Score score += POINT * bonus_rate bonus_rate += 0.1 hud_score.text = \"Score: \" + str(score) # Exit current Level node print(\"get child count: \", level.get_child_count()) if level.get_child_count() \u003c= 0: level.queue_free() print(\"level queue free\") set_next_level() func set_next_level(): print(\"set_next_level() start\") level_num += 1 # Show NextScreen node next_screen_level.text = \"Level: \" + str(level_num) next_screen_score.text = \"Score: \" + str(score) next_screen.show() # Set Level of HUD the next level hud_level.text = \"Level: \" + str(level_num) # Set Paddle and Ball the first position paddle.position = paddle_position ball.position = ball_position ball.mode = 3 # Set next Level node level = load(\"res://scene/Level\" + str(level_num) + \".tscn\").instance() add_child(level) move_child(level, 5) for child in level.get_children(): child.connect(\"tree_exited\", self, \"_on_Brick_tree_exited\") # Pause game until NextScreen is hidden get_tree().paused = true 現在のライフを表示する それでは最後に HUD の最後のセクションであるライフの表示に関わる更新していく。必要な作業は以下の通りだ。\n「Ball」ノードをシーンとして保存する 「Ball.gd」スクリプトを更新する 「Game.gd」スクリプトを更新する 「Ball」ノードをシーンとして保存する Ballが画面下に落ちたらライフが一つ減る、という仕組みにしたい。この仕組みを成立させるためには、ボールが下に落ちたら「Ball」ノードを削除して、新しい「Ball」ノードを追加する必要がある。「Ball」ノードを追加するには、現在「Game」ルートノードの子である「Ball」ノードをシーンとして保存し、毎回そのインスタンスを新しいノードとして追加するのが効率的だ。\nシーンドックで「Game」シーンの「Ball」ノードを右クリックし、「ブランチをシーンとして保存」を選択しよう。\n「res://scene/Ball.tscn」として保存すれば「Ball」シーンの完成だ。\n「Ball.gd」スクリプトを更新する この流れで、先に「Ball」ノードにアタッチしているスクリプト「Ball.gd」の方を先に更新しておく。\nfunc _on_VisibilityNotifier2D_screen_exited(): queue_free() #get_tree().change_scene(\"res://scene/GameOverView.tscn\") # 不要 「Ball.gd」スクリプトの一番最後にあるfunc _on_VisibilityNotifier2D_screen_exited():のブロックの中を修正する。ゲームオーバー画面へシーンを切り替えるコードget_tree().change_scene(\"res://scene/GameOverView.tscn\") を削除、またはコメントアウトするだけだ。理由は、ゲームオーバーになるタイミングが、今までは1回ボールが画面下に落ちた時だったが、これからはライフがゼロになった時に変わるからだ。その部分のコードは「Game.gd」スクリプトの方に記述していくので、こちらの更新はこれだけだ。\n「Game.gd」スクリプトを更新する では「Game.gd」スクリプトの更新内容を上から順番に確認していこう。\nvar life = 3 変数lifeの初期値を3として定義した。この値と「HUD」ノードの孫ノード「Life-」の表示数とが一致するようにしていく。「Life-」の数は全部で5個あるが、のちのちライフアップのアイテムも検討しているのと、5だと易しすぎるので3とした。\nonready var next_screen_life = $NextScreen/VBox/HBoxContainer/Life onready var hud_rightbox = $HUD/RightBox onreadyキーワード付きの変数を2つ追加した。next_screen_lifeは「NextScreen」ノードの曽孫ノード「Life」を、hud_rightboxは「HUD」ノードの子ノード「RightBox」をそれぞれ指している。\nfunc _ready(): # For debug leave_one_brick(43) update_hud_life() # 追加 ball.connect(\"tree_exited\", self, \"_on_Ball_tree_exited\") # 追加 for brick in level.get_children(): brick.connect(\"tree_exited\", self, \"_on_Brick_tree_exited\") _readyのブロック内にいくつか処理を追加した。まずupdate_hud_lifeという関数を追加したが、この関数の内容はあとで説明する。\nball.connect(\"tree_exited\", self, \"_on_Ball_tree_exited\") は「Ball」ノードのtree_exitedシグナルをこのスクリプトの_on_Ball_tree_exitedという関数に接続している。tree_exitedはたびたび使用しているが、そのノードがシーンツリーから削除された時に発信されるシグナルだ。ボールが画面下に落ちて、シーンツリーから消えたタイミングでライフを更新するために絶対に必要なシグナルなのだ。\n# Method receiving Ball signal func _on_Ball_tree_exited(): life -= 1 update_hud_life() if life \u003c= 0: get_tree().change_scene(\"res://scene/GameOverView.tscn\") else: paddle.position = paddle_position ball = load(\"res://scene/Ball.tscn\").instance() add_child(ball) move_child(ball, 3) ball.connect(\"tree_exited\", self, \"_on_Ball_tree_exited\") 先程のシグナルtree_exitedの接続先のメソッドがこの_on_Ball_tree_exitedだ。ボールが画面下に落ちて消えたタイミングで実行される。\nボールが画面下に落ちた時、ライフを一つ減らしたいので、まず変数lifeから- 1している。その次にupdate_hud_lifeという関数を実行して、ライフに関わるアップデートをしているが、その処理内容について詳しくはのちほど説明する。\nif life \u003c= 0:のブロックでは、ライフがゼロの場合、get_tree().change_scene(\"res://scene/GameOverView.tscn\")でゲームオーバー画面に遷移するようにしている。このコードは元々「Ball.gd」スクリプトにあったものだが、ゲームオーバーの条件が変わったため、こちらに移動させた。\n次にelse:ブロックだ。\nボールが画面下に落ちたら、パドルも一旦初期位置に戻したいのでpaddle.position = paddle_positionとしている。\nボールが画面下に落ちて「Ball」ノードが消えたら、新しい「Ball」ノードを用意する必要がある。そのために、まず「Ball.tscn」シーンファイルを読み込み、そのインスタンス作って、変数ballに代入している。そのあとadd_childで、その新しい「Ball」インスタンスを「Game」ルートノードの子ノードとして追加している。そしてさらにmove_childで、「Ball」ノードの順序を最後尾から最初と同じ3番目に移動させている。最後に改めて、新しい「Ball」ノードのtree_exitedシグナルを_on_Ball_tree_exitedメソッドに接続している。\n# Set life nodes shown and hidden as life variable func update_hud_life(): var count = 0 for child in hud_rightbox.get_children(): count += 1 if count \u003c= life: child.show() else: child.hide() update_hud_lifeという関数を新たに追加した。_ready内で実行されていたものだ。\nこれは HUD のライフ表示を更新するためのメソッドだ。forループ内では、「HUD」ノードの子ノード「RightBox」にぶら下がっている全ての子ノード、つまり全ての「Life-」ノードに対して処理を実行している。その処理というのは、「Life-」ノードの「RightBox」ノード中の順番が、変数lifeの値以下だったら表示し、そうでなければ非表示にする、というものだ。例えば、変数lifeの値が2になったら、「Life1」、「Life2」までは表示し、「Life3」、「Life4」、「Life5」は非表示にする、ということになる。\nfunc set_next_level(): print(\"set_next_level() start\") level_num += 1 # Show NextScreen node next_screen_level.text = \"Level: \" + str(level_num) next_screen_score.text = \"Score: \" + str(score) next_screen_life.text = \"x \" + str(life) # 追加 next_screen.show() # 以下省略 最後の更新箇所がこちらのset_next_level内のブロックだ。next_screen_life.text = \"x \" + str(life) の一行を追加した。内容は「NextScreen」ノードの「Life」ノードの「Text」プロパティの値（文字列）に変数lifeの値を反映させる、というものだ。\nこれで HUD のライフに関わる更新ができたはずだ。実際にプロジェクトを実行して確認してみよう。\n以下の動作に問題がないことを確認できた。\n「NextScreen」に現在のライフが表示される HUD のライフがボールを画面下に落とすたびに減る HUD のライフがゼロになったらゲームオーバー画面に遷移する 最終的に「Game.gd」のスクリプト全体はこのようになっている。うまく動作しなかった方はご自身で作ったスクリプトと見比べてみて欲しい。\nextends Node2D const POINT = 100 var level_num = 1 var score = 0 var bonus_rate = 1.0 var life = 3 onready var level = $Level1 onready var next_screen = $NextScreen onready var next_screen_level = $NextScreen/VBox/Level onready var next_screen_score = $NextScreen/VBox/Score onready var next_screen_life = $NextScreen/VBox/HBox/Life onready var hud_level = $HUD/LeftBox/Level onready var hud_score = $HUD/LeftBox/Score onready var hud_rightbox = $HUD/RightBox onready var paddle = $Paddle onready var ball = $Ball onready var paddle_position = paddle.position onready var ball_position = ball.position func _ready(): # For debug leave_one_brick(43) update_hud_life() ball.connect(\"tree_exited\", self, \"_on_Ball_tree_exited\") for brick in level.get_children(): brick.connect(\"tree_exited\", self, \"_on_Brick_tree_exited\") get_tree().paused = true # For debug func leave_one_brick(brick_num: int): for child in level.get_children(): if child.get_name() == \"Brick\" + str(brick_num): continue child.queue_free() # Method receiving Ball signal func _on_Ball_tree_exited(): life -= 1 update_hud_life() if life \u003c= 0: get_tree().change_scene(\"res://scene/GameOverView.tscn\") else: paddle.position = paddle_position ball = load(\"res://scene/Ball.tscn\").instance() add_child(ball) move_child(ball, 3) ball.connect(\"tree_exited\", self, \"_on_Ball_tree_exited\") # Set life nodes shown and hidden as life variable func update_hud_life(): var count = 0 for child in hud_rightbox.get_children(): count += 1 if count \u003c= life: child.show() else: child.hide() # Method receiving Brick signal func _on_Brick_tree_exited(): # Update Score score += POINT * bonus_rate bonus_rate += 0.1 hud_score.text = \"Score: \" + str(score) # Exit current Level node print(\"get child count: \", level.get_child_count()) if level.get_child_count() \u003c= 0: level.queue_free() print(\"level queue free\") set_next_level() func set_next_level(): print(\"set_next_level() start\") level_num += 1 # Show NextScreen node next_screen_level.text = \"Level: \" + str(level_num) next_screen_score.text = \"Score: \" + str(score) next_screen_life.text = \"x \" + str(life) next_screen.show() # Set Level of HUD the next level hud_level.text = \"Level: \" + str(level_num) # Set Paddle and Ball the first position paddle.position = paddle_position ball.position = ball_position ball.mode = 3 # Set next Level node level = load(\"res://scene/Level\" + str(level_num) + \".tscn\").instance() add_child(level) move_child(level, 5) for child in level.get_children(): child.connect(\"tree_exited\", self, \"_on_Brick_tree_exited\") # Pause game until NextScreen is hidden get_tree().paused = true おわりに 以上で Part 7 は完了だ。かなり長くなってしまったが、最後までうまく進められただろうか。今回行ったブロック崩しの更新内容をまとめておく。\nHUD に必要なノードを追加した 次のレベルの準備画面「NextScreen」に必要なノードを追加した 主に「Game.gd」スクリプトによってゲームの状況を HUD と NextScreen に連動させた 次回 Part 8 ではさらにプレイ中のポーズ画面とポーズ機能を追加していく予定だ。\n","wordCount":"17065","inLanguage":"ja","image":"https://www.peanuts-code.com/images/tutorials/gd0004_breakout/breakout_7/img_35.gif","datePublished":"2021-11-23T23:45:05+09:00","dateModified":"2021-11-23T23:45:05+09:00","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/breakout_7/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/ja/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/en/ title=English aria-label=🇬🇧English>🇬🇧English</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/ja/ title=ホーム><span>ホーム</span></a></li><li><a href=https://www.peanuts-code.com/ja/portfolio/ title=ゲーム><span>ゲーム</span></a></li><li><a href=https://www.peanuts-code.com/ja/posts/ title=ブログ><span>ブログ</span></a></li><li><a href=https://www.peanuts-code.com/ja/tutorials/ title=チュート><span>チュート</span></a></li><li><a href=https://www.peanuts-code.com/ja/about/ title=サイト紹介><span>サイト紹介</span></a></li><li><a href=https://www.peanuts-code.com/ja/search/ title="サイト内検索 (Alt + /)" accesskey=/><span>サイト内検索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/ja/>ホーム</a>&nbsp;»&nbsp;<a href=https://www.peanuts-code.com/ja/tutorials/>🤖 チュート</a>&nbsp;»&nbsp;<a href=https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/>🤖 シリーズ：Godot で作るブロック崩し</a></div><h1 class="post-title entry-hint-parent">Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！</h1><div class=post-meta><span title='2021-11-23 23:45:05 +0900 +0900'>2021-11-23</span>&nbsp;·&nbsp;35 分</div><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！ on x" href="https://x.com/intent/tweet/?text=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e5%b4%a9%e3%81%97%20Part%207%ef%bc%9aHUD%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e8%a1%a8%e7%a4%ba%e5%86%85%e5%ae%b9%e3%82%92%e6%9b%b4%e6%96%b0%e3%81%97%e3%81%a6%e3%81%bf%e3%82%88%e3%81%86%ef%bc%81&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0004_breakout%2fbreakout_7%2f&amp;hashtags=GodotEngine%2cGameDev%2c%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e5%b4%a9%e3%81%97%2c2D"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0004_breakout%2fbreakout_7%2f&title=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e5%b4%a9%e3%81%97%20Part%207%ef%bc%9aHUD%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e8%a1%a8%e7%a4%ba%e5%86%85%e5%ae%b9%e3%82%92%e6%9b%b4%e6%96%b0%e3%81%97%e3%81%a6%e3%81%bf%e3%82%88%e3%81%86%ef%bc%81"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0004_breakout%2fbreakout_7%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/ja/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/ja/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/ja/tags/%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%B4%A9%E3%81%97/>ブロック崩し</a></li><li><a href=https://www.peanuts-code.com/ja/tags/2d/>2D</a></li></ul></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0004_breakout/breakout_7/img_35.gif alt="ブロック崩し Part 7 サムネイル"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目次</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#ノードを追加する>ノードを追加する</a><ul><li><a href=#ノードの並び順を変更する>ノードの並び順を変更する</a></li><li><a href=#シーンの背景を黒にする>シーンの背景を黒にする</a></li><li><a href=#シーンを実行して確認>シーンを実行して確認</a></li></ul></li><li><a href=#hud-のレベルとスコアを作る>HUD のレベルとスコアを作る</a><ul><li><a href=#leftboxノードの編集>「LeftBox」ノードの編集</a></li><li><a href=#levelノードとscoreノードのtextプロパティの編集>「Level」ノードと「Score」ノードの「Text」プロパティの編集</a></li><li><a href=#levelノードの編集>「Level」ノードの編集</a></li><li><a href=#scoreノードの編集>「Score」ノードの編集</a></li><li><a href=#シーンを実行して確認-1>シーンを実行して確認</a></li></ul></li><li><a href=#hud-のライフを作る>HUD のライフを作る</a><ul><li><a href=#rightboxノードの編集>「RightBox」ノードの編集</a></li><li><a href=#life1ノードの編集>「Life1」ノードの編集</a></li><li><a href=#シーンを実行して確認-2>シーンを実行して確認</a></li></ul></li></ul><ul><li><a href=#現在のレベルを表示させる>現在のレベルを表示させる</a><ul><li><a href=#次のレベルのシーンを追加する>次のレベルのシーンを追加する</a></li><li><a href=#次のレベルに行く前の準備画面を作る>次のレベルに行く前の準備画面を作る</a></li><li><a href=#スクリプトで-hud-のレベルを変化させる>スクリプトで HUD のレベルを変化させる</a></li></ul></li><li><a href=#現在のスコアを表示する>現在のスコアを表示する</a></li><li><a href=#現在のライフを表示する>現在のライフを表示する</a><ul><li><a href=#ballノードをシーンとして保存する>「Ball」ノードをシーンとして保存する</a></li><li><a href=#ballgdスクリプトを更新する>「Ball.gd」スクリプトを更新する</a></li><li><a href=#gamegdスクリプトを更新する>「Game.gd」スクリプトを更新する</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>Part 7 の今回は、HUD（ヘッドアップディスプレイ）を作っていく。HUD というのは、例えば、プレイヤーのライフゲージやスコア、残り時間、レベル（ステージ）の番号などのように、ゲームプレイ画面に常に表示されているもののことだ。</p><p>それでは前回に引き続き<strong>ブロック崩し</strong>を開発していこう。</p><br><blockquote><p><em><strong><span style=color:salmon>Memo:</span></strong><br>過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。<br><a href=https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/ title="Godot で作るブロック崩し">Godot で作るブロック崩し</a></em></p></blockquote><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h1 id=hudの大まかなレイアウトをデザインする>HUDの大まかなレイアウトをデザインする</h1><p>ゲーム画面のデザインを作るとき、いきなり Godot でシーンを追加していくのは得策ではない。なぜなら、大まかなレイアウトが決まっていない状態では、「ああでもない、こうでもない」とノードの追加と削除を繰り返し、なかなかゴールに辿り着けなくなる恐れがあるからだ。</p><p>デザインの作業をする時は、まずをラフスケッチ作るところから始めよう。使う道具は紙と鉛筆でもいいし、PowerPoint や Keynote などスライド作成アプリでもいい。気軽に始められるツールで作業しよう。</p><p>今回は、このラフスケッチを基に「Game」シーンにノードを追加していく。ちなみにこのスケッチは iPad のメモアプリに ApplePencil で書いた。<br><img alt=HUDの下書き loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_1.png></p><br><hr><h1 id=hud-を作る>HUD を作る</h1><p>さきほどのラフスケッチに、さらにノードのクラスを加筆してみたのがこれだ。<br><img alt=HUDの下書きにノード追記 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_2.png></p><p>それでは「Game」シーンに HUD を追加していこう。</p><br><h2 id=ノードを追加する>ノードを追加する</h2><p>まずはHUDに必要なノードを一気に追加していこう。</p><ol><li>「Game」ノードに「Control」ノードを追加し、名前を「HUD」に変更</li><li>「HUD」ノードに「ColorRect」ノードを追加し、名前を「Backgournd」に変更</li><li>「HUD」ノードに「VBoxContainer」ノードを追加し、名前を「LeftBox」に変更</li><li>「HUD」ノードに「HBoxContainer」ノードを追加し、名前を「RightBox」に変更</li><li>「LeftBox」ノードに「Label」ノードを2つ追加し、それぞれの名前を「Level」、「Score」に変更</li><li>「RightBox」ノードに「TextureRect」ノードを追加し、名前を「Life1」に変更</li></ol><p>ここまでできたら、次はノードの並び順を更新しよう。</p><h3 id=ノードの並び順を変更する>ノードの並び順を変更する</h3><p>一般的に HUD はゲーム画面の最前面に表示されることが多いが、ブロック崩しでは、プレイ中に HUD の背後にボールが隠れてしまわないように、HUD を最背面に配置する。</p><p>原則として、シーンドック内で下にあるノードほどゲーム画面では前面に表示される。ノード追加時の仕様上、「HUD」ノードを追加した直後は最前面（シーンドックでは一番下）に配置されているだろう。「HUD」ノードを「Game」ノードの最背面に配置するには、単純にシーンドック内で「Game」ノードのすぐ下に「HUD」ノードをドラッグ&ドロップすれば良い。</p><p>ここまでできたら、シーンドック上の「HUD」関連ノードの並びは以下のようになったはずだ。<br><img alt=シーンドックでHUDの配置確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_3.png></p><br><h3 id=シーンの背景を黒にする>シーンの背景を黒にする</h3><p>HUDの「Level」や「Score」の文字は白で表示したい。白を強調するために、先に「Game」シーンの背景を黒にしてしまおう。</p><ol><li>親の「HUD」ノードを画面いっぱいに広げるため、シーンドックで「HUD」ノードを選択して、ツールバーから「レイアウト」＞「Rect全面」を選択する。</li><li>シーンドックで「HUD」ノードの子ノード「Backgournd」を選択して、同様にツールバーから「レイアウト」＞「Rect全面」を選択する。</li><li>インスペクタで「Backgournd」ノードの「Color」プロパティを黒（000000）に設定する。<br><img alt=BackgourndのColorプロパティを黒に loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_4.png></li></ol><br><h3 id=シーンを実行して確認>シーンを実行して確認</h3><p>以下のように表示されたら想定通りだ。<br><img alt=デバッグパネルでBackgourndの表示確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_5.png></p><br><h2 id=hud-のレベルとスコアを作る>HUD のレベルとスコアを作る</h2><h3 id=leftboxノードの編集>「LeftBox」ノードの編集</h3><p>次に HUD の左側にレベルとスコアの表示を作っていく。「LeftBox」ノードを編集していこう。以下の手順で「LeftBox」のレイアウトを調整する。</p><ol><li>シーンドックで「LeftBox」ノードを選択する</li><li>ツールバーで「レイアウト」＞「左上」を選択する</li><li>ツールバーでグリッドスナップを有効にする</li><li>移動モードを有効にし、2D ワークスペースで右と下に 1 グリッド（8 px）分移動する</li><li>選択モードを有効にして、2D ワークスペースで枠の右側を x 座標 320 まで広げる</li></ol><p><img alt="2D ワークスペースでLeftBox移動" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_6.png></p><p>インスペクタで「Margin」プロパティを見るとこのようになっているはずだ。もちろん上記のような 2D ワークスペースでの直感的操作ではなく、直接インスペクタ上でプロパティの数値を入力しても問題ない。<br><img alt=LeftBoxのMarginプロパティ loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_7.png></p><br><h3 id=levelノードとscoreノードのtextプロパティの編集>「Level」ノードと「Score」ノードの「Text」プロパティの編集</h3><p>続いて「LeftBox」ノードに追加した2つの「Label」ノードを編集していく。</p><ol><li>「Level」ノードの「Text」プロパティに「Level: 1」と入力する</li><li>「Score」ノードの「Text」プロパティに「Score: 0」と入力する</li></ol><p>これで HUD の左側に「Level」と「Score」が表示された。実際の数字はスクリプトでプレイ中に随時更新されるようにしていくが、一旦初期値としてこの状態にしておく。<br><img alt="2D ワークスペースでLevelとScoreの確認" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_8.png></p><p>フォントはデフォルトのままでも違和感ないが、せっかくなので、チュートリアル Part 6 でダウンロードした「PressStart2P-Regular.ttf」を適用しよう。軽く手順をおさらいしておく。</p><blockquote><p><strong><span style=color:salmon>Memo:</span></strong><br>「PressStart2P-Regular.ttf」のフォントがファイルシステムドックに見当たらない場合は、<a href="https://fonts.google.com/specimen/Press+Start+2P?preview.text=BREAKOUT%20press%20any%20key&amp;preview.text_type=custom&amp;stylecount=1&amp;query=press" target=_blank>Google Fonts のサイト</a>
から「<strong>Press Start 2P</strong>」というフォントをダウンロードして、ファイルシステムに改めて追加してください。</p></blockquote><br><h3 id=levelノードの編集>「Level」ノードの編集</h3><ol><li>シーンドックで「Level」ノードを選択し、インスペクタで「Custom Fonts」セクションを開く</li><li>「Font」プロパティ（一番上の方）で「新規 DynamicFont」を選択する。</li><li>「Font」プロパティ（四番目の方）の[空]に、ファイルシステムから「PressStart2P-Regular.ttf」をドラッグ&ドロップする。</li><li>「Size」プロパティの値を<code>12</code>にする。<br><img alt="2D ワークスペースでLevelとScoreの確認" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_8.1.png></li></ol><br><h3 id=scoreノードの編集>「Score」ノードの編集</h3><p>「Score」ノードも同様に設定するが、フォントファイルはインスペクタ上でコピー&ペーストができるのでその方法で設定しよう。</p><ol><li>「Level」ノードのインスペクタで「Custom Fonts」を開き、「Font」プロパティ（四番目の方）の「Font Data」右側のプルダウンをクリックして「<strong>コピー</strong>」を選択する。<br><img alt="2D ワークスペースでLevelとScoreの確認" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_8.2.png></li><li>「Score」ノードのインスペクタに切り替えて、「Custom Fonts」を開き、「Font」プロパティ（一番上の方）で「新規 DynamicFont」を選択する。</li><li>続けて「Font」プロパティ（四番目の方）の「Font Data」右側のプルダウンをクリックして「<strong>貼り付け</strong>」を選択する。<br><img alt="2D ワークスペースでLevelとScoreの確認" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_8.3.png></li></ol><p>これでカスタムフォントの設定ができた。<br><br></p><h3 id=シーンを実行して確認-1>シーンを実行して確認</h3><p>シーンを実行して、レベルとスコアの表示を確認しておこう。<br><img alt="2D ワークスペースでLevelとScoreの確認" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_8.4.png></p><br><h2 id=hud-のライフを作る>HUD のライフを作る</h2><p>次は HUD の右側にライフを表示させる。</p><h3 id=rightboxノードの編集>「RightBox」ノードの編集</h3><p>以下の手順で「RightBox」ノードのレイアウトを調整する。</p><ol><li>シーンドックで「RightBox」ノードを選択する</li><li>ツールバーで「レイアウト」＞「右上」を選択する</li><li>移動モードを有効にして、左と下に 1 グリッド（8 px）分移動する</li><li>選択モードを有効にして、枠の左側を x 座標 320 まで広げる<br><img alt="2D ワークスペースでRightBoxの編集" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_9.png></li><li>インスペクタで「Alignment」プロパティの値を「End」に変更しておく。これで子ノードが右寄せで配置される。<br><img alt=RightBoxのAlignmentプロパティの確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_10.png></li></ol><br><p>インスペクタでプロパティを見るとこのようになっているはずだ。さきほどの「LeftBox」の時と同様に、「Margin」プロパティに関しては、直接インスペクタ上で数値を入力してもOKだ。<br><img alt=RightBoxのMarginプロパティの確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_10.1.png></p><br><h3 id=life1ノードの編集>「Life1」ノードの編集</h3><p>次に「RightBox」の子ノード「Life1」ノードを編集していこう。「TextureRect」クラスは「Sprite」クラス同様、画像ファイルを割り当ててそれを表示することができる。</p><ol><li>シーンドックで「Life1」ノードを選択する。</li><li>ファイルシステムの「res://sprites/Heart3.png」（一番小さいハート）をインスペクタの「Texture」プロパティの[空]めがけてドラッグ&ドロップする。<br><img alt=ファイルシステムドックからTextureプロパティへドラッグ&ドロップ loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_11.png></li></ol><br><p>これで画像がセットされた。<br><img alt=インスペクタでTextureプロパティ確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_12.png></p><p>2D ワークスペースにはこのように表示されたはずだ。ただ、残念ながら、画像が元のサイズのままだと少し大きすぎる。もう少し小さく控えめにしていく。<br><img alt=2DワークスペースでLife1を確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_13.png></p><p>ではインスペクタで「Life1」ノードの必要なプロパティを以下の手順で変更していこう。</p><ol><li>まずは「Expand」プロパティを「オン」にする。「Strech Mode」プロパティはそのまま。<br><img alt="Expandをオン、Strech ModeをScale On Expandにする" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_14.png></li><li>「Rect」＞「Min Size」プロパティの x, y をそれぞれ 16 にする。これはノードのサイズの最小値だ。ここを(16, 16)としておくことで、親ノードの「RightBox」のサイズは子ノードの最初値(16, 16)より小さくすることはできない。<br><img alt="Min Sizeを(16, 16)にする" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_15.png></li><li>「RightBox」を選択モードにして枠の下側を 2 グリッド分（16 px）上げて、ちょうど「Life1」ノードにフィットするように上下幅を小さくする。一見回りくどい設定の仕方であり、「Life1」ノードだけを単に 16 px 上に移動させれば良いのでは、と思った方もいるかもしれない。しかし、「Containter」系のクラスの子ノードはそれ自体の位置を変更することができない。位置は完全に親の「Container」クラスに支配されているのだ。<br><img alt="Min Sizeを(16, 16)にする" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_16.png></li></ol><br><p>改めて「RightBox」のインスペクタでプロパティを見るとこのようになっているはずだ。<br><img alt=RightBoxのMaginプロパティ loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_17.png></p><p>「Life1」のプロパティ設定が終わったところで、シーンドックで「Life1」ノードを4つ複製して「Life5」まで量産しよう。このような作業はショートカットキーが便利だ（複製 > Windows: Ctrl + D / macOS: Cmd + D）。</p><p>シーンドックでこのようになっていればOKだ。<br><img alt=シーンドックでLife1からLife5まで確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_18.png></p><p>2D ワークスペースの方で見ると、このようにHBoxContainer内で横並びに配置される。<br><img alt="2D ワークスペースのLife1からLife5" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_19.png></p><p>ここまでの作業で、シーンドックはこのようになっている。<br><img alt=シーンドックのHUD loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_20.png></p><br><h3 id=シーンを実行して確認-2>シーンを実行して確認</h3><p>実際にシーンを実行して、HUD の表示が最初のラフスケッチとだいたい同じになったか確認しておこう。<br><img alt=デバッグパネルでHUDを確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_21.png></p><br><hr><h1 id=hud-をプレイ状況と連動させる>HUD をプレイ状況と連動させる</h1><p>ここからはゲームプレイの状況に応じて HUD の表示が変化するように、スクリプトも使って連動させていく。連動させたい内容は以下の3つだ。</p><ul><li>現在のレベルを表示させる</li><li>現在のスコアを表示させる</li><li>現在のライフを表示させる</li></ul><p>では順番に作業を進めていこう。</p><br><h2 id=現在のレベルを表示させる>現在のレベルを表示させる</h2><p>以下の作業が必要になるが、一つずつやっていこう。</p><ul><li>次のレベルのシーンを追加する</li><li>次のレベルに行く前の準備画面を作る</li><li>スクリプトで HUD のレベルを変化させる</li></ul><br><h3 id=次のレベルのシーンを追加する>次のレベルのシーンを追加する</h3><p>ブロックの配置などこだわり出すと時間がかかるので、ここではひとまず仮で次のレベルのシーンである「Level2」というシーンを作成する。一番簡単な方法は、すでに作成済みの「Level1」シーンを継承して作成する方法だ。</p><blockquote><p><strong><span style=color:salmon>Memo:</span></strong><br><strong>継承</strong>とは、オブジェクト指向のプログラミングでは大事な概念の一つです。他のクラスのプロパティやメソッドをそのまま引き継いで新たなクラスを作成することを指します。さらに内容を上書きして更新することもでき、また親のクラスを変更すると、自動的に継承した子クラスにも変更が反映されます。</p></blockquote><p>ではまず「シーン」メニュー＞「新しい継承シーン」を選択する。<br><img alt=「シーン」メニュー＞「新しい継承シーン」 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_22.png></p><p>次に 「Level1.tscn」ファイルを選択すれば、「Level1」シーンをまるまま継承したシーンができる。すぐにルートノードの名前を「Level2」に変更しておこう。<br><img alt=「Level2」に名前変更 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_23.png></p><p>そのまま新しく作ったシーン「Level2」を「Level2.tscn」という名前で保存すればひとまず2つ目のシーンの出来上がりだ。<br><img alt=「Level2.tscn」でシーンを保存 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_24.png></p><br><h3 id=次のレベルに行く前の準備画面を作る>次のレベルに行く前の準備画面を作る</h3><p>現状、レベルごとの準備画面がない。例えば「Level1」のブロックを全て消した後「Level2」に移行する時に、このままだとすぐに次のLevel2のブロックが画面に配置され、落ち着く暇もない。一呼吸置く意味でも、準備画面を作成していこう。準備画面には HUD と同じく以下の項目を表示させるよう構成する。</p><ul><li>次のレベル</li><li>現在のスコア</li><li>ライフ</li></ul><p>準備画面として「NextScreen」という名前のノードを「Game」ノードに追加し、レベルの切り替え時のみ画面に表示されるようにしていく。以下の手順で作業を進めていこう。</p><ol><li>では「Game」ノードに「Control」ノードを追加し、名前を「NextScreen」に変更する。</li><li>2D ワークスペースで「NextScreen」を選択モードにして、手動でサイズをプレイ画面全体に広げる。<br><img alt=「NextScreen」ノードを画面いっぱいに広げる loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_25.png></li><li>「NextScreen」ノードに「ColorRect」ノードを追加し、名前を「Background」に変更する。</li><li>2D ワークスペースで「Background」を「レイアウト」＞「Rect全面」で親ノードと同じだけ広げる。</li><li>インスペクタで「Background」の「Color」プロパティをお好みの色に変更する（例えば #106ed1）<br><img alt=「Background」ノードの状態 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_26.png></li><li>「NextScreen」ノードに「VBoxContainer」ノードを追加し、名前を「VBox」に変更する。インスペクタで「Alignment」プロパティの値を「Center」にする。さらに「Custom Constants」セクションの「Separation」プロパティの値を<code>24</code>にする。</li><li>「VBox」ノードに「Label」ノードを2つ追加し、名前をそれぞれ「Level」、「Score」とする。</li><li>インスペクタで「Level」ノードの「Text」プロパティの値を「Level: 1」とし、「Align」プロパティを「Center」にする。</li><li>同様に、「Score」ノードの「Text」プロパティの値を「Score: 0」とし、「Align」プロパティを「Center」にする。</li><li>「VBox」ノードに「HBoxContainer」ノードを追加し、名前を「HBox」に変更する。インスペクタで「Alignment」プロパティの値を「Center」にする。さらに「Custom Constants」セクションの「Separation」プロパティの値を<code>12</code>にする。</li><li>「HBox」ノードに「TextureRect」ノードを追加し、名前を「HeartImage」に変更する。インスペクタで「Texture」プロパティに、ファイルシステムから「res://sprites/Heart3.png」を割り当てる。続けて「Expand」プロパティをオンにし、「Rect」＞「Min Size」プロパティを (24, 24) にする。</li><li>「HBox」ノードに「Label」ノードを追加し、名前を「Life」に変更する。インスペクタで「Text」プロパティに「x 3」と入力する。</li><li>「Level」、「Score」、「Life」の3つの Label クラスのノードにカスタムフォントを設定する。「新規 DynamicFont」を設定し、「Font」プロパティにファイルシステムから「PressStart2P-Regular.ttf」を適用する。「Font」＞「Size」プロパティは<code>16</code>のままで良い。</li><li>シーンドックで「VBox」ノードを選択し、ツールバーの「レイアウト」＞「中央」を選択する。<br><img alt=2Dワークスペースで「NextScreen」ノードの確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_27.png></li></ol><p>さて、「NextScreen」ノードを追加したあと、シーンドックはこのようになっているだろうか。<br><img alt=シーンドックで「NextScreen」の位置確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_28.png></p><p>大事なポイントとして、「Game」ノードの子ノードのうち、「NextScreen」ノードが一番下に位置している必要がある。理由はゲームプレイ中は「NextScreen」ノードを非表示にしておき、一つのレベルをクリアして次のレベルをスタートする前に準備画面として表示し、その際、<strong>他のノードを覆い隠す</strong>ためだ。</p><br><h3 id=スクリプトで-hud-のレベルを変化させる>スクリプトで HUD のレベルを変化させる</h3><p>では、ここからスクリプトを作成していく。「NextScreen」にスクリプトをアタッチしよう。「res://scripts/NextScreen.gd」として保存する。</p><p>「NextScreen」ノードが画面に表示されている時に、インプットマップの「ui_accept」に該当するキー（Space、Enterなど）を入力すれば、次のレベルのプレイが開始されるような仕様にしたい。</p><p>そこでまず「NextScreen.gd」のスクリプトの中身を以下のコードで置き換えよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Control</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_input</span><span class=p>(</span><span class=n>event</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;ui_accept&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.1</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>hide</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=n>paused</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><p>まず、<code>yield</code>から始まる行のコードは丸ごと「GameStartView.gd」スクリプトから移動させた。これがないと、プレイヤーがスペースキーで次に進めた場合、プレイ画面に切り替わった瞬間にボールが発射されてしまうからだ。ということで、このタイミングで、<strong>「GameStartView.gd」スクリプトからはこの一行のコードをコメントアウトするか削除</strong>しておいてほしい。</p><p><code>hide</code>という関数は、「CanvasItem」クラスに組み込みのメソッドである。この関数を実行すると、画面上そのノードは非表示になる。ちなみにこれは、下のGIF画像のように、シーンドックでノードの右側の「目」アイコンをクリックして閉じるのと同じ意味だ。<br><img alt=シーンドックで「NextScreen」の表示/非表示 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_29.gif></p><p><code>get_tree().paused = false</code>は、プロジェクトの一時停止状態を解除するために実行する。後ほど、次のレベルの準備が終わったら「NextScreen」が最前面に表示された状態でプロジェクトを一時停止する処理を追加する。その時、インプットマップ<code>ui_accept</code>の操作により一時停止を解除して、次のレベルをスタートできるようにした。</p><br><p>それでは次に「Game」ノードにスクリプトをアタッチしよう。「res://scripts/Game.gd」として保存する。<br><img alt=Game.gdを保存 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_29.2.png></p><p>「Game」ノードは、シーンドック上、他の全てのノードの親ノードだ。そのため、このスクリプトではノード間をまたがって処理が必要な部分をコーディングしていく。少しコード量が今までより多くなるが頑張ろう。</p><p>まずは「Game.gd」スクリプトの内容を以下のコードで置き換えてほしい。そのあと一つずつスクリプトの内容を確認していく。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>level_num</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>level</span> <span class=o>=</span> <span class=nx>$Level1</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen</span> <span class=o>=</span> <span class=nx>$NextScreen</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen_level</span> <span class=o>=</span> <span class=nx>$NextScreen/VBox/Level</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>hud_level</span> <span class=o>=</span> <span class=nx>$HUD/LeftBox/Level</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>paddle</span> <span class=o>=</span> <span class=nx>$Paddle</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>ball</span> <span class=o>=</span> <span class=nx>$Ball</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>paddle_position</span> <span class=o>=</span> <span class=n>paddle</span><span class=o>.</span><span class=n>position</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>ball_position</span> <span class=o>=</span> <span class=n>ball</span><span class=o>.</span><span class=n>position</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># For debug</span>
</span></span><span class=line><span class=cl>	<span class=nf>leave_one_brick</span><span class=p>(</span><span class=mi>43</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>brick</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>brick</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Brick_tree_exited&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=n>paused</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># For debug</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>leave_one_brick</span><span class=p>(</span><span class=n>brick_num</span><span class=p>:</span> <span class=kt>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>child</span><span class=o>.</span><span class=nf>get_name</span><span class=p>()</span> <span class=o>==</span> <span class=s2>&#34;Brick&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>brick_num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=n>child</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method receiving signal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Brick_tree_exited</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_child_count</span><span class=p>()</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>level</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>set_next_level</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>set_next_level</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;set_next_level() start&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>level_num</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Show NextScreen node</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen</span><span class=o>.</span><span class=nf>show</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Set Level of HUD the next level</span>
</span></span><span class=line><span class=cl>	<span class=n>hud_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Set Paddle and Ball the first position</span>
</span></span><span class=line><span class=cl>	<span class=n>paddle</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>paddle_position</span>
</span></span><span class=line><span class=cl>	<span class=n>ball</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>ball_position</span>
</span></span><span class=line><span class=cl>	<span class=n>ball</span><span class=o>.</span><span class=n>mode</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Set next Level node</span>
</span></span><span class=line><span class=cl>	<span class=n>level</span> <span class=o>=</span> <span class=nb>load</span><span class=p>(</span><span class=s2>&#34;res://scene/Level&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span> <span class=o>+</span> <span class=s2>&#34;.tscn&#34;</span><span class=p>)</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>add_child</span><span class=p>(</span><span class=n>level</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>move_child</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>child</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Brick_tree_exited&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># Pause game until NextScreen is hidden</span>
</span></span><span class=line><span class=cl>	<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=n>paused</span> <span class=o>=</span> <span class=kc>true</span>
</span></span></code></pre></div><p>それでは上から順番に見ていこう。</p><p>最初に定義している<code>level_num</code>は単純に、現在のレベルの数値を保持する変数だ。初期値として<code>1</code>を入れている。</p><p>ノードが全て読み込まれてから定義すべき変数には<code>onready</code>キーワードをつけた。これらの変数は、ノードが全て読み込まれたあとのステップ（<code>_ready</code>関数を実行するタイミング）で定義されるので、変数の値に<code>get_node()</code>や<code>get_parent()</code>などの関数を含む場合に利用する。ちなみに変数の値の頭に<code>$</code>記号がついているものは、<code>get_node()</code>と同じ意味で、やや簡略化して記述できるので採用している。</p><p>変数<code>hud_level</code>から<code>next_screen_level</code>までは、値の示す通りそれぞれのノードを保持する。<code>paddle_position</code>と<code>ball_position</code>については、「Paddle」ノード、「Ball」ノードの位置を保持する。</p><p><code>_ready</code>関数では、コメントでも記述しているが、デバッグ用に<code>leave_one_brick(43)</code>という関数を実行している。これは<code>_ready</code>関数のすぐ下で定義している関数だ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># For debug</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>leave_one_brick</span><span class=p>(</span><span class=n>brick_num</span><span class=p>:</span> <span class=kt>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>child</span><span class=o>.</span><span class=nf>get_name</span><span class=p>()</span> <span class=o>==</span> <span class=s2>&#34;Brick&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>brick_num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=n>child</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span></code></pre></div><p>その内容は、「Level1」の子ノードの名前の最後が引数で指定した<code>43</code>の「Brick」ノードを残し、それ以外の「Brick」ノードを全て消すという処理だ。この「Brick43」というのは配置上、パドルの初期位置からボールを発射した時に最初にボールが当たるブロックなのだ。つまり、この唯一画面に残っている「Brick43」ノードにボールで当てればゲームクリアの状態が作れるようにしている。</p><p><code>_ready</code>関数内ではそのあと<code>for</code>ループを利用して、「Level1」の子ノードである全ての「Brick&ndash;」ノードでそれぞれシグナルの接続をコードで実行している。それが<code>brick.connect("tree_exited", self, "_on_Brick_tree_exited")</code>だ。第一引数にもなっている<code>tree_exited</code>というシグナルはデフォルトで用意されているもので、シーンツリーから消えたら信号を発信する。<code>self</code>はこの「Game.gd」スクリプトを指す。<code>_on_Brick_tree_exited</code>はこのスクリプト内の関数の名前だ。この関数にシグナルを接続している。これにより、シグナルが発信されれば<code>_on_Brick_tree_exited</code>関数が実行される。</p><p><code>get_tree().paused = true</code>で、プロジェクトを一時停止している。これは<code>_ready</code>で全ての準備が整ったら、一旦一時停止状態にして、「NextScreen」ノードが非表示になるまで入力操作も受け付けなくするためだ。ただし、このままでは「NextScreen」ノードも含めて全ての処理が停止してしまう。そこで、インスペクタで「NextScreen」ノードの「Pause Mode」プロパティを「Inherit」から「Process」に変更しておこう。これにより「NextScreen」ノードだけはプロセスが続行されるようになる。<br><img alt="NextScreenのPause ModeをProcessに変更" loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_29.1.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># Method receiving signal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Brick_tree_exited</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_child_count</span><span class=p>()</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>level</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>set_next_level</span><span class=p>()</span>
</span></span></code></pre></div><p>さて、シグナルを受信するメソッドがこちらの関数だ。「Level1」などの「Level」ノードの子ノード「Brick(番号)」がそれぞれボールに当たったら、消えるタイミングで、シグナルを発信し、この関数がそれを受け取る。そして、シグナルを受け取るたびに、ブロックの数がゼロになっていないかを確認している。それが<code>if level.get_child_count() &lt;= 0:</code>の一行だ。つまりこの if 構文で true になるのは、最後の1つのブロックが消えた時だ。</p><p>最後のブロックが消え、if 構文が true になったら、<code>queue_free</code>関数によって、親の「Level」ノードそのものが消える。そしてそのあと<code>set_next_level</code>関数によって、次のレベルの準備作業に入る、という流れだ。ではこの<code>set_next_level</code>関数の中身を見ていこう。</p><p><code>print("set_next_level() start")</code>は、この関数が実行されたのを確認するために用意している。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=n>level_num</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span></code></pre></div><p>これは<code>level_num = level_num + 1</code>と同じ意味である。今のレベルをクリアしたら、今現在のレベルナンバーを格納している変数<code>level_num</code>の値に 1 を加算し、レベルナンバーを次の数字に更新しているわけだ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># Show NextScreen node</span>
</span></span><span class=line><span class=cl><span class=n>next_screen_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>next_screen</span><span class=o>.</span><span class=nf>show</span><span class=p>()</span>
</span></span></code></pre></div><p><code>next_screen_level</code>という変数はこのスクリプトの冒頭で定義している「NextScreen」ノードの孫の「Level」ノードのことだ。そして、<code>.text</code>はその「Text」プロパティのことで画面に表示される文字列だ。その値を更新している。String 型（文字列）の値に int 型（整数）の値を格納した変数を結合したい場合、int 型は<code>str</code>関数によって文字列に変換できるので、このように<code>+</code>記号で連結すればひと続きの文字列にすることができる。</p><p><code>show</code>関数によって、非表示になっていた「NextScreen」ノードを表示している。このタイミングで次のレベルに行く前の準備画面に切り替わるわけだ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># Set Level of HUD the next level</span>
</span></span><span class=line><span class=cl><span class=n>hud_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span></code></pre></div><p><code>hud_level.text</code>も冒頭で定義している「HUD」ノードの孫「Level」ノードの「Text」プロパティだ。その値の数字部分を次のレベルナンバーに置き換えて、HUDの表示を更新している。たくさんのコードで埋もれそうだが、これが元々このチュートリアルでやろうとしていたことだ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># Set Paddle and Ball the first position</span>
</span></span><span class=line><span class=cl><span class=n>paddle</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>paddle_position</span>
</span></span><span class=line><span class=cl><span class=n>ball</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>ball_position</span>
</span></span><span class=line><span class=cl><span class=n>ball</span><span class=o>.</span><span class=n>mode</span> <span class=o>=</span> <span class=mi>3</span>
</span></span></code></pre></div><p>一つのレベルをクリアしたら次のレベルに移行するまでに、パドルとボールの位置を初期位置に戻す処理をしている。<code>.position</code>はそのノードの位置情報を格納するプロパティを指している。<code>paddle_position</code>及び<code>ball_position</code>はスクリプト冒頭で「Paddle」ノード、「Ball」ノードの初期位置を代入する形で定義済みだ。</p><p>ボールは「RigidBody2D」クラスのオブジェクトなので、「Mode」プロパティを「Character」から「Kinematic」に変更しないと、次のレベルが開始してパドルを動かした瞬間、どこか意図しない方向へ流れていってしまう。「Kinematic」に割り当てられている「Mode」プロパティの番号は<code>3</code>なので、<code>ball.mode = 3</code>としている。このあたりの「Ball」ノードの内容を忘れてしまった場合は、チュートリアル Part 2 を参照のこと。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># Set next Level node</span>
</span></span><span class=line><span class=cl><span class=n>level</span> <span class=o>=</span> <span class=nb>load</span><span class=p>(</span><span class=s2>&#34;res://scene/Level&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span> <span class=o>+</span> <span class=s2>&#34;.tscn&#34;</span><span class=p>)</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nf>add_child</span><span class=p>(</span><span class=n>level</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>move_child</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=n>child</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Brick_tree_exited&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>「Level1」ノードの全ての「Brick-」ノードを消したあと「Level1」ノード自体も<code>queue_free</code>関数で削除しているのえ、次の「Level2」シーンをノードとして「Game」シーンに追加する必要がある。</p><p><code>load</code>関数は、シーンファイルを読み込むための関数だ。引数にファイルパスを指定すれば読み込んでくれる。先に<code>level_num</code>変数は更新済みなので、それを利用してファイル名を指定している。<code>.instance</code>関数は読み込んだシーンファイルのインスタンスを作る。つまり設計図から実体を作っているわけだ。それを先ほどまで「Level1」ノードを格納していた変数<code>level</code>に代入している。</p><p><code>add_child</code>関数により、次の「Level2」シーンをこの「Game」シーンの子ノードとして追加している。シーンドックで「Game」ノードを選択した状態でノードを新しく追加する作業と同じ意味合いだ。</p><p><code>move_child</code>関数は、指定したノードを「Game」ノードの何番目の子ノードにするかを設定できる。先に<code>add_child</code>関数が実行された時には、 下のスクリーンショットのように「Level2」ノードがデフォルトで一番最後の順番（ここでは 6 番目）になってしまう。つまり、このままだと次のレベルのブロックが「NextScreen」ノードより全面に表示されてしまう。<br><img alt=NextScreenノードより全面にLevelノード loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_30.png></p><p>そこでこの<code>move_child</code>の第一引数に変数<code>level</code>（「Level2」ノード）を指定し、第二引数に<code>5</code>を指定して、5番目に移動しているという理屈だ。</p><p>最後に「Level2」ノードの全ての子ノード、つまり全ての「Brick-」ノードに対して、<code>for</code>ループを利用して<code>tree_exited</code>シグナルを<code>_on_Brick_tree_exited</code>関数に接続している。<code>_ready</code>関数内で最初に実行していたことと同じだ。なぜコードを使ってシグナルを接続するかというと、一つのレベルをクリアするたびに今の「Level-」ノードを削除して、次のレベルの「Level-」シーンを新たに子ノードとして追加するので、前もってノードドックから「Game」シーンのスクリプトにシグナルを接続しておくことができないからだ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># Pause game until NextScreen is hidden</span>
</span></span><span class=line><span class=cl><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=n>paused</span> <span class=o>=</span> <span class=kc>true</span>
</span></span></code></pre></div><p>最後に<code>_ready</code>でも最後に記述していたプロジェクト全体を一時停止するのためのコードだ。次のレベルの準備が全て整ったら、プレイヤーがインプットマップ「ui_accept」の操作を行うまでは、一時停止にする。</p><p>ではプロジェクトを実行して、実際の挙動を確認してみよう。<br><img alt=デバッグパネルで動作確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_31.gif></p><p>以下の動作に問題ないことが確認できた。</p><ul><li>次のレベル開始前に「NextScreen」ノードが表示されること</li><li>「NextScreen」ノードの孫ノード「Level」（Label クラス）にレベルナンバーが反映していること</li><li>インプットマップ「ui_accept」のキー操作により「NextScreen」ノードが非表示になること</li><li>次のレベルのプレイ画面が表示された時に、パドルとボールが初期位置に戻っていること</li><li>プレイ画面の「HUD」ノードの孫ノード「Level」（Label クラス）にもレベルナンバーが反映していること</li></ul><br><h2 id=現在のスコアを表示する>現在のスコアを表示する</h2><p>では次に現在のスコアを「HUD」の孫ノード「Score」に反映するように更新していこう。併せて「NextScreen」の孫ノードの方の「Score」にも同様に反映させる。また、現状、得点のシステムが全くない状態なので、ブロックを消したらポイントを獲得できるようにしていく。</p><p>では「Game.gd」スクリプトを更新していこう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>const</span> <span class=n>POINT</span> <span class=o>=</span> <span class=mi>100</span> <span class=c1># 追加</span>
</span></span></code></pre></div><p>スコア関連の定数と変数を追加した。<code>POINT</code>はブロックを一つ消した時に獲得できるポイントを<code>100</code>として定義した。これはずっと変わらないので<code>const</code>キーワードにより定数としている。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>var</span> <span class=n>score</span> <span class=o>=</span> <span class=mi>0</span> <span class=c1># 追加</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>bonus_rate</span> <span class=o>=</span> <span class=mf>1.0</span> <span class=c1># 追加</span>
</span></span></code></pre></div><p>変数<code>score</code>には一旦初期値の<code>0</code>を代入している。この変数には、ブロックを消して獲得したポイントを毎回加算してこれまでの合計値を保持させる。また、後ほどその値を「HUD」および「NextScreen」に反映させるように調整していく。</p><p>変数<code>bonus_rate</code>は、ブロックを消すたびに増加させて、ボールを落としたら初期値<code>1.0</code>にリセットされるようにする予定である。一つのブロックを消したときに<code>POINT</code>定数の<code>100</code>に<code>bonus_rate</code>を乗じた値をポイントとして獲得できるようにする。そうすることで、うまくブロックを消し続けるほど高得点が得られるようになる。ボールを落とすと<code>bonus_rate</code>の値を初期値にリセットさせる予定だ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen_score</span> <span class=o>=</span> <span class=nx>$NextScreen/VBox/Score</span> <span class=c1># 追加</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>hud_score</span> <span class=o>=</span> <span class=nx>$HUD/LeftBox/Score</span> <span class=c1># 追加</span>
</span></span></code></pre></div><p>次に<code>onready</code>キーワード付きの変数について見ていこう。追加しているのは 2 行だけだ。どちらも特定のノードを変数として定義している。<code>next_screen_score</code>は「NextScreen」ノードの孫ノード「Score」を、<code>hud_score</code>は「HUD」ノードの孫ノード「Score」をそれぞれ代入している。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># Method receiving signal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Brick_tree_exited</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Update Score</span>
</span></span><span class=line><span class=cl>	<span class=n>score</span> <span class=o>+=</span> <span class=n>POINT</span> <span class=o>*</span> <span class=n>bonus_rate</span> <span class=c1># 追加</span>
</span></span><span class=line><span class=cl>	<span class=n>bonus_rate</span> <span class=o>+=</span> <span class=mf>0.1</span> <span class=c1># 追加</span>
</span></span><span class=line><span class=cl>	<span class=n>hud_score</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>score</span><span class=p>)</span> <span class=c1># 追加</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># メソッド内の以下省略</span>
</span></span></code></pre></div><p><code>_on_Brick_tree_exited</code>にいくつか処理を追加する。この関数はブロックが消された時に「Brick-」ノードから<code>tree_exited</code>シグナルを受信するメソッドであることを思い出してほしい。今回、ブロックを消した時の処理に以下の3つを追加した形だ。</p><ul><li><code>score += POINT * bonus_rate</code>により、変数<code>score</code>の値にボーナス率である<code>bonus_rate</code>を乗じた値がポイントとして加算される。</li><li><code>bonus_rate += 0.1</code>は、その時の<code>bonus_rate</code>の値に<code>0.1</code>が加算する、という意味だ。なお、このアップデートされたボーナス率は次にブロックを消した時に利用される。</li><li><code>hud_score.text = "Level: " + str(score) </code>は、常に HUD の表示を更新するためのコードだ。「HUD」の孫ノード「Score」（Labelクラス）の「Text」プロパティの値として、ブロックが消されるたびにその時の変数<code>score</code>の値を代入している。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>func</span> <span class=nf>set_next_level</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;set_next_level() start&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>level_num</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Show NextScreen node</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_score</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Score: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>score</span><span class=p>)</span> <span class=c1># 追加</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen</span><span class=o>.</span><span class=nf>show</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1># メソッド内の以下省略</span>
</span></span></code></pre></div><p><code>set_next_level</code>関数にも 1 行だけコードを追加した。<code>next_screen_score.text = "Score: " + str(score)</code>だ。これは「NextScreen」ノードの孫ノード「Score」（Labelクラス）の「Text」プロパティに「Score: (現在の変数<code>score</code>の値)」という文字列を代入している。これにより、次のレベルの準備画面に現在のスコアが表示されるようになるはずだ。</p><p>ではまず、ブロックを消したら HUD のスコア表示が更新されるか確認してみよう。「Level1」ノードのブロックを全て表示してテストするため、<code>_ready</code>内の<code>leave_one_brick</code>の行をコメントアウトしてから、プロジェクトを実行する。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># For debug</span>
</span></span><span class=line><span class=cl>	<span class=c1>#leave_one_brick(43) #コメントアウト</span>
</span></span></code></pre></div><p><img alt=デバッグパネルでHUDのスコア動作確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_32.gif></p><p>ブロックを消すたびに HUD のスコアにボーナス込みのポイントが加算されているのが確認できた。</p><p>今度は次のレベルの前の準備画面「NextScreen」にスコアが反映するかを確認する。さっきコメントアウトした<code>_ready</code>内の<code>leave_one_brick</code>の行をアクティブにしてから、プロジェクトを実行して確認してみよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># For debug</span>
</span></span><span class=line><span class=cl>	<span class=nf>leave_one_brick</span><span class=p>(</span><span class=mi>43</span><span class=p>)</span>
</span></span></code></pre></div><p><img alt=デバッグパネルでNextScreenのスコア動作確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_33.gif></p><p>最後の1つを残して他のブロックを消した状態からスタートしているので、かなり高得点からの開始だが、「NextScreen」には問題なく変数<code>score</code>の値が反映されたことが確認できた。</p><p>それでは一旦ここまでに更新した「Game.gd」スクリプト全体を確認しておこう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>POINT</span> <span class=o>=</span> <span class=mi>100</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>level_num</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>score</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>bonus_rate</span> <span class=o>=</span> <span class=mf>1.0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>level</span> <span class=o>=</span> <span class=nx>$Level1</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen</span> <span class=o>=</span> <span class=nx>$NextScreen</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen_level</span> <span class=o>=</span> <span class=nx>$NextScreen/VBox/Level</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen_score</span> <span class=o>=</span> <span class=nx>$NextScreen/VBox/Score</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>hud_level</span> <span class=o>=</span> <span class=nx>$HUD/LeftBox/Level</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>hud_score</span> <span class=o>=</span> <span class=nx>$HUD/LeftBox/Score</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>paddle</span> <span class=o>=</span> <span class=nx>$Paddle</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>ball</span> <span class=o>=</span> <span class=nx>$Ball</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>paddle_position</span> <span class=o>=</span> <span class=n>paddle</span><span class=o>.</span><span class=n>position</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>ball_position</span> <span class=o>=</span> <span class=n>ball</span><span class=o>.</span><span class=n>position</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># For debug</span>
</span></span><span class=line><span class=cl>	<span class=nf>leave_one_brick</span><span class=p>(</span><span class=mi>43</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>brick</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>brick</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Brick_tree_exited&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=n>paused</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># For debug</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>leave_one_brick</span><span class=p>(</span><span class=n>brick_num</span><span class=p>:</span> <span class=kt>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>child</span><span class=o>.</span><span class=nf>get_name</span><span class=p>()</span> <span class=o>==</span> <span class=s2>&#34;Brick&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>brick_num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=n>child</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method receiving signal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Brick_tree_exited</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Update Score</span>
</span></span><span class=line><span class=cl>	<span class=n>score</span> <span class=o>+=</span> <span class=n>POINT</span> <span class=o>*</span> <span class=n>bonus_rate</span>
</span></span><span class=line><span class=cl>	<span class=n>bonus_rate</span> <span class=o>+=</span> <span class=mf>0.1</span>
</span></span><span class=line><span class=cl>	<span class=n>hud_score</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Score: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>score</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Exit current Level node</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;get child count: &#34;</span><span class=p>,</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_child_count</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_child_count</span><span class=p>()</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>level</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;level queue free&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>set_next_level</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>set_next_level</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;set_next_level() start&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>level_num</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Show NextScreen node</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_score</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Score: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>score</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen</span><span class=o>.</span><span class=nf>show</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Set Level of HUD the next level</span>
</span></span><span class=line><span class=cl>	<span class=n>hud_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Set Paddle and Ball the first position</span>
</span></span><span class=line><span class=cl>	<span class=n>paddle</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>paddle_position</span>
</span></span><span class=line><span class=cl>	<span class=n>ball</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>ball_position</span>
</span></span><span class=line><span class=cl>	<span class=n>ball</span><span class=o>.</span><span class=n>mode</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Set next Level node</span>
</span></span><span class=line><span class=cl>	<span class=n>level</span> <span class=o>=</span> <span class=nb>load</span><span class=p>(</span><span class=s2>&#34;res://scene/Level&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span> <span class=o>+</span> <span class=s2>&#34;.tscn&#34;</span><span class=p>)</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>add_child</span><span class=p>(</span><span class=n>level</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>move_child</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>child</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Brick_tree_exited&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># Pause game until NextScreen is hidden</span>
</span></span><span class=line><span class=cl>	<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=n>paused</span> <span class=o>=</span> <span class=kc>true</span>
</span></span></code></pre></div><br><h2 id=現在のライフを表示する>現在のライフを表示する</h2><p>それでは最後に HUD の最後のセクションであるライフの表示に関わる更新していく。必要な作業は以下の通りだ。</p><ul><li>「Ball」ノードをシーンとして保存する</li><li>「Ball.gd」スクリプトを更新する</li><li>「Game.gd」スクリプトを更新する</li></ul><h3 id=ballノードをシーンとして保存する>「Ball」ノードをシーンとして保存する</h3><p>Ballが画面下に落ちたらライフが一つ減る、という仕組みにしたい。この仕組みを成立させるためには、ボールが下に落ちたら「Ball」ノードを削除して、新しい「Ball」ノードを追加する必要がある。「Ball」ノードを追加するには、現在「Game」ルートノードの子である「Ball」ノードをシーンとして保存し、毎回そのインスタンスを新しいノードとして追加するのが効率的だ。</p><p>シーンドックで「Game」シーンの「Ball」ノードを右クリックし、「ブランチをシーンとして保存」を選択しよう。<br><img alt=ブランチをシーンとして保存 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_34.png></p><p>「res://scene/Ball.tscn」として保存すれば「Ball」シーンの完成だ。</p><br><h3 id=ballgdスクリプトを更新する>「Ball.gd」スクリプトを更新する</h3><p>この流れで、先に「Ball」ノードにアタッチしているスクリプト「Ball.gd」の方を先に更新しておく。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_VisibilityNotifier2D_screen_exited</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1>#get_tree().change_scene(&#34;res://scene/GameOverView.tscn&#34;) # 不要</span>
</span></span></code></pre></div><p>「Ball.gd」スクリプトの一番最後にある<code>func _on_VisibilityNotifier2D_screen_exited():</code>のブロックの中を修正する。ゲームオーバー画面へシーンを切り替えるコード<code>get_tree().change_scene("res://scene/GameOverView.tscn") </code>を削除、またはコメントアウトするだけだ。理由は、ゲームオーバーになるタイミングが、今までは1回ボールが画面下に落ちた時だったが、これからはライフがゼロになった時に変わるからだ。その部分のコードは「Game.gd」スクリプトの方に記述していくので、こちらの更新はこれだけだ。</p><br><h3 id=gamegdスクリプトを更新する>「Game.gd」スクリプトを更新する</h3><p>では「Game.gd」スクリプトの更新内容を上から順番に確認していこう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>var</span> <span class=n>life</span> <span class=o>=</span> <span class=mi>3</span>
</span></span></code></pre></div><p>変数<code>life</code>の初期値を<code>3</code>として定義した。この値と「HUD」ノードの孫ノード「Life-」の表示数とが一致するようにしていく。「Life-」の数は全部で<code>5</code>個あるが、のちのちライフアップのアイテムも検討しているのと、<code>5</code>だと易しすぎるので<code>3</code>とした。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen_life</span> <span class=o>=</span> <span class=nx>$NextScreen/VBox/HBoxContainer/Life</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>hud_rightbox</span> <span class=o>=</span> <span class=nx>$HUD/RightBox</span>
</span></span></code></pre></div><p><code>onready</code>キーワード付きの変数を2つ追加した。<code>next_screen_life</code>は「NextScreen」ノードの曽孫ノード「Life」を、<code>hud_rightbox</code>は「HUD」ノードの子ノード「RightBox」をそれぞれ指している。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># For debug</span>
</span></span><span class=line><span class=cl>	<span class=nf>leave_one_brick</span><span class=p>(</span><span class=mi>43</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>update_hud_life</span><span class=p>()</span> <span class=c1># 追加</span>
</span></span><span class=line><span class=cl>	<span class=n>ball</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Ball_tree_exited&#34;</span><span class=p>)</span> <span class=c1># 追加</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>brick</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>brick</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Brick_tree_exited&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p><code>_ready</code>のブロック内にいくつか処理を追加した。まず<code>update_hud_life</code>という関数を追加したが、この関数の内容はあとで説明する。</p><p><code>ball.connect("tree_exited", self, "_on_Ball_tree_exited") </code>は「Ball」ノードの<code>tree_exited</code>シグナルをこのスクリプトの<code>_on_Ball_tree_exited</code>という関数に接続している。<code>tree_exited</code>はたびたび使用しているが、そのノードがシーンツリーから削除された時に発信されるシグナルだ。ボールが画面下に落ちて、シーンツリーから消えたタイミングでライフを更新するために絶対に必要なシグナルなのだ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># Method receiving Ball signal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Ball_tree_exited</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>life</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nf>update_hud_life</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>life</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>change_scene</span><span class=p>(</span><span class=s2>&#34;res://scene/GameOverView.tscn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>paddle</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>paddle_position</span>
</span></span><span class=line><span class=cl>		<span class=n>ball</span> <span class=o>=</span> <span class=nb>load</span><span class=p>(</span><span class=s2>&#34;res://scene/Ball.tscn&#34;</span><span class=p>)</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>add_child</span><span class=p>(</span><span class=n>ball</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>move_child</span><span class=p>(</span><span class=n>ball</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>ball</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Ball_tree_exited&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>先程のシグナル<code>tree_exited</code>の接続先のメソッドがこの<code>_on_Ball_tree_exited</code>だ。ボールが画面下に落ちて消えたタイミングで実行される。</p><p>ボールが画面下に落ちた時、ライフを一つ減らしたいので、まず変数<code>life</code>から<code>- 1</code>している。その次に<code>update_hud_life</code>という関数を実行して、ライフに関わるアップデートをしているが、その処理内容について詳しくはのちほど説明する。</p><p><code>if life &lt;= 0:</code>のブロックでは、ライフがゼロの場合、<code>get_tree().change_scene("res://scene/GameOverView.tscn")</code>でゲームオーバー画面に遷移するようにしている。このコードは元々「Ball.gd」スクリプトにあったものだが、ゲームオーバーの条件が変わったため、こちらに移動させた。</p><p>次に<code>else:</code>ブロックだ。</p><p>ボールが画面下に落ちたら、パドルも一旦初期位置に戻したいので<code>paddle.position = paddle_position</code>としている。</p><p>ボールが画面下に落ちて「Ball」ノードが消えたら、新しい「Ball」ノードを用意する必要がある。そのために、まず「Ball.tscn」シーンファイルを読み込み、そのインスタンス作って、変数<code>ball</code>に代入している。そのあと<code>add_child</code>で、その新しい「Ball」インスタンスを「Game」ルートノードの子ノードとして追加している。そしてさらに<code>move_child</code>で、「Ball」ノードの順序を最後尾から最初と同じ<code>3</code>番目に移動させている。最後に改めて、新しい「Ball」ノードの<code>tree_exited</code>シグナルを<code>_on_Ball_tree_exited</code>メソッドに接続している。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1># Set life nodes shown and hidden as life variable</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>update_hud_life</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>hud_rightbox</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>count</span> <span class=o>&lt;=</span> <span class=n>life</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>child</span><span class=o>.</span><span class=nf>show</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>child</span><span class=o>.</span><span class=nf>hide</span><span class=p>()</span>
</span></span></code></pre></div><p><code>update_hud_life</code>という関数を新たに追加した。<code>_ready</code>内で実行されていたものだ。</p><p>これは HUD のライフ表示を更新するためのメソッドだ。<code>for</code>ループ内では、「HUD」ノードの子ノード「RightBox」にぶら下がっている全ての子ノード、つまり全ての「Life-」ノードに対して処理を実行している。その処理というのは、「Life-」ノードの「RightBox」ノード中の順番が、変数<code>life</code>の値以下だったら表示し、そうでなければ非表示にする、というものだ。例えば、変数<code>life</code>の値が<code>2</code>になったら、「Life1」、「Life2」までは表示し、「Life3」、「Life4」、「Life5」は非表示にする、ということになる。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>func</span> <span class=nf>set_next_level</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;set_next_level() start&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>level_num</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Show NextScreen node</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_score</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Score: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>score</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_life</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;x &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>life</span><span class=p>)</span> <span class=c1># 追加</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen</span><span class=o>.</span><span class=nf>show</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># 以下省略</span>
</span></span></code></pre></div><p>最後の更新箇所がこちらの<code>set_next_level</code>内のブロックだ。<code>next_screen_life.text = "x " + str(life) </code>の一行を追加した。内容は「NextScreen」ノードの「Life」ノードの「Text」プロパティの値（文字列）に変数<code>life</code>の値を反映させる、というものだ。</p><p>これで HUD のライフに関わる更新ができたはずだ。実際にプロジェクトを実行して確認してみよう。<br><img alt=デバッグパネルでライフの挙動を確認 loading=lazy src=/images/tutorials/gd0004_breakout/breakout_7/img_35.gif></p><p>以下の動作に問題がないことを確認できた。</p><ul><li>「NextScreen」に現在のライフが表示される</li><li>HUD のライフがボールを画面下に落とすたびに減る</li><li>HUD のライフがゼロになったらゲームオーバー画面に遷移する</li></ul><br><p>最終的に「Game.gd」のスクリプト全体はこのようになっている。うまく動作しなかった方はご自身で作ったスクリプトと見比べてみて欲しい。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>POINT</span> <span class=o>=</span> <span class=mi>100</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>level_num</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>score</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>bonus_rate</span> <span class=o>=</span> <span class=mf>1.0</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>life</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>level</span> <span class=o>=</span> <span class=nx>$Level1</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen</span> <span class=o>=</span> <span class=nx>$NextScreen</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen_level</span> <span class=o>=</span> <span class=nx>$NextScreen/VBox/Level</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen_score</span> <span class=o>=</span> <span class=nx>$NextScreen/VBox/Score</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>next_screen_life</span> <span class=o>=</span> <span class=nx>$NextScreen/VBox/HBox/Life</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>hud_level</span> <span class=o>=</span> <span class=nx>$HUD/LeftBox/Level</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>hud_score</span> <span class=o>=</span> <span class=nx>$HUD/LeftBox/Score</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>hud_rightbox</span> <span class=o>=</span> <span class=nx>$HUD/RightBox</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>paddle</span> <span class=o>=</span> <span class=nx>$Paddle</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>ball</span> <span class=o>=</span> <span class=nx>$Ball</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>paddle_position</span> <span class=o>=</span> <span class=n>paddle</span><span class=o>.</span><span class=n>position</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>ball_position</span> <span class=o>=</span> <span class=n>ball</span><span class=o>.</span><span class=n>position</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># For debug</span>
</span></span><span class=line><span class=cl>	<span class=nf>leave_one_brick</span><span class=p>(</span><span class=mi>43</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>update_hud_life</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>ball</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Ball_tree_exited&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>brick</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>brick</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Brick_tree_exited&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=n>paused</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># For debug</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>leave_one_brick</span><span class=p>(</span><span class=n>brick_num</span><span class=p>:</span> <span class=kt>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>child</span><span class=o>.</span><span class=nf>get_name</span><span class=p>()</span> <span class=o>==</span> <span class=s2>&#34;Brick&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>brick_num</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		<span class=n>child</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method receiving Ball signal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Ball_tree_exited</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>life</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=nf>update_hud_life</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>life</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>change_scene</span><span class=p>(</span><span class=s2>&#34;res://scene/GameOverView.tscn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>paddle</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>paddle_position</span>
</span></span><span class=line><span class=cl>		<span class=n>ball</span> <span class=o>=</span> <span class=nb>load</span><span class=p>(</span><span class=s2>&#34;res://scene/Ball.tscn&#34;</span><span class=p>)</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nf>add_child</span><span class=p>(</span><span class=n>ball</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>move_child</span><span class=p>(</span><span class=n>ball</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>ball</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Ball_tree_exited&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Set life nodes shown and hidden as life variable</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>update_hud_life</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>hud_rightbox</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>count</span> <span class=o>&lt;=</span> <span class=n>life</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>child</span><span class=o>.</span><span class=nf>show</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>child</span><span class=o>.</span><span class=nf>hide</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method receiving Brick signal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Brick_tree_exited</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Update Score</span>
</span></span><span class=line><span class=cl>	<span class=n>score</span> <span class=o>+=</span> <span class=n>POINT</span> <span class=o>*</span> <span class=n>bonus_rate</span>
</span></span><span class=line><span class=cl>	<span class=n>bonus_rate</span> <span class=o>+=</span> <span class=mf>0.1</span>
</span></span><span class=line><span class=cl>	<span class=n>hud_score</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Score: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>score</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Exit current Level node</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;get child count: &#34;</span><span class=p>,</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_child_count</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_child_count</span><span class=p>()</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>level</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;level queue free&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nf>set_next_level</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>set_next_level</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;set_next_level() start&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>level_num</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Show NextScreen node</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_score</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Score: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>score</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen_life</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;x &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>life</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>next_screen</span><span class=o>.</span><span class=nf>show</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Set Level of HUD the next level</span>
</span></span><span class=line><span class=cl>	<span class=n>hud_level</span><span class=o>.</span><span class=n>text</span> <span class=o>=</span> <span class=s2>&#34;Level: &#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Set Paddle and Ball the first position</span>
</span></span><span class=line><span class=cl>	<span class=n>paddle</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>paddle_position</span>
</span></span><span class=line><span class=cl>	<span class=n>ball</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>ball_position</span>
</span></span><span class=line><span class=cl>	<span class=n>ball</span><span class=o>.</span><span class=n>mode</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Set next Level node</span>
</span></span><span class=line><span class=cl>	<span class=n>level</span> <span class=o>=</span> <span class=nb>load</span><span class=p>(</span><span class=s2>&#34;res://scene/Level&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>level_num</span><span class=p>)</span> <span class=o>+</span> <span class=s2>&#34;.tscn&#34;</span><span class=p>)</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>add_child</span><span class=p>(</span><span class=n>level</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>move_child</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>level</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>child</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;tree_exited&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Brick_tree_exited&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Pause game until NextScreen is hidden</span>
</span></span><span class=line><span class=cl>	<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=n>paused</span> <span class=o>=</span> <span class=kc>true</span>
</span></span></code></pre></div><br><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><h1 id=おわりに>おわりに</h1><p>以上で Part 7 は完了だ。かなり長くなってしまったが、最後までうまく進められただろうか。今回行ったブロック崩しの更新内容をまとめておく。</p><ul><li>HUD に必要なノードを追加した</li><li>次のレベルの準備画面「NextScreen」に必要なノードを追加した</li><li>主に「Game.gd」スクリプトによってゲームの状況を HUD と NextScreen に連動させた</li></ul><p>次回 Part 8 ではさらにプレイ中のポーズ画面とポーズ機能を追加していく予定だ。</p><hr></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！ on x" href="https://x.com/intent/tweet/?text=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e5%b4%a9%e3%81%97%20Part%207%ef%bc%9aHUD%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e8%a1%a8%e7%a4%ba%e5%86%85%e5%ae%b9%e3%82%92%e6%9b%b4%e6%96%b0%e3%81%97%e3%81%a6%e3%81%bf%e3%82%88%e3%81%86%ef%bc%81&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0004_breakout%2fbreakout_7%2f&amp;hashtags=GodotEngine%2cGameDev%2c%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e5%b4%a9%e3%81%97%2c2D"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0004_breakout%2fbreakout_7%2f&title=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e3%83%96%e3%83%ad%e3%83%83%e3%82%af%e5%b4%a9%e3%81%97%20Part%207%ef%bc%9aHUD%e3%82%92%e4%bd%9c%e3%81%a3%e3%81%a6%e8%a1%a8%e7%a4%ba%e5%86%85%e5%ae%b9%e3%82%92%e6%9b%b4%e6%96%b0%e3%81%97%e3%81%a6%e3%81%bf%e3%82%88%e3%81%86%ef%bc%81"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Godot で作るブロック崩し Part 7：HUDを作って表示内容を更新してみよう！ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0004_breakout%2fbreakout_7%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/ja/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/ja/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/ja/tags/%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%B4%A9%E3%81%97/>ブロック崩し</a></li><li><a href=https://www.peanuts-code.com/ja/tags/2d/>2D</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/breakout_8/><span class=title>« 前へ</span><br><span>Godot で作るブロック崩し Part 8：ポーズ画面を作ろう！</span>
</a><a class=next href=https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/breakout_6/><span class=title>次へ »</span><br><span>Godot で作るブロック崩し Part 6：ゲームスタート/ゲームオーバーの画面を作ろう！</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/ja/>Peanuts Code</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="コピー";function s(){t.innerHTML="コピーされました!",setTimeout(()=>{t.innerHTML="コピー"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>