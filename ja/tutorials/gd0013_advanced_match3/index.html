<!DOCTYPE html>
<html lang="ja" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Godot で作る進化形マッチ 3 パズルゲーム | Peanuts Code</title>
<meta name="keywords" content="GodotEngine, GameDev, Godot3, 2D, パズルゲーム, モバイルゲーム, マッチ3, パズドラ" />
<meta name="description" content="今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。 これはモバイ">
<meta name="author" content="Gobo">
<link rel="canonical" href="https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/" />
<meta name="google-site-verification" content="XYZabc" />
<meta name="yandex-verification" content="XYZabc" />
<meta name="msvalidate.01" content="XYZabc" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.css" rel="preload stylesheet" as="style">
<link rel="preload" href="/images/logomark.png" as="image">
<link rel="icon" href="https://www.peanuts-code.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.peanuts-code.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.peanuts-code.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.peanuts-code.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.peanuts-code.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.102.3" />
<link rel="alternate" hreflang="ja" href="https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/" />
<link rel="alternate" hreflang="en" href="https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/" />

<script async src="https://www.googletagmanager.com/gtag/js?id=G-DK0NK2RTTW"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-DK0NK2RTTW', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Godot で作る進化形マッチ 3 パズルゲーム" />
<meta property="og:description" content="今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。 これはモバイ" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/" />
<meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif" /><meta property="article:section" content="tutorials" />
<meta property="article:published_time" content="2022-07-10T00:51:37&#43;09:00" />
<meta property="article:modified_time" content="2022-07-10T00:51:37&#43;09:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif" />
<meta name="twitter:title" content="Godot で作る進化形マッチ 3 パズルゲーム"/>
<meta name="twitter:description" content="今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。 これはモバイ"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "チュートリアル",
      "item": "https://www.peanuts-code.com/ja/tutorials/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Godot で作る進化形マッチ 3 パズルゲーム",
      "item": "https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Godot で作る進化形マッチ 3 パズルゲーム",
  "name": "Godot で作る進化形マッチ 3 パズルゲーム",
  "description": "今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。 これはモバイ",
  "keywords": [
    "GodotEngine", "GameDev", "Godot3", "2D", "パズルゲーム", "モバイルゲーム", "マッチ3", "パズドラ"
  ],
  "articleBody": "今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。\nこれはモバイルゲームで人気を博した「パズル\u0026ドラゴンズ（Puzzle \u0026 Dragons）/ 通称パズドラ」のようなパズルをイメージしていただくとわかりやすいだろう。\nただし、チュートリアルに味方のデッキやガチャ、敵キャラクターとのバトルなど全てのゲーム要素を盛り込むとボリュームが大きすぎるので、今回はパズル部分にフォーカスして手順を説明させていただく。\nなお「キャンディークラッシュ」のようなオーソドックスなマッチ3（スリー）パズルゲームや「LINEツムツム」のような指でピースをなぞって繋げて消すタイプのパズルゲームの作り方については、以下のチュートリアルを参照いただきたい。\nOther Tutorials 「キャンディークラッシュ」のようなゲームを作ってみたい場合：\nGodot で作るマッチ 3 パズルゲーム 「LINE：ディズニーツムツム」のようなゲームを作って見たい場合：\nGodot で作る同じ色をつなげて消すパズルゲーム このチュートリアルで最後にできあがるプロジェクトのファイルはGitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.4\n・コンピュータのOS: macOS 11.6.5\nMemo: ゲームを作り始めるのに以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 新規プロジェクトを作成する それでは Godot Engine を立ち上げて、新規プロジェクトを作成しよう。プロジェクトの名前はあなたのお好みで決めていただいてOKだ。もし思いつかなければ「Advanced Match3 Start」としておこう。\nプロジェクト設定を更新する エディタが表示されたら、先にプロジェクト全体に関わる設定を更新しておこう。\nまずはゲームのディスプレイサイズを設定する。今回はスマホの縦向きの画面を想定して、縦横の比率を 16 : 9 とする。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。 「Size」セクションで以下の項目の値を変更する。 Width: 630 Height: 1120 Test Width: 315 Test Height: 560\n「Stretch」セクションで以下の項目の値を変更する。 Mode: 2d Aspect: keep\nそのまま「プロジェクト設定」ウインドウを開いた状態で、デバッグパネルでスマホのタッチ操作をマウスで代用するための設定をする。\n「一般」タブで「mouse」と検索し、サイドバーの「Input Devices」＞「Pointing」を選択する。 「Emulate Touch From Mouse」の On のチェックを入れる。\nさらに「プロジェクト設定」ウインドウを開いた状態で、インプットマップにスマホのタッチ操作の相当するアクションを追加しよう。\n「インプットマップ」タブに切り替え、アクションに「touch」を追加する。 「touch」の操作にマウスの左クリックを追加する。\nアセットをダウンロードしてインポートする 次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは「Physics Assets 」というアセットパックだ。このアセットに含まれるなんともかわいいエイリアンの顔の画像を、ゲームの盤面に並べるピースのテクスチャとして使用する。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「/physicspack/PNG/Aliens」フォルダの中のファイル名が「~_round.png」の画像だけを残して他は削除し、「Aliens」フォルダごとエディタのファイルシステムドックへドラッグしてプロジェクトにインポートしよう。\nGrid シーンを作る まずはマッチ3パズルゲームでピースが配置される盤面として、「Grid」シーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Area2D」クラスのルートノードが生成されたら、その名前を「Grid」に変更する。 シーンを保存する。フォルダを作成して、ファイルパスを「res://Grid/Grid.tscn」としてシーンを保存する。\nGrid シーンにノードを追加する 「Grid」ルートノードに、さらにノードを追加していこう。\n「Grid」ルートノードに「CollisionShape2D」ノードを追加する。 「Grid」ルートノードに「Node2D」ノードを追加し、名前を「PiecesContainer」に変更する。 「Grid」ルートノードに「Timer」ノードを２つ追加し、それぞれ名前を「TouchTimer」、「WaitTimer」に変更する。 ひとまず現時点でのシーンツリーは以下のようになったはずだ。\n続けて追加したノードを編集していこう。\nGrid シーンのノードを編集する Grid (Area2D) ルートノード このパズドラ風のパズルでは、盤面上でピースを自由に動かせるわけだが、盤面から動かしているピースがはみ出してはいけない。そうしないと、盤面の外側を移動させて離れたピースと入れ替えることができてしまう。このパズルゲームは、あくまで動かしているピースと隣り合ったドロップが次々に交換されていく仕様なのだ。\nルートノードを Area2D クラスにしたのは、そのシグナルを使って盤面から指（動かしているピース）がはみ出したことを検知させるためだ。検知さえできれば、あとはスクリプトで制限できる。このシーンへのスクリプトのアタッチは最後に行うので、その時にあらためてシグナルの接続を行うことにしよう。\nこのノードそのもののプロパティ編集は不要だ。\nCollisionShape2D ノード このノードは、盤面の外に指（動かしているピース）がはみ出した時にそれを検知するために利用する。インスペクターで以下の通りに各プロパティを編集しよう。\nShape: 新規 RectangleShape2D リソースを適用する。 RectangleShape2D \u003e Extents: (x: 225, y: 190)\nTransform \u003e Position: (x: 315, y: 840)\n2D ワークスペース上では以下のようになったはずだ。\nPiecesContainer (Node2D) ノード このノードは盤面に配置されるピースをまとめるためのノードだ。ゲーム中、スクリプトでピースのインスタンスが生成されたら全てこの「PiecesContainer」ノードの子として追加することになる。そうすることで、ピースのインスタンスがどれだけ生成されても、シーンツリー上のノードの順序を維持することができる。\n特に編集が必要なプロパティはないので次へ行こう。\nTouchTimer ノード この Timer クラスのノードは、指でピースを動かし始めてからカウントダウンを始め、タイムアウトしたら、動かしていたピースが指から自動的に離れるようにするためのものだ。これにより、制限時間内でピースを並べなければならないというある種の緊張感をプレイヤーに与えることができる。今回は 5 秒間ピースを移動できる設定にする。\nインスペクターで以下のように編集しよう。\nWait Time: 5 One Shot: オン\nWaitTimer ノード こちらの Timer クラスのノードは、指からピースが離れた後の、ピースのマッチング処理、マッチしたピースの削除、削除されて空いたグリッドへピースを詰めて、不足している分を追加する、という一連の流れを自動処理する際に、それぞれの処理の間に一瞬だけ間をあけるためのノードだ。\nインスペクターで以下のように編集しよう。\nWait Time: 0.3 One Shot: オン\n以上で、「Grid」シーンの編集は完了だ。\nPiece シーンを作る 次に、盤面に並べるピースとして「Piece」シーンを作成する。ただし、この「Piece」シーンはあくまで雛形で、実際にゲーム中で利用する各色のピースは、この「Piece」シーンを継承する形でのちほど用意する。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のシーン」を選択する。 「Area2D」クラスのルートノードが生成されたら、その名前を「Piece」に変更する。 シーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Pieces/Piece.tscn」としてシーンを保存する。\nPiece シーンにノードを追加する 続けて、「Piece」シーンに必要なノードを追加していこう。\n「Piece」ルートノードに「Sprite」ノードを追加する。 「Piece」ルートノードに「CollisionShape2D」ノードを追加する。 「Piece」ルートノードに「Tween」ノードを追加する。\nPiece シーンのシーンツリーは以下のようになったはずだ。\nPiece シーンのノードを編集する Piece (Area2D) ルートノード ルートノードを Area2D クラスにしたのは、動かしたいピースに指が当たった時や離れた時、ピース同士が衝突した時に、それを検知できるようにするためだ。\nこのノードのプロパティは編集不要だが、１つだけグループへの追加が必要だ。シーンドックで「Piece」ルートノードを選択したら、ノードドック＞グループタブを選択して、「Pieces」という名前のグループを作成して追加しよう。\n「Grid」シーンの方で「Grid」ルートノードには盤面からのはみ出し検知用のコリジョン形状が設定されており、これは常に全ピースと接触しているので、ピース同士との衝突を区別するために必要なグループなのだ。\nSprite ノード 先述の通り、「Piece」はあくまで継承元（雛形）なので、このシーンでは「Sprite」ノードの「Texture」プロパティにはリソースを敢えて適用せずそのままにしておく。継承先のシーンでそれぞれのピースの色にあった画像を適用する予定だ。\nこのシーンを継承する各色のピースのシーンでは「Texture」プロパティに先にインポートした KENNEY の画像を適用するが、その画像の縦横のサイズが 70 px なので、その画像の中心を右上にずらして画像の左下の角が(x: 0, y: 0)に合うように「Offset」プロパティを設定しよう。\nOffset:\nOffset: (x: 35, y: -35)\nピースを配置する盤面のグリッドは x 軸は左から右へ、y 軸は下から上へカウントする仕様で、かつ盤面の 1 グリッドのサイズもテクスチャのサイズに合わせて 70 px とする。ピースのテクスチャ画像の左下の角を (x: 0, y: 0) に合わせれば、「Piece」ルートノードの位置 (x: 0, y: 0) をグリッドに合わせて配置したときに、ちょうど「Sprite」の画像がグリッドに沿って配置されるというわけだ。\nCollisionShape2D ノード このノードはルートノードにコリジョン形状を付与する役目だ。ピースに指を触れたり、指を離したり、隣のピースと衝突したりするのを検知させるのに必要なノードである。コリジョン形状を縦横 70 px の Sprite の Texture にピッタリ合わせてしまうと、少しピースを動かしただけで、隣のピースとの衝突を検知してしまう。かといって、コリジョン形状が小さすぎると、指でピースに触れているつもりなのに検知されなかったり、ピースを移動させるときに、ピース同士の衝突をうまく検知できずにピースとピースの間を通り抜けてしまったりする。そこでコリジョン形状は Sprite の Texture の半分のサイズにするとちょうど良い。位置も Sprite の Texture にきれいに重なるように調整しよう。\nShape: 新規 CircleShape2D リソースを適用する CircleShape2D: Radius: 17.5\nTransform: Position: x: 35, y: -35\n2D ワークスペース上では以下のようになったはずだ。\nTween ノード このノードは、指定したノードの単一のプロパティのみをアニメーションさせることができる。今回このノードを使用するのは、ピースの位置が交換される時や、マッチして消えたピースの位置にピースを詰める時のピースの移動をアニメーションさせるためだ。\nただし、アニメーションはスクリプトで実装するので、このタイミングでのプロパティの編集は不要だ。\nPiece ノードにスクリプトをアタッチして編集する 「Piece」ルートノードに新規スクリプトをアタッチしよう。ファイルパスを「res://Pieces/Piece.gd」としてスクリプトファイルを作成する。\nひとまずスクリプトを以下のように編集してほしい。\n###Piece.gd### extends Area2D # プレイヤーが動かしているピースに衝突したら発信するシグナル（引数にピース自身を渡す） signal collided(self_piece) # ピースの色を設定するプロパティ export (String) var color # マッチした場合のフラグとなるプロパティ var matched = false # マッチしたピースのグループに割り振られるインデックス var matched_index = 0 # プレイヤーが動かしている場合のフラグとなるプロパティ var held = false # ピースのテクスチャと同じオフセット var offset = Vector2(35, -35) # Spriteノードへの参照 onready var sprite = $Sprite # Tweenノードへの参照 onready var tween = $Tween # メインループで毎フレーム呼ばれる組み込みメソッド func _process(_delta): # もしプレイヤーがピースを移動中だったら if held: # ピースの位置を(35, -35)ずらしてマウスに追随させる position = get_global_mouse_position() - offset # ピースを移動させるメソッド func move(destination): # Tweenノードのアニメーションを設定する # ピースを0.1秒かけて現在の位置から引数destinationの位置まで移動させる tween.interpolate_property(self, \"position\", position, destination, .1, Tween.TRANS_QUINT, Tween.EASE_IN) # Tweenノードのアニメーションを開始する tween.start() # ピースがマッチした時に呼ばれるメソッド func make_matched(index): # マッチのフラグを立てる matched = true # マッチしたグループごとのインデックス（引数index）を割り当てる matched_index = index # ピースの色を半透明にする modulate = Color(1,1,1,.5) # プレイヤーの指がピースに触れたら呼ばれるメソッド func enable_held(): # プレイヤーが動かしているフラグを立てる held = true # ピースの色を20％透明にする modulate = Color(1, 1, 1, 0.8) # プレイヤーが指をピースから離したら呼ばれるメソッド func disable_held(): # プレイヤーが動かしているフラグを解除する held = false # ピースの色をデフォルトに戻す modulate = Color(1, 1, 1, 1) 続けて、ピースに別のピースが当たった時に発信されるシグナルを利用する。シーンドックで「Piece」ルートノードを選択したらノードドック＞シグナルタブでarea_entered(area: Area2D)を、現在編集中の「Piece.gd」スクリプトに接続しよう。\nプレイヤーが動かしているピースが当たったらシグナルcollided(self_piece)を発信させたいので、自動生成されたメソッド_on_Piece_area_entered(area)内にそのためのコードを記述しよう。\n###Piece.gd### # Area2Dが当たったらシグナルが発信されて呼ばれるメソッド func _on_Piece_area_entered(area): # もし当たったArea2Dが「Pieces」グループ（つまりPieceのインスタンス）で... # かつ、プレイヤーが動かしているピースだったら if area.is_in_group(\"Pieces\") and area.held: # 引数に自分自身のピースを渡してシグナル collided を発信する emit_signal(\"collided\", self) これで「Piece.gd」スクリプトの編集は完了だ。\nPiece シーンを継承した各色のシーンを作る 雛形となる「Piece」シーンは完成したので、それを継承したシーンをピースの色の数だけ作成していこう。ピースの色は、ベージュ、青、緑、ピンク、黄の 5 色だ。まずは「ベージュ」のドロップを例に手順を進めてみよう。\n「シーン」メニュー＞「新しい継承シーン」を選択する。 継承元のシーンとして「Piece.tscn」を選択する。 継承シーンが生成されたら、ルートノードの名前を「PieceBeige」に変更する。\n*このルートノードの名前はそれぞれのドロップの色に合わせること。 シーンを一旦保存しておく。ファイルパスを「res://Pieces/PieceBeige.tscn」として保存する。 シーンドックでルートノード「PieceBeige」を選択した状態で、インスペクターで「Script Variables」の「Color」プロパティの値を「beige」とする。\nシーンドックで「Sprite」ノードを選択し、「Texture」プロパティに先にインポートしておいたリソース「res://Aliens/alienBeige_round.png」を適用する（ファイルシステムドックからドラッグすればOK）。\n2D ワークスペース上では以下のスクリーンショットのようになったはずだ。\n以上で、「PieceBeige」シーンは完成だ。残りの 4 色のピースについても、同様の手順でシーンを作成してほしい。なお、シーンごとに異なる部分については、以下を参考にしてほしい。 青のピース ルートノード名: PieceBlue Color プロパティ: blue Sprite \u003e Texture プロパティ: res://Aliens/alienBlue_round.png シーン保存時のファイルパス: res://Pieces/PieceBlue.tscn 緑のピース ルートノード名: PieceGreen Color プロパティ: green Sprite \u003e Texture プロパティ: res://Aliens/alienGreen_round.png シーン保存時のファイルパス: res://Pieces/PieceGreen.tscn ピンクのピース ルートノード名: PiecePink Color プロパティ: green Sprite \u003e Texture プロパティ: res://Aliens/alienPink_round.png シーン保存時のファイルパス: res://Pieces/PiecePink.tscn 黄のピース ルートノード名: PieceYellow Color プロパティ: yellow Sprite \u003e Texture プロパティ: res://Aliens/alienYellow_round.png シーン保存時のファイルパス: res://Pieces/PieceYellow.tscn 全部で 5 色のピースの継承シーンができたら作業完了だ。\nGrid シーンをスクリプトで制御する ここからはスクリプトをコーディングしてゲームを制御していく。コード量がやや多めなので頑張ろう。\nGodot エディタで「Grid.tscn」シーンに切り替えたら、「Grid」ルートノードに新規スクリプトをアタッチしよう。ファイルパスは「res://Grid/Grid.gd」として作成する。\nなお、スクリプト内のコメントには「指が触れた」または「指が離れた」と記載しているが、Godot デバッグパネル上では「マウス左ボタンを押した」または「マウス左ボタンを離した」と置き換えてほしい。\nまた、同じ色が３つ以上揃った状態のことを「マッチ」と表現しているので、こちらもご留意いただきたい。\nでは、スクリプトエディタが開いたら、まずは必要なプロパティを定義しておこう。\n###Grid.gd### extends Area2D # ピースを動かして指を離した後の自動処理開始時に発信するシグナル signal waiting_started # 各色のピースのシーンファイルを要素とした配列 const pieces_scn = [ preload(\"res://Pieces/PieceBeige.tscn\"), preload(\"res://Pieces/PieceBlue.tscn\"), preload(\"res://Pieces/PieceGreen.tscn\"), preload(\"res://Pieces/PiecePink.tscn\"), preload(\"res://Pieces/PieceYellow.tscn\") ] # x軸方向のグリッド数 var width: = 7 # y軸方向のグリッド数 var height: = 6 # x軸方向のグリッド開始位置（pixel） var x_start: = 70 # y軸方向のグリッド開始位置（pixel） var y_start: = 1050 # 1グリッドのサイズ（PieceのSpriteのTextureと同じにする） var grid_size: = 70 # ピースが生成される時に何グリッドy軸方向にズラして落とすか var y_offset: = 3 # 盤面のピースの配置を表す配列（二次元配列） var board = [] # プレイヤーが動かしているピースの参照 var moving_piece # プレイヤーが動かしているピースの最後の位置（グリッド） var last_pos = Vector2() # ゲーム開始時の準備中のフラグ var is_initializing = true # プレイヤーがピースを動かしている場合のフラグ var is_touching = false # ピース入れ替え中のフラグ var is_swapping = false # プレイヤーがピースを動かした後の自動処理中のフラグ var is_waiting = false # マッチしたピースのグループの数（カウントアップする） var matched_groups = 0 # PiecesContainerノードの参照 onready var pieces_container = $PiecesContainer # TouchTimerノードの参照 onready var touch_timer = $TouchTimer # WaitTimerノードの参照 onready var wait_timer = $WaitTimer 続いてここからはメソッドを追加していく。なお、以下のコード内に出てくる 二次元配列 とは、要素として配列を格納する配列、つまり配列の配列のことだ。\n今回のスクリプトで利用している二次元配列の場合、一階層目の配列では、盤面の x 軸方向のグリッドの数だけ空の配列を要素とし、二階層目としてそれぞれの配列内に縦方向のグリッド数だけ要素を格納する。その要素として、ピースオブジェクトを格納することで、それぞれのピースが盤面のどこに位置しているか（x 軸方向に何番目のグリッドで、y 軸方向に何番目のグリッドか）を管理することができるのだ。\n###Grid.gd### # シーンが読み込まれたら呼ばれる関数 func _ready(): # ランダムな数を生成する関数の出力結果を毎回ランダムにするための組み込み関数を呼ぶ randomize() # board（配列）を盤面のグリッドを構成する二次元配列にする board = make_2d_array() # このあと定義 # ピースを生成して盤面に配置して盤面情報を board に反映する spawn_pieces() # このあと定義 is_initializing = false # 盤面のグリッドを構成する二次元配列を生成するメソッド func make_2d_array() -\u003e Array: # array という名前の配列を用意 var array = [] # array に x 軸方向のグリッド数だけ空の配列を入れる for i in width: array.append([]) # さらにそれぞれの配列に y 軸方向のグリッド数だけ暫定的に null を入れる for j in height: array[i].append(null) # できあがった二次元配列を返す return array # ピースを生成して盤面に配置して盤面情報を board に反映するメソッド func spawn_pieces(): # x軸方向のグリッド数だけループ for i in width: # y軸方向のグリッド数だけループ for j in height: # 全ピースの二次元配列上で該当グリッドにピースが存在しない場合 #（ゲーム開始時は全部 null） if board[i][j] == null: # 各色のピースのシーンからランダムで１つ選択してインスタンス化 var index = floor(rand_range(0, pieces_scn.size())) var piece = pieces_scn[index].instance() # もしゲーム開始時の準備中だったら if is_initializing: # マッチしてしまった場合は、ピースのインスタンスを削除してやり直し while match_at(i, j, piece.color): # このあと定義 piece.queue_free() index = floor(rand_range(0, pieces_scn.size())) piece = pieces_scn[index].instance() # ピースのインスタンスをPiecesContainerノードの子にする pieces_container.add_child(piece) # ピースのインスタンスの collided シグナルを... # _on_Piece_collided メソッド（あとで定義）に接続する piece.connect(\"collided\", self, \"_on_Piece_collided\") # ピースのインスタンスを配置位置より y_offset 分ずらして置き... # そこから配置位置へ移動させる（落とす） piece.position = grid_to_pixel(i, j + y_offset) # このあと定義 piece.move(grid_to_pixel(i, j)) # このあと定義 # 盤面情報として board の適切なインデックスの要素に生成したピースを追加 board[i][j] = piece 上記コードの中で未定義のmatch_atメソッドとgrid_to_pixelメソッドを定義しておこう。\n###Grid.gd### # 指定したグリッド位置で同じ色ピースが３つ以上並んでいるか確認するメソッド # 引数columnはx軸のグリッド位置、rowはy軸のグリッド位置、colorはピースの色 func match_at(column, row, color): # 指定したグリッドの x 軸方向の位置が3以上の場合 if column \u003e= 2: # 指定したグリッド位置の左隣ともう一つ左隣にピースがある場合 if board[column-1][row] != null \\ and board[column-2][row] != null: # 左隣ともう一つ左隣のピースの色が指定したピースの色と同じ場合 if board[column-1][row].color == color \\ and board[column-2][row].color == color: # true を返す return true # 指定したグリッドの y 軸方向の位置が3以上の場合 if row \u003e= 2: # 指定したグリッド位置の下ともう一つ下にピースがある場合 if board[column][row-1] != null \\ and board[column][row-2] != null: # 下ともう一つ下のピースの色が指定したピースの色と同じ場合 if board[column][row-1].color == color \\ and board[column][row-2].color == color: # true を返す return true # グリッドの位置をピクセルの位置に変換するメソッド func grid_to_pixel(column, row) -\u003e Vector2: # 先にピクセル位置出力用に Vector2 型の変数 pixel_pos を定義 var pixel_pos = Vector2() # ピクセル x 座標 = x 軸方向のグリッド開始位置 + グリッドサイズ x グリッド x 座標 pixel_pos.x = x_start + grid_size * column # ピクセル y 座標 = y 軸方向のグリッド開始位置 - グリッドサイズ x グリッド y 座標 pixel_pos.y = y_start - grid_size * row # ピクセル座標を返す return pixel_pos これで、ゲーム開始時に各色のピースが盤面にランダムで並べられるはずだ。一度プロジェクトを実行して確認してみよう。なお、初めてプロジェクトを実行する場合は、メインシーン選択のダイアログが表示されるので、「Grid.tscn」をメインシーンとして選択しよう。\nちょうどgrid_to_pixelメソッドを定義したので、ついでにこのあと使用するpixel_to_gridメソッドも定義しておこう。名前の通り、先に定義したgrid_to_pixelとは逆で、ピクセルの位置をグリッドの位置に変換するメソッドだ。\n###Grid.gd### # ピクセルの位置をグリッドの位置に変換するメソッド func pixel_to_grid(pixel_x, pixel_y) -\u003e Vector2: var grid_pos = Vector2() grid_pos.x = floor((pixel_x - x_start) / grid_size) grid_pos.y = floor((pixel_y - y_start) / -grid_size) return grid_pos さらに、もう一つこのあと使用するis_in_gridメソッドを定義しておく。これは引数に渡した位置が盤面グリッドの範囲内かどうかを判定してその結果を返すメソッドだ。\n###Grid.gd### # 指定した位置が盤面グリッドの範囲内かどうかを返すメソッド func is_in_grid(grid_position: Vector2) -\u003e bool: if grid_position.x \u003e= 0 and grid_position.x \u003c width \\ and grid_position.y \u003e= 0 and grid_position.y \u003c height: # 盤面グリッドの範囲内だったら true を返す return true else: # 盤面グリッドの範囲外だったら false を返す return false ここで、ゲームのプレイヤーの入力（画面のタッチ操作）を処理するプログラムを記述していく。\n###Grid.gd### # ゲームのメインループで毎フレーム呼ばれる関数 func _process(_delta): # もしマッチングの処理中でなければ if not is_waiting: # プレイヤーの入力を処理する touch_input() # このあと定義 # プレイヤーの入力を処理するメソッド func touch_input(): # もし画面に指が触れたら if Input.is_action_just_pressed(\"touch\"): # ピースに触れた時の処理を実行するメソッドを呼ぶ touch_piece() # このあと定義 # もし画面から指が離れたら if Input.is_action_just_released(\"touch\") and is_touching: # ピースから指が離れた時の処理を実行するメソッドを呼ぶ release_piece() # このあと定義 # ピースに触れた時の処理を実行するメソッド func touch_piece(): # 指が触れた時のピクセル座標を取得する var pos = get_global_mouse_position() # ピクセル座標からグリッド座標に変換する var grid_pos = pixel_to_grid(pos.x, pos.y) # もしグリッド座標が盤面の範囲内だったら if is_in_grid(grid_pos): # 動かしているピースの最後の位置としてグリッド座標を登録 last_pos = grid_pos # 動かしているピースとしてグリッド座標に位置するピースを登録 moving_piece = board[last_pos.x][last_pos.y] # ピースを動かしているフラグを立てる is_touching = true # 動かしているピースインスタンス自体の動かしているフラグも立てる moving_piece.enable_held() # ピースを動かせる制限時間のタイマースタート touch_timer.start() # ピースから指が離れた時の処理を実行するメソッド func release_piece(): # 二次元配列 board の要素から動かしていたピースを見つけたら... # 動かしていたピースを盤面グリッドにきっちり収める for i in width: for j in height: if board[i][j] == moving_piece: moving_piece.move(grid_to_pixel(i, j)) break # 動かしていたピースインスタンス自体の動かしているフラグを解除する moving_piece.disable_held() # ピースを動かしているフラグを解除する is_touching = false # ピースを動かせる制限時間のタイマーストップ touch_timer.stop() # このあとのマッチング自動処理開始のシグナルを発信 emit_signal(\"waiting_started\") まだピースの交換は実装していないが、ここまでのコーディングで、指で触ったピースを移動させ、指を離したら移動しているピースが最後にいた場所にきっちり収まる動きが実装できたはずだ。一度プロジェクトを実行して確認してみよう。\n次に定義する_on_Piece_collidedメソッドには、すでに Piece インスタンス生成時にcollidedシグナルを接続するようコーディング済みだ。このシグナルはピースにプレイヤーが動かしているピースが当たった時に発信されるように「Piece.gd」スクリプトの方でコーディングしたことを思い出してほしい。\n動かしているピースとそれに当たったピースの場所を入れ替えるメソッドを定義して、_on_Piece_collidedの中で呼び出してみよう。\n###Grid.gd### # Piece インスタンスの collided シグナルで呼ばれるメソッド func _on_Piece_collided(self_piece): # ピースを動かしていて、かつピース交換中でなければ if is_touching and not is_swapping: # ピース交換中のフラグを立てる is_swapping = true # ピースを交換するメソッドを呼ぶ swap_pieces(self_piece) # あとで定義 # ピース交換中のフラグを解除 is_swapping = false # 動かしているピースとそれに当たったピースの場所を入れ替えるメソッド # 引数 collided_piece には動かしているピースに当たったピースが渡される func swap_pieces(collided_piece): # 当たったピースのグリッド座標を取得する。 var collided_pos = pixel_to_grid(collided_piece.position.x, collided_piece.position.y) # 二次元配列 board 上の動かしているピースと動かしているピースが一致していれば if board[last_pos.x][last_pos.y] == moving_piece: # board の動かしているピースの位置に当たったピースを入れる board[last_pos.x][last_pos.y] = collided_piece # 当たったピースを動かしているピースの最後のグリッド座標へ移動させる collided_piece.move(grid_to_pixel(last_pos.x, last_pos.y)) # board の当たったピースの位置に動かしているピースを入れる board[collided_pos.x][collided_pos.y] = moving_piece # 動かしているピースの最後の位置として当たったピースのグリッド座標を登録する last_pos = collided_pos これでピースの交換も実装できたはずだ。では実際にプロジェクトを実行してピースを動かしてみよう。通ったルートのピースが次々と交換される動作を確認しよう。\nさて、この時点で問題になるのは以下の2点だ。\n盤面の外側を自由に移動できてしまうこと いつまでもピースをつかんでいられること これらの問題はシグナルを使って解決することができる。\nArea2D クラスである「Grid」ルートノードのシグナルをスクリプトに接続しよう。コリジョン形状を盤面のサイズに調整したことを覚えているだろうか。その範囲から指（動かしているピース）が外にはみ出た場合に発信するシグナルによってrelease_pieceメソッドを呼び出して、動かしていたピースが指からも離れて盤面上の最後の位置に戻るようにする。\nシーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブを選択し、erea_exitedシグナルをこのスクリプトに接続する。\nもう一つ、「TouchTimer」ノードのピースを動かせる制限時間がタイムアウトした時に発信されるシグナルもスクリプトに接続する。この場合も同様に、シグナルによってにrelease_pieceメソッドを呼び出すようにする。timeoutシグナルを接続しよう。\n続けて、それぞれのシグナルの接続によって生成されたメソッドを以下のように編集してほしい。\n###Grid.gd### # 盤面から Area2D がはみ出たときにシグナルで呼ばれるメソッド func _on_Grid_area_exited(area): # はみ出た Area2D が動かしているピースの場合 if area.is_in_group(\"Pieces\") and area.held: # ピースから指が離れた時の処理を実行するメソッドを呼ぶ release_piece() # ピースを動かせる制限時間が切れたときにシグナルで呼ばれるメソッド func _on_TouchTimer_timeout(): # 移動中の場合 if is_touching: # ピースから指が離れた時の処理を実行するメソッドを呼ぶ release_piece() これで盤面からはみ出したら、ピースが指から離れて盤面上の最後の位置に戻るようになったはずだ。また、5秒以上ピースをつかんでいた場合も、タイマーにより、指からピースが離れて盤面上の最後のグリッド座標に収まるようになったはずだ。\nそれでは実際にプロジェクトを実行して動作を確認してみよう。\nここからはマッチしたピースを自動的に処理するプログラムを作っていく。release_pieceメソッドの最後にemit_signal(\"waiting_started\")というコードでwaiting_startedシグナルを発信するようにしていたのだが、このシグナルをスクリプトに接続するところから始める。\nシーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブでwaiting_startedシグナルをスクリプトに接続しよう。_on_Grid_waiting_startedメソッドがスクリプトに追加されたら、そのメソッド内にマッチしたピースの自動処理を記述していく。大まかに自動処理は以下の流れになる。\n自動処理中のフラグを立てる マッチしたピースが1組でもあるかチェックする。1組でもある場合は以下の処理をループする。 全てのピースをチェックしてマッチしたピースにフラグを立てる。 フラグの立っているピースを削除する。 削除して空になったスペースへ同じ列の上のグリッドからピースを移動させて詰める。 ピースを下へ詰めたら、最後に空のスペースに新しいピースを生成する。 マッチしたピースが1組もなくなったら自動処理中のフラグを解除する。\n上記の流れを段階的に実装していこう。まずは「全てのピースをチェックしてマッチしたピースにフラグを立てる」ところまで進めてみよう。\n###Grid.gd### # releaseメソッドの最後に発信されるシグナルで呼ばれるメソッド func _on_Grid_waiting_started(): # 自動処理中のフラグを立てる is_waiting = true # 人組でマッチしているピースが1組でもあればループし続ける while check_matches(): # このあと定義 # マッチしているピースにフラグを立てるメソッドを呼ぶ find_matches() # このあと定義 # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \"timeout\") # 自動処理中のフラグを解除する is_waiting = false # マッチしているピースが1組でもあるかチェックするメソッド func check_matches() -\u003e bool: # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # そのグリッド座標にピースが存在していれば if board[i][j] != null: # そのピースがマッチしていたら if match_at(i, j, board[i][j].color): # true を返す return true # 1組もマッチしているピースがなければ false を返す return false # マッチしているピースにフラグを立てるメソッド func find_matches(): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # そのグリッド座標にピースが存在していれば if board[i][j] != null: # 現在の色をそのグリッド座標のピースの色と定義する var current_color = board[i][j].color # もしその x 軸座標が x 軸方向のグリッド数 - 2 より小さければ if i \u003c width - 2: # そのピースの右隣とさらにその右隣にピースが存在する場合 if board[i+1][j] != null \\ and board[i+2][j] != null: # それらのピースの色が現在の色と同じ場合 if board[i+1][j].color == current_color \\ and board[i+2][j].color == current_color: # マッチした組に割り振る番号の変数を定義 var matched_index: int # そのピースにすでにマッチしているフラグが立っていれば if board[i][j].matched: # マッチした組の番号はそのピースの組の番号とする matched_index = board[i][j].matched_index # そのピースにマッチしているフラグが立ってなければ else: # マッチした組のグループ数を1増やす matched_groups += 1 # マッチした組の番号をマッチした組のグループ数とする matched_index = matched_groups # その座標のピースにマッチしたフラグを立て、組の番号を割り当て、半透明にする board[i][j].make_matched(matched_index) # その座標の右隣のピースも同様にする board[i+1][j].make_matched(matched_index) # さらにもう一つ右隣のピースも同様にする board[i+2][j].make_matched(matched_index) # y軸方向に対しても同様にする if j \u003c height - 2: if board[i][j+1] != null \\ and board[i][j+2] != null: if board[i][j+1].color == current_color \\ and board[i][j+2].color == current_color: var matched_index: int if board[i][j].matched: matched_index = board[i][j].matched_index else: matched_groups += 1 matched_index = matched_groups board[i][j].make_matched(matched_index) board[i][j+1].make_matched(matched_index) board[i][j+2].make_matched(matched_index) マッチしたピースの処理のうち、マッチしているピースにフラグを立てるところまで実装した。プロジェクトを実行して、マッチしたピースが半透明になるか確認してみよう。 次はマッチ状態のフラグが立っているピースを削除するメソッドを定義する。\n###Grid.gd### # マッチのフラグが立っているピースを削除するメソッド # 引数 index には削除対象のマッチの組番号を渡す func delete_matches(index): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # もしそのグリッド座標にピースが存在していれば if board[i][j] != null: # もしそのグリッド座標のピースにマッチのフラグが立っていたら if board[i][j].matched: # もしそのグリッド座標のピースの組番号は削除対象の組番号と一致したら if board[i][j].matched_index == index: # そのグリッド座標のピースを解放する board[i][j].queue_free() # 二次元配列 board の該当の要素を null にする board[i][j] = null delete_matchesメソッドが定義できたので、これを_on_Grid_waiting_startedメソッドのループの中に入れよう。\n###Grid.gd### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \"timeout\") # ここを追加 # マッチしたグループの数が0より大きければ if matched_groups \u003e 0: # マッチしたグループの数だけループさせる # 全て同時に削除せず、マッチした組ごとに削除する for index in range(1, matched_groups + 1): # マッチしたピースを削除するメソッドを呼ぶ delete_matches(index) # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \"timeout\") # マッチしたピースをすべて削除したらマッチしたグループの数を 0 に戻す matched_groups = 0 is_waiting = false これで、マッチしたピースが半透明になったあと、削除されるところまで実装できたはずだ。プロジェクトを実行して確認してみよう。 続いて、ピースが削除されて空いたグリッドスペースに上のピースを詰める（落とす）処理を実装する。まずはメソッドから定義しよう。\n###Grid.gd### # 空いたグリッドスペースに上のピースを詰める（落とす）メソッド func collapse_columns(): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # もしそのグリッド座標にピースがなければ if board[i][j] == null: # その y座標より1つ上のグリッドから残りの y軸方向のグリッド数だけループ for k in range(j + 1, height): # もしそのグリッド座標にピースが存在していれば if board[i][k] != null: # そのグリッド座標のピースを空いたスペースへ移動する board[i][k].move(grid_to_pixel(i, j)) # 二次元配列 board の要素を入れ替える board[i][j] = board[i][k] board[i][k] = null # ループ終了 break collapse_columnsメソッドが定義できたので、これを_on_Grid_waiting_startedメソッドのループの中に追加しよう。\n###Grid.gd### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \"timeout\") if matched_groups \u003e 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \"timeout\") matched_groups = 0 # ここを追加 # 空いたグリッドスペースに上のピースを詰める（落とす）メソッドを呼ぶ collapse_columns() # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \"timeout\") is_waiting = false これで、マッチして半透明になったピースが削除されたあと、その空いたスペースには上のピースが詰められる（落とされる）ようになったはずだ。プロジェクトを実行して確認してみよう。\n最後に、ピースを下に詰めた後の上の空いたスペースには新しいピースを補充する必要がある。そのためのメソッドは、_ready関数の中でも実行している、すでに定義済みのspawn_piecesメソッドだ。ゲームのプレイが開始した時点ではis_initializingプロパティはfalseになっているので、このメソッドを実行してピースが生成された時点ですでに新たなマッチが発生するかもしれない。これが期待以上のコンボを発生させ、ゲーム体験をより気持ち良く、楽しいものにしてくれるはずだ。\nspawn_piecesメソッドを_on_Grid_waiting_startedメソッドのループの中に追加しよう。\n###Grid.gd### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \"timeout\") if matched_groups \u003e 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \"timeout\") matched_groups = 0 collapse_columns() wait_timer.start() yield(wait_timer, \"timeout\") # ここを追加 # 空いたスペースにピースを生成するメソッドを呼ぶ spawn_pieces() # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \"timeout\") is_waiting = false これでマッチ処理のコーディングが完了だ。このチュートリアルとしても作業はここまでとなる。最後にプロジェクトを実行して、このパズルゲームの最終動作確認をして終わりにしよう。\nサンプルゲーム 今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。\nYour browser does not support the video tag. サンプルゲームのプロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。\nゲームのルール:\nプレイヤーがピースを動かせるのは1回につき5秒まで。5秒経過すると指から離れる。 プレイヤーが動かしているピースが盤面からはみ出すと、ピースが指から離れて、移動もそこまでとなる。 マッチしたピースの組の数だけコンボ数が上がる。プレイヤーはコンボの数だけエイリアン（敵キャラクター）を攻撃でき、パワーも上がる。 エイリアンを攻撃するとパワーの分だけHPを減らすことができ、エイリアンのHPを0にすると倒すことができる。 エイリアンは一定の間隔でプレイヤーを攻撃してくる。 プレイヤーのライフは最大10。エイリアンに攻撃されると１つ減り、10回攻撃されるとゲームオーバー。 敵を倒すごとにレベルが1上がる。レベルが上がるとプレイヤーのパワーが少しアップする一方、敵キャラクターもHPが上がり、攻撃してくる間隔も少し短くなる。 マッチしたピースの自動処理中（コンボカウント中と敵への攻撃中）は敵のタイムゲージは一時停止する。 最終的に、倒したエイリアンの数がこのゲームのスコアとなる。 おわりに 今回のチュートリアルでは進化系マッチ3パズルゲームと銘打って、パズドラ風のパズルゲームを作った。オーソドックスなマッチ3とは違い、盤面上で一定時間ピースを自由に動かせるようにしたり、マッチしたピースが消える時も、パズドラのようにマッチした組ごとに順番に消えるようにしたりと、スクリプトのコードはやや複雑になったかもしれないが、最後まで作り切ることができただろうか。\n今回のような進化系マッチ3パズルゲームを作るときのポイントをまとめておこう。\n最低限必要なシーンは盤面とピースの２つだけ。 雛形のピースシーンを作ってから、それを継承して各色のピースシーンを作る。 二次元配列を利用して盤面グリッドに配置するピースを管理する。 Area2Dのシグナルを利用して、以下について検知させる。 指がピースに触れた時 指がピースから離れた時 動かしているピースと静止しているピースが当たった時 動かしているピースが盤面からはみ出した時 フラグ用のプロパティを用意して、状態管理をする。例えば以下。 ピースを動かしているかどうか ピースが入れ替え中かどうか ピースがマッチしているかどうか マッチの自動処理中かどうか ピースを入れ替えるときは、画面上のピースの位置と二次元配列の要素をそれぞれ更新する必要がある。 参照 KidsCanCode: OBJECT HEALTHBARS KidsCanCode: HEART CONTAINERS: 3 WAYS Puzzle＆Dragons（パズル＆ドラゴンズ） ",
  "wordCount" : "16296",
  "inLanguage": "ja",
  "image":"https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif","datePublished": "2022-07-10T00:51:37+09:00",
  "dateModified": "2022-07-10T00:51:37+09:00",
  "author":{
    "@type": "Person",
    "name": "Gobo"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Peanuts Code",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.peanuts-code.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.peanuts-code.com/ja/" accesskey="h" title="Peanuts Code (Alt + H)">
                <img src="/images/logomark.png" alt="logo" aria-label="logo"
                    height="35">Peanuts Code</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://www.peanuts-code.com/en/" title="English"
                            aria-label="English">En</a>
                    </li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.peanuts-code.com/ja/" title="ホーム">
                    <span>ホーム</span>
                </a>
            </li>
            <li>
                <a href="https://www.peanuts-code.com/ja/posts/" title="ブログ">
                    <span>ブログ</span>
                </a>
            </li>
            <li>
                <a href="https://www.peanuts-code.com/ja/tutorials/" title="チュートリアル">
                    <span>チュートリアル</span>
                </a>
            </li>
            <li>
                <a href="https://www.peanuts-code.com/ja/about/" title="サイト情報">
                    <span>サイト情報</span>
                </a>
            </li>
            <li>
                <a href="https://www.peanuts-code.com/ja/search/" title="検索 (Alt &#43; /)" accesskey=/>
                    <span>検索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.peanuts-code.com/ja/">Home</a>&nbsp;»&nbsp;<a href="https://www.peanuts-code.com/ja/tutorials/">チュートリアル</a></div>
    <h1 class="post-title">
      Godot で作る進化形マッチ 3 パズルゲーム
    </h1>
    <div class="post-meta">2022-07-10&nbsp;·&nbsp;33 分&nbsp;·&nbsp;Gobo&nbsp;|&nbsp;
<ul class="i18n_list">言語:
    <li>
        <a href="https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/">En</a>
    </li>
</ul>
</div>
    
    <ul class="post-tags">
      <li><a href="https://www.peanuts-code.com/ja/tags/godotengine/">GodotEngine</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/gamedev/">GameDev</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/godot3/">Godot3</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/2d/">2D</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/%E3%83%91%E3%82%BA%E3%83%AB%E3%82%B2%E3%83%BC%E3%83%A0/">パズルゲーム</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/%E3%83%A2%E3%83%90%E3%82%A4%E3%83%AB%E3%82%B2%E3%83%BC%E3%83%A0/">モバイルゲーム</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/%E3%83%9E%E3%83%83%E3%83%813/">マッチ3</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/%E3%83%91%E3%82%BA%E3%83%89%E3%83%A9/">パズドラ</a></li>
    </ul>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on twitter"
        href="https://twitter.com/intent/tweet/?text=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&amp;hashtags=GodotEngine%2cGameDev%2cGodot3%2c2D%2c%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0%2c%e3%83%a2%e3%83%90%e3%82%a4%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0%2c%e3%83%9e%e3%83%83%e3%83%813%2c%e3%83%91%e3%82%ba%e3%83%89%e3%83%a9">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&amp;title=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;summary=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;source=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&title=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on whatsapp"
        href="https://api.whatsapp.com/send?text=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0%20-%20https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on telegram"
        href="https://telegram.me/share/url?text=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

    
    
    
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif" alt="Godot で作る進化形マッチ 3 パズルゲーム">
        
</figure><div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目次</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%96%b0%e8%a6%8f%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e3%82%92%e4%bd%9c%e6%88%90%e3%81%99%e3%82%8b" aria-label="新規プロジェクトを作成する">新規プロジェクトを作成する</a><ul>
                        
                <li>
                    <a href="#%e3%83%97%e3%83%ad%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e8%a8%ad%e5%ae%9a%e3%82%92%e6%9b%b4%e6%96%b0%e3%81%99%e3%82%8b" aria-label="プロジェクト設定を更新する">プロジェクト設定を更新する</a></li>
                <li>
                    <a href="#%e3%82%a2%e3%82%bb%e3%83%83%e3%83%88%e3%82%92%e3%83%80%e3%82%a6%e3%83%b3%e3%83%ad%e3%83%bc%e3%83%89%e3%81%97%e3%81%a6%e3%82%a4%e3%83%b3%e3%83%9d%e3%83%bc%e3%83%88%e3%81%99%e3%82%8b" aria-label="アセットをダウンロードしてインポートする">アセットをダウンロードしてインポートする</a></li></ul>
                </li>
                <li>
                    <a href="#grid-%e3%82%b7%e3%83%bc%e3%83%b3%e3%82%92%e4%bd%9c%e3%82%8b" aria-label="Grid シーンを作る">Grid シーンを作る</a><ul>
                        
                <li>
                    <a href="#grid-%e3%82%b7%e3%83%bc%e3%83%b3%e3%81%ab%e3%83%8e%e3%83%bc%e3%83%89%e3%82%92%e8%bf%bd%e5%8a%a0%e3%81%99%e3%82%8b" aria-label="Grid シーンにノードを追加する">Grid シーンにノードを追加する</a></li>
                <li>
                    <a href="#grid-%e3%82%b7%e3%83%bc%e3%83%b3%e3%81%ae%e3%83%8e%e3%83%bc%e3%83%89%e3%82%92%e7%b7%a8%e9%9b%86%e3%81%99%e3%82%8b" aria-label="Grid シーンのノードを編集する">Grid シーンのノードを編集する</a><ul>
                        
                <li>
                    <a href="#grid-area2d-%e3%83%ab%e3%83%bc%e3%83%88%e3%83%8e%e3%83%bc%e3%83%89" aria-label="Grid (Area2D) ルートノード">Grid (Area2D) ルートノード</a></li>
                <li>
                    <a href="#collisionshape2d-%e3%83%8e%e3%83%bc%e3%83%89" aria-label="CollisionShape2D ノード">CollisionShape2D ノード</a></li>
                <li>
                    <a href="#piecescontainer-node2d-%e3%83%8e%e3%83%bc%e3%83%89" aria-label="PiecesContainer (Node2D) ノード">PiecesContainer (Node2D) ノード</a></li>
                <li>
                    <a href="#touchtimer-%e3%83%8e%e3%83%bc%e3%83%89" aria-label="TouchTimer ノード">TouchTimer ノード</a></li>
                <li>
                    <a href="#waittimer-%e3%83%8e%e3%83%bc%e3%83%89" aria-label="WaitTimer ノード">WaitTimer ノード</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#piece-%e3%82%b7%e3%83%bc%e3%83%b3%e3%82%92%e4%bd%9c%e3%82%8b" aria-label="Piece シーンを作る">Piece シーンを作る</a><ul>
                        
                <li>
                    <a href="#piece-%e3%82%b7%e3%83%bc%e3%83%b3%e3%81%ab%e3%83%8e%e3%83%bc%e3%83%89%e3%82%92%e8%bf%bd%e5%8a%a0%e3%81%99%e3%82%8b" aria-label="Piece シーンにノードを追加する">Piece シーンにノードを追加する</a></li>
                <li>
                    <a href="#piece-%e3%82%b7%e3%83%bc%e3%83%b3%e3%81%ae%e3%83%8e%e3%83%bc%e3%83%89%e3%82%92%e7%b7%a8%e9%9b%86%e3%81%99%e3%82%8b" aria-label="Piece シーンのノードを編集する">Piece シーンのノードを編集する</a><ul>
                        
                <li>
                    <a href="#piece-area2d-%e3%83%ab%e3%83%bc%e3%83%88%e3%83%8e%e3%83%bc%e3%83%89" aria-label="Piece (Area2D) ルートノード">Piece (Area2D) ルートノード</a></li>
                <li>
                    <a href="#sprite-%e3%83%8e%e3%83%bc%e3%83%89" aria-label="Sprite ノード">Sprite ノード</a></li>
                <li>
                    <a href="#collisionshape2d-%e3%83%8e%e3%83%bc%e3%83%89-1" aria-label="CollisionShape2D ノード">CollisionShape2D ノード</a></li>
                <li>
                    <a href="#tween-%e3%83%8e%e3%83%bc%e3%83%89" aria-label="Tween ノード">Tween ノード</a></li></ul>
                </li>
                <li>
                    <a href="#piece-%e3%83%8e%e3%83%bc%e3%83%89%e3%81%ab%e3%82%b9%e3%82%af%e3%83%aa%e3%83%97%e3%83%88%e3%82%92%e3%82%a2%e3%82%bf%e3%83%83%e3%83%81%e3%81%97%e3%81%a6%e7%b7%a8%e9%9b%86%e3%81%99%e3%82%8b" aria-label="Piece ノードにスクリプトをアタッチして編集する">Piece ノードにスクリプトをアタッチして編集する</a></li></ul>
                </li>
                <li>
                    <a href="#piece-%e3%82%b7%e3%83%bc%e3%83%b3%e3%82%92%e7%b6%99%e6%89%bf%e3%81%97%e3%81%9f%e5%90%84%e8%89%b2%e3%81%ae%e3%82%b7%e3%83%bc%e3%83%b3%e3%82%92%e4%bd%9c%e3%82%8b" aria-label="Piece シーンを継承した各色のシーンを作る">Piece シーンを継承した各色のシーンを作る</a></li>
                <li>
                    <a href="#grid-%e3%82%b7%e3%83%bc%e3%83%b3%e3%82%92%e3%82%b9%e3%82%af%e3%83%aa%e3%83%97%e3%83%88%e3%81%a7%e5%88%b6%e5%be%a1%e3%81%99%e3%82%8b" aria-label="Grid シーンをスクリプトで制御する">Grid シーンをスクリプトで制御する</a></li>
                <li>
                    <a href="#%e3%82%b5%e3%83%b3%e3%83%97%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0" aria-label="サンプルゲーム">サンプルゲーム</a></li>
                <li>
                    <a href="#%e3%81%8a%e3%82%8f%e3%82%8a%e3%81%ab" aria-label="おわりに">おわりに</a></li>
                <li>
                    <a href="#%e5%8f%82%e7%85%a7" aria-label="参照">参照</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。</p>
<p>これはモバイルゲームで人気を博した「パズル&amp;ドラゴンズ（Puzzle &amp; Dragons）/ 通称パズドラ」のようなパズルをイメージしていただくとわかりやすいだろう。</p>
<p>ただし、チュートリアルに味方のデッキやガチャ、敵キャラクターとのバトルなど全てのゲーム要素を盛り込むとボリュームが大きすぎるので、今回はパズル部分にフォーカスして手順を説明させていただく。</p>
<p>なお「キャンディークラッシュ」のようなオーソドックスなマッチ3（スリー）パズルゲームや「LINEツムツム」のような指でピースをなぞって繋げて消すタイプのパズルゲームの作り方については、以下のチュートリアルを参照いただきたい。</p>
<blockquote>
<p><em><strong><span style="color:salmon">Other Tutorials</span>
</strong><br>
「キャンディークラッシュ」のようなゲームを作ってみたい場合：<br>
<a href="https://www.peanuts-code.com/ja/tutorials/gd0012_match3/" title="Godot で作るマッチ 3 パズルゲーム">Godot で作るマッチ 3 パズルゲーム</a>
<br>
「LINE：ディズニーツムツム」のようなゲームを作って見たい場合：<br>
<a href="https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/" title="Godot で作る同じ色をつなげて消すパズルゲーム">Godot で作る同じ色をつなげて消すパズルゲーム</a>
</em></p>
</blockquote>
<br>
<p>このチュートリアルで最後にできあがるプロジェクトのファイルは<a href="https://github.com/msnsk/AdvancedMatch3.git" target="_blank">GitHubリポジトリ</a>
に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。<br>
<br></p>
<blockquote>
<p><em><strong><span style="color:salmon">Environment</span>
</strong><br>
このチュートリアルは以下の環境で作成しました。</em><br>
・<em>Godot のバージョン: <strong>3.4.4</strong></em><br>
・<em>コンピュータのOS: <strong>macOS 11.6.5</strong></em></p>
</blockquote>
<blockquote>
<p><em><strong><span style="color:salmon">Memo:</span>
</strong><br>
ゲームを作り始めるのに以下の記事もお役立てください。<br>
<a href="https://www.peanuts-code.com/ja/tutorials/gd0001_download/" title="Godot をダウンロードする">Godot をダウンロードする</a>
<br>
<a href="https://www.peanuts-code.com/ja/tutorials/gd0002_project_manager/" title="Godot のプロジェクトマネージャー">Godot のプロジェクトマネージャー</a>
<br>
<a href="https://www.peanuts-code.com/ja/tutorials/gd0003_change_language/" title="Godot の言語設定">Godot の言語設定</a>
</em></p>
</blockquote>
<br>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
style="display:block; text-align:center;"
data-ad-layout="in-article"
data-ad-format="fluid"
data-ad-client="ca-pub-4952908839423901"
data-ad-slot="9419515863"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<hr>
<h2 id="新規プロジェクトを作成する">新規プロジェクトを作成する<a hidden class="anchor" aria-hidden="true" href="#新規プロジェクトを作成する">#</a></h2>
<p>それでは Godot Engine を立ち上げて、新規プロジェクトを作成しよう。プロジェクトの名前はあなたのお好みで決めていただいてOKだ。もし思いつかなければ「Advanced Match3 Start」としておこう。</p>
<br>
<h3 id="プロジェクト設定を更新する">プロジェクト設定を更新する<a hidden class="anchor" aria-hidden="true" href="#プロジェクト設定を更新する">#</a></h3>
<p>エディタが表示されたら、先にプロジェクト全体に関わる設定を更新しておこう。</p>
<p>まずはゲームのディスプレイサイズを設定する。今回はスマホの縦向きの画面を想定して、縦横の比率を <strong>16 : 9</strong> とする。</p>
<ol>
<li>「プロジェクト」メニュー＞「プロジェクト設定」を開く。</li>
<li>「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。</li>
<li>「Size」セクションで以下の項目の値を変更する。
<ul>
<li>Width: 630</li>
<li>Height: 1120</li>
<li>Test Width: 315</li>
<li>Test Height: 560<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img1.png" alt="project settings - Display - Window - Size"  />
</li>
</ul>
</li>
<li>「Stretch」セクションで以下の項目の値を変更する。
<ul>
<li>Mode: 2d</li>
<li>Aspect: keep<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img2.png" alt="project settings - Display - Window - Stretch"  />
</li>
</ul>
</li>
</ol>
<br>
<p>そのまま「プロジェクト設定」ウインドウを開いた状態で、デバッグパネルでスマホのタッチ操作をマウスで代用するための設定をする。</p>
<ol>
<li>「一般」タブで「mouse」と検索し、サイドバーの「Input Devices」＞「Pointing」を選択する。</li>
<li>「Emulate Touch From Mouse」の On のチェックを入れる。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img3.png" alt="Input Devices - Pointing - Emulate Touch From Mouse"  />
</li>
</ol>
<br>
<p>さらに「プロジェクト設定」ウインドウを開いた状態で、インプットマップにスマホのタッチ操作の相当するアクションを追加しよう。</p>
<ol>
<li>「インプットマップ」タブに切り替え、アクションに「touch」を追加する。</li>
<li>「touch」の操作にマウスの左クリックを追加する。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img4.png" alt="Inputmap - action - tap"  />
</li>
</ol>
<br>
<h3 id="アセットをダウンロードしてインポートする">アセットをダウンロードしてインポートする<a hidden class="anchor" aria-hidden="true" href="#アセットをダウンロードしてインポートする">#</a></h3>
<p>次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは「<a href="https://www.kenney.nl/assets/physics-assets" target="_blank">Physics Assets</a>
」というアセットパックだ。このアセットに含まれるなんともかわいいエイリアンの顔の画像を、ゲームの盤面に並べるピースのテクスチャとして使用する。この素晴らしすぎる無料の素材に感謝せずにはいられない。</p>
<p>ダウンロードしたら「/physicspack/PNG/Aliens」フォルダの中のファイル名が「~_round.png」の画像だけを残して他は削除し、「Aliens」フォルダごとエディタのファイルシステムドックへドラッグしてプロジェクトにインポートしよう。</p>
<br>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
style="display:block; text-align:center;"
data-ad-layout="in-article"
data-ad-format="fluid"
data-ad-client="ca-pub-4952908839423901"
data-ad-slot="9419515863"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<hr>
<h2 id="grid-シーンを作る">Grid シーンを作る<a hidden class="anchor" aria-hidden="true" href="#grid-シーンを作る">#</a></h2>
<p>まずはマッチ3パズルゲームでピースが配置される盤面として、「Grid」シーンを作成しよう。</p>
<ol>
<li>「シーン」メニュー＞「新規シーン」を選択する。</li>
<li>「ルートノードを生成」にて「その他のノード」を選択する。</li>
<li>「Area2D」クラスのルートノードが生成されたら、その名前を「Grid」に変更する。</li>
<li>シーンを保存する。フォルダを作成して、ファイルパスを「res://Grid/Grid.tscn」としてシーンを保存する。<br>
<br></li>
</ol>
<h3 id="grid-シーンにノードを追加する">Grid シーンにノードを追加する<a hidden class="anchor" aria-hidden="true" href="#grid-シーンにノードを追加する">#</a></h3>
<p>「Grid」ルートノードに、さらにノードを追加していこう。</p>
<ol>
<li>「Grid」ルートノードに「CollisionShape2D」ノードを追加する。</li>
<li>「Grid」ルートノードに「Node2D」ノードを追加し、名前を「PiecesContainer」に変更する。</li>
<li>「Grid」ルートノードに「Timer」ノードを２つ追加し、それぞれ名前を「TouchTimer」、「WaitTimer」に変更する。</li>
</ol>
<p>ひとまず現時点でのシーンツリーは以下のようになったはずだ。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img5.png" alt="Scene Dock"  />
</p>
<p>続けて追加したノードを編集していこう。</p>
<br>
<h3 id="grid-シーンのノードを編集する">Grid シーンのノードを編集する<a hidden class="anchor" aria-hidden="true" href="#grid-シーンのノードを編集する">#</a></h3>
<h4 id="grid-area2d-ルートノード">Grid (Area2D) ルートノード<a hidden class="anchor" aria-hidden="true" href="#grid-area2d-ルートノード">#</a></h4>
<p>このパズドラ風のパズルでは、盤面上でピースを自由に動かせるわけだが、盤面から動かしているピースがはみ出してはいけない。そうしないと、盤面の外側を移動させて離れたピースと入れ替えることができてしまう。このパズルゲームは、あくまで動かしているピースと隣り合ったドロップが次々に交換されていく仕様なのだ。</p>
<p>ルートノードを Area2D クラスにしたのは、そのシグナルを使って盤面から指（動かしているピース）がはみ出したことを検知させるためだ。検知さえできれば、あとはスクリプトで制限できる。このシーンへのスクリプトのアタッチは最後に行うので、その時にあらためてシグナルの接続を行うことにしよう。</p>
<p>このノードそのもののプロパティ編集は不要だ。</p>
<br>
<h4 id="collisionshape2d-ノード">CollisionShape2D ノード<a hidden class="anchor" aria-hidden="true" href="#collisionshape2d-ノード">#</a></h4>
<p>このノードは、盤面の外に指（動かしているピース）がはみ出した時にそれを検知するために利用する。インスペクターで以下の通りに各プロパティを編集しよう。</p>
<ul>
<li>Shape: 新規 RectangleShape2D リソースを適用する。
<ul>
<li>RectangleShape2D &gt;
<ul>
<li>Extents: (x: 225, y: 190)<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img6.png" alt="CollisionShape2D Properties - Shape"  />
</li>
</ul>
</li>
<li>Transform &gt;
<ul>
<li>Position: (x: 315, y: 840)<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img7.png" alt="CollisionShape2D Properties - Position"  />
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2D ワークスペース上では以下のようになったはずだ。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img8.png" alt="CollisionShape2D in 2D workspace"  />
</p>
<br>
<h4 id="piecescontainer-node2d-ノード">PiecesContainer (Node2D) ノード<a hidden class="anchor" aria-hidden="true" href="#piecescontainer-node2d-ノード">#</a></h4>
<p>このノードは盤面に配置されるピースをまとめるためのノードだ。ゲーム中、スクリプトでピースのインスタンスが生成されたら全てこの「PiecesContainer」ノードの子として追加することになる。そうすることで、ピースのインスタンスがどれだけ生成されても、シーンツリー上のノードの順序を維持することができる。</p>
<p>特に編集が必要なプロパティはないので次へ行こう。</p>
<br>
<h4 id="touchtimer-ノード">TouchTimer ノード<a hidden class="anchor" aria-hidden="true" href="#touchtimer-ノード">#</a></h4>
<p>この Timer クラスのノードは、指でピースを動かし始めてからカウントダウンを始め、タイムアウトしたら、動かしていたピースが指から自動的に離れるようにするためのものだ。これにより、制限時間内でピースを並べなければならないというある種の緊張感をプレイヤーに与えることができる。今回は 5 秒間ピースを移動できる設定にする。</p>
<p>インスペクターで以下のように編集しよう。</p>
<ul>
<li>Wait Time: 5</li>
<li>One Shot: オン<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img8.1.png" alt="TouchTimer properties"  />
</li>
</ul>
<br>
<h4 id="waittimer-ノード">WaitTimer ノード<a hidden class="anchor" aria-hidden="true" href="#waittimer-ノード">#</a></h4>
<p>こちらの Timer クラスのノードは、指からピースが離れた後の、ピースのマッチング処理、マッチしたピースの削除、削除されて空いたグリッドへピースを詰めて、不足している分を追加する、という一連の流れを自動処理する際に、それぞれの処理の間に一瞬だけ間をあけるためのノードだ。</p>
<p>インスペクターで以下のように編集しよう。</p>
<ul>
<li>Wait Time: 0.3</li>
<li>One Shot: オン<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img8.2.png" alt="WaitTimer properties"  />
</li>
</ul>
<br>
<p>以上で、「Grid」シーンの編集は完了だ。</p>
<br>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
style="display:block; text-align:center;"
data-ad-layout="in-article"
data-ad-format="fluid"
data-ad-client="ca-pub-4952908839423901"
data-ad-slot="9419515863"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<hr>
<h2 id="piece-シーンを作る">Piece シーンを作る<a hidden class="anchor" aria-hidden="true" href="#piece-シーンを作る">#</a></h2>
<p>次に、盤面に並べるピースとして「Piece」シーンを作成する。ただし、この「Piece」シーンはあくまで雛形で、実際にゲーム中で利用する各色のピースは、この「Piece」シーンを継承する形でのちほど用意する。</p>
<ol>
<li>「シーン」メニュー＞「新規シーン」を選択する。</li>
<li>「ルートノードを生成」にて「その他のシーン」を選択する。</li>
<li>「Area2D」クラスのルートノードが生成されたら、その名前を「Piece」に変更する。</li>
<li>シーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Pieces/Piece.tscn」としてシーンを保存する。<br>
<br></li>
</ol>
<h3 id="piece-シーンにノードを追加する">Piece シーンにノードを追加する<a hidden class="anchor" aria-hidden="true" href="#piece-シーンにノードを追加する">#</a></h3>
<p>続けて、「Piece」シーンに必要なノードを追加していこう。</p>
<ol>
<li>「Piece」ルートノードに「Sprite」ノードを追加する。</li>
<li>「Piece」ルートノードに「CollisionShape2D」ノードを追加する。</li>
<li>「Piece」ルートノードに「Tween」ノードを追加する。<br>
<br></li>
</ol>
<p>Piece シーンのシーンツリーは以下のようになったはずだ。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img9.png" alt="Piece scene tree"  />
</p>
<br>
<h3 id="piece-シーンのノードを編集する">Piece シーンのノードを編集する<a hidden class="anchor" aria-hidden="true" href="#piece-シーンのノードを編集する">#</a></h3>
<h4 id="piece-area2d-ルートノード">Piece (Area2D) ルートノード<a hidden class="anchor" aria-hidden="true" href="#piece-area2d-ルートノード">#</a></h4>
<p>ルートノードを Area2D クラスにしたのは、動かしたいピースに指が当たった時や離れた時、ピース同士が衝突した時に、それを検知できるようにするためだ。</p>
<p>このノードのプロパティは編集不要だが、１つだけグループへの追加が必要だ。シーンドックで「Piece」ルートノードを選択したら、ノードドック＞グループタブを選択して、「Pieces」という名前のグループを作成して追加しよう。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img9.1.png" alt="Group Pieces"  />
<br>
「Grid」シーンの方で「Grid」ルートノードには盤面からのはみ出し検知用のコリジョン形状が設定されており、これは常に全ピースと接触しているので、ピース同士との衝突を区別するために必要なグループなのだ。</p>
<br>
<h4 id="sprite-ノード">Sprite ノード<a hidden class="anchor" aria-hidden="true" href="#sprite-ノード">#</a></h4>
<p>先述の通り、「Piece」はあくまで継承元（雛形）なので、このシーンでは「Sprite」ノードの「Texture」プロパティにはリソースを敢えて適用せずそのままにしておく。継承先のシーンでそれぞれのピースの色にあった画像を適用する予定だ。</p>
<p>このシーンを継承する各色のピースのシーンでは「Texture」プロパティに先にインポートした KENNEY の画像を適用するが、その画像の縦横のサイズが 70 px なので、その画像の中心を右上にずらして画像の左下の角が(x: 0, y: 0)に合うように「Offset」プロパティを設定しよう。</p>
<ul>
<li>Offset:<br>
Offset: (x: 35, y: -35)<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img10.png" alt="Sprite - offset"  />
</li>
</ul>
<p>ピースを配置する盤面のグリッドは x 軸は左から右へ、y 軸は下から上へカウントする仕様で、かつ盤面の 1 グリッドのサイズもテクスチャのサイズに合わせて 70 px とする。ピースのテクスチャ画像の左下の角を (x: 0, y: 0) に合わせれば、「Piece」ルートノードの位置 (x: 0, y: 0) をグリッドに合わせて配置したときに、ちょうど「Sprite」の画像がグリッドに沿って配置されるというわけだ。</p>
<br>
<h4 id="collisionshape2d-ノード-1">CollisionShape2D ノード<a hidden class="anchor" aria-hidden="true" href="#collisionshape2d-ノード-1">#</a></h4>
<p>このノードはルートノードにコリジョン形状を付与する役目だ。ピースに指を触れたり、指を離したり、隣のピースと衝突したりするのを検知させるのに必要なノードである。コリジョン形状を縦横 70 px の Sprite の Texture にピッタリ合わせてしまうと、少しピースを動かしただけで、隣のピースとの衝突を検知してしまう。かといって、コリジョン形状が小さすぎると、指でピースに触れているつもりなのに検知されなかったり、ピースを移動させるときに、ピース同士の衝突をうまく検知できずにピースとピースの間を通り抜けてしまったりする。そこでコリジョン形状は Sprite の Texture の半分のサイズにするとちょうど良い。位置も Sprite の Texture にきれいに重なるように調整しよう。</p>
<ul>
<li>Shape: 新規 CircleShape2D リソースを適用する
<ul>
<li>CircleShape2D:
<ul>
<li>Radius: 17.5<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img11.png" alt="CollisionShape2D - Shape, Radius"  />
</li>
</ul>
</li>
</ul>
</li>
<li>Transform:
<ul>
<li>Position: x: 35, y: -35<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img12.png" alt="CollisionShape2D - Position"  />
</li>
</ul>
</li>
</ul>
<p>2D ワークスペース上では以下のようになったはずだ。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img13.png" alt="CollisionShape2D - 2D workspace"  />
</p>
<br>
<h4 id="tween-ノード">Tween ノード<a hidden class="anchor" aria-hidden="true" href="#tween-ノード">#</a></h4>
<p>このノードは、指定したノードの単一のプロパティのみをアニメーションさせることができる。今回このノードを使用するのは、ピースの位置が交換される時や、マッチして消えたピースの位置にピースを詰める時のピースの移動をアニメーションさせるためだ。</p>
<p>ただし、アニメーションはスクリプトで実装するので、このタイミングでのプロパティの編集は不要だ。<br>
<br></p>
<h3 id="piece-ノードにスクリプトをアタッチして編集する">Piece ノードにスクリプトをアタッチして編集する<a hidden class="anchor" aria-hidden="true" href="#piece-ノードにスクリプトをアタッチして編集する">#</a></h3>
<p>「Piece」ルートノードに新規スクリプトをアタッチしよう。ファイルパスを「res://Pieces/Piece.gd」としてスクリプトファイルを作成する。</p>
<p>ひとまずスクリプトを以下のように編集してほしい。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Piece.gd###</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Area2D</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># プレイヤーが動かしているピースに衝突したら発信するシグナル（引数にピース自身を渡す）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> collided(self_piece)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースの色を設定するプロパティ</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">export</span> (<span style="color:#a6e22e">String</span>) <span style="color:#66d9ef">var</span> color
</span></span><span style="display:flex;"><span><span style="color:#75715e"># マッチした場合のフラグとなるプロパティ</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> matched <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span><span style="color:#75715e"># マッチしたピースのグループに割り振られるインデックス</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> matched_index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># プレイヤーが動かしている場合のフラグとなるプロパティ</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> held <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースのテクスチャと同じオフセット</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> offset <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">35</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">35</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Spriteノードへの参照</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> sprite <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#a6e22e">Sprite</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Tweenノードへの参照</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> tween <span style="color:#f92672">=</span> <span style="color:#f92672">$</span><span style="color:#a6e22e">Tween</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># メインループで毎フレーム呼ばれる組み込みメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _process(_delta):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># もしプレイヤーがピースを移動中だったら</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> held:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピースの位置を(35, -35)ずらしてマウスに追随させる</span>
</span></span><span style="display:flex;"><span>		position <span style="color:#f92672">=</span> get_global_mouse_position() <span style="color:#f92672">-</span> offset
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースを移動させるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> move(destination):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Tweenノードのアニメーションを設定する</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピースを0.1秒かけて現在の位置から引数destinationの位置まで移動させる</span>
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span>interpolate_property(self, <span style="color:#e6db74">&#34;position&#34;</span>, position, destination, <span style="color:#f92672">.</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">Tween</span><span style="color:#f92672">.</span>TRANS_QUINT, <span style="color:#a6e22e">Tween</span><span style="color:#f92672">.</span>EASE_IN)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Tweenノードのアニメーションを開始する</span>
</span></span><span style="display:flex;"><span>	tween<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースがマッチした時に呼ばれるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> make_matched(index):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># マッチのフラグを立てる</span>
</span></span><span style="display:flex;"><span>	matched <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># マッチしたグループごとのインデックス（引数index）を割り当てる</span>
</span></span><span style="display:flex;"><span>	matched_index <span style="color:#f92672">=</span> index
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピースの色を半透明にする</span>
</span></span><span style="display:flex;"><span>	modulate <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#f92672">.</span><span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># プレイヤーの指がピースに触れたら呼ばれるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> enable_held():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># プレイヤーが動かしているフラグを立てる</span>
</span></span><span style="display:flex;"><span>	held <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピースの色を20％透明にする</span>
</span></span><span style="display:flex;"><span>	modulate <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0.8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># プレイヤーが指をピースから離したら呼ばれるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> disable_held():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># プレイヤーが動かしているフラグを解除する</span>
</span></span><span style="display:flex;"><span>	held <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピースの色をデフォルトに戻す</span>
</span></span><span style="display:flex;"><span>	modulate <span style="color:#f92672">=</span> <span style="color:#a6e22e">Color</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
</span></span></code></pre></div><br>
<p>続けて、ピースに別のピースが当たった時に発信されるシグナルを利用する。シーンドックで「Piece」ルートノードを選択したらノードドック＞シグナルタブで<code>area_entered(area: Area2D)</code>を、現在編集中の「Piece.gd」スクリプトに接続しよう。</p>
<p>プレイヤーが動かしているピースが当たったらシグナル<code>collided(self_piece)</code>を発信させたいので、自動生成されたメソッド<code>_on_Piece_area_entered(area)</code>内にそのためのコードを記述しよう。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Piece.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Area2Dが当たったらシグナルが発信されて呼ばれるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _on_Piece_area_entered(area):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># もし当たったArea2Dが「Pieces」グループ（つまりPieceのインスタンス）で...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># かつ、プレイヤーが動かしているピースだったら</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> area<span style="color:#f92672">.</span>is_in_group(<span style="color:#e6db74">&#34;Pieces&#34;</span>) <span style="color:#f92672">and</span> area<span style="color:#f92672">.</span>held:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 引数に自分自身のピースを渡してシグナル collided を発信する</span>
</span></span><span style="display:flex;"><span>		emit_signal(<span style="color:#e6db74">&#34;collided&#34;</span>, self)
</span></span></code></pre></div><br>
<p>これで「Piece.gd」スクリプトの編集は完了だ。</p>
<br>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
style="display:block; text-align:center;"
data-ad-layout="in-article"
data-ad-format="fluid"
data-ad-client="ca-pub-4952908839423901"
data-ad-slot="9419515863"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<hr>
<h2 id="piece-シーンを継承した各色のシーンを作る">Piece シーンを継承した各色のシーンを作る<a hidden class="anchor" aria-hidden="true" href="#piece-シーンを継承した各色のシーンを作る">#</a></h2>
<p>雛形となる「Piece」シーンは完成したので、それを継承したシーンをピースの色の数だけ作成していこう。ピースの色は、ベージュ、青、緑、ピンク、黄の 5 色だ。まずは「ベージュ」のドロップを例に手順を進めてみよう。</p>
<ol>
<li>「シーン」メニュー＞「新しい継承シーン」を選択する。</li>
<li>継承元のシーンとして「Piece.tscn」を選択する。</li>
<li>継承シーンが生成されたら、ルートノードの名前を「PieceBeige」に変更する。<br>
*このルートノードの名前はそれぞれのドロップの色に合わせること。</li>
<li>シーンを一旦保存しておく。ファイルパスを「res://Pieces/PieceBeige.tscn」として保存する。</li>
<li>シーンドックでルートノード「PieceBeige」を選択した状態で、インスペクターで「Script Variables」の「Color」プロパティの値を「beige」とする。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img14.png" alt="BlueDrop - Color property"  />
</li>
<li>シーンドックで「Sprite」ノードを選択し、「Texture」プロパティに先にインポートしておいたリソース「res://Aliens/alienBeige_round.png」を適用する（ファイルシステムドックからドラッグすればOK）。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img15.png" alt="Sprite - Texture Region"  />
<br>
2D ワークスペース上では以下のスクリーンショットのようになったはずだ。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img16.png" alt="Sprite - Texture Region"  />
<br>
以上で、「PieceBeige」シーンは完成だ。残りの 4 色のピースについても、同様の手順でシーンを作成してほしい。なお、シーンごとに異なる部分については、以下を参考にしてほしい。</li>
</ol>
<ul>
<li><strong>青のピース</strong>
<ul>
<li>ルートノード名: PieceBlue</li>
<li>Color プロパティ: blue</li>
<li>Sprite &gt; Texture プロパティ: res://Aliens/alienBlue_round.png</li>
<li>シーン保存時のファイルパス: res://Pieces/PieceBlue.tscn</li>
</ul>
</li>
<li><strong>緑のピース</strong>
<ul>
<li>ルートノード名: PieceGreen</li>
<li>Color プロパティ: green</li>
<li>Sprite &gt; Texture プロパティ: res://Aliens/alienGreen_round.png</li>
<li>シーン保存時のファイルパス: res://Pieces/PieceGreen.tscn</li>
</ul>
</li>
<li><strong>ピンクのピース</strong>
<ul>
<li>ルートノード名: PiecePink</li>
<li>Color プロパティ: green</li>
<li>Sprite &gt; Texture プロパティ: res://Aliens/alienPink_round.png</li>
<li>シーン保存時のファイルパス: res://Pieces/PiecePink.tscn</li>
</ul>
</li>
<li><strong>黄のピース</strong>
<ul>
<li>ルートノード名: PieceYellow</li>
<li>Color プロパティ: yellow</li>
<li>Sprite &gt; Texture プロパティ: res://Aliens/alienYellow_round.png</li>
<li>シーン保存時のファイルパス: res://Pieces/PieceYellow.tscn</li>
</ul>
</li>
</ul>
<p>全部で 5 色のピースの継承シーンができたら作業完了だ。</p>
<br>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
style="display:block; text-align:center;"
data-ad-layout="in-article"
data-ad-format="fluid"
data-ad-client="ca-pub-4952908839423901"
data-ad-slot="9419515863"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<hr>
<h2 id="grid-シーンをスクリプトで制御する">Grid シーンをスクリプトで制御する<a hidden class="anchor" aria-hidden="true" href="#grid-シーンをスクリプトで制御する">#</a></h2>
<p>ここからはスクリプトをコーディングしてゲームを制御していく。コード量がやや多めなので頑張ろう。</p>
<p>Godot エディタで「Grid.tscn」シーンに切り替えたら、「Grid」ルートノードに新規スクリプトをアタッチしよう。ファイルパスは「res://Grid/Grid.gd」として作成する。</p>
<p>なお、スクリプト内のコメントには「指が触れた」または「指が離れた」と記載しているが、Godot デバッグパネル上では「マウス左ボタンを押した」または「マウス左ボタンを離した」と置き換えてほしい。</p>
<p>また、同じ色が３つ以上揃った状態のことを「マッチ」と表現しているので、こちらもご留意いただきたい。</p>
<p>では、スクリプトエディタが開いたら、まずは必要なプロパティを定義しておこう。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Area2D</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースを動かして指を離した後の自動処理開始時に発信するシグナル</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">signal</span> waiting_started
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 各色のピースのシーンファイルを要素とした配列</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> pieces_scn <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>	preload(<span style="color:#e6db74">&#34;res://Pieces/PieceBeige.tscn&#34;</span>),
</span></span><span style="display:flex;"><span>	preload(<span style="color:#e6db74">&#34;res://Pieces/PieceBlue.tscn&#34;</span>),
</span></span><span style="display:flex;"><span>	preload(<span style="color:#e6db74">&#34;res://Pieces/PieceGreen.tscn&#34;</span>),
</span></span><span style="display:flex;"><span>	preload(<span style="color:#e6db74">&#34;res://Pieces/PiecePink.tscn&#34;</span>),
</span></span><span style="display:flex;"><span>	preload(<span style="color:#e6db74">&#34;res://Pieces/PieceYellow.tscn&#34;</span>)
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># x軸方向のグリッド数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> width: <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># y軸方向のグリッド数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> height: <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># x軸方向のグリッド開始位置（pixel）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x_start: <span style="color:#f92672">=</span> <span style="color:#ae81ff">70</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># y軸方向のグリッド開始位置（pixel）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> y_start: <span style="color:#f92672">=</span> <span style="color:#ae81ff">1050</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1グリッドのサイズ（PieceのSpriteのTextureと同じにする）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> grid_size: <span style="color:#f92672">=</span> <span style="color:#ae81ff">70</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースが生成される時に何グリッドy軸方向にズラして落とすか</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> y_offset: <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 盤面のピースの配置を表す配列（二次元配列）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> board <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#75715e"># プレイヤーが動かしているピースの参照</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> moving_piece
</span></span><span style="display:flex;"><span><span style="color:#75715e"># プレイヤーが動かしているピースの最後の位置（グリッド）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> last_pos <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ゲーム開始時の準備中のフラグ</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> is_initializing <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span><span style="color:#75715e"># プレイヤーがピースを動かしている場合のフラグ</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> is_touching <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピース入れ替え中のフラグ</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> is_swapping <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span><span style="color:#75715e"># プレイヤーがピースを動かした後の自動処理中のフラグ</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> is_waiting <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># マッチしたピースのグループの数（カウントアップする）</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> matched_groups <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># PiecesContainerノードの参照</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> pieces_container <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>PiecesContainer
</span></span><span style="display:flex;"><span><span style="color:#75715e"># TouchTimerノードの参照</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> touch_timer <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>TouchTimer
</span></span><span style="display:flex;"><span><span style="color:#75715e"># WaitTimerノードの参照</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> wait_timer <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>WaitTimer
</span></span></code></pre></div><br>
<p>続いてここからはメソッドを追加していく。なお、以下のコード内に出てくる <strong>二次元配列</strong> とは、要素として配列を格納する配列、つまり配列の配列のことだ。</p>
<p>今回のスクリプトで利用している二次元配列の場合、一階層目の配列では、盤面の x 軸方向のグリッドの数だけ空の配列を要素とし、二階層目としてそれぞれの配列内に縦方向のグリッド数だけ要素を格納する。その要素として、ピースオブジェクトを格納することで、それぞれのピースが盤面のどこに位置しているか（x 軸方向に何番目のグリッドで、y 軸方向に何番目のグリッドか）を管理することができるのだ。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># シーンが読み込まれたら呼ばれる関数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _ready():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ランダムな数を生成する関数の出力結果を毎回ランダムにするための組み込み関数を呼ぶ</span>
</span></span><span style="display:flex;"><span>	randomize()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># board（配列）を盤面のグリッドを構成する二次元配列にする</span>
</span></span><span style="display:flex;"><span>	board <span style="color:#f92672">=</span> make_2d_array() <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピースを生成して盤面に配置して盤面情報を board に反映する</span>
</span></span><span style="display:flex;"><span>	spawn_pieces() <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>	is_initializing <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 盤面のグリッドを構成する二次元配列を生成するメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> make_2d_array() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># array という名前の配列を用意</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> array <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># array に x 軸方向のグリッド数だけ空の配列を入れる</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> width:
</span></span><span style="display:flex;"><span>		array<span style="color:#f92672">.</span>append([])
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># さらにそれぞれの配列に y 軸方向のグリッド数だけ暫定的に null を入れる</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> height:
</span></span><span style="display:flex;"><span>			array[i]<span style="color:#f92672">.</span>append(null)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># できあがった二次元配列を返す</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> array
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースを生成して盤面に配置して盤面情報を board に反映するメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> spawn_pieces():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># x軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> width:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># y軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> height:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 全ピースの二次元配列上で該当グリッドにピースが存在しない場合</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#（ゲーム開始時は全部 null）</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">==</span> null:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># 各色のピースのシーンからランダムで１つ選択してインスタンス化</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">var</span> index <span style="color:#f92672">=</span> floor(rand_range(<span style="color:#ae81ff">0</span>, pieces_scn<span style="color:#f92672">.</span>size()))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">var</span> piece <span style="color:#f92672">=</span> pieces_scn[index]<span style="color:#f92672">.</span>instance()
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># もしゲーム開始時の準備中だったら</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> is_initializing:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># マッチしてしまった場合は、ピースのインスタンスを削除してやり直し</span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">while</span> match_at(i, j, piece<span style="color:#f92672">.</span>color): <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>						piece<span style="color:#f92672">.</span>queue_free()
</span></span><span style="display:flex;"><span>						index <span style="color:#f92672">=</span> floor(rand_range(<span style="color:#ae81ff">0</span>, pieces_scn<span style="color:#f92672">.</span>size()))
</span></span><span style="display:flex;"><span>						piece <span style="color:#f92672">=</span> pieces_scn[index]<span style="color:#f92672">.</span>instance()
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># ピースのインスタンスをPiecesContainerノードの子にする</span>
</span></span><span style="display:flex;"><span>				pieces_container<span style="color:#f92672">.</span>add_child(piece)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># ピースのインスタンスの collided シグナルを...</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># _on_Piece_collided メソッド（あとで定義）に接続する</span>
</span></span><span style="display:flex;"><span>				piece<span style="color:#f92672">.</span>connect(<span style="color:#e6db74">&#34;collided&#34;</span>, self, <span style="color:#e6db74">&#34;_on_Piece_collided&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># ピースのインスタンスを配置位置より y_offset 分ずらして置き...</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># そこから配置位置へ移動させる（落とす）</span>
</span></span><span style="display:flex;"><span>				piece<span style="color:#f92672">.</span>position <span style="color:#f92672">=</span> grid_to_pixel(i, j <span style="color:#f92672">+</span> y_offset) <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>				piece<span style="color:#f92672">.</span>move(grid_to_pixel(i, j)) <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># 盤面情報として board の適切なインデックスの要素に生成したピースを追加</span>
</span></span><span style="display:flex;"><span>				board[i][j] <span style="color:#f92672">=</span> piece
</span></span></code></pre></div><br>
<p>上記コードの中で未定義の<code>match_at</code>メソッドと<code>grid_to_pixel</code>メソッドを定義しておこう。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 指定したグリッド位置で同じ色ピースが３つ以上並んでいるか確認するメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 引数columnはx軸のグリッド位置、rowはy軸のグリッド位置、colorはピースの色</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> match_at(column, row, color):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 指定したグリッドの x 軸方向の位置が3以上の場合</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> column <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 指定したグリッド位置の左隣ともう一つ左隣にピースがある場合</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> board[column<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][row] <span style="color:#f92672">!=</span> null \
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">and</span> board[column<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>][row] <span style="color:#f92672">!=</span> null:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 左隣ともう一つ左隣のピースの色が指定したピースの色と同じ場合</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> board[column<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][row]<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> color \
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">and</span> board[column<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>][row]<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> color:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># true を返す</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> true
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 指定したグリッドの y 軸方向の位置が3以上の場合</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> row <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 指定したグリッド位置の下ともう一つ下にピースがある場合</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> board[column][row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> null \
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">and</span> board[column][row<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">!=</span> null:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 下ともう一つ下のピースの色が指定したピースの色と同じ場合</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> board[column][row<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> color \
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">and</span> board[column][row<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> color:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># true を返す</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">return</span> true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># グリッドの位置をピクセルの位置に変換するメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> grid_to_pixel(column, row) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Vector2</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 先にピクセル位置出力用に Vector2 型の変数 pixel_pos を定義</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> pixel_pos <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピクセル x 座標 = x 軸方向のグリッド開始位置 + グリッドサイズ x グリッド x 座標</span>
</span></span><span style="display:flex;"><span>	pixel_pos<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> x_start <span style="color:#f92672">+</span> grid_size <span style="color:#f92672">*</span> column
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピクセル y 座標 = y 軸方向のグリッド開始位置 - グリッドサイズ x グリッド y 座標</span>
</span></span><span style="display:flex;"><span>	pixel_pos<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> y_start <span style="color:#f92672">-</span> grid_size <span style="color:#f92672">*</span> row
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピクセル座標を返す</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> pixel_pos
</span></span></code></pre></div><p>これで、ゲーム開始時に各色のピースが盤面にランダムで並べられるはずだ。一度プロジェクトを実行して確認してみよう。なお、初めてプロジェクトを実行する場合は、メインシーン選択のダイアログが表示されるので、「Grid.tscn」をメインシーンとして選択しよう。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img17.png" alt="run project - distribute pieces on the grid board"  />
</p>
<br>
<p>ちょうど<code>grid_to_pixel</code>メソッドを定義したので、ついでにこのあと使用する<code>pixel_to_grid</code>メソッドも定義しておこう。名前の通り、先に定義した<code>grid_to_pixel</code>とは逆で、ピクセルの位置をグリッドの位置に変換するメソッドだ。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピクセルの位置をグリッドの位置に変換するメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> pixel_to_grid(pixel_x, pixel_y) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Vector2</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> grid_pos <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>()
</span></span><span style="display:flex;"><span>	grid_pos<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> floor((pixel_x <span style="color:#f92672">-</span> x_start) <span style="color:#f92672">/</span> grid_size)
</span></span><span style="display:flex;"><span>	grid_pos<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> floor((pixel_y <span style="color:#f92672">-</span> y_start) <span style="color:#f92672">/</span> <span style="color:#f92672">-</span>grid_size)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> grid_pos
</span></span></code></pre></div><br>
<p>さらに、もう一つこのあと使用する<code>is_in_grid</code>メソッドを定義しておく。これは引数に渡した位置が盤面グリッドの範囲内かどうかを判定してその結果を返すメソッドだ。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 指定した位置が盤面グリッドの範囲内かどうかを返すメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> is_in_grid(grid_position: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> grid_position<span style="color:#f92672">.</span>x <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> grid_position<span style="color:#f92672">.</span>x <span style="color:#f92672">&lt;</span> width \
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">and</span> grid_position<span style="color:#f92672">.</span>y <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> grid_position<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> height:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 盤面グリッドの範囲内だったら true を返す</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> true
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 盤面グリッドの範囲外だったら false を返す</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> false
</span></span></code></pre></div><br>
<p>ここで、ゲームのプレイヤーの入力（画面のタッチ操作）を処理するプログラムを記述していく。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ゲームのメインループで毎フレーム呼ばれる関数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _process(_delta):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># もしマッチングの処理中でなければ</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_waiting:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># プレイヤーの入力を処理する</span>
</span></span><span style="display:flex;"><span>		touch_input() <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># プレイヤーの入力を処理するメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> touch_input():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># もし画面に指が触れたら</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_pressed(<span style="color:#e6db74">&#34;touch&#34;</span>):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピースに触れた時の処理を実行するメソッドを呼ぶ</span>
</span></span><span style="display:flex;"><span>		touch_piece() <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># もし画面から指が離れたら</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Input</span><span style="color:#f92672">.</span>is_action_just_released(<span style="color:#e6db74">&#34;touch&#34;</span>) <span style="color:#f92672">and</span> is_touching:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピースから指が離れた時の処理を実行するメソッドを呼ぶ</span>
</span></span><span style="display:flex;"><span>		release_piece() <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースに触れた時の処理を実行するメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> touch_piece():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 指が触れた時のピクセル座標を取得する</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> pos <span style="color:#f92672">=</span> get_global_mouse_position()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピクセル座標からグリッド座標に変換する</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> grid_pos <span style="color:#f92672">=</span> pixel_to_grid(pos<span style="color:#f92672">.</span>x, pos<span style="color:#f92672">.</span>y)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># もしグリッド座標が盤面の範囲内だったら</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> is_in_grid(grid_pos):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 動かしているピースの最後の位置としてグリッド座標を登録</span>
</span></span><span style="display:flex;"><span>		last_pos <span style="color:#f92672">=</span> grid_pos
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 動かしているピースとしてグリッド座標に位置するピースを登録</span>
</span></span><span style="display:flex;"><span>		moving_piece <span style="color:#f92672">=</span> board[last_pos<span style="color:#f92672">.</span>x][last_pos<span style="color:#f92672">.</span>y]
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピースを動かしているフラグを立てる</span>
</span></span><span style="display:flex;"><span>		is_touching <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 動かしているピースインスタンス自体の動かしているフラグも立てる</span>
</span></span><span style="display:flex;"><span>		moving_piece<span style="color:#f92672">.</span>enable_held()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピースを動かせる制限時間のタイマースタート</span>
</span></span><span style="display:flex;"><span>		touch_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースから指が離れた時の処理を実行するメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> release_piece():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 二次元配列 board の要素から動かしていたピースを見つけたら...</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 動かしていたピースを盤面グリッドにきっちり収める</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> width:
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> height:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">==</span> moving_piece:
</span></span><span style="display:flex;"><span>				moving_piece<span style="color:#f92672">.</span>move(grid_to_pixel(i, j))
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 動かしていたピースインスタンス自体の動かしているフラグを解除する</span>
</span></span><span style="display:flex;"><span>	moving_piece<span style="color:#f92672">.</span>disable_held()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピースを動かしているフラグを解除する</span>
</span></span><span style="display:flex;"><span>	is_touching <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピースを動かせる制限時間のタイマーストップ</span>
</span></span><span style="display:flex;"><span>	touch_timer<span style="color:#f92672">.</span>stop()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># このあとのマッチング自動処理開始のシグナルを発信</span>
</span></span><span style="display:flex;"><span>	emit_signal(<span style="color:#e6db74">&#34;waiting_started&#34;</span>)
</span></span></code></pre></div><br>
<p>まだピースの交換は実装していないが、ここまでのコーディングで、指で触ったピースを移動させ、指を離したら移動しているピースが最後にいた場所にきっちり収まる動きが実装できたはずだ。一度プロジェクトを実行して確認してみよう。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img18.gif" alt="run project - touch and release a piece"  />
</p>
<br>
<p>次に定義する<code>_on_Piece_collided</code>メソッドには、すでに Piece インスタンス生成時に<code>collided</code>シグナルを接続するようコーディング済みだ。このシグナルはピースにプレイヤーが動かしているピースが当たった時に発信されるように「Piece.gd」スクリプトの方でコーディングしたことを思い出してほしい。</p>
<p>動かしているピースとそれに当たったピースの場所を入れ替えるメソッドを定義して、<code>_on_Piece_collided</code>の中で呼び出してみよう。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Piece インスタンスの collided シグナルで呼ばれるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _on_Piece_collided(self_piece):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># ピースを動かしていて、かつピース交換中でなければ</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> is_touching <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> is_swapping:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピース交換中のフラグを立てる</span>
</span></span><span style="display:flex;"><span>		is_swapping <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピースを交換するメソッドを呼ぶ</span>
</span></span><span style="display:flex;"><span>		swap_pieces(self_piece) <span style="color:#75715e"># あとで定義</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピース交換中のフラグを解除</span>
</span></span><span style="display:flex;"><span>		is_swapping <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 動かしているピースとそれに当たったピースの場所を入れ替えるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 引数 collided_piece には動かしているピースに当たったピースが渡される</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> swap_pieces(collided_piece):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 当たったピースのグリッド座標を取得する。</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> collided_pos <span style="color:#f92672">=</span> pixel_to_grid(collided_piece<span style="color:#f92672">.</span>position<span style="color:#f92672">.</span>x, collided_piece<span style="color:#f92672">.</span>position<span style="color:#f92672">.</span>y)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 二次元配列 board 上の動かしているピースと動かしているピースが一致していれば</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> board[last_pos<span style="color:#f92672">.</span>x][last_pos<span style="color:#f92672">.</span>y] <span style="color:#f92672">==</span> moving_piece:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># board の動かしているピースの位置に当たったピースを入れる</span>
</span></span><span style="display:flex;"><span>		board[last_pos<span style="color:#f92672">.</span>x][last_pos<span style="color:#f92672">.</span>y] <span style="color:#f92672">=</span> collided_piece
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 当たったピースを動かしているピースの最後のグリッド座標へ移動させる</span>
</span></span><span style="display:flex;"><span>		collided_piece<span style="color:#f92672">.</span>move(grid_to_pixel(last_pos<span style="color:#f92672">.</span>x, last_pos<span style="color:#f92672">.</span>y))
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># board の当たったピースの位置に動かしているピースを入れる</span>
</span></span><span style="display:flex;"><span>		board[collided_pos<span style="color:#f92672">.</span>x][collided_pos<span style="color:#f92672">.</span>y] <span style="color:#f92672">=</span> moving_piece
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 動かしているピースの最後の位置として当たったピースのグリッド座標を登録する</span>
</span></span><span style="display:flex;"><span>		last_pos <span style="color:#f92672">=</span> collided_pos
</span></span></code></pre></div><br>
<p>これでピースの交換も実装できたはずだ。では実際にプロジェクトを実行してピースを動かしてみよう。通ったルートのピースが次々と交換される動作を確認しよう。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img19.gif" alt="run project - swapping piece"  />
</p>
<p>さて、この時点で問題になるのは以下の2点だ。</p>
<ul>
<li>盤面の外側を自由に移動できてしまうこと</li>
<li>いつまでもピースをつかんでいられること</li>
</ul>
<p>これらの問題はシグナルを使って解決することができる。</p>
<p>Area2D クラスである「Grid」ルートノードのシグナルをスクリプトに接続しよう。コリジョン形状を盤面のサイズに調整したことを覚えているだろうか。その範囲から指（動かしているピース）が外にはみ出た場合に発信するシグナルによって<code>release_piece</code>メソッドを呼び出して、動かしていたピースが指からも離れて盤面上の最後の位置に戻るようにする。</p>
<p>シーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブを選択し、<code>erea_exited</code>シグナルをこのスクリプトに接続する。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img20.png" alt="Grid - Connect signal - area_exited"  />
</p>
<p>もう一つ、「TouchTimer」ノードのピースを動かせる制限時間がタイムアウトした時に発信されるシグナルもスクリプトに接続する。この場合も同様に、シグナルによってに<code>release_piece</code>メソッドを呼び出すようにする。<code>timeout</code>シグナルを接続しよう。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img21.png" alt="TouchTimer - Connect signal - timeout"  />
</p>
<p>続けて、それぞれのシグナルの接続によって生成されたメソッドを以下のように編集してほしい。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 盤面から Area2D がはみ出たときにシグナルで呼ばれるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _on_Grid_area_exited(area):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># はみ出た Area2D が動かしているピースの場合</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> area<span style="color:#f92672">.</span>is_in_group(<span style="color:#e6db74">&#34;Pieces&#34;</span>) <span style="color:#f92672">and</span> area<span style="color:#f92672">.</span>held:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピースから指が離れた時の処理を実行するメソッドを呼ぶ</span>
</span></span><span style="display:flex;"><span>		release_piece()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ピースを動かせる制限時間が切れたときにシグナルで呼ばれるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _on_TouchTimer_timeout():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 移動中の場合</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> is_touching:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ピースから指が離れた時の処理を実行するメソッドを呼ぶ</span>
</span></span><span style="display:flex;"><span>		release_piece()
</span></span></code></pre></div><br>
<p>これで盤面からはみ出したら、ピースが指から離れて盤面上の最後の位置に戻るようになったはずだ。また、5秒以上ピースをつかんでいた場合も、タイマーにより、指からピースが離れて盤面上の最後のグリッド座標に収まるようになったはずだ。</p>
<p>それでは実際にプロジェクトを実行して動作を確認してみよう。<br>
<img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img22.gif" alt="run project - signal effects"  />
</p>
<br>
<p>ここからはマッチしたピースを自動的に処理するプログラムを作っていく。<code>release_piece</code>メソッドの最後に<code>emit_signal(&quot;waiting_started&quot;)</code>というコードで<code>waiting_started</code>シグナルを発信するようにしていたのだが、このシグナルをスクリプトに接続するところから始める。</p>
<p>シーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブで<code>waiting_started</code>シグナルをスクリプトに接続しよう。<code>_on_Grid_waiting_started</code>メソッドがスクリプトに追加されたら、そのメソッド内にマッチしたピースの自動処理を記述していく。大まかに自動処理は以下の流れになる。</p>
<ol>
<li>自動処理中のフラグを立てる</li>
<li>マッチしたピースが1組でもあるかチェックする。1組でもある場合は以下の処理をループする。
<ol>
<li>全てのピースをチェックしてマッチしたピースにフラグを立てる。</li>
<li>フラグの立っているピースを削除する。</li>
<li>削除して空になったスペースへ同じ列の上のグリッドからピースを移動させて詰める。</li>
<li>ピースを下へ詰めたら、最後に空のスペースに新しいピースを生成する。</li>
</ol>
</li>
<li>マッチしたピースが1組もなくなったら自動処理中のフラグを解除する。<br>
<br></li>
</ol>
<p>上記の流れを段階的に実装していこう。まずは「全てのピースをチェックしてマッチしたピースにフラグを立てる」ところまで進めてみよう。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># releaseメソッドの最後に発信されるシグナルで呼ばれるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _on_Grid_waiting_started():
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 自動処理中のフラグを立てる</span>
</span></span><span style="display:flex;"><span>	is_waiting <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 人組でマッチしているピースが1組でもあればループし続ける</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> check_matches(): <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># マッチしているピースにフラグを立てるメソッドを呼ぶ</span>
</span></span><span style="display:flex;"><span>		find_matches() <span style="color:#75715e"># このあと定義</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># WaitTimerのタイマースタート(0.3秒)</span>
</span></span><span style="display:flex;"><span>		wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># WaitTimerがタイムアウトするまで待機</span>
</span></span><span style="display:flex;"><span>		yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 自動処理中のフラグを解除する</span>
</span></span><span style="display:flex;"><span>	is_waiting <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># マッチしているピースが1組でもあるかチェックするメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> check_matches() <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 盤面の x 軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> width:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 盤面の y 軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> height:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># そのグリッド座標にピースが存在していれば</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">!=</span> null:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># そのピースがマッチしていたら</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> match_at(i, j, board[i][j]<span style="color:#f92672">.</span>color):
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># true を返す</span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> true
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 1組もマッチしているピースがなければ false を返す</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># マッチしているピースにフラグを立てるメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> find_matches():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 盤面の x 軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> width:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 盤面の y 軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> height:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># そのグリッド座標にピースが存在していれば</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">!=</span> null:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># 現在の色をそのグリッド座標のピースの色と定義する</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">var</span> current_color <span style="color:#f92672">=</span> board[i][j]<span style="color:#f92672">.</span>color
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># もしその x 軸座標が x 軸方向のグリッド数 - 2 より小さければ</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> width <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># そのピースの右隣とさらにその右隣にピースが存在する場合</span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> board[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">!=</span> null \
</span></span><span style="display:flex;"><span>					<span style="color:#f92672">and</span> board[i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>][j] <span style="color:#f92672">!=</span> null:
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># それらのピースの色が現在の色と同じ場合</span>
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">if</span> board[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> current_color \
</span></span><span style="display:flex;"><span>						<span style="color:#f92672">and</span> board[i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>][j]<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> current_color:
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e"># マッチした組に割り振る番号の変数を定義</span>
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">var</span> matched_index: <span style="color:#a6e22e">int</span>
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e"># そのピースにすでにマッチしているフラグが立っていれば</span>
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">if</span> board[i][j]<span style="color:#f92672">.</span>matched:
</span></span><span style="display:flex;"><span>                                <span style="color:#75715e"># マッチした組の番号はそのピースの組の番号とする</span>
</span></span><span style="display:flex;"><span>								matched_index <span style="color:#f92672">=</span> board[i][j]<span style="color:#f92672">.</span>matched_index
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e"># そのピースにマッチしているフラグが立ってなければ</span>
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                                <span style="color:#75715e"># マッチした組のグループ数を1増やす</span>
</span></span><span style="display:flex;"><span>								matched_groups <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                                <span style="color:#75715e"># マッチした組の番号をマッチした組のグループ数とする</span>
</span></span><span style="display:flex;"><span>								matched_index <span style="color:#f92672">=</span> matched_groups
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e"># その座標のピースにマッチしたフラグを立て、組の番号を割り当て、半透明にする</span>
</span></span><span style="display:flex;"><span>							board[i][j]<span style="color:#f92672">.</span>make_matched(matched_index)
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e"># その座標の右隣のピースも同様にする</span>
</span></span><span style="display:flex;"><span>							board[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">.</span>make_matched(matched_index)
</span></span><span style="display:flex;"><span>                            <span style="color:#75715e"># さらにもう一つ右隣のピースも同様にする</span>
</span></span><span style="display:flex;"><span>							board[i<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>][j]<span style="color:#f92672">.</span>make_matched(matched_index)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># y軸方向に対しても同様にする</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> j <span style="color:#f92672">&lt;</span> height <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> board[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> null \
</span></span><span style="display:flex;"><span>					<span style="color:#f92672">and</span> board[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>] <span style="color:#f92672">!=</span> null:
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">if</span> board[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> current_color \
</span></span><span style="display:flex;"><span>						<span style="color:#f92672">and</span> board[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> current_color:
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">var</span> matched_index: <span style="color:#a6e22e">int</span>
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">if</span> board[i][j]<span style="color:#f92672">.</span>matched:
</span></span><span style="display:flex;"><span>								matched_index <span style="color:#f92672">=</span> board[i][j]<span style="color:#f92672">.</span>matched_index
</span></span><span style="display:flex;"><span>							<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>								matched_groups <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>								matched_index <span style="color:#f92672">=</span> matched_groups
</span></span><span style="display:flex;"><span>							board[i][j]<span style="color:#f92672">.</span>make_matched(matched_index)
</span></span><span style="display:flex;"><span>							board[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>make_matched(matched_index)
</span></span><span style="display:flex;"><span>							board[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>make_matched(matched_index)
</span></span></code></pre></div><br>
マッチしたピースの処理のうち、マッチしているピースにフラグを立てるところまで実装した。プロジェクトを実行して、マッチしたピースが半透明になるか確認してみよう。
<p><img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img24.gif" alt="run project - add flag on matched pieces"  />
</p>
<br>
<p>次はマッチ状態のフラグが立っているピースを削除するメソッドを定義する。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># マッチのフラグが立っているピースを削除するメソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 引数 index には削除対象のマッチの組番号を渡す</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> delete_matches(index):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 盤面の x 軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> width:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 盤面の y 軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> height:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># もしそのグリッド座標にピースが存在していれば</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">!=</span> null:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># もしそのグリッド座標のピースにマッチのフラグが立っていたら</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> board[i][j]<span style="color:#f92672">.</span>matched:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># もしそのグリッド座標のピースの組番号は削除対象の組番号と一致したら</span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> board[i][j]<span style="color:#f92672">.</span>matched_index <span style="color:#f92672">==</span> index:
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># そのグリッド座標のピースを解放する</span>
</span></span><span style="display:flex;"><span>						board[i][j]<span style="color:#f92672">.</span>queue_free()
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># 二次元配列 board の該当の要素を null にする</span>
</span></span><span style="display:flex;"><span>						board[i][j] <span style="color:#f92672">=</span> null
</span></span></code></pre></div><br>
<p><code>delete_matches</code>メソッドが定義できたので、これを<code>_on_Grid_waiting_started</code>メソッドのループの中に入れよう。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _on_Grid_waiting_started():
</span></span><span style="display:flex;"><span>	is_waiting <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> check_matches():
</span></span><span style="display:flex;"><span>		find_matches()
</span></span><span style="display:flex;"><span>		wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>		yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ここを追加</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># マッチしたグループの数が0より大きければ</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> matched_groups <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># マッチしたグループの数だけループさせる</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 全て同時に削除せず、マッチした組ごとに削除する</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> index <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, matched_groups <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># マッチしたピースを削除するメソッドを呼ぶ</span>
</span></span><span style="display:flex;"><span>				delete_matches(index)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># WaitTimerのタイマースタート(0.3秒)</span>
</span></span><span style="display:flex;"><span>				wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># WaitTimerがタイムアウトするまで待機</span>
</span></span><span style="display:flex;"><span>				yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># マッチしたピースをすべて削除したらマッチしたグループの数を 0 に戻す</span>
</span></span><span style="display:flex;"><span>			matched_groups <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	is_waiting <span style="color:#f92672">=</span> false
</span></span></code></pre></div><br>
これで、マッチしたピースが半透明になったあと、削除されるところまで実装できたはずだ。プロジェクトを実行して確認してみよう。
<p><img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img25.gif" alt="run project - delete matched pieces"  />
</p>
<br>
<p>続いて、ピースが削除されて空いたグリッドスペースに上のピースを詰める（落とす）処理を実装する。まずはメソッドから定義しよう。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 空いたグリッドスペースに上のピースを詰める（落とす）メソッド</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> collapse_columns():
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 盤面の x 軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> width:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 盤面の y 軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> height:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># もしそのグリッド座標にピースがなければ</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">==</span> null:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># その y座標より1つ上のグリッドから残りの y軸方向のグリッド数だけループ</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, height):
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># もしそのグリッド座標にピースが存在していれば</span>
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> board[i][k] <span style="color:#f92672">!=</span> null:
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># そのグリッド座標のピースを空いたスペースへ移動する</span>
</span></span><span style="display:flex;"><span>						board[i][k]<span style="color:#f92672">.</span>move(grid_to_pixel(i, j))
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># 二次元配列 board の要素を入れ替える</span>
</span></span><span style="display:flex;"><span>						board[i][j] <span style="color:#f92672">=</span> board[i][k]
</span></span><span style="display:flex;"><span>						board[i][k] <span style="color:#f92672">=</span> null
</span></span><span style="display:flex;"><span>                        <span style="color:#75715e"># ループ終了</span>
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">break</span>
</span></span></code></pre></div><br>
<p><code>collapse_columns</code>メソッドが定義できたので、これを<code>_on_Grid_waiting_started</code>メソッドのループの中に追加しよう。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _on_Grid_waiting_started():
</span></span><span style="display:flex;"><span>	is_waiting <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> check_matches():
</span></span><span style="display:flex;"><span>		find_matches()
</span></span><span style="display:flex;"><span>		wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>		yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> matched_groups <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> index <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, matched_groups <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>				delete_matches(index)
</span></span><span style="display:flex;"><span>				wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>				yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>			matched_groups <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ここを追加</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 空いたグリッドスペースに上のピースを詰める（落とす）メソッドを呼ぶ</span>
</span></span><span style="display:flex;"><span>		collapse_columns()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># WaitTimerのタイマースタート(0.3秒)</span>
</span></span><span style="display:flex;"><span>		wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># WaitTimerがタイムアウトするまで待機</span>
</span></span><span style="display:flex;"><span>		yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	is_waiting <span style="color:#f92672">=</span> false
</span></span></code></pre></div><br>
<p>これで、マッチして半透明になったピースが削除されたあと、その空いたスペースには上のピースが詰められる（落とされる）ようになったはずだ。プロジェクトを実行して確認してみよう。</p>
<p><img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img26.gif" alt="run project - delete matched pieces"  />
</p>
<br>
<p>最後に、ピースを下に詰めた後の上の空いたスペースには新しいピースを補充する必要がある。そのためのメソッドは、<code>_ready</code>関数の中でも実行している、すでに定義済みの<code>spawn_pieces</code>メソッドだ。ゲームのプレイが開始した時点では<code>is_initializing</code>プロパティは<code>false</code>になっているので、このメソッドを実行してピースが生成された時点ですでに新たなマッチが発生するかもしれない。これが期待以上のコンボを発生させ、ゲーム体験をより気持ち良く、楽しいものにしてくれるはずだ。</p>
<p><code>spawn_pieces</code>メソッドを<code>_on_Grid_waiting_started</code>メソッドのループの中に追加しよう。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GDScript" data-lang="GDScript"><span style="display:flex;"><span><span style="color:#75715e">###Grid.gd###</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> _on_Grid_waiting_started():
</span></span><span style="display:flex;"><span>	is_waiting <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">while</span> check_matches():
</span></span><span style="display:flex;"><span>		find_matches()
</span></span><span style="display:flex;"><span>		wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>		yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> matched_groups <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> index <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, matched_groups <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>				delete_matches(index)
</span></span><span style="display:flex;"><span>				wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>				yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>			matched_groups <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		collapse_columns()
</span></span><span style="display:flex;"><span>		wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>		yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ここを追加</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 空いたスペースにピースを生成するメソッドを呼ぶ</span>
</span></span><span style="display:flex;"><span>		spawn_pieces()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># WaitTimerのタイマースタート(0.3秒)</span>
</span></span><span style="display:flex;"><span>		wait_timer<span style="color:#f92672">.</span>start()
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># WaitTimerがタイムアウトするまで待機</span>
</span></span><span style="display:flex;"><span>		yield(wait_timer, <span style="color:#e6db74">&#34;timeout&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	is_waiting <span style="color:#f92672">=</span> false
</span></span></code></pre></div><br>
<p>これでマッチ処理のコーディングが完了だ。このチュートリアルとしても作業はここまでとなる。最後にプロジェクトを実行して、このパズルゲームの最終動作確認をして終わりにしよう。</p>
<p><img loading="lazy" src="/images/tutorials/gd0013_advanced_match3/img27.gif" alt="run project - delete matched pieces"  />
</p>
<br>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
style="display:block; text-align:center;"
data-ad-layout="in-article"
data-ad-format="fluid"
data-ad-client="ca-pub-4952908839423901"
data-ad-slot="9419515863"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<hr>
<h2 id="サンプルゲーム">サンプルゲーム<a hidden class="anchor" aria-hidden="true" href="#サンプルゲーム">#</a></h2>
<p>今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。</p>
<p>
<video controls autoplay loop muted playsinline aria-label='Sample game demo' style='ZgotmplZ'>

    <source src="/images/tutorials/gd0013_advanced_match3/img28.mp4" type="video/mp4">
    
    Your browser does not support the video tag.
</video>
<br>
<br></p>
<p>サンプルゲームのプロジェクトファイルは、<a href="https://github.com/msnsk/AdvancedMatch3.git" target="_blank">GitHubリポジトリ</a>
に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。<br>
<br></p>
<p><strong>ゲームのルール:</strong></p>
<ul>
<li>プレイヤーがピースを動かせるのは1回につき5秒まで。5秒経過すると指から離れる。</li>
<li>プレイヤーが動かしているピースが盤面からはみ出すと、ピースが指から離れて、移動もそこまでとなる。</li>
<li>マッチしたピースの組の数だけコンボ数が上がる。プレイヤーはコンボの数だけエイリアン（敵キャラクター）を攻撃でき、パワーも上がる。</li>
<li>エイリアンを攻撃するとパワーの分だけHPを減らすことができ、エイリアンのHPを0にすると倒すことができる。</li>
<li>エイリアンは一定の間隔でプレイヤーを攻撃してくる。</li>
<li>プレイヤーのライフは最大10。エイリアンに攻撃されると１つ減り、10回攻撃されるとゲームオーバー。</li>
<li>敵を倒すごとにレベルが1上がる。レベルが上がるとプレイヤーのパワーが少しアップする一方、敵キャラクターもHPが上がり、攻撃してくる間隔も少し短くなる。</li>
<li>マッチしたピースの自動処理中（コンボカウント中と敵への攻撃中）は敵のタイムゲージは一時停止する。</li>
<li>最終的に、倒したエイリアンの数がこのゲームのスコアとなる。</li>
</ul>
<br>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901"
     crossorigin="anonymous"></script>
<p><ins class="adsbygoogle"
style="display:block; text-align:center;"
data-ad-layout="in-article"
data-ad-format="fluid"
data-ad-client="ca-pub-4952908839423901"
data-ad-slot="9419515863"></ins></p>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
<hr>
<h2 id="おわりに">おわりに<a hidden class="anchor" aria-hidden="true" href="#おわりに">#</a></h2>
<p>今回のチュートリアルでは進化系マッチ3パズルゲームと銘打って、パズドラ風のパズルゲームを作った。オーソドックスなマッチ3とは違い、盤面上で一定時間ピースを自由に動かせるようにしたり、マッチしたピースが消える時も、パズドラのようにマッチした組ごとに順番に消えるようにしたりと、スクリプトのコードはやや複雑になったかもしれないが、最後まで作り切ることができただろうか。</p>
<p>今回のような進化系マッチ3パズルゲームを作るときのポイントをまとめておこう。</p>
<ul>
<li>最低限必要なシーンは盤面とピースの２つだけ。</li>
<li>雛形のピースシーンを作ってから、それを継承して各色のピースシーンを作る。</li>
<li>二次元配列を利用して盤面グリッドに配置するピースを管理する。</li>
<li>Area2Dのシグナルを利用して、以下について検知させる。
<ul>
<li>指がピースに触れた時</li>
<li>指がピースから離れた時</li>
<li>動かしているピースと静止しているピースが当たった時</li>
<li>動かしているピースが盤面からはみ出した時</li>
</ul>
</li>
<li>フラグ用のプロパティを用意して、状態管理をする。例えば以下。
<ul>
<li>ピースを動かしているかどうか</li>
<li>ピースが入れ替え中かどうか</li>
<li>ピースがマッチしているかどうか</li>
<li>マッチの自動処理中かどうか</li>
</ul>
</li>
<li>ピースを入れ替えるときは、画面上のピースの位置と二次元配列の要素をそれぞれ更新する必要がある。</li>
</ul>
<br>
<hr>
<h2 id="参照">参照<a hidden class="anchor" aria-hidden="true" href="#参照">#</a></h2>
<ul>
<li><a href="http://kidscancode.org/godot_recipes/ui/unit_healthbar/" target="_blank">KidsCanCode: OBJECT HEALTHBARS</a>
</li>
<li><a href="http://kidscancode.org/godot_recipes/ui/heart_containers_3/" target="_blank">KidsCanCode: HEART CONTAINERS: 3 WAYS</a>
</li>
<li><a href="https://pad.gungho.jp/" target="_blank">Puzzle＆Dragons（パズル＆ドラゴンズ）</a>
</li>
</ul>
<hr>
<!-- **UPDATE** -->
<!-- 2022/05/25 新規作成 -->


  </div>

  <footer class="post-footer">
    
    <div class="recommendation">
        <span>Twitter で新しい記事のお知らせやゲーム開発の進捗を投稿しています。<br>
お気軽にフォローしてください。</span>
      <div class="social-icons">
    <a href="https://twitter.com/MasanaoSako" target="_blank" rel="noopener noreferrer me" title="Twitter">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z">
    </path>
</svg>
    </a>
    <a href="https://github.com/msnsk/" target="_blank" rel="noopener noreferrer me" title="GitHub">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg>
    </a>
</div>

    </div>
    <div class="recommendation">
        <span>もしこの記事が良かったら、ぜひSNSなどでシェアしていただけると幸いです。</span>
    </div>
    
    

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on twitter"
        href="https://twitter.com/intent/tweet/?text=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&amp;hashtags=GodotEngine%2cGameDev%2cGodot3%2c2D%2c%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0%2c%e3%83%a2%e3%83%90%e3%82%a4%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0%2c%e3%83%9e%e3%83%83%e3%83%813%2c%e3%83%91%e3%82%ba%e3%83%89%e3%83%a9">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&amp;title=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;summary=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;source=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&title=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on whatsapp"
        href="https://api.whatsapp.com/send?text=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0%20-%20https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Godot で作る進化形マッチ 3 パズルゲーム on telegram"
        href="https://telegram.me/share/url?text=Godot%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

    <ul class="post-tags">
      <li><a href="https://www.peanuts-code.com/ja/tags/godotengine/">GodotEngine</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/gamedev/">GameDev</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/godot3/">Godot3</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/2d/">2D</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/%E3%83%91%E3%82%BA%E3%83%AB%E3%82%B2%E3%83%BC%E3%83%A0/">パズルゲーム</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/%E3%83%A2%E3%83%90%E3%82%A4%E3%83%AB%E3%82%B2%E3%83%BC%E3%83%A0/">モバイルゲーム</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/%E3%83%9E%E3%83%83%E3%83%813/">マッチ3</a></li>
      <li><a href="https://www.peanuts-code.com/ja/tags/%E3%83%91%E3%82%BA%E3%83%89%E3%83%A9/">パズドラ</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://www.peanuts-code.com/ja/tutorials/gd0014_screen_shake/">
    <span class="title">« 前のページ</span>
    <br>
    <span>Godot で作る画面揺れ</span>
  </a>
  <a class="next" href="https://www.peanuts-code.com/ja/tutorials/gd0012_match3/">
    <span class="title">次のページ »</span>
    <br>
    <span>Godot で作るマッチ 3 パズルゲーム</span>
  </a>
</nav>

    
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://www.peanuts-code.com/ja/">Peanuts Code</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
