<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>🤖 Godot3 で作る進化形マッチ 3 パズルゲーム | Peanuts Code</title>
<meta name=keywords content="GodotEngine,GameDev,2D,PuzzleGame,MobileGame,Match3"><meta name=description content="今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。
これはモバイルゲームで人気を博した「パズル&ドラゴンズ（Puzzle & Dragons）/ 通称パズドラ」のようなパズルをイメージしていただくとわかりやすいだろう。
ただし、チュートリアルに味方のデッキやガチャ、敵キャラクターとのバトルなど全てのゲーム要素を盛り込むとボリュームが大きすぎるので、今回はパズル部分にフォーカスして手順を説明させていただく。"><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/"><meta property="og:site_name" content="Peanuts Code"><meta property="og:title" content="🤖 Godot3 で作る進化形マッチ 3 パズルゲーム"><meta property="og:description" content="今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。
これはモバイルゲームで人気を博した「パズル&ドラゴンズ（Puzzle & Dragons）/ 通称パズドラ」のようなパズルをイメージしていただくとわかりやすいだろう。
ただし、チュートリアルに味方のデッキやガチャ、敵キャラクターとのバトルなど全てのゲーム要素を盛り込むとボリュームが大きすぎるので、今回はパズル部分にフォーカスして手順を説明させていただく。"><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-07-10T00:51:37+09:00"><meta property="article:modified_time" content="2022-07-10T00:51:37+09:00"><meta property="article:tag" content="GodotEngine"><meta property="article:tag" content="GameDev"><meta property="article:tag" content="2D"><meta property="article:tag" content="PuzzleGame"><meta property="article:tag" content="MobileGame"><meta property="article:tag" content="Match3"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif"><meta name=twitter:title content="🤖 Godot3 で作る進化形マッチ 3 パズルゲーム"><meta name=twitter:description content="今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。
これはモバイルゲームで人気を博した「パズル&ドラゴンズ（Puzzle & Dragons）/ 通称パズドラ」のようなパズルをイメージしていただくとわかりやすいだろう。
ただし、チュートリアルに味方のデッキやガチャ、敵キャラクターとのバトルなど全てのゲーム要素を盛り込むとボリュームが大きすぎるので、今回はパズル部分にフォーカスして手順を説明させていただく。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"🤖 チュート","item":"https://www.peanuts-code.com/ja/tutorials/"},{"@type":"ListItem","position":2,"name":"🤖 Godot3 で作る進化形マッチ 3 パズルゲーム","item":"https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"🤖 Godot3 で作る進化形マッチ 3 パズルゲーム","name":"🤖 Godot3 で作る進化形マッチ 3 パズルゲーム","description":"今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。\nこれはモバイルゲームで人気を博した「パズル\u0026amp;ドラゴンズ（Puzzle \u0026amp; Dragons）/ 通称パズドラ」のようなパズルをイメージしていただくとわかりやすいだろう。\nただし、チュートリアルに味方のデッキやガチャ、敵キャラクターとのバトルなど全てのゲーム要素を盛り込むとボリュームが大きすぎるので、今回はパズル部分にフォーカスして手順を説明させていただく。\n","keywords":["GodotEngine","GameDev","2D","PuzzleGame","MobileGame","Match3"],"articleBody":"今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。\nこれはモバイルゲームで人気を博した「パズル\u0026ドラゴンズ（Puzzle \u0026 Dragons）/ 通称パズドラ」のようなパズルをイメージしていただくとわかりやすいだろう。\nただし、チュートリアルに味方のデッキやガチャ、敵キャラクターとのバトルなど全てのゲーム要素を盛り込むとボリュームが大きすぎるので、今回はパズル部分にフォーカスして手順を説明させていただく。\nなお「キャンディークラッシュ」のようなオーソドックスなマッチ3（スリー）パズルゲームや「LINEツムツム」のような指でピースをなぞって繋げて消すタイプのパズルゲームの作り方については、以下のチュートリアルを参照いただきたい。\nOther Tutorials 「キャンディークラッシュ」のようなゲームを作ってみたい場合：\nGodot で作るマッチ 3 パズルゲーム 「LINE：ディズニーツムツム」のようなゲームを作って見たい場合：\nGodot で作る同じ色をつなげて消すパズルゲーム このチュートリアルで最後にできあがるプロジェクトのファイルはGitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.4\n・コンピュータのOS: macOS 11.6.5\nMemo: ゲームを作り始めるのに以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 新規プロジェクトを作成する それでは Godot Engine を立ち上げて、新規プロジェクトを作成しよう。プロジェクトの名前はあなたのお好みで決めていただいてOKだ。もし思いつかなければ「Advanced Match3 Start」としておこう。\nプロジェクト設定を更新する エディタが表示されたら、先にプロジェクト全体に関わる設定を更新しておこう。\nまずはゲームのディスプレイサイズを設定する。今回はスマホの縦向きの画面を想定して、縦横の比率を 16 : 9 とする。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。 「Size」セクションで以下の項目の値を変更する。 Width: 630 Height: 1120 Test Width: 315 Test Height: 560\n「Stretch」セクションで以下の項目の値を変更する。 Mode: 2d Aspect: keep\nそのまま「プロジェクト設定」ウインドウを開いた状態で、デバッグパネルでスマホのタッチ操作をマウスで代用するための設定をする。\n「一般」タブで「mouse」と検索し、サイドバーの「Input Devices」＞「Pointing」を選択する。 「Emulate Touch From Mouse」の On のチェックを入れる。\nさらに「プロジェクト設定」ウインドウを開いた状態で、インプットマップにスマホのタッチ操作の相当するアクションを追加しよう。\n「インプットマップ」タブに切り替え、アクションに「touch」を追加する。 「touch」の操作にマウスの左クリックを追加する。\nアセットをダウンロードしてインポートする 次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは「Physics Assets 」というアセットパックだ。このアセットに含まれるなんともかわいいエイリアンの顔の画像を、ゲームの盤面に並べるピースのテクスチャとして使用する。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「/physicspack/PNG/Aliens」フォルダの中のファイル名が「~_round.png」の画像だけを残して他は削除し、「Aliens」フォルダごとエディタのファイルシステムドックへドラッグしてプロジェクトにインポートしよう。\nGrid シーンを作る まずはマッチ3パズルゲームでピースが配置される盤面として、「Grid」シーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Area2D」クラスのルートノードが生成されたら、その名前を「Grid」に変更する。 シーンを保存する。フォルダを作成して、ファイルパスを「res://Grid/Grid.tscn」としてシーンを保存する。\nGrid シーンにノードを追加する 「Grid」ルートノードに、さらにノードを追加していこう。\n「Grid」ルートノードに「CollisionShape2D」ノードを追加する。 「Grid」ルートノードに「Node2D」ノードを追加し、名前を「PiecesContainer」に変更する。 「Grid」ルートノードに「Timer」ノードを２つ追加し、それぞれ名前を「TouchTimer」、「WaitTimer」に変更する。 ひとまず現時点でのシーンツリーは以下のようになったはずだ。\n続けて追加したノードを編集していこう。\nGrid シーンのノードを編集する Grid (Area2D) ルートノード このパズドラ風のパズルでは、盤面上でピースを自由に動かせるわけだが、盤面から動かしているピースがはみ出してはいけない。そうしないと、盤面の外側を移動させて離れたピースと入れ替えることができてしまう。このパズルゲームは、あくまで動かしているピースと隣り合ったドロップが次々に交換されていく仕様なのだ。\nルートノードを Area2D クラスにしたのは、そのシグナルを使って盤面から指（動かしているピース）がはみ出したことを検知させるためだ。検知さえできれば、あとはスクリプトで制限できる。このシーンへのスクリプトのアタッチは最後に行うので、その時にあらためてシグナルの接続を行うことにしよう。\nこのノードそのもののプロパティ編集は不要だ。\nCollisionShape2D ノード このノードは、盤面の外に指（動かしているピース）がはみ出した時にそれを検知するために利用する。インスペクターで以下の通りに各プロパティを編集しよう。\nShape: 新規 RectangleShape2D リソースを適用する。 RectangleShape2D \u003e Extents: (x: 225, y: 190)\nTransform \u003e Position: (x: 315, y: 840)\n2D ワークスペース上では以下のようになったはずだ。\nPiecesContainer (Node2D) ノード このノードは盤面に配置されるピースをまとめるためのノードだ。ゲーム中、スクリプトでピースのインスタンスが生成されたら全てこの「PiecesContainer」ノードの子として追加することになる。そうすることで、ピースのインスタンスがどれだけ生成されても、シーンツリー上のノードの順序を維持することができる。\n特に編集が必要なプロパティはないので次へ行こう。\nTouchTimer ノード この Timer クラスのノードは、指でピースを動かし始めてからカウントダウンを始め、タイムアウトしたら、動かしていたピースが指から自動的に離れるようにするためのものだ。これにより、制限時間内でピースを並べなければならないというある種の緊張感をプレイヤーに与えることができる。今回は 5 秒間ピースを移動できる設定にする。\nインスペクターで以下のように編集しよう。\nWait Time: 5 One Shot: オン\nWaitTimer ノード こちらの Timer クラスのノードは、指からピースが離れた後の、ピースのマッチング処理、マッチしたピースの削除、削除されて空いたグリッドへピースを詰めて、不足している分を追加する、という一連の流れを自動処理する際に、それぞれの処理の間に一瞬だけ間をあけるためのノードだ。\nインスペクターで以下のように編集しよう。\nWait Time: 0.3 One Shot: オン\n以上で、「Grid」シーンの編集は完了だ。\nPiece シーンを作る 次に、盤面に並べるピースとして「Piece」シーンを作成する。ただし、この「Piece」シーンはあくまで雛形で、実際にゲーム中で利用する各色のピースは、この「Piece」シーンを継承する形でのちほど用意する。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のシーン」を選択する。 「Area2D」クラスのルートノードが生成されたら、その名前を「Piece」に変更する。 シーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Pieces/Piece.tscn」としてシーンを保存する。\nPiece シーンにノードを追加する 続けて、「Piece」シーンに必要なノードを追加していこう。\n「Piece」ルートノードに「Sprite」ノードを追加する。 「Piece」ルートノードに「CollisionShape2D」ノードを追加する。 「Piece」ルートノードに「Tween」ノードを追加する。\nPiece シーンのシーンツリーは以下のようになったはずだ。\nPiece シーンのノードを編集する Piece (Area2D) ルートノード ルートノードを Area2D クラスにしたのは、動かしたいピースに指が当たった時や離れた時、ピース同士が衝突した時に、それを検知できるようにするためだ。\nこのノードのプロパティは編集不要だが、１つだけグループへの追加が必要だ。シーンドックで「Piece」ルートノードを選択したら、ノードドック＞グループタブを選択して、「Pieces」という名前のグループを作成して追加しよう。\n「Grid」シーンの方で「Grid」ルートノードには盤面からのはみ出し検知用のコリジョン形状が設定されており、これは常に全ピースと接触しているので、ピース同士との衝突を区別するために必要なグループなのだ。\nSprite ノード 先述の通り、「Piece」はあくまで継承元（雛形）なので、このシーンでは「Sprite」ノードの「Texture」プロパティにはリソースを敢えて適用せずそのままにしておく。継承先のシーンでそれぞれのピースの色にあった画像を適用する予定だ。\nこのシーンを継承する各色のピースのシーンでは「Texture」プロパティに先にインポートした KENNEY の画像を適用するが、その画像の縦横のサイズが 70 px なので、その画像の中心を右上にずらして画像の左下の角が(x: 0, y: 0)に合うように「Offset」プロパティを設定しよう。\nOffset:\nOffset: (x: 35, y: -35)\nピースを配置する盤面のグリッドは x 軸は左から右へ、y 軸は下から上へカウントする仕様で、かつ盤面の 1 グリッドのサイズもテクスチャのサイズに合わせて 70 px とする。ピースのテクスチャ画像の左下の角を (x: 0, y: 0) に合わせれば、「Piece」ルートノードの位置 (x: 0, y: 0) をグリッドに合わせて配置したときに、ちょうど「Sprite」の画像がグリッドに沿って配置されるというわけだ。\nCollisionShape2D ノード このノードはルートノードにコリジョン形状を付与する役目だ。ピースに指を触れたり、指を離したり、隣のピースと衝突したりするのを検知させるのに必要なノードである。コリジョン形状を縦横 70 px の Sprite の Texture にピッタリ合わせてしまうと、少しピースを動かしただけで、隣のピースとの衝突を検知してしまう。かといって、コリジョン形状が小さすぎると、指でピースに触れているつもりなのに検知されなかったり、ピースを移動させるときに、ピース同士の衝突をうまく検知できずにピースとピースの間を通り抜けてしまったりする。そこでコリジョン形状は Sprite の Texture の半分のサイズにするとちょうど良い。位置も Sprite の Texture にきれいに重なるように調整しよう。\nShape: 新規 CircleShape2D リソースを適用する CircleShape2D: Radius: 17.5\nTransform: Position: x: 35, y: -35\n2D ワークスペース上では以下のようになったはずだ。\nTween ノード このノードは、指定したノードの単一のプロパティのみをアニメーションさせることができる。今回このノードを使用するのは、ピースの位置が交換される時や、マッチして消えたピースの位置にピースを詰める時のピースの移動をアニメーションさせるためだ。\nただし、アニメーションはスクリプトで実装するので、このタイミングでのプロパティの編集は不要だ。\nPiece ノードにスクリプトをアタッチして編集する 「Piece」ルートノードに新規スクリプトをアタッチしよう。ファイルパスを「res://Pieces/Piece.gd」としてスクリプトファイルを作成する。\nひとまずスクリプトを以下のように編集してほしい。\n###Piece.gd### extends Area2D # プレイヤーが動かしているピースに衝突したら発信するシグナル（引数にピース自身を渡す） signal collided(self_piece) # ピースの色を設定するプロパティ export (String) var color # マッチした場合のフラグとなるプロパティ var matched = false # マッチしたピースのグループに割り振られるインデックス var matched_index = 0 # プレイヤーが動かしている場合のフラグとなるプロパティ var held = false # ピースのテクスチャと同じオフセット var offset = Vector2(35, -35) # Spriteノードへの参照 onready var sprite = $Sprite # Tweenノードへの参照 onready var tween = $Tween # メインループで毎フレーム呼ばれる組み込みメソッド func _process(_delta): # もしプレイヤーがピースを移動中だったら if held: # ピースの位置を(35, -35)ずらしてマウスに追随させる position = get_global_mouse_position() - offset # ピースを移動させるメソッド func move(destination): # Tweenノードのアニメーションを設定する # ピースを0.1秒かけて現在の位置から引数destinationの位置まで移動させる tween.interpolate_property(self, \"position\", position, destination, .1, Tween.TRANS_QUINT, Tween.EASE_IN) # Tweenノードのアニメーションを開始する tween.start() # ピースがマッチした時に呼ばれるメソッド func make_matched(index): # マッチのフラグを立てる matched = true # マッチしたグループごとのインデックス（引数index）を割り当てる matched_index = index # ピースの色を半透明にする modulate = Color(1,1,1,.5) # プレイヤーの指がピースに触れたら呼ばれるメソッド func enable_held(): # プレイヤーが動かしているフラグを立てる held = true # ピースの色を20％透明にする modulate = Color(1, 1, 1, 0.8) # プレイヤーが指をピースから離したら呼ばれるメソッド func disable_held(): # プレイヤーが動かしているフラグを解除する held = false # ピースの色をデフォルトに戻す modulate = Color(1, 1, 1, 1) 続けて、ピースに別のピースが当たった時に発信されるシグナルを利用する。シーンドックで「Piece」ルートノードを選択したらノードドック＞シグナルタブでarea_entered(area: Area2D)を、現在編集中の「Piece.gd」スクリプトに接続しよう。\nプレイヤーが動かしているピースが当たったらシグナルcollided(self_piece)を発信させたいので、自動生成されたメソッド_on_Piece_area_entered(area)内にそのためのコードを記述しよう。\n###Piece.gd### # Area2Dが当たったらシグナルが発信されて呼ばれるメソッド func _on_Piece_area_entered(area): # もし当たったArea2Dが「Pieces」グループ（つまりPieceのインスタンス）で... # かつ、プレイヤーが動かしているピースだったら if area.is_in_group(\"Pieces\") and area.held: # 引数に自分自身のピースを渡してシグナル collided を発信する emit_signal(\"collided\", self) これで「Piece.gd」スクリプトの編集は完了だ。\nPiece シーンを継承した各色のシーンを作る 雛形となる「Piece」シーンは完成したので、それを継承したシーンをピースの色の数だけ作成していこう。ピースの色は、ベージュ、青、緑、ピンク、黄の 5 色だ。まずは「ベージュ」のドロップを例に手順を進めてみよう。\n「シーン」メニュー＞「新しい継承シーン」を選択する。 継承元のシーンとして「Piece.tscn」を選択する。 継承シーンが生成されたら、ルートノードの名前を「PieceBeige」に変更する。\n*このルートノードの名前はそれぞれのドロップの色に合わせること。 シーンを一旦保存しておく。ファイルパスを「res://Pieces/PieceBeige.tscn」として保存する。 シーンドックでルートノード「PieceBeige」を選択した状態で、インスペクターで「Script Variables」の「Color」プロパティの値を「beige」とする。\nシーンドックで「Sprite」ノードを選択し、「Texture」プロパティに先にインポートしておいたリソース「res://Aliens/alienBeige_round.png」を適用する（ファイルシステムドックからドラッグすればOK）。\n2D ワークスペース上では以下のスクリーンショットのようになったはずだ。\n以上で、「PieceBeige」シーンは完成だ。残りの 4 色のピースについても、同様の手順でシーンを作成してほしい。なお、シーンごとに異なる部分については、以下を参考にしてほしい。 青のピース ルートノード名: PieceBlue Color プロパティ: blue Sprite \u003e Texture プロパティ: res://Aliens/alienBlue_round.png シーン保存時のファイルパス: res://Pieces/PieceBlue.tscn 緑のピース ルートノード名: PieceGreen Color プロパティ: green Sprite \u003e Texture プロパティ: res://Aliens/alienGreen_round.png シーン保存時のファイルパス: res://Pieces/PieceGreen.tscn ピンクのピース ルートノード名: PiecePink Color プロパティ: green Sprite \u003e Texture プロパティ: res://Aliens/alienPink_round.png シーン保存時のファイルパス: res://Pieces/PiecePink.tscn 黄のピース ルートノード名: PieceYellow Color プロパティ: yellow Sprite \u003e Texture プロパティ: res://Aliens/alienYellow_round.png シーン保存時のファイルパス: res://Pieces/PieceYellow.tscn 全部で 5 色のピースの継承シーンができたら作業完了だ。\nGrid シーンをスクリプトで制御する ここからはスクリプトをコーディングしてゲームを制御していく。コード量がやや多めなので頑張ろう。\nGodot エディタで「Grid.tscn」シーンに切り替えたら、「Grid」ルートノードに新規スクリプトをアタッチしよう。ファイルパスは「res://Grid/Grid.gd」として作成する。\nなお、スクリプト内のコメントには「指が触れた」または「指が離れた」と記載しているが、Godot デバッグパネル上では「マウス左ボタンを押した」または「マウス左ボタンを離した」と置き換えてほしい。\nまた、同じ色が３つ以上揃った状態のことを「マッチ」と表現しているので、こちらもご留意いただきたい。\nでは、スクリプトエディタが開いたら、まずは必要なプロパティを定義しておこう。\n###Grid.gd### extends Area2D # ピースを動かして指を離した後の自動処理開始時に発信するシグナル signal waiting_started # 各色のピースのシーンファイルを要素とした配列 const pieces_scn = [ preload(\"res://Pieces/PieceBeige.tscn\"), preload(\"res://Pieces/PieceBlue.tscn\"), preload(\"res://Pieces/PieceGreen.tscn\"), preload(\"res://Pieces/PiecePink.tscn\"), preload(\"res://Pieces/PieceYellow.tscn\") ] # x軸方向のグリッド数 var width: = 7 # y軸方向のグリッド数 var height: = 6 # x軸方向のグリッド開始位置（pixel） var x_start: = 70 # y軸方向のグリッド開始位置（pixel） var y_start: = 1050 # 1グリッドのサイズ（PieceのSpriteのTextureと同じにする） var grid_size: = 70 # ピースが生成される時に何グリッドy軸方向にズラして落とすか var y_offset: = 3 # 盤面のピースの配置を表す配列（二次元配列） var board = [] # プレイヤーが動かしているピースの参照 var moving_piece # プレイヤーが動かしているピースの最後の位置（グリッド） var last_pos = Vector2() # ゲーム開始時の準備中のフラグ var is_initializing = true # プレイヤーがピースを動かしている場合のフラグ var is_touching = false # ピース入れ替え中のフラグ var is_swapping = false # プレイヤーがピースを動かした後の自動処理中のフラグ var is_waiting = false # マッチしたピースのグループの数（カウントアップする） var matched_groups = 0 # PiecesContainerノードの参照 onready var pieces_container = $PiecesContainer # TouchTimerノードの参照 onready var touch_timer = $TouchTimer # WaitTimerノードの参照 onready var wait_timer = $WaitTimer 続いてここからはメソッドを追加していく。なお、以下のコード内に出てくる 二次元配列 とは、要素として配列を格納する配列、つまり配列の配列のことだ。\n今回のスクリプトで利用している二次元配列の場合、一階層目の配列では、盤面の x 軸方向のグリッドの数だけ空の配列を要素とし、二階層目としてそれぞれの配列内に縦方向のグリッド数だけ要素を格納する。その要素として、ピースオブジェクトを格納することで、それぞれのピースが盤面のどこに位置しているか（x 軸方向に何番目のグリッドで、y 軸方向に何番目のグリッドか）を管理することができるのだ。\n###Grid.gd### # シーンが読み込まれたら呼ばれる関数 func _ready(): # ランダムな数を生成する関数の出力結果を毎回ランダムにするための組み込み関数を呼ぶ randomize() # board（配列）を盤面のグリッドを構成する二次元配列にする board = make_2d_array() # このあと定義 # ピースを生成して盤面に配置して盤面情報を board に反映する spawn_pieces() # このあと定義 is_initializing = false # 盤面のグリッドを構成する二次元配列を生成するメソッド func make_2d_array() -\u003e Array: # array という名前の配列を用意 var array = [] # array に x 軸方向のグリッド数だけ空の配列を入れる for i in width: array.append([]) # さらにそれぞれの配列に y 軸方向のグリッド数だけ暫定的に null を入れる for j in height: array[i].append(null) # できあがった二次元配列を返す return array # ピースを生成して盤面に配置して盤面情報を board に反映するメソッド func spawn_pieces(): # x軸方向のグリッド数だけループ for i in width: # y軸方向のグリッド数だけループ for j in height: # 全ピースの二次元配列上で該当グリッドにピースが存在しない場合 #（ゲーム開始時は全部 null） if board[i][j] == null: # 各色のピースのシーンからランダムで１つ選択してインスタンス化 var index = floor(rand_range(0, pieces_scn.size())) var piece = pieces_scn[index].instance() # もしゲーム開始時の準備中だったら if is_initializing: # マッチしてしまった場合は、ピースのインスタンスを削除してやり直し while match_at(i, j, piece.color): # このあと定義 piece.queue_free() index = floor(rand_range(0, pieces_scn.size())) piece = pieces_scn[index].instance() # ピースのインスタンスをPiecesContainerノードの子にする pieces_container.add_child(piece) # ピースのインスタンスの collided シグナルを... # _on_Piece_collided メソッド（あとで定義）に接続する piece.connect(\"collided\", self, \"_on_Piece_collided\") # ピースのインスタンスを配置位置より y_offset 分ずらして置き... # そこから配置位置へ移動させる（落とす） piece.position = grid_to_pixel(i, j + y_offset) # このあと定義 piece.move(grid_to_pixel(i, j)) # このあと定義 # 盤面情報として board の適切なインデックスの要素に生成したピースを追加 board[i][j] = piece 上記コードの中で未定義のmatch_atメソッドとgrid_to_pixelメソッドを定義しておこう。\n###Grid.gd### # 指定したグリッド位置で同じ色ピースが３つ以上並んでいるか確認するメソッド # 引数columnはx軸のグリッド位置、rowはy軸のグリッド位置、colorはピースの色 func match_at(column, row, color): # 指定したグリッドの x 軸方向の位置が3以上の場合 if column \u003e= 2: # 指定したグリッド位置の左隣ともう一つ左隣にピースがある場合 if board[column-1][row] != null \\ and board[column-2][row] != null: # 左隣ともう一つ左隣のピースの色が指定したピースの色と同じ場合 if board[column-1][row].color == color \\ and board[column-2][row].color == color: # true を返す return true # 指定したグリッドの y 軸方向の位置が3以上の場合 if row \u003e= 2: # 指定したグリッド位置の下ともう一つ下にピースがある場合 if board[column][row-1] != null \\ and board[column][row-2] != null: # 下ともう一つ下のピースの色が指定したピースの色と同じ場合 if board[column][row-1].color == color \\ and board[column][row-2].color == color: # true を返す return true # グリッドの位置をピクセルの位置に変換するメソッド func grid_to_pixel(column, row) -\u003e Vector2: # 先にピクセル位置出力用に Vector2 型の変数 pixel_pos を定義 var pixel_pos = Vector2() # ピクセル x 座標 = x 軸方向のグリッド開始位置 + グリッドサイズ x グリッド x 座標 pixel_pos.x = x_start + grid_size * column # ピクセル y 座標 = y 軸方向のグリッド開始位置 - グリッドサイズ x グリッド y 座標 pixel_pos.y = y_start - grid_size * row # ピクセル座標を返す return pixel_pos これで、ゲーム開始時に各色のピースが盤面にランダムで並べられるはずだ。一度プロジェクトを実行して確認してみよう。なお、初めてプロジェクトを実行する場合は、メインシーン選択のダイアログが表示されるので、「Grid.tscn」をメインシーンとして選択しよう。\nちょうどgrid_to_pixelメソッドを定義したので、ついでにこのあと使用するpixel_to_gridメソッドも定義しておこう。名前の通り、先に定義したgrid_to_pixelとは逆で、ピクセルの位置をグリッドの位置に変換するメソッドだ。\n###Grid.gd### # ピクセルの位置をグリッドの位置に変換するメソッド func pixel_to_grid(pixel_x, pixel_y) -\u003e Vector2: var grid_pos = Vector2() grid_pos.x = floor((pixel_x - x_start) / grid_size) grid_pos.y = floor((pixel_y - y_start) / -grid_size) return grid_pos さらに、もう一つこのあと使用するis_in_gridメソッドを定義しておく。これは引数に渡した位置が盤面グリッドの範囲内かどうかを判定してその結果を返すメソッドだ。\n###Grid.gd### # 指定した位置が盤面グリッドの範囲内かどうかを返すメソッド func is_in_grid(grid_position: Vector2) -\u003e bool: if grid_position.x \u003e= 0 and grid_position.x \u003c width \\ and grid_position.y \u003e= 0 and grid_position.y \u003c height: # 盤面グリッドの範囲内だったら true を返す return true else: # 盤面グリッドの範囲外だったら false を返す return false ここで、ゲームのプレイヤーの入力（画面のタッチ操作）を処理するプログラムを記述していく。\n###Grid.gd### # ゲームのメインループで毎フレーム呼ばれる関数 func _process(_delta): # もしマッチングの処理中でなければ if not is_waiting: # プレイヤーの入力を処理する touch_input() # このあと定義 # プレイヤーの入力を処理するメソッド func touch_input(): # もし画面に指が触れたら if Input.is_action_just_pressed(\"touch\"): # ピースに触れた時の処理を実行するメソッドを呼ぶ touch_piece() # このあと定義 # もし画面から指が離れたら if Input.is_action_just_released(\"touch\") and is_touching: # ピースから指が離れた時の処理を実行するメソッドを呼ぶ release_piece() # このあと定義 # ピースに触れた時の処理を実行するメソッド func touch_piece(): # 指が触れた時のピクセル座標を取得する var pos = get_global_mouse_position() # ピクセル座標からグリッド座標に変換する var grid_pos = pixel_to_grid(pos.x, pos.y) # もしグリッド座標が盤面の範囲内だったら if is_in_grid(grid_pos): # 動かしているピースの最後の位置としてグリッド座標を登録 last_pos = grid_pos # 動かしているピースとしてグリッド座標に位置するピースを登録 moving_piece = board[last_pos.x][last_pos.y] # ピースを動かしているフラグを立てる is_touching = true # 動かしているピースインスタンス自体の動かしているフラグも立てる moving_piece.enable_held() # ピースを動かせる制限時間のタイマースタート touch_timer.start() # ピースから指が離れた時の処理を実行するメソッド func release_piece(): # 二次元配列 board の要素から動かしていたピースを見つけたら... # 動かしていたピースを盤面グリッドにきっちり収める for i in width: for j in height: if board[i][j] == moving_piece: moving_piece.move(grid_to_pixel(i, j)) break # 動かしていたピースインスタンス自体の動かしているフラグを解除する moving_piece.disable_held() # ピースを動かしているフラグを解除する is_touching = false # ピースを動かせる制限時間のタイマーストップ touch_timer.stop() # このあとのマッチング自動処理開始のシグナルを発信 emit_signal(\"waiting_started\") まだピースの交換は実装していないが、ここまでのコーディングで、指で触ったピースを移動させ、指を離したら移動しているピースが最後にいた場所にきっちり収まる動きが実装できたはずだ。一度プロジェクトを実行して確認してみよう。\n次に定義する_on_Piece_collidedメソッドには、すでに Piece インスタンス生成時にcollidedシグナルを接続するようコーディング済みだ。このシグナルはピースにプレイヤーが動かしているピースが当たった時に発信されるように「Piece.gd」スクリプトの方でコーディングしたことを思い出してほしい。\n動かしているピースとそれに当たったピースの場所を入れ替えるメソッドを定義して、_on_Piece_collidedの中で呼び出してみよう。\n###Grid.gd### # Piece インスタンスの collided シグナルで呼ばれるメソッド func _on_Piece_collided(self_piece): # ピースを動かしていて、かつピース交換中でなければ if is_touching and not is_swapping: # ピース交換中のフラグを立てる is_swapping = true # ピースを交換するメソッドを呼ぶ swap_pieces(self_piece) # あとで定義 # ピース交換中のフラグを解除 is_swapping = false # 動かしているピースとそれに当たったピースの場所を入れ替えるメソッド # 引数 collided_piece には動かしているピースに当たったピースが渡される func swap_pieces(collided_piece): # 当たったピースのグリッド座標を取得する。 var collided_pos = pixel_to_grid(collided_piece.position.x, collided_piece.position.y) # 二次元配列 board 上の動かしているピースと動かしているピースが一致していれば if board[last_pos.x][last_pos.y] == moving_piece: # board の動かしているピースの位置に当たったピースを入れる board[last_pos.x][last_pos.y] = collided_piece # 当たったピースを動かしているピースの最後のグリッド座標へ移動させる collided_piece.move(grid_to_pixel(last_pos.x, last_pos.y)) # board の当たったピースの位置に動かしているピースを入れる board[collided_pos.x][collided_pos.y] = moving_piece # 動かしているピースの最後の位置として当たったピースのグリッド座標を登録する last_pos = collided_pos これでピースの交換も実装できたはずだ。では実際にプロジェクトを実行してピースを動かしてみよう。通ったルートのピースが次々と交換される動作を確認しよう。\nさて、この時点で問題になるのは以下の2点だ。\n盤面の外側を自由に移動できてしまうこと いつまでもピースをつかんでいられること これらの問題はシグナルを使って解決することができる。\nArea2D クラスである「Grid」ルートノードのシグナルをスクリプトに接続しよう。コリジョン形状を盤面のサイズに調整したことを覚えているだろうか。その範囲から指（動かしているピース）が外にはみ出た場合に発信するシグナルによってrelease_pieceメソッドを呼び出して、動かしていたピースが指からも離れて盤面上の最後の位置に戻るようにする。\nシーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブを選択し、erea_exitedシグナルをこのスクリプトに接続する。\nもう一つ、「TouchTimer」ノードのピースを動かせる制限時間がタイムアウトした時に発信されるシグナルもスクリプトに接続する。この場合も同様に、シグナルによってにrelease_pieceメソッドを呼び出すようにする。timeoutシグナルを接続しよう。\n続けて、それぞれのシグナルの接続によって生成されたメソッドを以下のように編集してほしい。\n###Grid.gd### # 盤面から Area2D がはみ出たときにシグナルで呼ばれるメソッド func _on_Grid_area_exited(area): # はみ出た Area2D が動かしているピースの場合 if area.is_in_group(\"Pieces\") and area.held: # ピースから指が離れた時の処理を実行するメソッドを呼ぶ release_piece() # ピースを動かせる制限時間が切れたときにシグナルで呼ばれるメソッド func _on_TouchTimer_timeout(): # 移動中の場合 if is_touching: # ピースから指が離れた時の処理を実行するメソッドを呼ぶ release_piece() これで盤面からはみ出したら、ピースが指から離れて盤面上の最後の位置に戻るようになったはずだ。また、5秒以上ピースをつかんでいた場合も、タイマーにより、指からピースが離れて盤面上の最後のグリッド座標に収まるようになったはずだ。\nそれでは実際にプロジェクトを実行して動作を確認してみよう。\nここからはマッチしたピースを自動的に処理するプログラムを作っていく。release_pieceメソッドの最後にemit_signal(\"waiting_started\")というコードでwaiting_startedシグナルを発信するようにしていたのだが、このシグナルをスクリプトに接続するところから始める。\nシーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブでwaiting_startedシグナルをスクリプトに接続しよう。_on_Grid_waiting_startedメソッドがスクリプトに追加されたら、そのメソッド内にマッチしたピースの自動処理を記述していく。大まかに自動処理は以下の流れになる。\n自動処理中のフラグを立てる マッチしたピースが1組でもあるかチェックする。1組でもある場合は以下の処理をループする。 全てのピースをチェックしてマッチしたピースにフラグを立てる。 フラグの立っているピースを削除する。 削除して空になったスペースへ同じ列の上のグリッドからピースを移動させて詰める。 ピースを下へ詰めたら、最後に空のスペースに新しいピースを生成する。 マッチしたピースが1組もなくなったら自動処理中のフラグを解除する。\n上記の流れを段階的に実装していこう。まずは「全てのピースをチェックしてマッチしたピースにフラグを立てる」ところまで進めてみよう。\n###Grid.gd### # releaseメソッドの最後に発信されるシグナルで呼ばれるメソッド func _on_Grid_waiting_started(): # 自動処理中のフラグを立てる is_waiting = true # 人組でマッチしているピースが1組でもあればループし続ける while check_matches(): # このあと定義 # マッチしているピースにフラグを立てるメソッドを呼ぶ find_matches() # このあと定義 # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \"timeout\") # 自動処理中のフラグを解除する is_waiting = false # マッチしているピースが1組でもあるかチェックするメソッド func check_matches() -\u003e bool: # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # そのグリッド座標にピースが存在していれば if board[i][j] != null: # そのピースがマッチしていたら if match_at(i, j, board[i][j].color): # true を返す return true # 1組もマッチしているピースがなければ false を返す return false # マッチしているピースにフラグを立てるメソッド func find_matches(): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # そのグリッド座標にピースが存在していれば if board[i][j] != null: # 現在の色をそのグリッド座標のピースの色と定義する var current_color = board[i][j].color # もしその x 軸座標が x 軸方向のグリッド数 - 2 より小さければ if i \u003c width - 2: # そのピースの右隣とさらにその右隣にピースが存在する場合 if board[i+1][j] != null \\ and board[i+2][j] != null: # それらのピースの色が現在の色と同じ場合 if board[i+1][j].color == current_color \\ and board[i+2][j].color == current_color: # マッチした組に割り振る番号の変数を定義 var matched_index: int # そのピースにすでにマッチしているフラグが立っていれば if board[i][j].matched: # マッチした組の番号はそのピースの組の番号とする matched_index = board[i][j].matched_index # そのピースにマッチしているフラグが立ってなければ else: # マッチした組のグループ数を1増やす matched_groups += 1 # マッチした組の番号をマッチした組のグループ数とする matched_index = matched_groups # その座標のピースにマッチしたフラグを立て、組の番号を割り当て、半透明にする board[i][j].make_matched(matched_index) # その座標の右隣のピースも同様にする board[i+1][j].make_matched(matched_index) # さらにもう一つ右隣のピースも同様にする board[i+2][j].make_matched(matched_index) # y軸方向に対しても同様にする if j \u003c height - 2: if board[i][j+1] != null \\ and board[i][j+2] != null: if board[i][j+1].color == current_color \\ and board[i][j+2].color == current_color: var matched_index: int if board[i][j].matched: matched_index = board[i][j].matched_index else: matched_groups += 1 matched_index = matched_groups board[i][j].make_matched(matched_index) board[i][j+1].make_matched(matched_index) board[i][j+2].make_matched(matched_index) マッチしたピースの処理のうち、マッチしているピースにフラグを立てるところまで実装した。プロジェクトを実行して、マッチしたピースが半透明になるか確認してみよう。\n次はマッチ状態のフラグが立っているピースを削除するメソッドを定義する。\n###Grid.gd### # マッチのフラグが立っているピースを削除するメソッド # 引数 index には削除対象のマッチの組番号を渡す func delete_matches(index): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # もしそのグリッド座標にピースが存在していれば if board[i][j] != null: # もしそのグリッド座標のピースにマッチのフラグが立っていたら if board[i][j].matched: # もしそのグリッド座標のピースの組番号は削除対象の組番号と一致したら if board[i][j].matched_index == index: # そのグリッド座標のピースを解放する board[i][j].queue_free() # 二次元配列 board の該当の要素を null にする board[i][j] = null delete_matchesメソッドが定義できたので、これを_on_Grid_waiting_startedメソッドのループの中に入れよう。\n###Grid.gd### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \"timeout\") # ここを追加 # マッチしたグループの数が0より大きければ if matched_groups \u003e 0: # マッチしたグループの数だけループさせる # 全て同時に削除せず、マッチした組ごとに削除する for index in range(1, matched_groups + 1): # マッチしたピースを削除するメソッドを呼ぶ delete_matches(index) # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \"timeout\") # マッチしたピースをすべて削除したらマッチしたグループの数を 0 に戻す matched_groups = 0 is_waiting = false これで、マッチしたピースが半透明になったあと、削除されるところまで実装できたはずだ。プロジェクトを実行して確認してみよう。\n続いて、ピースが削除されて空いたグリッドスペースに上のピースを詰める（落とす）処理を実装する。まずはメソッドから定義しよう。\n###Grid.gd### # 空いたグリッドスペースに上のピースを詰める（落とす）メソッド func collapse_columns(): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # もしそのグリッド座標にピースがなければ if board[i][j] == null: # その y座標より1つ上のグリッドから残りの y軸方向のグリッド数だけループ for k in range(j + 1, height): # もしそのグリッド座標にピースが存在していれば if board[i][k] != null: # そのグリッド座標のピースを空いたスペースへ移動する board[i][k].move(grid_to_pixel(i, j)) # 二次元配列 board の要素を入れ替える board[i][j] = board[i][k] board[i][k] = null # ループ終了 break collapse_columnsメソッドが定義できたので、これを_on_Grid_waiting_startedメソッドのループの中に追加しよう。\n###Grid.gd### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \"timeout\") if matched_groups \u003e 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \"timeout\") matched_groups = 0 # ここを追加 # 空いたグリッドスペースに上のピースを詰める（落とす）メソッドを呼ぶ collapse_columns() # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \"timeout\") is_waiting = false これで、マッチして半透明になったピースが削除されたあと、その空いたスペースには上のピースが詰められる（落とされる）ようになったはずだ。プロジェクトを実行して確認してみよう。\n最後に、ピースを下に詰めた後の上の空いたスペースには新しいピースを補充する必要がある。そのためのメソッドは、_ready関数の中でも実行している、すでに定義済みのspawn_piecesメソッドだ。ゲームのプレイが開始した時点ではis_initializingプロパティはfalseになっているので、このメソッドを実行してピースが生成された時点ですでに新たなマッチが発生するかもしれない。これが期待以上のコンボを発生させ、ゲーム体験をより気持ち良く、楽しいものにしてくれるはずだ。\nspawn_piecesメソッドを_on_Grid_waiting_startedメソッドのループの中に追加しよう。\n###Grid.gd### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \"timeout\") if matched_groups \u003e 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \"timeout\") matched_groups = 0 collapse_columns() wait_timer.start() yield(wait_timer, \"timeout\") # ここを追加 # 空いたスペースにピースを生成するメソッドを呼ぶ spawn_pieces() # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \"timeout\") is_waiting = false これでマッチ処理のコーディングが完了だ。このチュートリアルとしても作業はここまでとなる。最後にプロジェクトを実行して、このパズルゲームの最終動作確認をして終わりにしよう。\nサンプルゲーム 今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。\nYour browser does not support the video tag. サンプルゲームのプロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。\nゲームのルール:\nプレイヤーがピースを動かせるのは1回につき5秒まで。5秒経過すると指から離れる。 プレイヤーが動かしているピースが盤面からはみ出すと、ピースが指から離れて、移動もそこまでとなる。 マッチしたピースの組の数だけコンボ数が上がる。プレイヤーはコンボの数だけエイリアン（敵キャラクター）を攻撃でき、パワーも上がる。 エイリアンを攻撃するとパワーの分だけHPを減らすことができ、エイリアンのHPを0にすると倒すことができる。 エイリアンは一定の間隔でプレイヤーを攻撃してくる。 プレイヤーのライフは最大10。エイリアンに攻撃されると１つ減り、10回攻撃されるとゲームオーバー。 敵を倒すごとにレベルが1上がる。レベルが上がるとプレイヤーのパワーが少しアップする一方、敵キャラクターもHPが上がり、攻撃してくる間隔も少し短くなる。 マッチしたピースの自動処理中（コンボカウント中と敵への攻撃中）は敵のタイムゲージは一時停止する。 最終的に、倒したエイリアンの数がこのゲームのスコアとなる。 おわりに 今回のチュートリアルでは進化系マッチ3パズルゲームと銘打って、パズドラ風のパズルゲームを作った。オーソドックスなマッチ3とは違い、盤面上で一定時間ピースを自由に動かせるようにしたり、マッチしたピースが消える時も、パズドラのようにマッチした組ごとに順番に消えるようにしたりと、スクリプトのコードはやや複雑になったかもしれないが、最後まで作り切ることができただろうか。\n今回のような進化系マッチ3パズルゲームを作るときのポイントをまとめておこう。\n最低限必要なシーンは盤面とピースの２つだけ。 雛形のピースシーンを作ってから、それを継承して各色のピースシーンを作る。 二次元配列を利用して盤面グリッドに配置するピースを管理する。 Area2Dのシグナルを利用して、以下について検知させる。 指がピースに触れた時 指がピースから離れた時 動かしているピースと静止しているピースが当たった時 動かしているピースが盤面からはみ出した時 フラグ用のプロパティを用意して、状態管理をする。例えば以下。 ピースを動かしているかどうか ピースが入れ替え中かどうか ピースがマッチしているかどうか マッチの自動処理中かどうか ピースを入れ替えるときは、画面上のピースの位置と二次元配列の要素をそれぞれ更新する必要がある。 参照 KidsCanCode: OBJECT HEALTHBARS KidsCanCode: HEART CONTAINERS: 3 WAYS Puzzle＆Dragons（パズル＆ドラゴンズ） ","wordCount":"16296","inLanguage":"ja","image":"https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif","datePublished":"2022-07-10T00:51:37+09:00","dateModified":"2022-07-10T00:51:37+09:00","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/ja/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/en/ title=English aria-label=🇬🇧English>🇬🇧English</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/ja/ title=ホーム><span>ホーム</span></a></li><li><a href=https://www.peanuts-code.com/ja/portfolio/ title=ゲーム><span>ゲーム</span></a></li><li><a href=https://www.peanuts-code.com/ja/posts/ title=ブログ><span>ブログ</span></a></li><li><a href=https://www.peanuts-code.com/ja/tutorials/ title=チュート><span>チュート</span></a></li><li><a href=https://www.peanuts-code.com/ja/about/ title=サイト紹介><span>サイト紹介</span></a></li><li><a href=https://www.peanuts-code.com/ja/search/ title="サイト内検索 (Alt + /)" accesskey=/><span>サイト内検索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/ja/>ホーム</a>&nbsp;»&nbsp;<a href=https://www.peanuts-code.com/ja/tutorials/>🤖 チュート</a></div><h1 class="post-title entry-hint-parent">🤖 Godot3 で作る進化形マッチ 3 パズルゲーム</h1><div class=post-meta><span title='2022-07-10 00:51:37 +0900 +0900'>2022-07-10</span>&nbsp;·&nbsp;33 分&nbsp;|&nbsp;言語:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/>🇬🇧English</a></li></ul></div><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る進化形マッチ 3 パズルゲーム on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Godot3%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cPuzzleGame%2cMobileGame%2cMatch3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る進化形マッチ 3 パズルゲーム on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&title=%f0%9f%a4%96%20Godot3%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る進化形マッチ 3 パズルゲーム on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/ja/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/ja/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/ja/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/ja/tags/puzzlegame/>PuzzleGame</a></li><li><a href=https://www.peanuts-code.com/ja/tags/mobilegame/>MobileGame</a></li><li><a href=https://www.peanuts-code.com/ja/tags/match3/>Match3</a></li></ul></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif alt="Godot で作る進化形マッチ 3 パズルゲーム"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目次</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#新規プロジェクトを作成する>新規プロジェクトを作成する</a><ul><li><a href=#プロジェクト設定を更新する>プロジェクト設定を更新する</a></li><li><a href=#アセットをダウンロードしてインポートする>アセットをダウンロードしてインポートする</a></li></ul></li><li><a href=#grid-シーンを作る>Grid シーンを作る</a><ul><li><a href=#grid-シーンにノードを追加する>Grid シーンにノードを追加する</a></li><li><a href=#grid-シーンのノードを編集する>Grid シーンのノードを編集する</a></li></ul></li><li><a href=#piece-シーンを作る>Piece シーンを作る</a><ul><li><a href=#piece-シーンにノードを追加する>Piece シーンにノードを追加する</a></li><li><a href=#piece-シーンのノードを編集する>Piece シーンのノードを編集する</a></li><li><a href=#piece-ノードにスクリプトをアタッチして編集する>Piece ノードにスクリプトをアタッチして編集する</a></li></ul></li><li><a href=#piece-シーンを継承した各色のシーンを作る>Piece シーンを継承した各色のシーンを作る</a></li><li><a href=#grid-シーンをスクリプトで制御する>Grid シーンをスクリプトで制御する</a></li><li><a href=#サンプルゲーム>サンプルゲーム</a></li><li><a href=#おわりに>おわりに</a></li><li><a href=#参照>参照</a></li></ul></nav></div></details></div><div class=post-content><p>今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。</p><p>これはモバイルゲームで人気を博した「パズル&ドラゴンズ（Puzzle & Dragons）/ 通称パズドラ」のようなパズルをイメージしていただくとわかりやすいだろう。</p><p>ただし、チュートリアルに味方のデッキやガチャ、敵キャラクターとのバトルなど全てのゲーム要素を盛り込むとボリュームが大きすぎるので、今回はパズル部分にフォーカスして手順を説明させていただく。</p><p>なお「キャンディークラッシュ」のようなオーソドックスなマッチ3（スリー）パズルゲームや「LINEツムツム」のような指でピースをなぞって繋げて消すタイプのパズルゲームの作り方については、以下のチュートリアルを参照いただきたい。</p><blockquote><p><em><strong><span style=color:salmon>Other Tutorials</span></strong><br>「キャンディークラッシュ」のようなゲームを作ってみたい場合：<br><a href=https://www.peanuts-code.com/ja/tutorials/gd0012_match3/ title="Godot で作るマッチ 3 パズルゲーム">Godot で作るマッチ 3 パズルゲーム</a><br>「LINE：ディズニーツムツム」のようなゲームを作って見たい場合：<br><a href=https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/ title="Godot で作る同じ色をつなげて消すパズルゲーム">Godot で作る同じ色をつなげて消すパズルゲーム</a></em></p></blockquote><br><p>このチュートリアルで最後にできあがるプロジェクトのファイルは<a href=https://github.com/msnsk/AdvancedMatch3.git target=_blank>GitHubリポジトリ</a>
に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。<br><br></p><blockquote><p><em><strong><span style=color:salmon>Environment</span></strong><br>このチュートリアルは以下の環境で作成しました。</em><br>・<em>Godot のバージョン: <strong>3.4.4</strong></em><br>・<em>コンピュータのOS: <strong>macOS 11.6.5</strong></em></p></blockquote><blockquote><p><em><strong><span style=color:salmon>Memo:</span></strong><br>ゲームを作り始めるのに以下の記事もお役立てください。<br><a href=https://www.peanuts-code.com/ja/tutorials/gd0001_download/ title="Godot をダウンロードする">Godot をダウンロードする</a><br><a href=https://www.peanuts-code.com/ja/tutorials/gd0002_project_manager/ title="Godot のプロジェクトマネージャー">Godot のプロジェクトマネージャー</a><br><a href=https://www.peanuts-code.com/ja/tutorials/gd0003_change_language/ title="Godot の言語設定">Godot の言語設定</a></em></p></blockquote><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=新規プロジェクトを作成する>新規プロジェクトを作成する</h2><p>それでは Godot Engine を立ち上げて、新規プロジェクトを作成しよう。プロジェクトの名前はあなたのお好みで決めていただいてOKだ。もし思いつかなければ「Advanced Match3 Start」としておこう。</p><br><h3 id=プロジェクト設定を更新する>プロジェクト設定を更新する</h3><p>エディタが表示されたら、先にプロジェクト全体に関わる設定を更新しておこう。</p><p>まずはゲームのディスプレイサイズを設定する。今回はスマホの縦向きの画面を想定して、縦横の比率を <strong>16 : 9</strong> とする。</p><ol><li>「プロジェクト」メニュー＞「プロジェクト設定」を開く。</li><li>「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。</li><li>「Size」セクションで以下の項目の値を変更する。<ul><li>Width: 630</li><li>Height: 1120</li><li>Test Width: 315</li><li>Test Height: 560<br><img alt="project settings - Display - Window - Size" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img1.png></li></ul></li><li>「Stretch」セクションで以下の項目の値を変更する。<ul><li>Mode: 2d</li><li>Aspect: keep<br><img alt="project settings - Display - Window - Stretch" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img2.png></li></ul></li></ol><br><p>そのまま「プロジェクト設定」ウインドウを開いた状態で、デバッグパネルでスマホのタッチ操作をマウスで代用するための設定をする。</p><ol><li>「一般」タブで「mouse」と検索し、サイドバーの「Input Devices」＞「Pointing」を選択する。</li><li>「Emulate Touch From Mouse」の On のチェックを入れる。<br><img alt="Input Devices - Pointing - Emulate Touch From Mouse" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img3.png></li></ol><br><p>さらに「プロジェクト設定」ウインドウを開いた状態で、インプットマップにスマホのタッチ操作の相当するアクションを追加しよう。</p><ol><li>「インプットマップ」タブに切り替え、アクションに「touch」を追加する。</li><li>「touch」の操作にマウスの左クリックを追加する。<br><img alt="Inputmap - action - tap" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img4.png></li></ol><br><h3 id=アセットをダウンロードしてインポートする>アセットをダウンロードしてインポートする</h3><p>次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは「<a href=https://www.kenney.nl/assets/physics-assets target=_blank>Physics Assets</a>
」というアセットパックだ。このアセットに含まれるなんともかわいいエイリアンの顔の画像を、ゲームの盤面に並べるピースのテクスチャとして使用する。この素晴らしすぎる無料の素材に感謝せずにはいられない。</p><p>ダウンロードしたら「/physicspack/PNG/Aliens」フォルダの中のファイル名が「~_round.png」の画像だけを残して他は削除し、「Aliens」フォルダごとエディタのファイルシステムドックへドラッグしてプロジェクトにインポートしよう。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=grid-シーンを作る>Grid シーンを作る</h2><p>まずはマッチ3パズルゲームでピースが配置される盤面として、「Grid」シーンを作成しよう。</p><ol><li>「シーン」メニュー＞「新規シーン」を選択する。</li><li>「ルートノードを生成」にて「その他のノード」を選択する。</li><li>「Area2D」クラスのルートノードが生成されたら、その名前を「Grid」に変更する。</li><li>シーンを保存する。フォルダを作成して、ファイルパスを「res://Grid/Grid.tscn」としてシーンを保存する。<br><br></li></ol><h3 id=grid-シーンにノードを追加する>Grid シーンにノードを追加する</h3><p>「Grid」ルートノードに、さらにノードを追加していこう。</p><ol><li>「Grid」ルートノードに「CollisionShape2D」ノードを追加する。</li><li>「Grid」ルートノードに「Node2D」ノードを追加し、名前を「PiecesContainer」に変更する。</li><li>「Grid」ルートノードに「Timer」ノードを２つ追加し、それぞれ名前を「TouchTimer」、「WaitTimer」に変更する。</li></ol><p>ひとまず現時点でのシーンツリーは以下のようになったはずだ。<br><img alt="Scene Dock" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img5.png></p><p>続けて追加したノードを編集していこう。</p><br><h3 id=grid-シーンのノードを編集する>Grid シーンのノードを編集する</h3><h4 id=grid-area2d-ルートノード>Grid (Area2D) ルートノード</h4><p>このパズドラ風のパズルでは、盤面上でピースを自由に動かせるわけだが、盤面から動かしているピースがはみ出してはいけない。そうしないと、盤面の外側を移動させて離れたピースと入れ替えることができてしまう。このパズルゲームは、あくまで動かしているピースと隣り合ったドロップが次々に交換されていく仕様なのだ。</p><p>ルートノードを Area2D クラスにしたのは、そのシグナルを使って盤面から指（動かしているピース）がはみ出したことを検知させるためだ。検知さえできれば、あとはスクリプトで制限できる。このシーンへのスクリプトのアタッチは最後に行うので、その時にあらためてシグナルの接続を行うことにしよう。</p><p>このノードそのもののプロパティ編集は不要だ。</p><br><h4 id=collisionshape2d-ノード>CollisionShape2D ノード</h4><p>このノードは、盤面の外に指（動かしているピース）がはみ出した時にそれを検知するために利用する。インスペクターで以下の通りに各プロパティを編集しよう。</p><ul><li>Shape: 新規 RectangleShape2D リソースを適用する。<ul><li>RectangleShape2D ><ul><li>Extents: (x: 225, y: 190)<br><img alt="CollisionShape2D Properties - Shape" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img6.png></li></ul></li><li>Transform ><ul><li>Position: (x: 315, y: 840)<br><img alt="CollisionShape2D Properties - Position" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img7.png></li></ul></li></ul></li></ul><p>2D ワークスペース上では以下のようになったはずだ。<br><img alt="CollisionShape2D in 2D workspace" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img8.png></p><br><h4 id=piecescontainer-node2d-ノード>PiecesContainer (Node2D) ノード</h4><p>このノードは盤面に配置されるピースをまとめるためのノードだ。ゲーム中、スクリプトでピースのインスタンスが生成されたら全てこの「PiecesContainer」ノードの子として追加することになる。そうすることで、ピースのインスタンスがどれだけ生成されても、シーンツリー上のノードの順序を維持することができる。</p><p>特に編集が必要なプロパティはないので次へ行こう。</p><br><h4 id=touchtimer-ノード>TouchTimer ノード</h4><p>この Timer クラスのノードは、指でピースを動かし始めてからカウントダウンを始め、タイムアウトしたら、動かしていたピースが指から自動的に離れるようにするためのものだ。これにより、制限時間内でピースを並べなければならないというある種の緊張感をプレイヤーに与えることができる。今回は 5 秒間ピースを移動できる設定にする。</p><p>インスペクターで以下のように編集しよう。</p><ul><li>Wait Time: 5</li><li>One Shot: オン<br><img alt="TouchTimer properties" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img8.1.png></li></ul><br><h4 id=waittimer-ノード>WaitTimer ノード</h4><p>こちらの Timer クラスのノードは、指からピースが離れた後の、ピースのマッチング処理、マッチしたピースの削除、削除されて空いたグリッドへピースを詰めて、不足している分を追加する、という一連の流れを自動処理する際に、それぞれの処理の間に一瞬だけ間をあけるためのノードだ。</p><p>インスペクターで以下のように編集しよう。</p><ul><li>Wait Time: 0.3</li><li>One Shot: オン<br><img alt="WaitTimer properties" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img8.2.png></li></ul><br><p>以上で、「Grid」シーンの編集は完了だ。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=piece-シーンを作る>Piece シーンを作る</h2><p>次に、盤面に並べるピースとして「Piece」シーンを作成する。ただし、この「Piece」シーンはあくまで雛形で、実際にゲーム中で利用する各色のピースは、この「Piece」シーンを継承する形でのちほど用意する。</p><ol><li>「シーン」メニュー＞「新規シーン」を選択する。</li><li>「ルートノードを生成」にて「その他のシーン」を選択する。</li><li>「Area2D」クラスのルートノードが生成されたら、その名前を「Piece」に変更する。</li><li>シーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Pieces/Piece.tscn」としてシーンを保存する。<br><br></li></ol><h3 id=piece-シーンにノードを追加する>Piece シーンにノードを追加する</h3><p>続けて、「Piece」シーンに必要なノードを追加していこう。</p><ol><li>「Piece」ルートノードに「Sprite」ノードを追加する。</li><li>「Piece」ルートノードに「CollisionShape2D」ノードを追加する。</li><li>「Piece」ルートノードに「Tween」ノードを追加する。<br><br></li></ol><p>Piece シーンのシーンツリーは以下のようになったはずだ。<br><img alt="Piece scene tree" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img9.png></p><br><h3 id=piece-シーンのノードを編集する>Piece シーンのノードを編集する</h3><h4 id=piece-area2d-ルートノード>Piece (Area2D) ルートノード</h4><p>ルートノードを Area2D クラスにしたのは、動かしたいピースに指が当たった時や離れた時、ピース同士が衝突した時に、それを検知できるようにするためだ。</p><p>このノードのプロパティは編集不要だが、１つだけグループへの追加が必要だ。シーンドックで「Piece」ルートノードを選択したら、ノードドック＞グループタブを選択して、「Pieces」という名前のグループを作成して追加しよう。<br><img alt="Group Pieces" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img9.1.png><br>「Grid」シーンの方で「Grid」ルートノードには盤面からのはみ出し検知用のコリジョン形状が設定されており、これは常に全ピースと接触しているので、ピース同士との衝突を区別するために必要なグループなのだ。</p><br><h4 id=sprite-ノード>Sprite ノード</h4><p>先述の通り、「Piece」はあくまで継承元（雛形）なので、このシーンでは「Sprite」ノードの「Texture」プロパティにはリソースを敢えて適用せずそのままにしておく。継承先のシーンでそれぞれのピースの色にあった画像を適用する予定だ。</p><p>このシーンを継承する各色のピースのシーンでは「Texture」プロパティに先にインポートした KENNEY の画像を適用するが、その画像の縦横のサイズが 70 px なので、その画像の中心を右上にずらして画像の左下の角が(x: 0, y: 0)に合うように「Offset」プロパティを設定しよう。</p><ul><li>Offset:<br>Offset: (x: 35, y: -35)<br><img alt="Sprite - offset" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img10.png></li></ul><p>ピースを配置する盤面のグリッドは x 軸は左から右へ、y 軸は下から上へカウントする仕様で、かつ盤面の 1 グリッドのサイズもテクスチャのサイズに合わせて 70 px とする。ピースのテクスチャ画像の左下の角を (x: 0, y: 0) に合わせれば、「Piece」ルートノードの位置 (x: 0, y: 0) をグリッドに合わせて配置したときに、ちょうど「Sprite」の画像がグリッドに沿って配置されるというわけだ。</p><br><h4 id=collisionshape2d-ノード-1>CollisionShape2D ノード</h4><p>このノードはルートノードにコリジョン形状を付与する役目だ。ピースに指を触れたり、指を離したり、隣のピースと衝突したりするのを検知させるのに必要なノードである。コリジョン形状を縦横 70 px の Sprite の Texture にピッタリ合わせてしまうと、少しピースを動かしただけで、隣のピースとの衝突を検知してしまう。かといって、コリジョン形状が小さすぎると、指でピースに触れているつもりなのに検知されなかったり、ピースを移動させるときに、ピース同士の衝突をうまく検知できずにピースとピースの間を通り抜けてしまったりする。そこでコリジョン形状は Sprite の Texture の半分のサイズにするとちょうど良い。位置も Sprite の Texture にきれいに重なるように調整しよう。</p><ul><li>Shape: 新規 CircleShape2D リソースを適用する<ul><li>CircleShape2D:<ul><li>Radius: 17.5<br><img alt="CollisionShape2D - Shape, Radius" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img11.png></li></ul></li></ul></li><li>Transform:<ul><li>Position: x: 35, y: -35<br><img alt="CollisionShape2D - Position" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img12.png></li></ul></li></ul><p>2D ワークスペース上では以下のようになったはずだ。<br><img alt="CollisionShape2D - 2D workspace" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img13.png></p><br><h4 id=tween-ノード>Tween ノード</h4><p>このノードは、指定したノードの単一のプロパティのみをアニメーションさせることができる。今回このノードを使用するのは、ピースの位置が交換される時や、マッチして消えたピースの位置にピースを詰める時のピースの移動をアニメーションさせるためだ。</p><p>ただし、アニメーションはスクリプトで実装するので、このタイミングでのプロパティの編集は不要だ。<br><br></p><h3 id=piece-ノードにスクリプトをアタッチして編集する>Piece ノードにスクリプトをアタッチして編集する</h3><p>「Piece」ルートノードに新規スクリプトをアタッチしよう。ファイルパスを「res://Pieces/Piece.gd」としてスクリプトファイルを作成する。</p><p>ひとまずスクリプトを以下のように編集してほしい。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Piece.gd###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Area2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># プレイヤーが動かしているピースに衝突したら発信するシグナル（引数にピース自身を渡す）</span>
</span></span><span class=line><span class=cl><span class=kd>signal</span> <span class=nf>collided</span><span class=p>(</span><span class=n>self_piece</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># ピースの色を設定するプロパティ</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=p>(</span><span class=nc>String</span><span class=p>)</span> <span class=kd>var</span> <span class=n>color</span>
</span></span><span class=line><span class=cl><span class=c1># マッチした場合のフラグとなるプロパティ</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>matched</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># マッチしたピースのグループに割り振られるインデックス</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>matched_index</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=c1># プレイヤーが動かしている場合のフラグとなるプロパティ</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>held</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># ピースのテクスチャと同じオフセット</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>offset</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>(</span><span class=mi>35</span><span class=p>,</span> <span class=o>-</span><span class=mi>35</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># Spriteノードへの参照</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>sprite</span> <span class=o>=</span> <span class=nx>$Sprite</span>
</span></span><span class=line><span class=cl><span class=c1># Tweenノードへの参照</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>tween</span> <span class=o>=</span> <span class=nx>$Tween</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># メインループで毎フレーム呼ばれる組み込みメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_process</span><span class=p>(</span><span class=n>_delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># もしプレイヤーがピースを移動中だったら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>held</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピースの位置を(35, -35)ずらしてマウスに追随させる</span>
</span></span><span class=line><span class=cl>		<span class=n>position</span> <span class=o>=</span> <span class=nf>get_global_mouse_position</span><span class=p>()</span> <span class=o>-</span> <span class=n>offset</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ピースを移動させるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>move</span><span class=p>(</span><span class=n>destination</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># Tweenノードのアニメーションを設定する</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピースを0.1秒かけて現在の位置から引数destinationの位置まで移動させる</span>
</span></span><span class=line><span class=cl>	<span class=n>tween</span><span class=o>.</span><span class=nf>interpolate_property</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;position&#34;</span><span class=p>,</span> <span class=n>position</span><span class=p>,</span> <span class=n>destination</span><span class=p>,</span> <span class=o>.</span><span class=mi>1</span><span class=p>,</span> <span class=nc>Tween</span><span class=o>.</span><span class=n>TRANS_QUINT</span><span class=p>,</span> <span class=nc>Tween</span><span class=o>.</span><span class=n>EASE_IN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># Tweenノードのアニメーションを開始する</span>
</span></span><span class=line><span class=cl>	<span class=n>tween</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ピースがマッチした時に呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>make_matched</span><span class=p>(</span><span class=n>index</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># マッチのフラグを立てる</span>
</span></span><span class=line><span class=cl>	<span class=n>matched</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=c1># マッチしたグループごとのインデックス（引数index）を割り当てる</span>
</span></span><span class=line><span class=cl>	<span class=n>matched_index</span> <span class=o>=</span> <span class=n>index</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピースの色を半透明にする</span>
</span></span><span class=line><span class=cl>	<span class=n>modulate</span> <span class=o>=</span> <span class=nc>Color</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=o>.</span><span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># プレイヤーの指がピースに触れたら呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>enable_held</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># プレイヤーが動かしているフラグを立てる</span>
</span></span><span class=line><span class=cl>	<span class=n>held</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピースの色を20％透明にする</span>
</span></span><span class=line><span class=cl>	<span class=n>modulate</span> <span class=o>=</span> <span class=nc>Color</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mf>0.8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># プレイヤーが指をピースから離したら呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>disable_held</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># プレイヤーが動かしているフラグを解除する</span>
</span></span><span class=line><span class=cl>	<span class=n>held</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピースの色をデフォルトに戻す</span>
</span></span><span class=line><span class=cl>	<span class=n>modulate</span> <span class=o>=</span> <span class=nc>Color</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><br><p>続けて、ピースに別のピースが当たった時に発信されるシグナルを利用する。シーンドックで「Piece」ルートノードを選択したらノードドック＞シグナルタブで<code>area_entered(area: Area2D)</code>を、現在編集中の「Piece.gd」スクリプトに接続しよう。</p><p>プレイヤーが動かしているピースが当たったらシグナル<code>collided(self_piece)</code>を発信させたいので、自動生成されたメソッド<code>_on_Piece_area_entered(area)</code>内にそのためのコードを記述しよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Piece.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Area2Dが当たったらシグナルが発信されて呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Piece_area_entered</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># もし当たったArea2Dが「Pieces」グループ（つまりPieceのインスタンス）で...</span>
</span></span><span class=line><span class=cl>    <span class=c1># かつ、プレイヤーが動かしているピースだったら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Pieces&#34;</span><span class=p>)</span> <span class=ow>and</span> <span class=n>area</span><span class=o>.</span><span class=n>held</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 引数に自分自身のピースを渡してシグナル collided を発信する</span>
</span></span><span class=line><span class=cl>		<span class=nf>emit_signal</span><span class=p>(</span><span class=s2>&#34;collided&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>)</span>
</span></span></code></pre></div><br><p>これで「Piece.gd」スクリプトの編集は完了だ。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=piece-シーンを継承した各色のシーンを作る>Piece シーンを継承した各色のシーンを作る</h2><p>雛形となる「Piece」シーンは完成したので、それを継承したシーンをピースの色の数だけ作成していこう。ピースの色は、ベージュ、青、緑、ピンク、黄の 5 色だ。まずは「ベージュ」のドロップを例に手順を進めてみよう。</p><ol><li>「シーン」メニュー＞「新しい継承シーン」を選択する。</li><li>継承元のシーンとして「Piece.tscn」を選択する。</li><li>継承シーンが生成されたら、ルートノードの名前を「PieceBeige」に変更する。<br>*このルートノードの名前はそれぞれのドロップの色に合わせること。</li><li>シーンを一旦保存しておく。ファイルパスを「res://Pieces/PieceBeige.tscn」として保存する。</li><li>シーンドックでルートノード「PieceBeige」を選択した状態で、インスペクターで「Script Variables」の「Color」プロパティの値を「beige」とする。<br><img alt="BlueDrop - Color property" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img14.png></li><li>シーンドックで「Sprite」ノードを選択し、「Texture」プロパティに先にインポートしておいたリソース「res://Aliens/alienBeige_round.png」を適用する（ファイルシステムドックからドラッグすればOK）。<br><img alt="Sprite - Texture Region" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img15.png><br>2D ワークスペース上では以下のスクリーンショットのようになったはずだ。<br><img alt="Sprite - Texture Region" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img16.png><br>以上で、「PieceBeige」シーンは完成だ。残りの 4 色のピースについても、同様の手順でシーンを作成してほしい。なお、シーンごとに異なる部分については、以下を参考にしてほしい。</li></ol><ul><li><strong>青のピース</strong><ul><li>ルートノード名: PieceBlue</li><li>Color プロパティ: blue</li><li>Sprite > Texture プロパティ: res://Aliens/alienBlue_round.png</li><li>シーン保存時のファイルパス: res://Pieces/PieceBlue.tscn</li></ul></li><li><strong>緑のピース</strong><ul><li>ルートノード名: PieceGreen</li><li>Color プロパティ: green</li><li>Sprite > Texture プロパティ: res://Aliens/alienGreen_round.png</li><li>シーン保存時のファイルパス: res://Pieces/PieceGreen.tscn</li></ul></li><li><strong>ピンクのピース</strong><ul><li>ルートノード名: PiecePink</li><li>Color プロパティ: green</li><li>Sprite > Texture プロパティ: res://Aliens/alienPink_round.png</li><li>シーン保存時のファイルパス: res://Pieces/PiecePink.tscn</li></ul></li><li><strong>黄のピース</strong><ul><li>ルートノード名: PieceYellow</li><li>Color プロパティ: yellow</li><li>Sprite > Texture プロパティ: res://Aliens/alienYellow_round.png</li><li>シーン保存時のファイルパス: res://Pieces/PieceYellow.tscn</li></ul></li></ul><p>全部で 5 色のピースの継承シーンができたら作業完了だ。</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=grid-シーンをスクリプトで制御する>Grid シーンをスクリプトで制御する</h2><p>ここからはスクリプトをコーディングしてゲームを制御していく。コード量がやや多めなので頑張ろう。</p><p>Godot エディタで「Grid.tscn」シーンに切り替えたら、「Grid」ルートノードに新規スクリプトをアタッチしよう。ファイルパスは「res://Grid/Grid.gd」として作成する。</p><p>なお、スクリプト内のコメントには「指が触れた」または「指が離れた」と記載しているが、Godot デバッグパネル上では「マウス左ボタンを押した」または「マウス左ボタンを離した」と置き換えてほしい。</p><p>また、同じ色が３つ以上揃った状態のことを「マッチ」と表現しているので、こちらもご留意いただきたい。</p><p>では、スクリプトエディタが開いたら、まずは必要なプロパティを定義しておこう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Area2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ピースを動かして指を離した後の自動処理開始時に発信するシグナル</span>
</span></span><span class=line><span class=cl><span class=kd>signal</span> <span class=n>waiting_started</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 各色のピースのシーンファイルを要素とした配列</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>pieces_scn</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PieceBeige.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PieceBlue.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PieceGreen.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PiecePink.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PieceYellow.tscn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># x軸方向のグリッド数</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>width</span><span class=p>:</span> <span class=o>=</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=c1># y軸方向のグリッド数</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>height</span><span class=p>:</span> <span class=o>=</span> <span class=mi>6</span>
</span></span><span class=line><span class=cl><span class=c1># x軸方向のグリッド開始位置（pixel）</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>x_start</span><span class=p>:</span> <span class=o>=</span> <span class=mi>70</span>
</span></span><span class=line><span class=cl><span class=c1># y軸方向のグリッド開始位置（pixel）</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>y_start</span><span class=p>:</span> <span class=o>=</span> <span class=mi>1050</span>
</span></span><span class=line><span class=cl><span class=c1># 1グリッドのサイズ（PieceのSpriteのTextureと同じにする）</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>grid_size</span><span class=p>:</span> <span class=o>=</span> <span class=mi>70</span>
</span></span><span class=line><span class=cl><span class=c1># ピースが生成される時に何グリッドy軸方向にズラして落とすか</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>y_offset</span><span class=p>:</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 盤面のピースの配置を表す配列（二次元配列）</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>board</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=c1># プレイヤーが動かしているピースの参照</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>moving_piece</span>
</span></span><span class=line><span class=cl><span class=c1># プレイヤーが動かしているピースの最後の位置（グリッド）</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>last_pos</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ゲーム開始時の準備中のフラグ</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_initializing</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=c1># プレイヤーがピースを動かしている場合のフラグ</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_touching</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># ピース入れ替え中のフラグ</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_swapping</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># プレイヤーがピースを動かした後の自動処理中のフラグ</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># マッチしたピースのグループの数（カウントアップする）</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>matched_groups</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># PiecesContainerノードの参照</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>pieces_container</span> <span class=o>=</span> <span class=nx>$PiecesContainer</span>
</span></span><span class=line><span class=cl><span class=c1># TouchTimerノードの参照</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>touch_timer</span> <span class=o>=</span> <span class=nx>$TouchTimer</span>
</span></span><span class=line><span class=cl><span class=c1># WaitTimerノードの参照</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>wait_timer</span> <span class=o>=</span> <span class=nx>$WaitTimer</span>
</span></span></code></pre></div><br><p>続いてここからはメソッドを追加していく。なお、以下のコード内に出てくる <strong>二次元配列</strong> とは、要素として配列を格納する配列、つまり配列の配列のことだ。</p><p>今回のスクリプトで利用している二次元配列の場合、一階層目の配列では、盤面の x 軸方向のグリッドの数だけ空の配列を要素とし、二階層目としてそれぞれの配列内に縦方向のグリッド数だけ要素を格納する。その要素として、ピースオブジェクトを格納することで、それぞれのピースが盤面のどこに位置しているか（x 軸方向に何番目のグリッドで、y 軸方向に何番目のグリッドか）を管理することができるのだ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># シーンが読み込まれたら呼ばれる関数</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># ランダムな数を生成する関数の出力結果を毎回ランダムにするための組み込み関数を呼ぶ</span>
</span></span><span class=line><span class=cl>	<span class=nb>randomize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># board（配列）を盤面のグリッドを構成する二次元配列にする</span>
</span></span><span class=line><span class=cl>	<span class=n>board</span> <span class=o>=</span> <span class=nf>make_2d_array</span><span class=p>()</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピースを生成して盤面に配置して盤面情報を board に反映する</span>
</span></span><span class=line><span class=cl>	<span class=nf>spawn_pieces</span><span class=p>()</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>	<span class=n>is_initializing</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 盤面のグリッドを構成する二次元配列を生成するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>make_2d_array</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nc>Array</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># array という名前の配列を用意</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>array</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>    <span class=c1># array に x 軸方向のグリッド数だけ空の配列を入れる</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>array</span><span class=o>.</span><span class=nf>append</span><span class=p>([])</span>
</span></span><span class=line><span class=cl>        <span class=c1># さらにそれぞれの配列に y 軸方向のグリッド数だけ暫定的に null を入れる</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=kt>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># できあがった二次元配列を返す</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>array</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ピースを生成して盤面に配置して盤面情報を board に反映するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>spawn_pieces</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># x軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># y軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 全ピースの二次元配列上で該当グリッドにピースが存在しない場合</span>
</span></span><span class=line><span class=cl>            <span class=c1>#（ゲーム開始時は全部 null）</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 各色のピースのシーンからランダムで１つ選択してインスタンス化</span>
</span></span><span class=line><span class=cl>				<span class=kd>var</span> <span class=n>index</span> <span class=o>=</span> <span class=nb>floor</span><span class=p>(</span><span class=nf>rand_range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>pieces_scn</span><span class=o>.</span><span class=nf>size</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>				<span class=kd>var</span> <span class=n>piece</span> <span class=o>=</span> <span class=n>pieces_scn</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># もしゲーム開始時の準備中だったら</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=n>is_initializing</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># マッチしてしまった場合は、ピースのインスタンスを削除してやり直し</span>
</span></span><span class=line><span class=cl>					<span class=k>while</span> <span class=nf>match_at</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>piece</span><span class=o>.</span><span class=n>color</span><span class=p>):</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>						<span class=n>piece</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>						<span class=n>index</span> <span class=o>=</span> <span class=nb>floor</span><span class=p>(</span><span class=nf>rand_range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>pieces_scn</span><span class=o>.</span><span class=nf>size</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>						<span class=n>piece</span> <span class=o>=</span> <span class=n>pieces_scn</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># ピースのインスタンスをPiecesContainerノードの子にする</span>
</span></span><span class=line><span class=cl>				<span class=n>pieces_container</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>piece</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># ピースのインスタンスの collided シグナルを...</span>
</span></span><span class=line><span class=cl>                <span class=c1># _on_Piece_collided メソッド（あとで定義）に接続する</span>
</span></span><span class=line><span class=cl>				<span class=n>piece</span><span class=o>.</span><span class=nf>connect</span><span class=p>(</span><span class=s2>&#34;collided&#34;</span><span class=p>,</span> <span class=bp>self</span><span class=p>,</span> <span class=s2>&#34;_on_Piece_collided&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># ピースのインスタンスを配置位置より y_offset 分ずらして置き...</span>
</span></span><span class=line><span class=cl>                <span class=c1># そこから配置位置へ移動させる（落とす）</span>
</span></span><span class=line><span class=cl>				<span class=n>piece</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span> <span class=o>+</span> <span class=n>y_offset</span><span class=p>)</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>				<span class=n>piece</span><span class=o>.</span><span class=nf>move</span><span class=p>(</span><span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>))</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>                <span class=c1># 盤面情報として board の適切なインデックスの要素に生成したピースを追加</span>
</span></span><span class=line><span class=cl>				<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>piece</span>
</span></span></code></pre></div><br><p>上記コードの中で未定義の<code>match_at</code>メソッドと<code>grid_to_pixel</code>メソッドを定義しておこう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定したグリッド位置で同じ色ピースが３つ以上並んでいるか確認するメソッド</span>
</span></span><span class=line><span class=cl><span class=c1># 引数columnはx軸のグリッド位置、rowはy軸のグリッド位置、colorはピースの色</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>match_at</span><span class=p>(</span><span class=n>column</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>color</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 指定したグリッドの x 軸方向の位置が3以上の場合</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>column</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 指定したグリッド位置の左隣ともう一つ左隣にピースがある場合</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>column</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>row</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span> \
</span></span><span class=line><span class=cl>        <span class=ow>and</span> <span class=n>board</span><span class=p>[</span><span class=n>column</span><span class=o>-</span><span class=mi>2</span><span class=p>][</span><span class=n>row</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 左隣ともう一つ左隣のピースの色が指定したピースの色と同じ場合</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>column</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>row</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>color</span> \
</span></span><span class=line><span class=cl>            <span class=ow>and</span> <span class=n>board</span><span class=p>[</span><span class=n>column</span><span class=o>-</span><span class=mi>2</span><span class=p>][</span><span class=n>row</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># true を返す</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=c1># 指定したグリッドの y 軸方向の位置が3以上の場合</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>row</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 指定したグリッド位置の下ともう一つ下にピースがある場合</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>column</span><span class=p>][</span><span class=n>row</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span> \
</span></span><span class=line><span class=cl>        <span class=ow>and</span> <span class=n>board</span><span class=p>[</span><span class=n>column</span><span class=p>][</span><span class=n>row</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 下ともう一つ下のピースの色が指定したピースの色と同じ場合</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>column</span><span class=p>][</span><span class=n>row</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>color</span> \
</span></span><span class=line><span class=cl>            <span class=ow>and</span> <span class=n>board</span><span class=p>[</span><span class=n>column</span><span class=p>][</span><span class=n>row</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># true を返す</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># グリッドの位置をピクセルの位置に変換するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>column</span><span class=p>,</span> <span class=n>row</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nc>Vector2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 先にピクセル位置出力用に Vector2 型の変数 pixel_pos を定義</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>pixel_pos</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピクセル x 座標 = x 軸方向のグリッド開始位置 + グリッドサイズ x グリッド x 座標</span>
</span></span><span class=line><span class=cl>	<span class=n>pixel_pos</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x_start</span> <span class=o>+</span> <span class=n>grid_size</span> <span class=o>*</span> <span class=n>column</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピクセル y 座標 = y 軸方向のグリッド開始位置 - グリッドサイズ x グリッド y 座標</span>
</span></span><span class=line><span class=cl>	<span class=n>pixel_pos</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>y_start</span> <span class=o>-</span> <span class=n>grid_size</span> <span class=o>*</span> <span class=n>row</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピクセル座標を返す</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>pixel_pos</span>
</span></span></code></pre></div><p>これで、ゲーム開始時に各色のピースが盤面にランダムで並べられるはずだ。一度プロジェクトを実行して確認してみよう。なお、初めてプロジェクトを実行する場合は、メインシーン選択のダイアログが表示されるので、「Grid.tscn」をメインシーンとして選択しよう。<br><img alt="run project - distribute pieces on the grid board" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img17.png></p><br><p>ちょうど<code>grid_to_pixel</code>メソッドを定義したので、ついでにこのあと使用する<code>pixel_to_grid</code>メソッドも定義しておこう。名前の通り、先に定義した<code>grid_to_pixel</code>とは逆で、ピクセルの位置をグリッドの位置に変換するメソッドだ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ピクセルの位置をグリッドの位置に変換するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>pixel_to_grid</span><span class=p>(</span><span class=n>pixel_x</span><span class=p>,</span> <span class=n>pixel_y</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nc>Vector2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>grid_pos</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>grid_pos</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=nb>floor</span><span class=p>((</span><span class=n>pixel_x</span> <span class=o>-</span> <span class=n>x_start</span><span class=p>)</span> <span class=o>/</span> <span class=n>grid_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>grid_pos</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=nb>floor</span><span class=p>((</span><span class=n>pixel_y</span> <span class=o>-</span> <span class=n>y_start</span><span class=p>)</span> <span class=o>/</span> <span class=o>-</span><span class=n>grid_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>grid_pos</span>
</span></span></code></pre></div><br><p>さらに、もう一つこのあと使用する<code>is_in_grid</code>メソッドを定義しておく。これは引数に渡した位置が盤面グリッドの範囲内かどうかを判定してその結果を返すメソッドだ。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 指定した位置が盤面グリッドの範囲内かどうかを返すメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>is_in_grid</span><span class=p>(</span><span class=n>grid_position</span><span class=p>:</span> <span class=nc>Vector2</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=kt>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>grid_position</span><span class=o>.</span><span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>grid_position</span><span class=o>.</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>width</span> \
</span></span><span class=line><span class=cl>	<span class=ow>and</span> <span class=n>grid_position</span><span class=o>.</span><span class=n>y</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>grid_position</span><span class=o>.</span><span class=n>y</span> <span class=o>&lt;</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 盤面グリッドの範囲内だったら true を返す</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 盤面グリッドの範囲外だったら false を返す</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>ここで、ゲームのプレイヤーの入力（画面のタッチ操作）を処理するプログラムを記述していく。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ゲームのメインループで毎フレーム呼ばれる関数</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_process</span><span class=p>(</span><span class=n>_delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># もしマッチングの処理中でなければ</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=ow>not</span> <span class=n>is_waiting</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># プレイヤーの入力を処理する</span>
</span></span><span class=line><span class=cl>		<span class=nf>touch_input</span><span class=p>()</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># プレイヤーの入力を処理するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>touch_input</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># もし画面に指が触れたら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピースに触れた時の処理を実行するメソッドを呼ぶ</span>
</span></span><span class=line><span class=cl>		<span class=nf>touch_piece</span><span class=p>()</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>    <span class=c1># もし画面から指が離れたら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_released</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>)</span> <span class=ow>and</span> <span class=n>is_touching</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピースから指が離れた時の処理を実行するメソッドを呼ぶ</span>
</span></span><span class=line><span class=cl>		<span class=nf>release_piece</span><span class=p>()</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ピースに触れた時の処理を実行するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>touch_piece</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 指が触れた時のピクセル座標を取得する</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>pos</span> <span class=o>=</span> <span class=nf>get_global_mouse_position</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピクセル座標からグリッド座標に変換する</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>grid_pos</span> <span class=o>=</span> <span class=nf>pixel_to_grid</span><span class=p>(</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=n>pos</span><span class=o>.</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># もしグリッド座標が盤面の範囲内だったら</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>is_in_grid</span><span class=p>(</span><span class=n>grid_pos</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 動かしているピースの最後の位置としてグリッド座標を登録</span>
</span></span><span class=line><span class=cl>		<span class=n>last_pos</span> <span class=o>=</span> <span class=n>grid_pos</span>
</span></span><span class=line><span class=cl>        <span class=c1># 動かしているピースとしてグリッド座標に位置するピースを登録</span>
</span></span><span class=line><span class=cl>		<span class=n>moving_piece</span> <span class=o>=</span> <span class=n>board</span><span class=p>[</span><span class=n>last_pos</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>last_pos</span><span class=o>.</span><span class=n>y</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピースを動かしているフラグを立てる</span>
</span></span><span class=line><span class=cl>		<span class=n>is_touching</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=c1># 動かしているピースインスタンス自体の動かしているフラグも立てる</span>
</span></span><span class=line><span class=cl>		<span class=n>moving_piece</span><span class=o>.</span><span class=nf>enable_held</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピースを動かせる制限時間のタイマースタート</span>
</span></span><span class=line><span class=cl>		<span class=n>touch_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ピースから指が離れた時の処理を実行するメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>release_piece</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 二次元配列 board の要素から動かしていたピースを見つけたら...</span>
</span></span><span class=line><span class=cl>    <span class=c1># 動かしていたピースを盤面グリッドにきっちり収める</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=n>moving_piece</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=n>moving_piece</span><span class=o>.</span><span class=nf>move</span><span class=p>(</span><span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span>
</span></span><span class=line><span class=cl>    <span class=c1># 動かしていたピースインスタンス自体の動かしているフラグを解除する</span>
</span></span><span class=line><span class=cl>	<span class=n>moving_piece</span><span class=o>.</span><span class=nf>disable_held</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピースを動かしているフラグを解除する</span>
</span></span><span class=line><span class=cl>	<span class=n>is_touching</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピースを動かせる制限時間のタイマーストップ</span>
</span></span><span class=line><span class=cl>	<span class=n>touch_timer</span><span class=o>.</span><span class=nf>stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># このあとのマッチング自動処理開始のシグナルを発信</span>
</span></span><span class=line><span class=cl>	<span class=nf>emit_signal</span><span class=p>(</span><span class=s2>&#34;waiting_started&#34;</span><span class=p>)</span>
</span></span></code></pre></div><br><p>まだピースの交換は実装していないが、ここまでのコーディングで、指で触ったピースを移動させ、指を離したら移動しているピースが最後にいた場所にきっちり収まる動きが実装できたはずだ。一度プロジェクトを実行して確認してみよう。<br><img alt="run project - touch and release a piece" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img18.gif></p><br><p>次に定義する<code>_on_Piece_collided</code>メソッドには、すでに Piece インスタンス生成時に<code>collided</code>シグナルを接続するようコーディング済みだ。このシグナルはピースにプレイヤーが動かしているピースが当たった時に発信されるように「Piece.gd」スクリプトの方でコーディングしたことを思い出してほしい。</p><p>動かしているピースとそれに当たったピースの場所を入れ替えるメソッドを定義して、<code>_on_Piece_collided</code>の中で呼び出してみよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Piece インスタンスの collided シグナルで呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Piece_collided</span><span class=p>(</span><span class=n>self_piece</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># ピースを動かしていて、かつピース交換中でなければ</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>is_touching</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>is_swapping</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピース交換中のフラグを立てる</span>
</span></span><span class=line><span class=cl>		<span class=n>is_swapping</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピースを交換するメソッドを呼ぶ</span>
</span></span><span class=line><span class=cl>		<span class=nf>swap_pieces</span><span class=p>(</span><span class=n>self_piece</span><span class=p>)</span> <span class=c1># あとで定義</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピース交換中のフラグを解除</span>
</span></span><span class=line><span class=cl>		<span class=n>is_swapping</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 動かしているピースとそれに当たったピースの場所を入れ替えるメソッド</span>
</span></span><span class=line><span class=cl><span class=c1># 引数 collided_piece には動かしているピースに当たったピースが渡される</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>swap_pieces</span><span class=p>(</span><span class=n>collided_piece</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 当たったピースのグリッド座標を取得する。</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>collided_pos</span> <span class=o>=</span> <span class=nf>pixel_to_grid</span><span class=p>(</span><span class=n>collided_piece</span><span class=o>.</span><span class=n>position</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=n>collided_piece</span><span class=o>.</span><span class=n>position</span><span class=o>.</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 二次元配列 board 上の動かしているピースと動かしているピースが一致していれば</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>last_pos</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>last_pos</span><span class=o>.</span><span class=n>y</span><span class=p>]</span> <span class=o>==</span> <span class=n>moving_piece</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># board の動かしているピースの位置に当たったピースを入れる</span>
</span></span><span class=line><span class=cl>		<span class=n>board</span><span class=p>[</span><span class=n>last_pos</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>last_pos</span><span class=o>.</span><span class=n>y</span><span class=p>]</span> <span class=o>=</span> <span class=n>collided_piece</span>
</span></span><span class=line><span class=cl>        <span class=c1># 当たったピースを動かしているピースの最後のグリッド座標へ移動させる</span>
</span></span><span class=line><span class=cl>		<span class=n>collided_piece</span><span class=o>.</span><span class=nf>move</span><span class=p>(</span><span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>last_pos</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=n>last_pos</span><span class=o>.</span><span class=n>y</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1># board の当たったピースの位置に動かしているピースを入れる</span>
</span></span><span class=line><span class=cl>		<span class=n>board</span><span class=p>[</span><span class=n>collided_pos</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>collided_pos</span><span class=o>.</span><span class=n>y</span><span class=p>]</span> <span class=o>=</span> <span class=n>moving_piece</span>
</span></span><span class=line><span class=cl>        <span class=c1># 動かしているピースの最後の位置として当たったピースのグリッド座標を登録する</span>
</span></span><span class=line><span class=cl>		<span class=n>last_pos</span> <span class=o>=</span> <span class=n>collided_pos</span>
</span></span></code></pre></div><br><p>これでピースの交換も実装できたはずだ。では実際にプロジェクトを実行してピースを動かしてみよう。通ったルートのピースが次々と交換される動作を確認しよう。<br><img alt="run project - swapping piece" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img19.gif></p><p>さて、この時点で問題になるのは以下の2点だ。</p><ul><li>盤面の外側を自由に移動できてしまうこと</li><li>いつまでもピースをつかんでいられること</li></ul><p>これらの問題はシグナルを使って解決することができる。</p><p>Area2D クラスである「Grid」ルートノードのシグナルをスクリプトに接続しよう。コリジョン形状を盤面のサイズに調整したことを覚えているだろうか。その範囲から指（動かしているピース）が外にはみ出た場合に発信するシグナルによって<code>release_piece</code>メソッドを呼び出して、動かしていたピースが指からも離れて盤面上の最後の位置に戻るようにする。</p><p>シーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブを選択し、<code>erea_exited</code>シグナルをこのスクリプトに接続する。<br><img alt="Grid - Connect signal - area_exited" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img20.png></p><p>もう一つ、「TouchTimer」ノードのピースを動かせる制限時間がタイムアウトした時に発信されるシグナルもスクリプトに接続する。この場合も同様に、シグナルによってに<code>release_piece</code>メソッドを呼び出すようにする。<code>timeout</code>シグナルを接続しよう。<br><img alt="TouchTimer - Connect signal - timeout" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img21.png></p><p>続けて、それぞれのシグナルの接続によって生成されたメソッドを以下のように編集してほしい。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 盤面から Area2D がはみ出たときにシグナルで呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Grid_area_exited</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># はみ出た Area2D が動かしているピースの場合</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Pieces&#34;</span><span class=p>)</span> <span class=ow>and</span> <span class=n>area</span><span class=o>.</span><span class=n>held</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピースから指が離れた時の処理を実行するメソッドを呼ぶ</span>
</span></span><span class=line><span class=cl>		<span class=nf>release_piece</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># ピースを動かせる制限時間が切れたときにシグナルで呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_TouchTimer_timeout</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 移動中の場合</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>is_touching</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># ピースから指が離れた時の処理を実行するメソッドを呼ぶ</span>
</span></span><span class=line><span class=cl>		<span class=nf>release_piece</span><span class=p>()</span>
</span></span></code></pre></div><br><p>これで盤面からはみ出したら、ピースが指から離れて盤面上の最後の位置に戻るようになったはずだ。また、5秒以上ピースをつかんでいた場合も、タイマーにより、指からピースが離れて盤面上の最後のグリッド座標に収まるようになったはずだ。</p><p>それでは実際にプロジェクトを実行して動作を確認してみよう。<br><img alt="run project - signal effects" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img22.gif></p><br><p>ここからはマッチしたピースを自動的に処理するプログラムを作っていく。<code>release_piece</code>メソッドの最後に<code>emit_signal("waiting_started")</code>というコードで<code>waiting_started</code>シグナルを発信するようにしていたのだが、このシグナルをスクリプトに接続するところから始める。</p><p>シーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブで<code>waiting_started</code>シグナルをスクリプトに接続しよう。<code>_on_Grid_waiting_started</code>メソッドがスクリプトに追加されたら、そのメソッド内にマッチしたピースの自動処理を記述していく。大まかに自動処理は以下の流れになる。</p><ol><li>自動処理中のフラグを立てる</li><li>マッチしたピースが1組でもあるかチェックする。1組でもある場合は以下の処理をループする。<ol><li>全てのピースをチェックしてマッチしたピースにフラグを立てる。</li><li>フラグの立っているピースを削除する。</li><li>削除して空になったスペースへ同じ列の上のグリッドからピースを移動させて詰める。</li><li>ピースを下へ詰めたら、最後に空のスペースに新しいピースを生成する。</li></ol></li><li>マッチしたピースが1組もなくなったら自動処理中のフラグを解除する。<br><br></li></ol><p>上記の流れを段階的に実装していこう。まずは「全てのピースをチェックしてマッチしたピースにフラグを立てる」ところまで進めてみよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># releaseメソッドの最後に発信されるシグナルで呼ばれるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Grid_waiting_started</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1># 自動処理中のフラグを立てる</span>
</span></span><span class=line><span class=cl>	<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 人組でマッチしているピースが1組でもあればループし続ける</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=nf>check_matches</span><span class=p>():</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>        <span class=c1># マッチしているピースにフラグを立てるメソッドを呼ぶ</span>
</span></span><span class=line><span class=cl>		<span class=nf>find_matches</span><span class=p>()</span> <span class=c1># このあと定義</span>
</span></span><span class=line><span class=cl>        <span class=c1># WaitTimerのタイマースタート(0.3秒)</span>
</span></span><span class=line><span class=cl>		<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># WaitTimerがタイムアウトするまで待機</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 自動処理中のフラグを解除する</span>
</span></span><span class=line><span class=cl>	<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># マッチしているピースが1組でもあるかチェックするメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>check_matches</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=kt>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># 盤面の x 軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 盤面の y 軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># そのグリッド座標にピースが存在していれば</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># そのピースがマッチしていたら</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nf>match_at</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>color</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=c1># true を返す</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=c1># 1組もマッチしているピースがなければ false を返す</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># マッチしているピースにフラグを立てるメソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>find_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 盤面の x 軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 盤面の y 軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># そのグリッド座標にピースが存在していれば</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># 現在の色をそのグリッド座標のピースの色と定義する</span>
</span></span><span class=line><span class=cl>				<span class=kd>var</span> <span class=n>current_color</span> <span class=o>=</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>color</span>
</span></span><span class=line><span class=cl>                <span class=c1># もしその x 軸座標が x 軸方向のグリッド数 - 2 より小さければ</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>width</span> <span class=o>-</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># そのピースの右隣とさらにその右隣にピースが存在する場合</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span> \
</span></span><span class=line><span class=cl>					<span class=ow>and</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=c1># それらのピースの色が現在の色と同じ場合</span>
</span></span><span class=line><span class=cl>						<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>current_color</span> \
</span></span><span class=line><span class=cl>						<span class=ow>and</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>current_color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                            <span class=c1># マッチした組に割り振る番号の変数を定義</span>
</span></span><span class=line><span class=cl>							<span class=kd>var</span> <span class=n>matched_index</span><span class=p>:</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>                            <span class=c1># そのピースにすでにマッチしているフラグが立っていれば</span>
</span></span><span class=line><span class=cl>							<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                                <span class=c1># マッチした組の番号はそのピースの組の番号とする</span>
</span></span><span class=line><span class=cl>								<span class=n>matched_index</span> <span class=o>=</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched_index</span>
</span></span><span class=line><span class=cl>                            <span class=c1># そのピースにマッチしているフラグが立ってなければ</span>
</span></span><span class=line><span class=cl>							<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                                <span class=c1># マッチした組のグループ数を1増やす</span>
</span></span><span class=line><span class=cl>								<span class=n>matched_groups</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                                <span class=c1># マッチした組の番号をマッチした組のグループ数とする</span>
</span></span><span class=line><span class=cl>								<span class=n>matched_index</span> <span class=o>=</span> <span class=n>matched_groups</span>
</span></span><span class=line><span class=cl>                            <span class=c1># その座標のピースにマッチしたフラグを立て、組の番号を割り当て、半透明にする</span>
</span></span><span class=line><span class=cl>							<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>(</span><span class=n>matched_index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                            <span class=c1># その座標の右隣のピースも同様にする</span>
</span></span><span class=line><span class=cl>							<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>(</span><span class=n>matched_index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                            <span class=c1># さらにもう一つ右隣のピースも同様にする</span>
</span></span><span class=line><span class=cl>							<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>(</span><span class=n>matched_index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># y軸方向に対しても同様にする</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>height</span> <span class=o>-</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span> \
</span></span><span class=line><span class=cl>					<span class=ow>and</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>						<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>current_color</span> \
</span></span><span class=line><span class=cl>						<span class=ow>and</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>current_color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>							<span class=kd>var</span> <span class=n>matched_index</span><span class=p>:</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>							<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>								<span class=n>matched_index</span> <span class=o>=</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched_index</span>
</span></span><span class=line><span class=cl>							<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>								<span class=n>matched_groups</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>								<span class=n>matched_index</span> <span class=o>=</span> <span class=n>matched_groups</span>
</span></span><span class=line><span class=cl>							<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>(</span><span class=n>matched_index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>							<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>(</span><span class=n>matched_index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>							<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>(</span><span class=n>matched_index</span><span class=p>)</span>
</span></span></code></pre></div><p><br><br>マッチしたピースの処理のうち、マッチしているピースにフラグを立てるところまで実装した。プロジェクトを実行して、マッチしたピースが半透明になるか確認してみよう。</p><p><img alt="run project - add flag on matched pieces" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img24.gif></p><br><p>次はマッチ状態のフラグが立っているピースを削除するメソッドを定義する。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># マッチのフラグが立っているピースを削除するメソッド</span>
</span></span><span class=line><span class=cl><span class=c1># 引数 index には削除対象のマッチの組番号を渡す</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>delete_matches</span><span class=p>(</span><span class=n>index</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 盤面の x 軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 盤面の y 軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># もしそのグリッド座標にピースが存在していれば</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># もしそのグリッド座標のピースにマッチのフラグが立っていたら</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># もしそのグリッド座標のピースの組番号は削除対象の組番号と一致したら</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched_index</span> <span class=o>==</span> <span class=n>index</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=c1># そのグリッド座標のピースを解放する</span>
</span></span><span class=line><span class=cl>						<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                        <span class=c1># 二次元配列 board の該当の要素を null にする</span>
</span></span><span class=line><span class=cl>						<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=kt>null</span>
</span></span></code></pre></div><br><p><code>delete_matches</code>メソッドが定義できたので、これを<code>_on_Grid_waiting_started</code>メソッドのループの中に入れよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Grid_waiting_started</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=nf>check_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=nf>find_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>        <span class=c1># ここを追加</span>
</span></span><span class=line><span class=cl>        <span class=c1># マッチしたグループの数が0より大きければ</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>matched_groups</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># マッチしたグループの数だけループさせる</span>
</span></span><span class=line><span class=cl>            <span class=c1># 全て同時に削除せず、マッチした組ごとに削除する</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=n>index</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>matched_groups</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># マッチしたピースを削除するメソッドを呼ぶ</span>
</span></span><span class=line><span class=cl>				<span class=nf>delete_matches</span><span class=p>(</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># WaitTimerのタイマースタート(0.3秒)</span>
</span></span><span class=line><span class=cl>				<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># WaitTimerがタイムアウトするまで待機</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># マッチしたピースをすべて削除したらマッチしたグループの数を 0 に戻す</span>
</span></span><span class=line><span class=cl>			<span class=n>matched_groups</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><p><br><br>これで、マッチしたピースが半透明になったあと、削除されるところまで実装できたはずだ。プロジェクトを実行して確認してみよう。</p><p><img alt="run project - delete matched pieces" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img25.gif></p><br><p>続いて、ピースが削除されて空いたグリッドスペースに上のピースを詰める（落とす）処理を実装する。まずはメソッドから定義しよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 空いたグリッドスペースに上のピースを詰める（落とす）メソッド</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>collapse_columns</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 盤面の x 軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 盤面の y 軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># もしそのグリッド座標にピースがなければ</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># その y座標より1つ上のグリッドから残りの y軸方向のグリッド数だけループ</span>
</span></span><span class=line><span class=cl>				<span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>height</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=c1># もしそのグリッド座標にピースが存在していれば</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>!=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=c1># そのグリッド座標のピースを空いたスペースへ移動する</span>
</span></span><span class=line><span class=cl>						<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span><span class=o>.</span><span class=nf>move</span><span class=p>(</span><span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                        <span class=c1># 二次元配列 board の要素を入れ替える</span>
</span></span><span class=line><span class=cl>						<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span>
</span></span><span class=line><span class=cl>						<span class=n>board</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=kt>null</span>
</span></span><span class=line><span class=cl>                        <span class=c1># ループ終了</span>
</span></span><span class=line><span class=cl>						<span class=k>break</span>
</span></span></code></pre></div><br><p><code>collapse_columns</code>メソッドが定義できたので、これを<code>_on_Grid_waiting_started</code>メソッドのループの中に追加しよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Grid_waiting_started</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=nf>check_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=nf>find_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>matched_groups</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=n>index</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>matched_groups</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>				<span class=nf>delete_matches</span><span class=p>(</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>matched_groups</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># ここを追加</span>
</span></span><span class=line><span class=cl>        <span class=c1># 空いたグリッドスペースに上のピースを詰める（落とす）メソッドを呼ぶ</span>
</span></span><span class=line><span class=cl>		<span class=nf>collapse_columns</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># WaitTimerのタイマースタート(0.3秒)</span>
</span></span><span class=line><span class=cl>		<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># WaitTimerがタイムアウトするまで待機</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>これで、マッチして半透明になったピースが削除されたあと、その空いたスペースには上のピースが詰められる（落とされる）ようになったはずだ。プロジェクトを実行して確認してみよう。</p><p><img alt="run project - delete matched pieces" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img26.gif></p><br><p>最後に、ピースを下に詰めた後の上の空いたスペースには新しいピースを補充する必要がある。そのためのメソッドは、<code>_ready</code>関数の中でも実行している、すでに定義済みの<code>spawn_pieces</code>メソッドだ。ゲームのプレイが開始した時点では<code>is_initializing</code>プロパティは<code>false</code>になっているので、このメソッドを実行してピースが生成された時点ですでに新たなマッチが発生するかもしれない。これが期待以上のコンボを発生させ、ゲーム体験をより気持ち良く、楽しいものにしてくれるはずだ。</p><p><code>spawn_pieces</code>メソッドを<code>_on_Grid_waiting_started</code>メソッドのループの中に追加しよう。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Grid.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Grid_waiting_started</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>while</span> <span class=nf>check_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=nf>find_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>matched_groups</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=n>index</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>matched_groups</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>				<span class=nf>delete_matches</span><span class=p>(</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>matched_groups</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=nf>collapse_columns</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># ここを追加</span>
</span></span><span class=line><span class=cl>        <span class=c1># 空いたスペースにピースを生成するメソッドを呼ぶ</span>
</span></span><span class=line><span class=cl>		<span class=nf>spawn_pieces</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># WaitTimerのタイマースタート(0.3秒)</span>
</span></span><span class=line><span class=cl>		<span class=n>wait_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># WaitTimerがタイムアウトするまで待機</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=n>wait_timer</span><span class=p>,</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>これでマッチ処理のコーディングが完了だ。このチュートリアルとしても作業はここまでとなる。最後にプロジェクトを実行して、このパズルゲームの最終動作確認をして終わりにしよう。</p><p><img alt="run project - delete matched pieces" loading=lazy src=/images/tutorials/gd0013_advanced_match3/img27.gif></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=サンプルゲーム>サンプルゲーム</h2><p>今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。</p><p><div><video controls autoplay loop muted playsinline aria-label='Sample game demo' style=zgotmplz>
<source src=/images/tutorials/gd0013_advanced_match3/img28.mp4 type=video/mp4>Your browser does not support the video tag.</video></div><br><br></p><p>サンプルゲームのプロジェクトファイルは、<a href=https://github.com/msnsk/AdvancedMatch3.git target=_blank>GitHubリポジトリ</a>
に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。<br><br></p><p><strong>ゲームのルール:</strong></p><ul><li>プレイヤーがピースを動かせるのは1回につき5秒まで。5秒経過すると指から離れる。</li><li>プレイヤーが動かしているピースが盤面からはみ出すと、ピースが指から離れて、移動もそこまでとなる。</li><li>マッチしたピースの組の数だけコンボ数が上がる。プレイヤーはコンボの数だけエイリアン（敵キャラクター）を攻撃でき、パワーも上がる。</li><li>エイリアンを攻撃するとパワーの分だけHPを減らすことができ、エイリアンのHPを0にすると倒すことができる。</li><li>エイリアンは一定の間隔でプレイヤーを攻撃してくる。</li><li>プレイヤーのライフは最大10。エイリアンに攻撃されると１つ減り、10回攻撃されるとゲームオーバー。</li><li>敵を倒すごとにレベルが1上がる。レベルが上がるとプレイヤーのパワーが少しアップする一方、敵キャラクターもHPが上がり、攻撃してくる間隔も少し短くなる。</li><li>マッチしたピースの自動処理中（コンボカウント中と敵への攻撃中）は敵のタイムゲージは一時停止する。</li><li>最終的に、倒したエイリアンの数がこのゲームのスコアとなる。</li></ul><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=おわりに>おわりに</h2><p>今回のチュートリアルでは進化系マッチ3パズルゲームと銘打って、パズドラ風のパズルゲームを作った。オーソドックスなマッチ3とは違い、盤面上で一定時間ピースを自由に動かせるようにしたり、マッチしたピースが消える時も、パズドラのようにマッチした組ごとに順番に消えるようにしたりと、スクリプトのコードはやや複雑になったかもしれないが、最後まで作り切ることができただろうか。</p><p>今回のような進化系マッチ3パズルゲームを作るときのポイントをまとめておこう。</p><ul><li>最低限必要なシーンは盤面とピースの２つだけ。</li><li>雛形のピースシーンを作ってから、それを継承して各色のピースシーンを作る。</li><li>二次元配列を利用して盤面グリッドに配置するピースを管理する。</li><li>Area2Dのシグナルを利用して、以下について検知させる。<ul><li>指がピースに触れた時</li><li>指がピースから離れた時</li><li>動かしているピースと静止しているピースが当たった時</li><li>動かしているピースが盤面からはみ出した時</li></ul></li><li>フラグ用のプロパティを用意して、状態管理をする。例えば以下。<ul><li>ピースを動かしているかどうか</li><li>ピースが入れ替え中かどうか</li><li>ピースがマッチしているかどうか</li><li>マッチの自動処理中かどうか</li></ul></li><li>ピースを入れ替えるときは、画面上のピースの位置と二次元配列の要素をそれぞれ更新する必要がある。</li></ul><br><hr><h2 id=参照>参照</h2><ul><li><a href=http://kidscancode.org/godot_recipes/ui/unit_healthbar/ target=_blank>KidsCanCode: OBJECT HEALTHBARS</a></li><li><a href=http://kidscancode.org/godot_recipes/ui/heart_containers_3/ target=_blank>KidsCanCode: HEART CONTAINERS: 3 WAYS</a></li><li><a href=https://pad.gungho.jp/ target=_blank>Puzzle＆Dragons（パズル＆ドラゴンズ）</a></li></ul><hr></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る進化形マッチ 3 パズルゲーム on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Godot3%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cPuzzleGame%2cMobileGame%2cMatch3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る進化形マッチ 3 パズルゲーム on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f&title=%f0%9f%a4%96%20Godot3%20%e3%81%a7%e4%bd%9c%e3%82%8b%e9%80%b2%e5%8c%96%e5%bd%a2%e3%83%9e%e3%83%83%e3%83%81%203%20%e3%83%91%e3%82%ba%e3%83%ab%e3%82%b2%e3%83%bc%e3%83%a0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Godot3 で作る進化形マッチ 3 パズルゲーム on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fja%2ftutorials%2fgd0013_advanced_match3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/ja/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/ja/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/ja/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/ja/tags/puzzlegame/>PuzzleGame</a></li><li><a href=https://www.peanuts-code.com/ja/tags/mobilegame/>MobileGame</a></li><li><a href=https://www.peanuts-code.com/ja/tags/match3/>Match3</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/ja/tutorials/gd0014_screen_shake/><span class=title>« 前へ</span><br><span>🤖 Godot3 で作る画面揺れ</span>
</a><a class=next href=https://www.peanuts-code.com/ja/posts/post0003_how_to_avoid_frustration/><span class=title>次へ »</span><br><span>📔 ゲームの個人開発で挫折しないための方法</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/ja/>Peanuts Code</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="コピー";function s(){t.innerHTML="コピーされました!",setTimeout(()=>{t.innerHTML="コピー"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>