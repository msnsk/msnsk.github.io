[{"content":"現在、App Store の審査待ちとなります。ダウンロード可能になり次第更新いたします。 カジュアル・タイミングゲーム「もの切り侍」登場！ 今あなたの動体視力と反射神経が試される！侍を操作して、空から降ってくるあんな物やこんな物を見事空中で切ることができるか？！簡単片手操作でプレイできる、激ハマり必至の爽快カジュアル・タイミングゲーム！\nYour browser does not support the video tag. どんなゲーム？ ゲームのジャンルはいわゆるタイミングゲームになります。ゲームの各ステージでは、なんらかの落ち物（ドーナッツ、ぬいぐるみ、トマト、自転車、石像、などなど、古今東西さまざま！）が、空から降ってきます。プレイヤーのタッチ＆リリース操作で、ドット絵の侍をジャンプさせ、空中でうまく落ち物を切ることができればステージクリアとなります。\n無料でプレイできる！ 現在、App Store の審査待ちとなります。ダウンロード可能になり次第更新いたします。 ゲームのおすすめポイント 1. 簡単操作！ プレイするときの基本操作は、画面をタッチ \u0026amp; リリースするだけですので、とっても簡単です。片手でも操作しやすくなっています。\n具体的な操作は以下のようになります。\n空から物が落ちてきたら、タイミングよく画面をタッチします。すると侍がジャンプします。 そのまま画面をタッチしている間、侍は一定の高さまで上昇します。 侍の目の前まで物が落ちてきたら、すばやく指を離します。うまくタイミングを合わせることができれば落ち物を切ることができ、ステージクリアとなります。 2. 落ち物が分断された瞬間の爽快感！ 侍の剣の腕は一流なので、落ち物は切られたことにしばらく気づかないほどです。落ち物を切ったあと、z「カチャッ」と刀を鞘に納めた瞬間、落ち物は「ああ私は切られたのだ」と初めて気づくのです。細かく切り刻まれた落ち物がパッと分断される瞬間はとっても爽快です。\n3. 失敗しても何度でもすぐに挑戦できる！ 失敗は誰にでもあります。失敗したらできるだけすぐにやり直したいものです。「もの切り侍」では、失敗してもすぐに再挑戦できるので、読み込み時間や必要以上に表示される広告でストレスを感じることはないでしょう。\n4. おかしな侍のつぶやき！ 侍の生きている国や時代には存在しない物が、たくさん落ち物として召喚されます。各ステージのプレイ開始直前に、それら落ち物に対して侍が一言つぶやきます。このつぶやきがなんとも的外れで笑えます。（笑いのツボは人それぞれです。つまらなければ、遠慮なく非表示に設定してください）。\n4. 収集意欲を掻き立てる落ち物記録！ ステージをクリアするごとに、落ち物の記録が追加されます。ステージ選択画面から、過去にクリアしたステージの落ち物の情報を閲覧することができます。\n5. たっぷり遊べる全200ステージ！ レベルは1から10まであり、それぞれに20ステージ用意されているので、全部で200のステージを遊ぶことができます。最初は比較的簡単にステージをクリアできますが、レベルが上がるほど、徐々に難しくなっていきますので、やりごたえも感じていただけることでしょう。\n6. 無料ダウンロード！ 現在、App Store の審査待ちとなります。ダウンロード可能になり次第更新いたします。 プライバシーポリシー スマホゲーム「もの切り侍」のプライバシーポリシーを以下のリンク先でご確認いただけます。\nプライバシーポリシー ","permalink":"https://www.peanuts-code.com/ja/portfolio/work0001_slashing_samurai/","summary":"現在、App Store の審査待ちとなります。ダウンロード可能になり次第更新いたします。 カジュアル・タイミングゲーム「もの切り侍」登場！ 今あなたの動体視力と反射神経が試される！侍を操作して、空から降ってくるあん","title":"モバイルゲーム「もの切り侍」"},{"content":"Part 14 の今回は、ブロック崩しのブロックの種類を増やして、複数のレベル（ステージ）をデザインしていく。併せてゲームクリア画面も作成する。\nMemo: 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るブロック崩し ブロックの種類を増やす 今回用意するブロックの種類は、オーソドックスに以下の3種類とする。\nNORMAL: 1回ボールが当たったら消えるブロック（これまでと同じ仕様） HARD: 2回ボールが当たったら消えるブロック METAL: 何度当てても消えないブロック Brick.gd スクリプトを更新する ブロック用のシーンはこれまで同様「Brick.tscn」のみとし、「Brick.gd」スクリプトにプロパティとメソッドを追加することでブロックの種類を設定できるようにしていく。\nそれでは「Brick.gd」スクリプトの更新内容を見ていこう。\ntool extends StaticBody2D enum Hardness{ NORMAL, HARD, METAL, } # 追加 export (Hardness) var brick_hardness = Hardness.NORMAL setget set_color # 追加 #export (Color) var brick_color = Color(1, 1, 1, 1) setget set_color # 削除 新たに enum Hardnessを定義した。要素はブロックの種類に対応したNORMAL、HARD、METALの3つだ。\n変数brick_colorを削除し、代わりに変数brick_hardnessを定義した。この変数に先ほど定義した enumHardnessの要素を割り当てる。一旦、初期値はNORMALとしたが、exportキーワード付きで定義しているので、インスペクタドックから適宜、変更可能だ。これにより、今後いくつかのレベルシーンをデザインする際に、2D ワークスペースでブロックを配置しつつ、手軽にブロックの種類も変更できるので効率的だ。\n次にset_colorメソッドを更新した。\nfunc set_color(hardness): # 更新 brick_hardness = hardness var brick_color: Color match hardness: Hardness.METAL: brick_color = Color.darkgray Hardness.HARD: brick_color = Color.firebrick Hardness.NORMAL: brick_color = Color.white if is_inside_tree(): sprite.set_modulate(brick_color) これまでは引数はcolorだったがhardnessに変更した。元々この引数に渡していた変数brick_colorは今回削除した。代わりに、引数には変数brick_hardnessを渡すことになったので、わかりやすい引数名に変更したというわけだ。\nこのset_colorメソッドは、変数brick_hardnessのセッター関数にもなっているので、brick_hardness = hardnessを最初に記述している。\nメソッドの中で変数brick_colorを定義し、データ型をColorとした。この変数の値はこの後のmatch構文で決定される。\nmatch構文では、引数hardnessの値を判定する形にした。hardnessの値が enumNORMAL、HARD、またはMETALの場合で分岐させている。ではmatch構文で分岐した後のそれぞれのコード内容を見ていこう。\nhardnessが enumMETALだった場合：変数brick_colorにdarkgray（ダークグレー）に代入する。 hardnessが enumHARDだった場合：変数brick_colorにColor.firebrick（レンガ色）を代入する。 hardnessが enumNORMALだった場合：変数brick_colorにColor.white（白）を代入する。 ちなみにGodot 公式ドキュメント \u0026amp;gt; Color をご覧いただき、あなたのお好みの色を設定していただいてもOKだ。\nset_colorメソッドの最後のif構文は変更なしで、is_inside_treeメソッドによりシーンツリーにこのノードが存在するかどうかを判定し、存在すれば、子ノード「Sprite」の色に変数brick_colorの色を適用する。\n最後に_readyメソッドの内容を確認しよう。\nfunc _ready(): set_color(brick_hardness) # 引数を変更 modulate = Color(1, 1, 1, 1) sprite.scale = Vector2(1, 1) ほとんど変更はないが、set_colorメソッドの引数には元々、変数brick_colorを渡していた。しかし、それは今回削除し、メソッドの内容も先ほど変更したところだ。よって、引数には今回新しく定義した変数brick_hardnessを渡すのが正解だ。これにより、変数brick_hardnessの値がどのブロックの種類かによって、ゲーム開始前にブロックの色も自動的に設定される。\n複数のレベルをデザインする ここからは、先ほど作成した3種類のブロックを使って、複数のレベルをデザインしていく。\nレベルの雛形シーンを作る 「Level1.tscn」シーンの名前を「Level_base.tscn」に変更し、それをそのまま雛形として使用していく。ルートノードの名前も「Level1」から「Level」（1だけ削除）に変更しておこう。\n雛形シーンを複製してレベルのシーンを量産する レベルシーンをデザインする（ブロックの種類を選択したり、配置したりする）際、雛形を「継承」したシーンではノードの削除ができない。つまり、デザイン上、不要なブロックがあっても削除できない。継承なしでレベルシーンを量産する方法は以下の2通りある。\nファイルシステムドックで「Level_base.tscn」を右クリック＞「複製」を選択する シーンドックで「Level_base.tscn」を開き、「シーン」メニュー＞「名前を付けてシーンを保存」を選択する おそらく前者の方が手順が効率的なので、このチュートリアルではそちらで作業を進めていく。では、以下の手順を繰り返し、レベル 10 くらいまで作成していこう。\nファイルシステムドックで「Level_base.tscn」を右クリック＞「複製」を選択する\nシーンの名前を「Level_.tscn」（例：Level3.tscn）にして「複製」をクリックする\nルートノードの名前の末尾にレベルの数字を追加する（例：Level3）\nもちろん、この後のレベルシーンのデザインと並行して、都度シーンを作成しても良い。その場合は、用意した雛形シーン「Level_base.tscn」から複製するのではなく、デザイン済みのレベルシーンを複製しても構わない。お好みの手順で進めてほしい。\nそれぞれのレベルをデザインする 作成したシーンを 2D ワークスペースでデザインしていこう。基本的にここはあなたの思うようにやっていただいて問題ない。効率的にデザインするための Tips だけ説明しておく。\n2D ワークスペース上でブロック（ノード）を複数選択する場合は、shift キーを押しながらノードをクリックする。\nブロックの種類を変更する場合は、シーンドック、または 2D ワークスペース上で対象のブロックノードを選択し、インスペクタドックから「Brick Hardness」プロパティの値を変更する。複数ノードを選択していれば同時に変更可能。\nブロックを複製するときは、シーンドック、または 2D ワークスペース上で対象のブロックノードを選択し、ショートカットキー操作（ノードの削除 Windows: Ctrl + D / macOS: Cmd + D）が便利。ちなみに、複製直後は複製元のノードに完全に重なっている（positionプロパティの値が同じ）ため、複製したら移動先が決まっていなくても一旦位置を少しズラすことをお勧めする。 ブロックを削除するときは、シーンドック、または 2D ワークスペース上で対象のブロックノードを選択し、ショートカットキー操作（ノードの削除 Windows: Del / macOS: Cmd + BkSp）が便利。複数ノードを選択していれば同時に削除可能。\n実際のゲーム画面でのブロックの位置を確認したい時は、プロジェクトではなくシーンを実行する。\nレベルシーンのサンプル レベル 1 から レベル 10 までのシーンのデザインサンプルを紹介しておく。是非、あなたがレベルシーンをデザインする時の参考にしてほしい。\nレベル 1 ~ 10 のシーンのデザインを見る レベル 1：\nレベル 2：\nレベル 3：\nレベル 4：\nレベル 5：\nレベル 6：\nレベル 7：\nレベル 8：\nレベル 9：\nレベル 10：\nブロックにアニメーションとサウンドエフェクトを追加する ブロックの種類が増えたので、HARD ブロック、および METAL ブロックにボールが衝突した時のアニメーションとサウンドエフェクトを追加していこう。なお、NORMAL ブロックには今まで使用してきたアニメーションとサウンドエフェクトを使用する。\nブロックのアニメーションを追加する HARD ブロック、 METAL ブロックには NORMAL ブロック用の既存のアニメーション「collided」を複製、編集したものを割り当てていく。\nまずは「Brick.tscn」シーンを開いたら、下準備として「collided」を複製して2つの新しいアニメーションを用意しよう。以下の手順で複製できる。\nアニメーションパネルでアニメーション「collided」を選択した状態から上部の「アニメーション」をクリックする。\n表示されたメニューから「複製」を選択する。\n同じメニューから「名前の変更」を選択して、複製されたアニメーションの名前を変更する。アニメーションの名前は「hard_collided」および「metal_collided」としておこう\nここまでできたら、次は新しく用意したアニメーションをそれぞれ編集していく。\nアニメーション hard_collided の編集 まずは「hard_collided」から編集作業を進めよう。\nアニメーション「hard_collided」は、HARD ブロックにボールが当たった時に再生したい。「modulate」プロパティのトラックは、ブロックの透明度を上げていって最後に消えるアニメーションだ。これは不要なので削除しておこう。トラックの右端にあるゴミ箱アイコンをクリックすれば削除できる。\nなお、HARD ブロックにボールが当たると NORMAL ブロックに変わる仕組みをのちほど実装していく。\n「position」プロパティのトラックはそのまま残しておこう。\n「scale」プロパティのトラックは少し編集する。まず、0.2 秒のところにキーを挿入し、Value を (0.8, 0.8) にする。\n同様にして、0.4 秒のところのキーの Value は (1, 1)にする。\n再生してみると以下の GIF 画像のようになる。\n「hard_collided」の編集はこれで完了だ。\nアニメーション metal_collided の編集 次は「metal_collided」の方を編集していこう。こちらは METAL ブロックにボールが当たった時に再生するアニメーションだ。METL ブロックにボールが当たってもびくともしない様を演出したい。\nまず「position」プロパティのトラックだ。キーの挿入位置はそのままにしておこう。以下のように、それぞれのキーの Value (x, y)の絶対値を0.5を0.2に変更しよう。\n0 秒: (0.2, 0.2) 0.05秒: (-0.2, -0.2) 0.1秒: (0.2, -0.2) 0.15秒: (-0.2, 0.2) 0.2秒: (0.2, 0.2) 0.25秒: (-0.2, -0.2) 0.3秒: (0.2, -0.2) 0.35秒: (-0.2, 0.2) 0.4秒: (0, 0) 「scale」プロパティのトラックは、ブロックのサイズが変化するアニメーションだ。これはイメージに合わないので削除しておこう。\n最後に「modulate」プロパティのトラックを編集する。METAL ブロックの「無敵感」を演出するため、ブロックの色を立て続けに一瞬間ごとに切り替えるアニメーションを作成する。これには「modulate」プロパティのトラックに短い間隔で複数キーを挿入し、それぞれのキーの Value に虹色の構成色を順番に割り当てるようにして編集していく。具体的な手順は以下の通りだ。\n0 秒: #dfff0000 0.05秒: #dfff9b00 0.1秒: #dffdff00 0.15秒: #df00ff10 0.2秒: #df00fff9 0.25秒: #df007cff 0.3秒: #df4400ff 0.35秒: #dfcd00ff 0.4秒: #a8a8a8（METAL ブロックのデフォルトの色 darkgray と同じ） これでアニメーションの作成は完了だ。\nサウンドエフェクトを追加する 次は HARD ブロック、METAL ブロックにボールが衝突した時のサウンドエフェクトを追加していく。\nサウンドエフェクトファイルをファイルシステムに追加する 今回も「Bfxr」アプリケーションを使用して、サウンドエフェクトのファイルを用意した。Dropbox に追加しているので必要に応じてダウンロードしてほしい。\nMemo: 以下のリンク先のフォルダから「brick_collided_hard.wav」および「brick_collided_metal.wav」ファイルをダウンロードいただけます。\nDropbox の sounds フォルダ サウンドエフェクトのファイルが用意できたら、Godot のファイルシステムドックへドラッグ\u0026amp;ドロップして追加しよう。\nAudioStreamPlayer ノードを追加・編集する 「Brick.tscn」シーンを引き続き編集していく。\nルートノード「Brick」に「AudioStreamPlayer」クラスのノードを2つ追加し、それぞれの名前を「HardCollideSound」「MetalCollideSound」とする。\n「HardCollideSound」ノードの「Stream」プロパティに、先ほどファイルシステムに追加した「brick_collided_hard.wav」を適用する。\n同様に「MetalCollideSound」ノードの「Stream」プロパティには、「brick_collided_metal.wav」を適用する。\nこれでサウンドエフェクトに必要なノードの追加と編集は完了だ。\nBall.gd スクリプトを更新する 「Ball.gd」スクリプトを編集していこう。追加する内容は、主にボールがブロックに衝突した時のブロックの種類による条件分岐と、分岐後のアニメーション、サウンドエフェクトの再生だ。\n今回の編集の対象となるのは、スクリプト内の_on_Ball_body_enteredメソッドのみだ。このメソッドは、ボールがいずれかの物理オブジェクトと衝突した時に発信されるシグナルbody_enteredによって呼ばれる。よって、基本的には衝突したオブジェクトがブロックだった場合のコード、つまりif body.is_in_group(\u0026quot;Bricks\u0026quot;): のブロック内のコードを更新していけば良い。\nでは具体的に更新した_on_Ball_body_enteredメソッドを見てみよう。\nfunc _on_Ball_body_entered(body): ball_speed += speed_up direction = linear_velocity.normalized() velocity = direction * min(ball_speed, MAX_SPEED) if body.is_in_group(\u0026#34;Bricks\u0026#34;): # 大幅に更新 var collide_sound # 追加 var animation = body.get_node(\u0026#34;AnimationPlayer\u0026#34;) match body.brick_hardness: # 追加 body.Hardness.METAL: collide_sound = body.get_node(\u0026#34;MetalCollideSound\u0026#34;) collide_sound.play() animation.play(\u0026#34;metal_collided\u0026#34;) body.Hardness.HARD: collide_sound = body.get_node(\u0026#34;HardCollideSound\u0026#34;) collide_sound.play() animation.play(\u0026#34;hard_collided\u0026#34;) body.brick_hardness = body.Hardness.NORMAL body.Hardness.NORMAL: collide_sound = body.get_node(\u0026#34;CollideSound\u0026#34;) collide_sound.play() animation.play(\u0026#34;collided\u0026#34;) yield(animation, \u0026#34;animation_finished\u0026#34;) body.queue_free() #（後略） if body.is_in_group(\u0026quot;Bricks\u0026quot;): のブロック内で二つの変数を定義している。\nまず一つ目の変数collide_soundには「AudioStreamPlayer」クラスのノードを値として入れる予定だが、定義した時点ではまだ何も値を入れていない。このクラスのノードがブロックの種類に合わせて3つ存在するからだ。のちほどmatch構文でブロックの種類によって分岐させ、それぞれの条件下で適切なノードを参照させる。\n変数animationはこれまで同様Brickノードの子ノードAnimationPlayerを参照している。サウンドエフェクトと異なり、一つのAnimationPlayerノードで複数のアニメーションを実行できる。\nmatch構文だが、Brickシーンの変数brick_hardnessの値によって分岐させている。\nまずbrick_hardnessがHardness.METALだった場合（つまり、ブロックの種類が METAL だった場合）、変数collide_soundには「MetalCollideSound」ノードを参照させ、playメソッドにより METAL ブロック用のサウンドエフェクトを再生する。続けて、アニメーションmetal_collidedを再生する。\n次にbrick_hardnessがHardness.HARDだった場合、変数collide_soundには「HardCollideSound」ノードを参照させ、HARD ブロック用のサウンドエフェクトを再生する。続けて、アニメーションhard_collidedを再生する。その後body.brick_hardness = body.Hardness.NORMALのコードにより、ブロックの種類を HARD から NORMAL に変更する。これによって、セッターのset_colorメソッドが呼ばれ、スプライトの色も NORMAL ブロックの白に切り替わる。これで HARD ブロックは、ボールが 2 回衝突すると消える仕組みができた。\n最後にbrick_hardnessがHardness.NORMALだった場合だが、この分岐後のコードはこれまでボールがブロックに衝突した時に実行されていたものと全く同じである。\n以上で「Ball.gd」スクリプトの更新は完了だ。\nGame.gd スクリプトを更新する 次にゲーム全体に関わる制御を実装していく。\n変更を加えるのは、「Game.gd」スクリプト内の_on_Brick_tree_exitedメソッドだ。このメソッドはブロックが消えた時に毎回発信されるシグナルtree_exitedによって呼ばれる。\nfunc _on_Brick_tree_exited(brick_position): # Update Score score += POINT * bonus_rate bonus_rate += 0.1 hud_score.text = \u0026#34;Score: \u0026#34; + str(score) # Exit current Level node var no_brick = true # 追加 for child in level.get_children(): # 追加 if child.brick_hardness != child.Hardness.METAL: # 追加 no_brick = false break #if level.get_child_count() \u0026lt;= 0: # 削除 if no_brick: # 追加 set_next_level() else: # Drop powerup item drop_powerup(brick_position) #（後略） まず、no_brickという変数を bool 値trueで定義した。NORMAL ブロックまたは HARD ブロックのオブジェクトが一つも無い状態がtrue、一つでもあればfalseとなる。現在のレベルの「Level」ノードの子ノード（「Brick.tscn」シーンのインスタンス）全てに対してforループを回していく。ループ内のif構文の条件は「もしそのブロックが METAL ではなかったら」と定義している。これに当てはまる場合、NORAML または HARD のブロックが存在することになるので、変数no_brickの値をfalseとして、breakでループを抜ける。一方、NORMAL も HARD も存在しない場合は、変数no_brickは初期値のtrueのままでforループを終える。\n次に、これまでは「Level」ノードに子ノード（つまり「Brick.tscn」のインスタンスノード）がなくなったら、という条件で次のレベルに切り替えていたが、それを意味するif level.get_child_count() \u0026lt;= 0:というコードは今回削除した。その代わりに METAL を除くブロックが全てなくなっていることを示すno_brickがtrueの場合に次のレベルに切り替えるように記述した。\nこれで「Game.gd」スクリプトの編集は完了だ。\nゲームクリア画面を作る ゲームクリアシーンを作る すべてのレベルをクリアした時に表示されるゲームクリア画面を作成しておこう。表示する内容はゲームオーバー画面とあまり変わらないため、「GameOverView.tscn」を複製する形で用意しよう。\nシーンができたら、いくつかのノードの名前に「GameOver」の文言が含まれるので、それを「GameClear」に変更していく。具体的には以下のノードだ。\n「GameOverView」＞「GameClearView」 「GameOverLabel」＞「GameClearLabel」 「GameOverBGM」＞「GameClearBGM」 名前編集後、シーンツリーは以下のようになっているはずだ。\nゲームオーバー画面のラベルがそのまま残っているので、修正する。まず、シーンドックで「GameClearLabel」ノードを選択したら、インスペクタドックで「Text」プロパティを「game clear」に書き換える。\nそして、「Custom Color」＞「Font Color」プロパティの値（色）を「00ff88」（緑色）に変更する。ゲームオーバーの時の色が赤だったので、補色の関係にした。\nゲームクリア画面で流れるBGMを追加する ゲームクリア画面での BGM も追加しておこう。\n今回も魔王魂さん にお世話になった。使用させて頂いたのは「オーケストラ02 」という BGM だ。明るい雰囲気の BGM なのでゲームクリアのタイミングで流れると雰囲気としてはマッチしそうだ。ゲームに使用している BGM に一貫性がないが大目に見て欲しい。もちろん、別の BGM を選んでも良いし、ご自身で作成していただいても構わない。特にこだわりがなければ、リンクからこのチュートリアルと同じ BGM をダウンロードしてしまおう。こちらのファイルは取り扱いのルール上 Dropbox にはアップロードしていないのでご了承いただきたい。\nゲームクリア画面用の BGM のファイルが用意できたら、名前を「bgm_game_clear.ogg」などとして、Godot のファイルシステムドックへドラッグ\u0026amp;ドロップして追加しよう。\nファイルシステムに BGM ファイルを追加できたら、シーンドックで「GameClearBGM」ノード（「AudioStreamPlayer」クラス）を選択し、そのファイルをインスペクタドックの「Stream」プロパティめがけてドラッグ\u0026amp;ドロップする。これで既存の「GameOverView.tscn」で使用していた BGM ファイルが置き換えられる。\n「GameOverView.tscn」を複製したので、「Pitch Scale」プロパティが0.8になったままのはずだ。これをデフォルトの1に戻しておこう。\nすべてのレベルをクリアしたらゲームクリア画面に遷移させる 用意しているすべてのレベルをクリアしたらゲームクリア画面に切り替わるように、スクリプトを編集する。編集する対象は「Game.gd」スクリプトだ。なお「GameClearView」ノードにアタッチされているスクリプト「GameOverView.gd」はそのままで問題ない。\nこのスクリプトのset_next_levelメソッドを以下のように編集する。\nfunc set_next_level(): print(\u0026#34;set_next_level() called\u0026#34;) # Change status is_playing = false is_multiple_on = false is_laser_on = false # Clear left objects level.queue_free() for child in get_children(): if child.is_in_group(\u0026#34;Balls\u0026#34;) or child.is_in_group(\u0026#34;Lasers\u0026#34;): child.queue_free() # Save data save_data() # 追加 # Increment level number level_num += 1 # If no more level, game clear if ResourceLoader.exists(\u0026#34;res://scene/Level\u0026#34; + str(level_num) + \u0026#34;.tscn\u0026#34;): # 追加 # Stop PauseScreen node pause_screen.pause_mode = 1 # Show NextScreen node next_screen.pause_mode = 2 next_screen_level.text = \u0026#34;Level: \u0026#34; + str(level_num) next_screen_score.text = \u0026#34;Score: \u0026#34; + str(score) next_screen_life.text = \u0026#34;x \u0026#34; + str(life) next_screen.show() # Set Level of HUD the next level hud_level.text = \u0026#34;Level: \u0026#34; + str(level_num) # Set next Level node add_new_level() # Pause game until NextScreen is hidden get_tree().paused = true else: get_tree().change_scene(\u0026#34;res://scene/GameClearView.tscn\u0026#34;) print(\u0026#34;no more level!\u0026#34;) 編集したのは「# 追加」とコメントを記載している箇所だ。\nまずsave_dataメソッドをlevel_num += 1のコードの前に追加した。レベルクリア時点で毎回データを保存するようにした形だ。変数level_numに1を加算する前（レベルの数字が1上がる前）に、last_levelとhigh_levelのデータを保存する必要があるため、この位置に挿入した。\nもう一つ追加したのがlevel_num += 1のコードのすぐあとのif / else構文だ。GDScript にはResourceLoaderというクラスがあり、そのexistsメソッドを利用して、引数で渡したファイルパスに該当するリソースが存在するかどうかを確認できる。戻り値がtrueであれば存在し、falseであれば存在しない、ということになる。したがって、上記のスクリプトでは、次のレベルの .tscn ファイルが存在すれば、今まで通り次のレベルへの切り替え処理を行い、存在しなければ、最後のレベルをクリアしたとして、change_sceneメソッドでゲームクリア画面へ遷移するようになっている。\nところで上述の通り、set_next_levelメソッド内にsave_dataメソッドを追加したが、データを保存する前にハイスコア、ハイレベルを更新する必要がある。そこで_on_Ball_tree_exitedメソッドから、ハイスコア、ハイレベルを更新する 4 行のコードをsave_dataメソッド内へ移動させることにする。\nfunc _on_Ball_tree_exited(): #（中略） if no_ball: if is_playing: life -= 1 if life \u0026lt;= 0: #\tif high_score \u0026lt; score: # 削除 #\thigh_score = score #\tif high_level_num \u0026lt; level_num: # 削除 #\thigh_level_num = level_num save_data() get_tree().change_scene(\u0026#34;res://scene/GameOverView.tscn\u0026#34;) #（後略） func save_data(): if high_score \u0026lt; score: # 追加 high_score = score if high_level_num \u0026lt; level_num: # 追加 high_level_num = level_num var data = { \u0026#34;last_level\u0026#34;: level_num, \u0026#34;high_level\u0026#34;: high_level_num, \u0026#34;last_score\u0026#34;: score, \u0026#34;high_score\u0026#34;: high_score, } var file = File.new() file.open(SCORE_FILE_PATH, File.WRITE) file.store_line(to_json(data)) file.close() これでsave_dataメソッドを実行するだけで、必ずハイスコア、ハイレベルのデータが最新の状態で保存されるようになった。\n以上でゲームクリア画面の作成は完了だ。\nそれでは、このあとデバッグしやすくなるように、変数level_numにexportキーワードを付けて、インスペクタで値を変更可能にしておこう。\nexport var level_num: int = 1 # 変更 さっそく「Game」ノードを選択して、インスペクタから「Level Num」プロパティの値をあなたが作った最後のレベルの数字に変更しよう。このチュートリアルのサンプルはレベル 10 までなので、プロパティの値は10に変更した。\nさらに「Game.gd」スクリプトの_readyメソッド内も、デバッグ用に更新する。\nfunc _ready(): randomize() add_new_level() add_new_ball() update_hud_life() load_data() # For debug leave_one_brick(73) # 変更 leave_one_brickメソッドのコメントアウトを解除し、引数には、すぐにボール当てられるブロックのノード名の末尾の数字を渡そう。例として、このチュートリアルでサンプルとして作成したレベル 10 のシーンでは73を指定して、「Brick73」ノードのみを残すようにした。あなたの作った最後のレベルシーンのノードを確認して適切な値を入れて欲しい。\nでは、プロジェクトを実行して挙動を確認しよう。チェックする内容は以下の通りだ。\n最後のレベルをクリアしたらゲームクリア画面に遷移するか 正しいスコアが表示されるか ゲームクリア画面でキーを押下してスタート画面に戻るか エラーの対応、バグの修正 先ほどプロジェクトを実行した時、ゲームクリア画面に遷移するタイミングで以下のようなエラーが出力された。\nResumed function \u0026rsquo;enable_multiple_balls()\u0026rsquo; after yield, but script is gone. At script: res://scripts/Game.gd:211\n上記エラーはパワーアップ「Multiple」を発動するメソッドenable_multiple_ballsに関する内容だが、他に「Expand」や「Laser」でも同様のエラーが出てしまう状況だ。\nこれはパワーアップアイテムの有効時間を表すタイマーが切れる前に、シーンを「GameClearView.tscn」に切り替えたことが原因だ。「Game.gd」スクリプトでは、yield関数によって各パワーアップのタイマーがtimeoutシグナルを発信するまで待機しており、timeoutしてメソッドが Resume（再開）される時にはすでにシーンが切り替わって「Game.gd」スクリプトがないため、次のコードを読み込めずエラーを吐いている。\nこれを修正するにはどうやらyieldの使用を止める必要がありそうだ。代わりにTimerクラスのインスタンスを用意して、同様の処理を行っていく。\nでは「Game.gd」スクリプトを修正していこう。\nまずは変数を3つ追加する。\nvar expand_timer = Timer.new() # 追加 var multiple_timer = Timer.new() # 追加 var laser_timer = Timer.new() # 追加 「Expand」「Multiple」「Laser」それぞれのパワーアップが有効になった時にカウント開始する3つのタイマーだ。Timerクラスのノード生成して変数に代入している。これらのタイマーは繰り返し使用することになる。\n次に_readyメソッドだ。\nfunc _ready(): randomize() add_new_level() add_new_ball() update_hud_life() load_data() set_timer(expand_timer, \u0026#34;stop_expand\u0026#34;) # 追加 set_timer(multiple_timer, \u0026#34;stop_multiple\u0026#34;) # 追加 set_timer(laser_timer, \u0026#34;stop_laser\u0026#34;) # 追加 leave_one_brick(73) 「# 追加」とコメントしている３行を追加した。その３行で実行されているset_timerメソッドはこのあと定義しているので見ていこう。\nfunc set_timer(timer_var, stop_func): add_child(timer_var) timer_var.connect(\u0026#34;timeout\u0026#34;, self, stop_func) 必要な引数は2つ。1つ目がタイマーの変数、2つ目がタイマーを止めるメソッド名。なお、その2つ目の引数に入れるメソッドはのちほど定義する。\nメソッドの内容は、まずadd_childメソッドにて、タイマーをこのスクリプトがアタッチされている「Game」ノードの子ノードに追加する。続いて、connectメソッドにより、タイマーのtimeoutシグナルをstop_funcに接続する。\n続いて、それぞれのパワーアップを発動するメソッドの修正と、タイマーを停止するメソッドの定義を行っていく。\nまずはパワーアップ「Expand」に関わるメソッドを見てみよう。\nfunc expand_paddle(): expand_collide_sound.play() if paddle.scale \u0026lt;= paddle_scale: paddle.scale.x *= 2 #yield(get_tree().create_timer(3), \u0026#34;timeout\u0026#34;) # 削除 #paddle.scale = paddle_scale # 削除 expand_timer.wait_time = 10 # 追加 expand_timer.start() # 追加 func stop_expand(): # 追加 expand_timer.stop() paddle.scale = paddle_scale expand_paddleメソッドから、yield関数とpaddle.scale = paddle_scaleのコードを削除した。一方、タイマーの時間をセットするためにwait_timeプロパティに10秒を指定している。続けてタイマーをスタートさせるために変数startメソッドを実行させている。\nさらにタイマーを止めるためのメソッドとしてstop_expandを新たに定義した。このstop_expandメソッドには_readyメソッド内でtimeoutシグナルが接続されているので、タイマーの待機時間が0になったら呼ばれる。呼ばれたらexpand_timer.stop()が実行されて、タイマーが止まる。併せてexpand_paddleメソッドから移動したpaddle.scale = paddle_scaleのコードによりパドルの長さを初期値に戻している。\n「Multiple」および「Laser」に関しても同様の更新を行った。コードは以下の通りだ。\nfunc enable_multiple_balls(): multiple_collide_sound.play() if not is_multiple_on: is_multiple_on = true #yield(get_tree().create_timer(3), \u0026#34;timeout\u0026#34;) # 削除 #is_multiple_on = false # 削除 multiple_timer.wait_time = 3 # 追加 multiple_timer.start() # 追加 func stop_multiple(): # 追加 multiple_timer.stop() is_multiple_on = false func enable_laser(): laser_collide_sound.play() if not is_laser_on: is_laser_on = true #yield(get_tree().create_timer(3), \u0026#34;timeout\u0026#34;) # 削除 #is_laser_on = false # 削除 laser_timer.wait_time = 3 # 追加 laser_timer.start() # 追加 func stop_laser(): # 追加 laser_timer.stop() is_laser_on = false 最後にset_next_levelメソッドも更新する。\nfunc set_next_level(): print(\u0026#34;set_next_level() called\u0026#34;) # Change status is_playing = false #is_multiple_on = false # 削除 #is_laser_on = false # 削除 stop_expand() # 追加 stop_multiple() # 追加 stop_laser() # 追加 #（後略） このset_next_levelメソッドが呼ばれるのは、各レベルをクリアしたタイミングだ。その時、もしまだパワーアップ「Expand」「Multiple」「Laser」が有効だったら、タイマーもカウントダウン中なので、それをストップさせるのにstop_expand、stop_multiple、stop_laserメソッドを追加した。\nis_multiple_on = falseとis_laser_on = falseのコードは、それぞれstop_multipleメソッドとstop_laserメソッドの中に記述されていて不要になったので削除した。\n少々コード量が増えてしまったが、これで仕組みはほぼそのままで、yieldに関わるエラーが解消されたはずだ。\nあとは、デバッガパネルに黄色丸 🟡 で表示されるエラー（アラート）のうち、引数があるのに一度も使ってなくて怒られているものは、引数名の前にアンダースコアを付けて対処しよう。デバッガパネルのエラーをクリックすると、スクリプトパネルでスクリプトの該当箇所を表示してくれる。\nThe argument \u0026rsquo;event\u0026rsquo; is never used in the function \u0026lsquo;_input\u0026rsquo;. If this is intended, prefix it with an underscore: \u0026lsquo;_event\u0026rsquo;\n例えば「NextScreen.gd」スクリプトの_inputメソッドの引数を(event)から(_event)に変更する。\nfunc _input(_event): #（後略） 一方、デバッガパネルに黄色丸 🟡 で表示されるエラー（アラート）のうち、戻り値があるのに一度も使ってなくて怒られているものは、変数に代入することでも対処可能だが、このブロック崩しのチュートリアルではそのままにしておく。\nThe function \u0026lsquo;change_scene()\u0026rsquo; returns a value, but this value is never used.\n現時点で確認できているバグも修正しておこう。\nあまり気にならないので見逃していたが、「Ball.gd」スクリプトの変数ball_speedに、first_speedのデフォルトの値でしか代入されない問題があった。これはインスペクタドックで「First Speed」プロパティの値を、例えば、50にしてみても、実際にゲームのプレイ開始時はデフォルトの150になってしまうというものだ。\nonready var ball_speed = first_speed # 変更 このようにonreadyキーワードを付けてあげると、first_speedがインスペクタで指定した値に更新されてからball_speedに代入されるので、問題が解消する。\nもう一つバグも修正する。\nハイレベルは10が最大のはずが、18 や 20、31 などはるかに大きい数値が記録されるバグが見つかった。実は先のGIF画像のゲームクリア画面でもそのような結果になっている。\n確認すると、最後のブロックを消したあと、「Game.gd」スクリプト内のset_next_levelメソッドが複数回呼ばれ、そのメソッド内で変数level_numに1が加算されて、値が大きくなることがわかった。これは、最後のブロックを消したあと、残っている METAL ブロックが自動的に消される時に、その残っている数だけlevel_numの数値が大きくなっていのが原因だった。\nそこで「Game.gd」スクリプト内のadd_new_levelメソッドで、METALブロックは_on_Brick_tree_exitedメソッドにシグナルを接続しないようにすることで解決できる。シグナルを接続しなければ、METAL ブロックが最後にいくつ残っていても_on_Brick_tree_exitedメソッドが呼ばれることはなく、その結果set_next_levelメソッドが複数回呼ばれることもなくなる、というわけだ。\nメソッドは以下のように編集した。\nfunc add_new_level(): level = load(\u0026#34;res://scene/Level\u0026#34; + str(level_num) + \u0026#34;.tscn\u0026#34;).instance() add_child(level) move_child(level, 3) for child in level.get_children(): if child.brick_hardness != child.Hardness.METAL: # 追加 child.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;_on_Brick_tree_exited\u0026#34;, [child.global_position]) 以上で、現状見つかっているバグの修正は完了だ。\nゲームバランスに関わる定数、変数の値の見直し 最後にゲームバランスを整えるために、いくつかの定数、変数の値を更新していく。\nGame.gd スクリプト 「Game.gd」スクリプトでは以下のように変更した。\nconst POINT = 10 一つのブロックを消して100ポイントも得られると、ボーナスも合わさってすぐに桁数が大きくなってしまうので一桁減らした。\nBall.gd スクリプト 「Ball.gd」スクリプトでは以下のように変更した。\nexport (float) var first_speed = 120.0 export (float) var speed_up = 1.0 難易度が高すぎたので、最初のスピードをもっと落として、スピードアップのテンポも落とした。\nPaddle.gd スクリプト 「Paddle.gd」スクリプトでは以下のように変更した。\nexport (int) var speed = 300 ボールが最高速度300になってもプレイヤーのテクニックさえあればついていけるようにパドルの速度を上げた。\n自分で作ったレベルをプレイしてみる せっかく色々なレベルをデザインしたので自分でも遊んでみよう。\nこのチュートリアルでサンプルとして作ったレベルのうち、レベル9はパワーアップアイテムの内容によってはなかなか厳しいステージだった。レベル10と順番が逆ではないかと思うほどだ。\n実際にプレイしてみて、難易度が想像と違った場合は、レベルのデザイン自体を変更しても良いし、レベルの順番を変えても良い。一プレイヤー目線で、どこが良くてどこがダメなのか感じながらプレイし、その体感を自分へのフィードバックとして一つずつ改善に役立てるようにすると、ゲームがより良くなっていくだろう。\nおわりに 以上で Part 14 は完了だ。今回はブロックの種類を増やし、それを利用してレベルを複数デザインした。ついでにゲームクリア画面も用意し、ブロック崩しゲームとしてひとまず形にすることができた。\n次回 Part 15 は、ゲームの書き出し作業に関するチュートリアルだ。そして、次回がこのブロック崩しのチュートリアルの最終回となる。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0004_breakout/breakout_14/","summary":"Part 14 の今回は、ブロック崩しのブロックの種類を増やして、複数のレベル（ステージ）をデザインしていく。併せてゲームクリア画面も作成する。 Memo: 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただ","title":"Godot で作るブロック崩し Part 14：ブロックの種類を増やしてレベルをデザインしよう！"},{"content":"このチュートリアルシリーズでは、スーパーマリオのような横スクロールアクションゲーム、いわゆる「プラットフォーマー」というジャンルのゲームを作っていく。今回は、初回ということで、ゲームのプレイ画面にプレイヤーキャラクターを用意して操作するところまでやってみよう。\nMemo: ゲームを作り始めるのに以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 Godot で作るブロック崩しシリーズ 新規プロジェクトを作る 右側の「新規プロジェクト」ボタンをクリックする。\nプロジェクトを保存したい場所を選択して、右上の「フォルダーを作成」をクリックしてプロジェクトのフォルダ名を入力して「OK」をクリックする。ここではシンプルに「Platformer」と名付けたが、実際に自分のオリジナルのゲームを開発するときは仮でも独自の名前を設定しよう。\n「現在のフォルダーを選択」をクリックする。\nレンダラーには「OpenGL ES3.0」を選択して「作成して編集」をクリックする。Webブラウザで動くようなゲームを開発する場合はレンダラーに「OpenGL ES 2.0」を選択するが、このチュートリアルでは PC ゲームを想定しているので、これで良い。\nこれでエディターの初期画面が表示された。\nアセットファイルを取り込む まずはプロジェクトに必要なキャラクターや背景の画像ファイル一式（アセット）をまとめて準備しておこう。\nただし、このまま画像のインポートをすると、ドット絵（Pixel Art）の場合、特有のエッジが効いた画像ではなく、ぼやけた感じの画像に補正されてしまう。これを避けるために、事前準備として、インポートのデフォルトの設定を変更する。\n具体的には、Godot エディタ左上の「インポート」ドックを開き、「プリセット」ボタンをクリックしたら「2D Pixel」を選択する。\n同様に「プリセット」を開き、「\u0026lsquo;Texture\u0026rsquo;のデフォルトとして設定」を選択する。\nこれでインポートの必要な設定変更ができたので、下記のリンクからアセットをまとめてダウンロードしよう。\nDownload Assets: 1. Dropboxの共有フォルダ \u0026amp;gt; Assets.zip 2. アセット1: Pixel Adventure 3. アセット2: Pixel Adventure 2 1 は、このチュートリアルのために 2、3 でダウンロードしたファイルを一つにまとめたものです。2、3で直接ダウンロードする場合、制作者の方に寄付したり、作品に高評価をつけたりすることで、結果制作活動を応援することができます。ここで取り扱っているアセットファイルは Creative Commons Zero (CC0) ライセンスの下でリリースされています。ライセンスについて詳しくはこちら をご覧ください。\nダウンロードしたアセットファイルをまとめた「Assets」フォルダを丸ごと、ファイルシステム上の「res://」フォルダ直下にドラッグ\u0026amp;ドロップして取り込む。\nゲームのウインドウサイズを設定する 事前準備がもう少しある。実際にゲームをプレイする時のウインドウサイズを設定しておこう。\n「プロジェクト」メニュー＞「プロジェクト設定」を選択する。\n「一般」タブを開いた状態で、「検索」ボタンをクリックして「window」と検索しよう。すると「Display」カテゴリの「Window」という項目が見つかるはずだ。これを選択してウインドウサイズを設定する。\n「Size」セクションの「Width（幅）」と「Height（高さ）」を 384 x 256 px に設定する。これから使用するキャラクターのスプライトの画像が 32 x 32 px なので、32 で割り切れるサイズにした。\n続けて「Stretch」セクションの「Mode」を「2d」に変更し、「Aspect（縦横比）」を「keep」にしておこう。\nLevel1 シーンを作る レベルというと、日本ではRPGのキャラクターの成長を表す指標としてよく用いられる単語だが、海外のゲームの場合、日本のアクションゲームやシューティングゲームで階層を表す「ステージ」に相当する単語として用いられる。海外のスタンダードにも慣れておきたいので、このチュートリアルでも「ステージ」ではなく「レベル」という単語を使用していく。\nさっそくだが、まずは最初のレベルである「Level1」のシーンを作っていく。\nプロジェクトを作ってすぐの画面では、左側のシーンドックでルートノードを生成できる。ここでは「2D シーン」を選択しよう。これを選択すると「Node2D」クラスのノードがルートノードとして作られる。\nNode2D ノードの名前を「Level1」に変更しよう。\nそのまま「シーン」メニュー＞「シーンを保存」、もしくは Windows: Ctrl + S / macOS: Cmd + S のショートカットでシーンを保存する。このとき、レベルのシーンをまとめるためのフォルダを先々のために用意しておく。まずは表示されたパネルの右上にある「フォルダーを作成」をクリックする。\n「Levels」と名付けて「OK」をクリック。\nLevel1 シーンのファイル名を「Level1.tscn」として「保存」をクリックする。\nこれでゲームの舞台となる「Level1」シーンが用意できた。この舞台に、背景を配置したり、役者であるプレイヤーキャラクターや、敵キャラクター、コインなどのアイテム、ゴールなどを配置して、徐々にゲーム画面を作り上げていく。\nプレイヤーキャラクターのノードを作る 「Level1」ノードが同名の「Level1」シーンのルートノードであり、そのルートノードに紐づくノードを子ノードと言う。子ノードにさらにノードがぶら下がって孫ノードとなり、これらのルートの下に紐づく子ノード以下のノードの集まりをブランチという。\nシーンを一つの木だとすると、ルートノードが木の幹、ブランチが枝葉である。このような構造を一般的にツリー構造と呼ぶ。Godot の一つの特徴として、このツリー構造を最大限活かして、コンポーネントの構成が非常に分かりやすくなっている。\nではルートノード「Level1」にプレイヤーキャラクターとして必要なノードを追加していこう。「Level1」ノードを選択した状態で、上の「＋」ボタン、もしくはショートカット（Windows: Ctrl + A / macOS: Cmd + A）でノードを追加する。\n最初に追加するのは「KinematicBody2D」クラスのノードだ。検索して選択したら「作成」ボタンをクリックすれば、このクラスのノードが追加される。「KinematicBody2D」ノードの名前を「Player」に変更しておこう。\n次に「Player」ノードを選択して、子ノードを追加する。「AnimatedSprite」クラスのノードを追加しよう。\n同様に、「Player」ノードを選択した状態で、子ノードをもう一つ追加する。今度は「CollisionShape2D」クラスのノードを追加しよう。\nここまでで、シーンドックはこのように表示されていればOKだ。\nAnimatedSprite ノードを編集する ただ一枚の画像をスプライトとして割り当てるなら「Sprite」クラスのノードを使用するが、スプライトに複数の画像を割り当ててアニメーションさせたいときは、「AnimatedSprite」クラスのノードを使用する。\n公式オンラインドキュメント： AnimatedSprite シーンドックで「AnimatedSprite」ノードを選択した状態で、右側のインスペクタードックを見てほしい。\nでは、一番上の「Frames」プロパティを編集する。「空」の箇所をクリックするとプルダウンメニューが表示されるので、「新規 SpriteFrames」を選択しよう。\n次に「Playing」プロパティをオンにしよう。デフォルトではオフになっているが、それではアニメーションが再生されないから要注意だ。\nプロパティの編集はひとまずこれだけだ。次に、一番上の「Frames」プロパティの「SpriteFrames」をクリックしよう。\nすると Godot エディタ下部の「スプライトフレーム」パネルが開く。ここでアニメーションを作っていく。\n元々一つ用意されているアニメーションの名前を「defalut」から「idle」に変更しよう。\nこのアニメーション「idle」にスプライトシート（複数の画像が一つの画像ファイルにまとめられたもの）を割り当てる。「アニメーションフレーム」セクション上部の左から二番目のアイコンをクリックしよう。\nこのチュートリアルで使うプレイヤーキャラクターは「Pink Man」にしたいので、先ほどインポートしたアセットファイル一式から「res://Assets/Main Characters/Pink Man」フォルダまでたどり、「idle (32x32).png」ファイルを選択して「開く」を押す。\n今度はパネル左上を見てみよう。スプライトシート上で水平方向と垂直方向にいくつずつ画像が分けられているのかを指定する。今回開いたスプライトシートを見ると、画像は横一列に11種類用意されているので、ここでは「水平：11、垂直：1」としておこう。この数値がおかしいと、画像が途中で切れたり、隣の画像が入ってきたりするのでよく見て設定してほしい。\n続けてパネル右上を見てみると「すべてのフレームを選択/消去」ボタンがある。これをクリックしよう。\nすると、シートの画像が正しい区切りで全て選択できた。\n最後にパネル下部の「11フレームを追加」をクリックする。\nこれでスプライトシート上の全てのスプライトのテクスチャ画像を一括で取り込むことができた。\nアニメーションの速度を変更しておこう。値は 1 秒あたりのフレーム数（FPS: Frames Per Second）だ。デフォルトは 5 になっており、値が大きくなるほど、アニメーションの動きが速くなる。ここでは 24 とした。\nちなみに、アニメーションフレームセクション右上の (+) と (-) ボタンで画像の拡大縮小が可能だ。\n同様の手順で他のスプライトシートの分もアニメーションを用意しておこう。\nなお「Pink Man/Fall (32x32).png」と「Pink Man/Jump (32x32).png」はスプライトシートではなくテクスチャ画像が1つだけのファイルなので、単純にファイルシステムドックからアニメーションフレームへドラッグ\u0026amp;ドロップしたほうが早い。\nインスペクターで「Animation」プロパティの選択を切り替えながら、2D ワークスペース上でそれぞれのアニメーションをチェックしてみよう。\n最終的に作ったアニメーション全てを使うかどうかはまだこの時点ではわからないが、ひとまずプレイヤーキャラクターのアニメーション作成は完了だ。\nCollisionShape2D ノードを編集する ここからは「CollisionShape2D」ノードのプロパティを編集していく。とは言っても、比較的直感的に作業することが多いので、サクッと終えられるに違いない。さっそくコリジョン形状を設定しよう。\n公式オンラインドキュメント： CollisionShape2D シーンドックで「CollisionShape2D」ノードを選択したら、インスペクターで「Shape」プロパティのプルダウンメニューをクリックし、「新規CapsuleShape2D」を選択しよう。「新規RectangleShape2D」でも良いのだが、スプライトのテクスチャが丸みのあるデザインのため、今回は四角ではなくカプセル型にした。\n次に2Dワークスペースで、今設定したばかりのコリジョン形状を調整していく。まずはドラッグ操作で調整しやすいように、ツールバーのスナッピングオプションアイコンをクリックして、「ピクセルスナップを使用」にチェックを入れておく。これで 1 pixel 単位でコリジョン形状がスナップするので、調整しやすいはずだ。ドット絵の場合は特に便利なので覚えておこう。\nそのまま2Dワークスペース上で、コリジョン形状の上と右にある 赤い丸 をドラッグしてサイズと形を調整しよう。下のスクリーンショットのように、横幅はスプライトテクスチャの体の幅に、縦の高さはスプライトテクスチャの頭のてっぺんから足までの長さに、それぞれ合わせられたらOKだ。\n調整が完了したら、「Player」ノードの子ノードである「AnimatedSprite」ノードや「CollisionShape2D」ノードの位置が2Dワークスペース上で誤ってズレてしまわないように、子ノードを選択できないようにしよう。\nまずシーンドックで「Player」ノードを選択する。\nツールバーの「子ノードを選択不可にする」アイコンをクリックするだけでOKだ。\n同じアイコンがシーンドックの「Player」ノードの横に表示された。これで2Dワークスペース上で「Player」の子ノードは選択できない状態になった。\n仮の足場を作る このゲームはプラットフォーマーなので、このあとキャラクターに歩いたりジャンプしたりする動作を設定していく。しかし、その時に足場がないと、キャラクターはゲームが開始するや否や、重力によって画面の下方向に落下して消えてしまう。\nそこで、「Level1」ノードに、ひとまず仮の足場として「StaticBody2D」ノードを追加しよう。名前を「TempGround」とでも変更しておくと分かりやすい。さらに「TempGround」ノードに「CollisionShape2D」ノードを追加しよう。ちなみに、マップはあとできちんと作る機会があるので安心してほしい。\n「CollisionShape2D」ノードにコリジョン形状を設定する。「Shape」プロパティを「新規RectangleShape2D」とし、「Extents」プロパティ (x, y) を (128, 10) に設定しよう。\n2D ワークスペースで「Player」ノードを大体中央に移動し、「TempGround」ノードをその少し下に配置する。これで仮の足場ができた。\nインプットマップにアクションを追加する インプットマップとは、ゲームの入力操作設定だ。キーボードのキーやマウスのクリック、ゲームパッドのボタンなど、ゲームで利用する予定のものを「アクション」として登録することができる。デフォルトの「アクション」もいくつか登録されているが、このチュートリアルではキーボードのキー入力をいくつか追加登録していく。プレイヤーの動きをプログラミングする前に必要な作業だ。\nまずは「プロジェクト」メニュー＞「プロジェクト設定」を選択する。\n「インプットマップ」タブに切り替えたら、追加したい「アクション」（入力操作）に名前をつけて「追加」ボタンで登録する。\n以下の4つのアクションを登録しよう。登録できたら「+」ボタンでキーを割り当てていく。\nmove_right move_left jump_force dash\n登録したアクションの「+」ボタンを押したら、入力装置の種類の選択をする。ここでは「キー」を選択しよう。これはキーボードのキーを意味している。\n中央に「確認」のダイアログが出るので、この状態で設定したいキーボードのキーを実際に押下する。例えば、一つ目のアクション「move_right」の場合はキーボードの「右矢印キー」を押下すれば良い。確定するときは「OK」をクリックする。つい「Enter」キーを押下しがちだが、それだと「Enter」キーが割り当てられてしまう。\n追加した4つのアクションには以下通りにキーを割り当てると良い。もちろん自分好みに変更していただいても結構だ。\nmove_right: Right（右矢印キー） move_left: Left（左矢印キー） jump: Up（上矢印キー） dash: Space（スペースキー） 4つとも登録できたら「閉じる」ボタンをクリックして設定は完了だ。\nPlayer ノードにスクリプトをアタッチする さてここからは、プレイヤーキャラクターの動きを作っていく。動きを作るには、プログラミングが必要だ。プログラミングがまだ不慣れな方は、ひとまずチュートリアルのコードをコピー＆ペーストして、プレイヤーキャラクターの動きを見ながら理解を深めていっていただいても良いだろう。\nところで、Godot では GDScriptという独自のプログラミング言語か、別のゲームエンジン Unity でも使用される C# と言うプログラミング言語を使用する。C# の場合、Godot とは別のエディターを使用する必要があったり、文法がやや難しかったりで、経験者向きの側面が強いことから、このチュートリアルでは、文法がより初学者にも理解しやすい GDScript を使用する。GDScript なら、Godot エディター上でそのままコーディング（コードを入力してプログラムを作っていく作業のこと）でき、ドキュメンテーションを Godot エディター上で確認できるので、よりゲーム開発の作業に集中しやすいだろう。\nでは「Player」ノードにプログラムを記述するためのスクリプトをアタッチしよう。シーンドックで「Player」を選択し、右上の「選択したノードに新規または既存のスクリプトをアタッチする」アイコンをクリックする。\nスクリプトの保存先を変更したいので、「パス」の右側にあるフォルダーアイコンをクリックする。\nパネルが開いたら、パスを確認しよう。パスがリソースのルート「res://」になっていなければ、左上の「↑」アイコンをクリックしてルートまで戻り、そこで右上の「フォルダーを作成」ボタンをクリックする。\nフォルダーの名前に「Player」と入力して「OK」をクリックして確定する。\nパネル上部の「パス」が今作成したフォルダーのパスになっていればOKだ。ファイル名を「Player.gd」として「開く」をクリックしよう。ちなみに、ファイルの拡張子 .gd は GDScript ファイルのことを指している。\nパスが変更されたのを確認したら「作成」ボタンをクリックする。\nGodot エディタの中央が、2D ワークスペースからスクリプトエディタに切り替わり、今アタッチしたばかりのスクリプト「Player.gd」が開いた状態になった。これから、このスクリプトを編集していく。\nプレイヤーキャラクターの動きを実装する まず、デフォルトで入力されているコメントや_readyメソッドはこのスクリプトでは不要なので、削除しておこう。\n次に必要なプロパティ（クラス内で定義する変数のこと）を定義していく。下記のコードを「Player.gd」スクリプトの 3 行目以下に記述してほしい。\nexport var acceleration = 256 export var max_speed = 64 export var max_dash_speed = 80 export var friction = 0.1 export var gravity = 512 export var jump_force = 224 export var air_resistance = 0.02 var velocity = Vector2.ZERO コードの先頭にexportがついているプロパティは、その値をインスペクターでも編集できるようになる。試しに「player」ノードを選択してインスペクターを見てみよう。スクリプトに記述したプロパティが表示されているのがわかるだろう。スクリプトで定義した値がデフォルトの値になっている。\nexportキーワードをつければ、スクリプト上でプロパティの値を直接編集しなくても、インスペクター上で気軽に編集できる。デバッグしながら値の微調整が必要になると思われるプロパティにはexportをつけるのがおすすめだ。\nでは今回定義したプロパティについてそれぞれ説明しておこう。\nacceleration: プレイヤーキャラクターの左右移動操作時の加速度。 max_speed: プレイヤーキャラクターの左右移動操作時の最大速度。 max_dash_speed: プレイヤーキャラクターの左右ダッシュ移動操作時の最大速度。 friction: プレイヤーキャラクターの左右移動操作をやめた時に受ける摩擦抵抗。 gravity: プレイヤーキャラクターが常に画面下方向に受ける重力。 jump_force: プレイヤーキャラクターのジャンプ操作時のジャンプ力。 air_resistance: プレイヤーキャラクターのジャンプ操作時に受ける空気抵抗。 velocity: 方向の要素を持ったプレイヤーキャラクターの速度、デフォルト値はVector2型で(0, 0)。値はこのあとのプログラミングによりリアルタイムで更新される予定。 さらにスクリプトの一番下の行で、spriteプロパティをonreadyキーワードをつけて定義しよう。\nonready var sprite = $AnimatedSprite spriteプロパティの値は、「Player」ノードの子ノードである「AnimatedSprite」ノードを定義した。onreadyをつけたプロパティは、全てのノードの読み込みが終わってから定義される。ノードの読み込みは親ノードの方が子ノードより先なので、子ノードをプロパティに格納したい場合は、onreadyキーワードを利用してプロパティを定義する。\nこのようにして、子ノードのプロパティやメソッドにアクセスする予定がある場合は、プロパティとして定義しておくと、このあとのコーディングが楽になる。また、シーンツリー（シーン内のノードの構成）に変更があっても、このプロパティの値だけ変更すれば良いので、メンテナンスがしやすいというメリットもある。Godot でのゲーム開発では割と一般的な手法だ。\n次に定義するのは_physics_processメソッドだ。このメソッドは「Node」クラスの組み込み関数だ。「KinematicBody2D」クラスは「Node」クラスを継承しているので利用できる。\n_physics_processメソッドは、物理フレーム（デフォルトでは1秒間に60フレーム）ごとにメソッド内のコードを実行してくれる。これを利用して、プレイヤーの入力操作によって、プレイヤーキャラクターの動きを制御することができる。\nでは具体的にやっていこう。スクリプトの一番下に次のコードを記述しよう。\nfunc _physics_process(delta): velocity.y += gravity * delta _physics_processの引数deltaは1フレームあたりの秒数（デフォルトでは1/60秒）だ。velocity.yの値にgravityにdeltaを乗じた値を足している。ゲーム開発では一般的に、2次元の x, y 座標で y 軸の値は、画面の下にいくほど大きく、上にいくほど小さくなる。毎フレームgravityの値をvelocityの y に加算することで、プレイヤーキャラクターを常に画面下方向に動かす力を加えている。これにより、キャラクターに重力がかかっている状態を作ることができた。\nさらに、次のコードを_physics_processメソッドに追加しよう。\nvar x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration velocity.x = clamp(velocity.x, -max_speed, max_speed) メソッド内でx_input変数を定義した。Inputクラスのget_action_strengthメソッドは、引数のインプットアクションが入力されれば 1 を、されなければ 0 を返す。つまり、プレイヤーが右矢印キーを押せば 1 、左矢印キーを押せば -1 、どちらも押さなければ 0 の値がx_inputに入る。\nその次のif x_input != 0:の if 構文は、右か左の矢印キーいずれかを押した場合、ということになる。\nvelocity.xに、x_inputにaccelerationを乗じた値を加算している。これで、プレイヤーが右か左の矢印キーを押した方向へ、毎フレーム加速しながらプレイヤーキャラクターを移動させる仕組みができた。\nしかし、このままだと毎フレーム加速し続け、とんでもないスピードでキャラクターが移動してしまう。そこで、組み込みのclampメソッドを利用して、velocity.xの値が最大値および最小値の範囲内に収まるようにする。clampメソッドは最大値に第二引数、最小値に第三引数、どちらにも達していなければ第一引数を返す。\nさらに、プレイヤーキャラクターにダッシュ機能を実装したいので、インプットアクション「dash」の入力操作、つまりスペースキーを入力しているかどうかで、条件分岐させた。if x_input != 0:のブロックは以下のように変更した。\nif x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) else: velocity.x = clamp(velocity.x, -max_speed, max_speed) さらにif x_input != 0:ブロックの最後にこのコードも追加しよう。\nsprite.flip_h = x_input \u0026lt; 0 スプライトのテクスチャの水平方向に反転させるプロパティflip_hは、x_inputが 0 より小さい値（つまり左矢印キーを押下して -1 ）になっているときに有効になるようにした。\nvelocityの値を実際のキャラクターの移動に反映させるために、「KinematicBody2D」クラスの組み込みメソッドであるmove_and_slideを_physics_processメソッドの最後に追加する。\nvelocity = move_and_slide(velocity, Vector2.UP) このmove_and_slideメソッドは、第一引数に割り当てた速度に delta を自動的に乗じて、このスクリプトがアタッチされている「KinematicBody2D」クラスのノードを移動してくれる。第二引数は、上方向がどちらかを指定する。プラットフォーマーは画面の上方向がそれに当たるのでVector2.UPを割り当てた。これによって、自動的に天井、地面、壁がどの方向なのかを判別してくれる。\nでは一旦ここでプロジェクトを実行してキャラクターの動きを確認してみよう。\nデバッグパネルで、足場である「TempGround」ノードのコリジョン形状が見えるようにするため、先に「デバッグ」メニュー＞「コリジョン形状を表示」にチェックを入れておこう。\nGodot エディタ右上の「プロジェクトを実行」アイコンをクリックする。\nまだメインシーンを選択していない場合はダイアログが表示されるので、「現在のものを選択」をクリックする。\nデバッグパネルが開くので動きを確認してみよう。\n重力は機能して、キャラクターはきちんと足場に落ちている。スプライトのテクスチャもflip_hプロパティの切り替えにより向きが変われば反転している。しかし、左右の移動は右または左の矢印キーを一回押下しただけで滑り続けて止まらない状態だ。さらに必要なコードを追加していこう。\n今度は、velocity = move_and_slide(velocity, Vector2.UP)のコードより前に、以下の if ブロックのコードを追加しよう。\nif is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) is_on_floorメソッドは、現在地面にキャラクターが接しているかを判定してくれる。接していれば戻り値が true になる。if x_input == 0:は左右移動の入力がない場合という条件の if 構文だ。この if / else ブロック内を見ていく。\nまず、sprite（「AnimatedSprite」ノード）のplayメソッドによりアニメーション「idle」を再生する。\n次に、velocity.xの値は組み込みのlerpメソッドにより、現在のvelocity.xの値の間を第三引数であるfrictionプロパティの重み分だけ、第二引数 0 に近づけていく。_physics_processメソッドが毎フレーム実行されることにより、次第に値は 0 になる。\nelse ブロックの方は、左右移動の入力があった場合という条件になり、このとき「AnimatedSprite」ノードのplayメソッドによりアニメーション「run」が再生される。\nそれでは、改めてプロジェクトを実行して、滑らなくなったか、アニメーションが切り替わるか確認しよう。\nlerpメソッドによる摩擦抵抗の実装で、左右移動の入力がなければ減速して停止するようになった。スペースキーを押下した時のダッシュの挙動も上々だ。ちなみに、何度かmax_dash_speedの値を変更して検証してみたが、80 ではあまり移動速度が変わらなかったので 200 に変更した。せっかくなので、あなたもインスペクターからお好みの速度に調整してみよう。\n次はキャラクターがジャンプできるようにしょう。続けてif is_on_floor():ブロック内に次のコードを追加しよう。\nif Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force この if ブロックif Input.is_action_just_pressed(\u0026quot;jump\u0026quot;):は、（地面にキャラクターが接している時に）インプットアクション「jump」の操作、つまり上矢印キーを一回押した場合、という意味合いだ。この場合「AnimatedSprite」ノードのplayメソッドによりアニメーション「jump」を再生する。そして、この瞬間にvelocity.yにジャンプ力を示すjump_forceを引き算している。引き算するのは、先ほどお伝えした通り、画面上方向にいくほど y 軸の値が小さくなるからだ。\nではプロジェクトを実行して、ジャンプ操作も確認してみよう。\n今のところ大きな問題はなさそうなので良しとしよう。\nあとは少し細かいが、ジャンプ中に左右移動の入力がなかった場合と、ジャンプしてすぐに上矢印キーを離した場合、このそれぞれの動きをコーディングしていこう。\nif is_on_floor():ブロックに続けて、以下のelseブロックを追加して、if / else構文にする。\nelse: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 elseブロックは、is_on_floorメソッドの戻り値が false だったら、と言い換えられる。つまり、「地面に接していなかったら（空中だったら）」という意味になる。さらにネストされたif構文が続く。一つ目のifブロックの条件は、if x_input == 0:で、これは「左右移動の入力がなかったら」という意味だ。その場合、velocity.xはlerpメソッドにより、air_resistanceの空気抵抗により毎フレーム 0 に近づいていく。\nelseブロックにネストされて2つ目のif構文を見てみよう。条件式は2つの条件がandで結合されていて、「2つとも満たした場合」という条件になる。\n一つ目の条件は、Inputクラスのis_action_just_releasedメソッドを利用した、（空中で）一度「jump」アクション操作（上矢印キー）を離した場合、という内容だ。\n2つ目の条件は、velocity.yの値が-jump_force / 2（ジャンプ力の2分の1）未満の場合、という内容だ。\nこれらを合わせると、空中でスペースキーを離した時にプレイヤーキャラクターの y 軸方向の速度がジャンプ力の半分未満だったら、という意味になる。これを満たした場合、velocity.yの値には-jump_force / 2（ジャンプ力の半分）の値を適用する。これにより、スペースキーをちょんと押しただけだと、低いジャンプになる。\nそれでは、プロジェクトを実行して変更した内容を確認してみよう。\nスペースキーを押し続けた時と、ちょんと押した時とで、ジャンプする高さが変わった。また、ジャンプ中に左右移動の入力をしない場合、空気抵抗の影響を受け、x 方向の移動距離が少し落ちた。\nひとまずプレイヤーキャラクターの動きが想定通りになったので、「Player.gd」スクリプトの編集は一旦ここまでにしておこう。\nPart 1 で編集したスクリプトのコード 今回編集した「Player.gd」スクリプト全体のコードを最後に共有しておこう。何か動きが思い通りに行かない場合はこちらを参考にしてほしい。\nPlayer.gd スクリプトを確認する extends KinematicBody2D export var acceleration = 256 export var max_speed = 64 export var max_dash_speed = 80 export var friction = 0.1 export var gravity = 512 export var jump_force = 224 export var air_resistance = 0.02 var velocity = Vector2() onready var sprite = $AnimatedSprite func _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.flip_h = x_input \u0026lt; 0 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force else: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 velocity = move_and_slide(velocity, Vector2.UP) Player ノードをシーンにする 最後に「Player」ノードを個別のシーンとして保存し、「Level1」シーンには「Player」シーンのインスタンスをノードとして追加させるようにする。今後、別の新たなブランチをルートノードに追加する場合も、「Player」ノードと同様に、先に別シーンとして作成してから、そのインスタンスをルートノードに追加していくことになるだろう。\n実は Godot では、このように個々のシーンのインスタンスを別のより大きなシーンの子ノードとして追加するのが一般的だ。ゲームの小さい部品を作って、それらを集めて少し大きな部品のシーンを作る、ということを繰り返して、少しずつゲームの規模を大きくしていくというわけだ。とはいえ、Godot でのゲーム開発をはじめ、オブジェクト指向プログラミング全般がそういうものだとも言えるだろう。大きく複雑なプログラムも小さくて簡単なプログラムの組み合わせに過ぎない、と考えれば、ゲーム開発はまったくもって怖くない。\nでは具体的な作業を進めよう。\nシーンドックで「Player」ノードを右クリックして「ブランチをシーンとして保存」を選択する。\nシーンの保存先パスを「res://Player」とし、ファイル名を「Player.tscn」として、「保存」をクリックする。\nすると「Level1」シーンの「Player」ノードの右側に「エディターで開く」アイコンが表示される。これは別のシーンのインスタンスであることを示している。このアイコンをクリックしてみよう。\nするとシーンドックと2Dワークスペースが「Player.tscn」シーンの表示に切り替わる。これで「Player」ノードをシーンにすることができた。\n最後に、後処理を少しやっておこう。まず「Player.tscn」シーンのまま、インスペクターの「Position」プロパティを見て見よう。今までのまま(192, 80)のように、（0, 0）以外の値になっているはずだ。これを、「Player.tscn」シーン上では (0, 0)にしておこう。なぜならこのシーン上でプレイヤーキャラクターの位置を変更する必要がないからだ。\n続けて、2Dワークスペースにて「Level1」タブをクリックして「Level1.tscn」シーンに戻そう。\n同じくインスペクターから「Position」プロパティを (0, 0) から (192, 80)などに変更しておこう。これでさっきデバッグしていた時と同じ状態に戻った。\nおわりに 以上で Part 1 は完了だ。プレイヤーキャラクターが自分の操作で想定通りに動くと嬉しいものだ。ゲーム開発のモチベーションを高めるには、最初にプレイヤーキャラクターを作るというのが実践しやすい一つの方法ではないだろうか。\n次回はタイルマップを作ってゲームの世界を作っていくのでお楽しみに。\nUPDATE\n2022-10-16 仮の足場を作るの手順の「Area2D」の誤記を「StaticBody2D」に訂正\n2022-03-26 Dropbox のアセットの内容に Part 12 で利用するファイルを追加してリンクを更新\n2022-03-24 Dropbox のアセットの内容に Part 11 で利用するファイルを追加してリンクを更新\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_1/","summary":"このチュートリアルシリーズでは、スーパーマリオのような横スクロールアクションゲーム、いわゆる「プラットフォーマー」というジャンルのゲームを作っていく。今回は、初回ということで、ゲームのプレイ画面にプレ","title":"Godot で作るプラットフォーマー Part 1：プレイヤーキャラクターを作ろう！"},{"content":"今回は、第2回ということで、ゲームのプレイ画面にタイルマップを配置してプレイヤーが動き回る舞台を作っていく。\nなお、タイルマップについては、公式ドキュメントでも説明があるので、併せて確認いただくのが良いだろう。\n公式オンラインドキュメント： Using TileMaps Memo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー Level1 シーンに TileMap ノードを追加する まずはプラットフォーマーの舞台となるタイルマップを用意しよう。タイルマップとは、タイル状の画像を画面上に配置して作られるキャラクターが動き回る舞台のことだ。2D のドット絵を採用するレトロゲームで多く採用される。\nシーンドックにて「Level1」ノードを選択し、子ノードとして「TileMap」ノードを追加しよう。前回の Part 1 で用意した仮の足場「TempGround」ノードは不要になるので、今の時点で削除しておこう。\nシーンドックで「TileMap」ノードを選択した状態で、インスペクターから「Tile Set」プロパティに「新規 TileSet」を設定する。\n「Tile Set」プロパティの「TileSet」をクリックする。これでタイルセットの作成を開始できる。\nGodot エディタ下部を見るとタイルセットパネルが開いている。ここでタイルセット作成の作業を行っていく。\nタイルセットにテクスチャ画像ファイルを追加する タイルセットを作るには、タイルセット用のテクスチャ画像をタイルセットに追加する必要がある。Part 1 のチュートリアルでインポートしたアセットから追加しよう。\nファイルシステムから「res://Assets/Terrain/Terrain (16x16).png」を見つけたら、タイルセットパネルの左側にドラッグ\u0026amp;ドロップしよう。もしくはタイルセットパネル左下の[+]ボタンをクリックして同ファイルを選択して追加しよう。\n作業しやすくなるように、タイルセットパネル右下の「下パネルを展開」アイコンをクリックして、タイルセットパネルを広げよう。\nさっき追加したテクスチャを選択すると、このような画面になる。この状態から具体的にタイルセットを作っていく。\nタイルセットを作る 新しいタイルを用意する時は、以下の3種類のタイルのいずれかを選択する。\nシングルタイル：1つのタイル オートタイル：同じ種類のタイルを一定のルールでグループ化したもの。タイルマップにタイルを配置する時に、1マスずつ手動でタイルを選択する必要がなく、自動的に配置してくれる。これを用意するには、定められたテンプレートに沿ったテクスチャ画像が必要になる。 アトラス：複数のタイルをまとめて一つのグループとして設定する。似ているタイルをグループ化できるので、シングルタイルよりも効率的に作業することができる。 このチュートリアルではアトラスのタイルを作っていく。まずはタイルセットパネルで「新しいアトラス」をクリックする。\nまずは「領域」の編集モードになっているので、そのまま石のブロックの画像を1つのアトラスの領域として、ドラッグして選択しよう。デフォルトで「スナップとグリッドの表示を有効にする」アイコンが有効になっているので、簡単に選択できるだろう。\nこのように選択できればOKだ。\nさてここで次のコリジョンやオクルージョンの設定の事前準備をしておく。\nインスペクターから「TilesetEditorContext」セクションの「Step」プロパティを(8, 8)に変更しよう。この石のブロックのタイルが8x8のデザインになっているからだ。これで、コリジョンやオクルージョンの領域を選択するときに、縦横 8 px ごとにスナップしてくれるはずだ。\n併せて、「Selected Tile」セクションの「Name」を「stones」にしておこう。\nではタイルセットパネル上部で「コリジョン」編集モードを選択し、コリジョンを設定しよう。基本的に石のブロックの範囲はコリジョンを追加する。真っ黒の部分はコリジョン不要だ。\n「オクルージョン」編集モードにして、コリジョンと同様にオクルージョンの範囲も設定しておこう。ちなみにゲーム画面でライトを使用する際に、オクルージョンが設定された範囲に光が当たると影ができる。後々、ゲームを発展させる際に利用する予定だ。\n「アイコン」編集モードに切り替えたら、このアトラスを代表する1マスのタイルを選択しよう。タイルマップに配置するタイルを選択する際にこのアイコンが目印になる。ここでは左上の1マスを採用した。\n同様にして「earth」のアトラスを新規で作成しよう。上段中央の緑の草と土のタイルセットだ。ただしオクルージョンの設定は不要だ。\n同様にして「blocks」のアトラスも新規で作成しよう。右上の茶色いブロックのタイルセットだ。こちらはオクルージョンも設定しておこう。\nこれで3つのアトラスが作成できた。ちなみに、タイルセットパネル右上の拡大縮小のアイコンの右側にある (i) のアイコンをクリックすると、設定したタイルの名前が表示される。\nでは作成したアトラスを使って、タイルマップにタイルを配置していこう。\nTileSet を TileMap ノードに配置する それではいよいよタイルマップにタイルを配置してゲームの世界を作っていく。\nまずはシーンドックで「TileMap」ノードを選択しよう。インスペクターで「Cell」セクションの「Size」プロパティが(16, 16)になっていることを確認しておこう。この値はタイル1マス分の大きさと同じでなければならないためだ。\n2Dワークスペースが自動的にタイルマップの編集モードになっているのがわかるだろう。ここで編集ツールをざっと見ておこう。\n左側のアイコンから順番に説明していく。\nペンのアイコンがペイントだ。クリックで 1 マス分タイルを描く。ドラッグ操作で連続的に描く。その他の操作はスクリーンショットの説明の通りだ。 バケツのアイコンは塗りつぶしだ。広範囲のタイルを一気に描きたい時に使用する。 スポイトのアイコンはすでに描いたタイルをピックして、それを選択中のタイルにすることができる。右側でタイルを選ぶのが面倒な時はこちらの方が早いかもしれない。 重なった四角のアイコンは選択だ。選択した範囲のタイルをコピーしたり、切り取ったり、消去したりすることができる。 TileMap アイコンからは、切り取り、コピー、消去が可能だ。だがしかし、これはショートカットキー操作の方が早そうではある。 また、失敗した時は右クリックで不要なタイルを消去できる。これもドラッグ操作で連続的に広範囲の消去が可能だ。\n続いて、以下のアイコンも左側から順番に簡単に説明しておこう。\nタイルを左に90°回転 タイルを右に90°回転 タイルを左右反転 タイルを上下反転 トランスフォームをクリア *今は気にしなくて良いだろう。 2Dワークスペース右側で描画するタイルを選択できる。今回はアトラスで3つ作成したので、上側でアトラスを選択し、下側でそのアトラスに属するタイルを選択できるようになっている。タイルが多くて探すのが大変な時は上部で検索もできる。検索欄下のスライダーはタイルの表示サイズだ。お好みで調整してほしい。\n実際にタイルを配置してみよう。下のGIFはあくまでサンプルなので、多少アレンジしてもらって構わない。ここではゲーム序盤らしく、「earth」アトラスのタイルで真っ直ぐな地面を作成した。\nプレイヤーキャラクターをタイルマップ上で動かす 以前、チュートリアル Part 1 で仮の足場を作成する際に、「コリジョン形状の表示」にチェックを入れたが、これはお好みでチェックを外してもらって構わない。\nでは、プロジェクトを実行してみよう。\nタイルに設定したコリジョンがきちんと機能し、プレイヤーキャラクターをタイル上で動かすことができた。\nおわりに 以上で Part 2 は完了だ。タイルマップを追加して、キャラクターが動き回る舞台を用意することができた。前回に比べて、ゲームらしさが格段に向上したのではないだろうか。\n次回はカメラを追加して、さらに広いタイルマップ上を移動できるようにしていくのでお楽しみに。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_2/","summary":"今回は、第2回ということで、ゲームのプレイ画面にタイルマップを配置してプレイヤーが動き回る舞台を作っていく。 なお、タイルマップについては、公式ドキュメントでも説明があるので、併せて確認いただくのが良い","title":"Godot で作るプラットフォーマー Part 2：タイルマップを作ろう！"},{"content":"第3回目の今回は、プレイヤーキャラクターの動きに合わせてカメラが移動し、Part 2 の時より広いタイルマップ上をキャラクターが移動できるようにしていく。\nなお、2Dゲームのカメラについて、公式ドキュメントにも説明があるので、併せて確認いただくのが良いだろう。\n公式オンラインドキュメント： Camera2D Memo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー Level1 シーンに Camera2D ノードを追加する 2Dゲームにカメラを追加するには、「Camera2D」ノードを利用する。ではさっそく「Level1」ノードに「Camera2Dノード」を追加しよう。ノードの並び順を少し変えているがこの時点ではただの好みだ。インスタンスノードを下に持ってきている。\nインスペクターで「Camera2D」ノードの「Current」プロパティをオンにしておこう。これがオフだとその『Camera2D」ノードはカメラとして機能しない。カメラを複数用意してそれらで画面を切り替えるようなゲームでない限り、このプロパティは基本的にオンになるだろう。\nカメラをプレイヤーキャラクターに連動させる 続いて、追加した「Camera2D」ノードがプレイヤーを追跡するようにしていく。これは GDScript で制御していくのだが、新しいスクリプトをアタッチするノードは「Camera2D」ノードではなく「Level1」だ。理由は、「Player」ノードと「Camera2D」ノードの両方にアクセスしやすいのが「Level1」ノードだからだ。\nではシーンドックで「Level1」ノードを選択し、スクリプトをアタッチしよう。\nスクリプトのパスは「res://Levels/Lvel1.gd」する。テンプレートは「No Comments」にして、デフォルトのコメントやメソッドを削除する手間を省略しよう。問題なければ、「作成」をクリックしてスクリプトを開こう。\nスクリプトを開いたら、まず4行目以降にonreadyキーワード付きのプロパティを3つ用意しよう。\nextends Node2D onready var player = $Player onready var map = $TileMap onready var camera = $Camera2D 追加した3つのプロパティには、それぞれ「Level1」ノードの子ノードである「Player」、「TileMap」、「Camera2D」を代入している。これらの子ノードにアクセスする必要があるので、事前にプロパティとして用意している。\n続いて、組み込みメソッドの_processを追加しよう。\nfunc _process(_delta): camera.global_position = player.global_position _processメソッドは_physics_processメソッドと似ているが少し異なる。どちらも引数がdeltaとなっているが、_physics_processの場合は毎フレーム一定の長さのためdeltaも常に一定だ。しかし_processメソッドの場合、1フレームの長さはその時の処理の量によって変動する。つまりdeltaが一定ではない。きっちり一定間隔で処理が必要な場合は_physics_processメソッドを使い、常に処理は必要だが、正確に一定間隔である必要はない場合は_processメソッドを使う、という認識で良いだろう。\nちなみに、メソッド内で引数deltaを使うことがない場合は引数の表記を_deltaとしておくと余計なアラートが出なくなる。\nさて_processメソッド内に記述したコードは、「Camera2D」ノードのglobal_positionの値を「Player」ノードのglobal_positionの値と同じにする処理だ。\nなお、ここではglobal_positionという組み込みのプロパティを利用しているが、現時点でのシーンツリーの構造が変更されない限りはpositionプロパティでも問題ない。なぜならpositionは親ノードの位置からの相対的位置を示し、global_positionはゲーム画面上の絶対的な位置を示すからだ。シーンツリーの構造がいつ更新されるかわからない場合の複数ノードの位置の利用はglobal_positionを使用するのが得策だろう。\nでは、カメラがプレイヤーキャラクターについてくるか確認してみよう。\nきっちりキャラクターをカメラの中心に捉えたまま連動しているので、OKとしよう。\nなお、このタイミングで、プレイヤーキャラクターの移動速度が快適ではなかったので、以下のプロパティの値変更をした。あなたもご自身が気持ち良いと感じる値に適宜調整してほしい。\nmax_speed: 80 max_dash_speed: 120 タイルマップを発展させる 前回の Part2 ではあまりタイルマップを作り込まなかったので、カメラが動くようになったこのタイミングで、きっちり「Level1」シーンのマップを作ってしまおう。\n使用するタイルは、Part 2 で作成した「earth」アトラスと「blocks」アトラスだけでOKだ。これらのタイルで、初めてプレイヤーが体験するレベルをイメージしてタイルマップを完成させよう。\nここでプレイヤーキャラクターのサイズと動きによって、下記の制約があるのでご注意いただきたい。\nキャラクターはタイル2個分の高さ\nキャラクターはタイル3個分の高さまでしかジャンプで飛び乗れない\nキャラクターは通常のスピードではタイル3個分の幅までしかジャンプで飛び越えられない\nサンプルとして、このチュートリアルでは以下のようなマップを作成した。もっと短くてもいいし、長くてもいい。ここは完全にあなたの自由だ。\nなお、タイルマップを作成中、2Dワークスペースの左下には現在のカーソルの位置とどの種類のタイルが配置されているかが表示される。例えば、今回のサンプルのタイルが配置されている一番右下の位置にカーソルを合わせると、「155, 15 [blocks]」と表示されている。x, y が (0, 0)の位置から数えて、右方向に 155 マス、下方向に 15 マスの位置までタイルを配置していることがわかる。\nそれでは、このタイルマップでプレイヤーキャラクターを動かしてみよう。\nカメラが常にプレイヤーキャラクターを中央に捉えたままだが、できればカメラに映されるプレイ画面は、配置されたタイルの一番端を超えないようにしたいところだ。次はこの部分を更新していく。\nタイルマップの端に合わせてカメラの移動範囲を制限する それでは改めて「Level1.gd」スクリプトを開いて編集していく。\nまずは_readyメソッドを追加する。\nfunc _ready(): adjust_camera() メソッド内でadjust_cameraメソッドを実行するようにコーディングした。このメソッドを今から定義する。\nfunc adjust_camera(): var map_limits = map.get_used_rect() print(\u0026#34;map_limits\u0026#34;, map_limits) var map_cell_size = map.cell_size print(\u0026#34;map_cell_size\u0026#34;, map_cell_size) 「TileMap」ノードのメソッドにget_used_rectがある。これは現在のタイルマップでタイルが配置されている範囲を返してくれる。返される値は（position.x, position.y, end.x, end.y）の形式だが、それぞれの値は pixel ではなく、グリッド数、つまりタイルのマス目の数だ。\n同じく「TileMap」ノードのメソッドにcell_sizeがある。これはタイル一つ分の縦・横のサイズを Vector2 型の値で返してくれる。\nprint関数は、「TileMap」ノードの2つのメソッドでどのような値が返されるのかを確認するために追加している。さっそくプロジェクトを実行して、print関数の出力結果を見てみよう。\n出力パネルの結果をみると、map_limitsメソッドで返される値は(0, 1, 156, 15)で、cell_sizeメソッドで返される値は(16, 16)だった。これらの値を利用して、カメラの移動範囲を制限していく。\n具体的には、map_limitsメソッドで得られる結果のそれぞれの要素に対して、cell_sizeメソッドで得られる結果の x または y の値を乗算することで、タイルを配置している上下左右の範囲を pixel 単位で取得することができる。その値を「Camera2D」ノードの移動制限用のプロパティlimit_xxxに適用すれば良い。\nではadjust_cameraメソッドを以下のように更新しよう。\nfunc adjust_camera(): var map_limits = map.get_used_rect() #print(\u0026#34;map_limits\u0026#34;, map_limits) var map_cell_size = map.cell_size #print(\u0026#34;map_cell_size\u0026#34;, map_cell_size) camera.limit_left = map_limits.position.x * map_cell_size.x camera.limit_right = map_limits.end.x * map_cell_size.x #camera.limit_top = map_limits.position.y * map_cell_size.y #指定しない camera.limit_bottom = map_limits.end.y * map_cell_size.y camera.limit_smoothed = true 「Camera2D」ノードのlimit_leftやlimit_rightのプロパティはそれぞれの方向に対するカメラの移動制限を pixel 単位で指定することができる。\nただ、「Camera2D」ノードのlimit_topの値だけ指定しない。理由は2つある。\n1つは、最も高い位置のタイルに乗ってさらにプレイヤーキャラクターがジャンプする場合、キャラクターが画面上に全く映らない状態になってしまうからだ。\nもう1つの理由は、limit_topの値の方がlimit_bottomの値よりも優先されてしまうからだ。画面上最も上にあるタイルの y 軸の位置が 0 グリッドより大きい（画面下方向）場合、カメラが常にlimit_bottomの値を超えた状態になり得るからだ。下のスクリーンショットがサンプルだ。1タイル分下に下がってしまっているのは、画面上最も上に位置するタイルが y 軸上 0 グリッドではなく 1 グリッドの位置にあるためだ。\n最後のlimit_smoothedプロパティは、その値がtrueの場合はカメラの移動制限範囲に到達した時に、カメラがスムーズに止まる。\nprintメソッドはもう不要なので削除かコメントアウトしておこう。\nでは、これで一度プロジェクトを実行して、カメラがタイルを配置している範囲までしか移動しないことを確認しよう。\n現状、カメラはタイルマップの端で止まるようになったが、プレイヤーキャラクターはカメラに映らなくなっても動けてしまう状態だ。\nプレイヤーキャラクターの画面左方向の移動を制限しておこう。「Player.gd」スクリプトの一番最後に以下のコードを追加する。\nif position.x \u0026lt; 16: position.x = 16 プレイヤーキャラクターのスプライトのテクスチャが 32 x 32 px なので、16 px がちょうどプレイヤーキャラクターの中心の値になる。プレイヤーキャラクターの中心がposition.x == 16の位置に来た時、プレイヤーキャラクターの左端がちょうどゲーム画面の左端と一致しているはずだ。だからposition.xが 16 未満の場合はposition.xを16にするようにした。これで画面左端に見えない壁ができたような状態になり、プレイヤーキャラクターはそれ以上左側に進むことができなくなった。\n実際にプロジェクトを実行して確認してみよう。\nプレイヤーキャラクターが画面右端に到達した場合の同様の処理は行わない。なぜなら、右方向はキャラクターの進行方向なので、まだ先に行けそうなのに行けないと、プレイヤーは違和感を感じてしまうからだ。代わりに、タイルマップのタイルの配置を工夫して対処する。\n例えば、完全に壁を作ってしまうのも一つだ。\nもしくは、一番右端のタイルをキャラクターが行き着けない場所に配置するのも良いだろう。\nプレイヤーキャラクターが画面下方向に画面から消えた場合は、ライフを減らすか、ゲームオーバーにするなどの実装を今後やっていくことになるので、今はこのままにしておこう。\nPart 3 で編集したスクリプトのコード 最後に今回の Part 3 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nLevel1.gd の全コード extends Node2D # Created @ Part 3 onready var player = $Player onready var map = $TileMap onready var camera = $Camera2D func _ready(): adjust_camera() func _process(_delta): camera.global_position = player.global_position func adjust_camera(): var map_limits = map.get_used_rect() print(\u0026#34;map_limits\u0026#34;, map_limits) var map_cell_size = map.cell_size print(\u0026#34;map_cell_size\u0026#34;, map_cell_size) camera.limit_left = map_limits.position.x * map_cell_size.x camera.limit_right = map_limits.end.x * map_cell_size.x #camera.limit_top = map_limits.position.y * map_cell_size.y # 指定しない camera.limit_bottom = map_limits.end.y * map_cell_size.y camera.limit_smoothed = true Player.gd の全コード extends KinematicBody2D # Created @ Part 1 export var acceleration = 256 export var max_speed = 64 export var max_dash_speed = 200 export var friction = 0.1 export var gravity = 512 export var jump_force = 224 export var air_resistance = 0.02 var velocity = Vector2() onready var sprite = $AnimatedSprite func _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.flip_h = x_input \u0026lt; 0 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force else: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 velocity = move_and_slide(velocity, Vector2.UP) # Added @ Part 3 if position.x \u0026lt; 16: position.x = 16 おわりに 以上で Part 3 は完了だ。カメラ用意して、タイルマップをさらに拡大させて、その上をキャラクターに走らせることができた。ようやくプラットフォーマーの骨格ができてきた。\n次回は敵キャラクターを追加する予定なので、お楽しみに。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_3/","summary":"第3回目の今回は、プレイヤーキャラクターの動きに合わせてカメラが移動し、Part 2 の時より広いタイルマップ上をキャラクターが移動できるようにしていく。 なお、2Dゲームのカメラについて、公式ドキュメント","title":"Godot で作るプラットフォーマー Part 3：カメラを追加しよう！"},{"content":"第4回目の今回は、敵キャラクターの雛形となるシーンを作成し、それを継承する形で個別の敵キャラクターを一つ作っていく。そのあと、その敵キャラクターをレベルシーンに配置して、プレイヤーキャラクターに踏まれたら消えるところまで実装してみよう。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー 敵キャラクターの雛形となるシーンを作ろう 一般的に、プラットフォーマーゲームには複数種類の敵キャラクターが存在する。今回のチュートリアルでは、まず 1 種類、敵キャラクターを作る。そして、次回以降 Part でさらに種類を増やしていこう。\nだが、敵キャラクターを一種類ずつ、はじめから作り始めると、それなりに時間がかかる。全ての敵キャラクターに共通の部分を先に雛形のシーンとして作っておき、そのシーンを継承する形でそれぞれの敵キャラクターのシーンを作成すれば効率的だ。\nということで、まずは雛形のシーンから作っていこう。「シーン」メニュー＞「新規シーン」を選択する。\n「ルートノードを生成」のオプションで「＋その他のノード」を選択する。\nここからは、先に必要なノードをシーンツリーに追加していこう。\nルートノードには「KinematicBody2D」クラスのノードを設定する。名前を「Enemy」に変更しておこう。続けてそのルートノードに「AnimatedSprite」ノード、および「CollisionShape2D」ノードを子ノードとして追加する。\nさらに「Enemy」ルートノードに「Area2D」クラスのノードを追加し、名前を「HitBox」に変更する。その「HitBox」ノードに「CollisionShape2D」ノードを追加する。この「HitBox」のコリジョン形状は、プレイヤーキャラクターに踏まれた時の衝突検出に使用するためのものだ。\n最後に「Enemy」ノードに「VisibilityEnabler2D」ノードを追加する。このノードは、敵キャラクターがゲーム画面の範囲内に入った瞬間や、ゲーム画面内にいた敵キャラクターが画面外に消えた時にシグナルを発信できるので、敵キャラクターの動きの制御に後ほど利用する予定だ。\nここまでで、シーンツリーの構造はシーンドック上で以下のようになったはずだ。\nここからは、インスペクターでいくつかノードのプロパティを編集していく。\n「AnimatedSprite」ノードの「Frames」プロパティに「新規 SpriteFrames」を設定する。具体的なアニメーションは、「Enemy」シーンを継承したシーンでそれぞれ行っていく。あとは「Playing」プロパティをオンにしておこう。\n「Enemy」ルートノード直下の「CollisionShape2D」ノードの「Shape」プロパティには「新規 CapsuleShape2D」を設定しておく。ただし、具体的なコリジョン形状の調整は「Enemy」シーンを継承したシーンで行う。\n次に「HitBox」ノードの子ノードの方の「CollisionShape2D」ノードの「Shape」プロパティには「新規 RectangleShape2D」を設定しておく。こちらも、コリジョン形状の調整は「Enemy」シーンを継承したシーンで行う。\n「VisibilityEnabler2D」ノードの「Rect」プロパティの値を「x: -16, y: -16, w: 32, h: 32」にしておこう。\nこのピンクの四角い範囲がゲーム画面を出た時や入った時にノードがシグナルを発信することができる。\nでは、ここまでできたら一度シーンを保存しておこう。シーンを保存するためのフォルダを「Enemies」という名前にして作成し、ファイル名を「Enemy.tscn」として保存しよう。ファイルパスは「res://Enemies/Enemy.tscn」になる。\nEnemy シーンにスクリプトをアタッチする 次に敵キャラクターの共通部分について、スクリプトの方も作成しておこう。\nシーンドックで「Enemy」ルートノードを選択して、スクリプトをアタッチする。この時、先ほどシーンを保存する時に作成した「Enemies」フォルダに保存するようにしよう。スクリプトのファイルパスは「res://Enemies/Enemy.gd」となるはずだ。\nでは、スクリプトエディタが開いたら、まず敵キャラクターに共通するプロパティを用意しておこう。\nextends KinematicBody2D export var gravity: int export var speed: int var velocity = Vector2() onready var sprite = $AnimatedSprite gravity、speedの2つのプロパティは、敵キャラクターによって、違ったほうが面白そうなので、インスペクターで気軽に更新できるようにexportキーワードをつけた。この時点では値を指定せず、データ型をintとして指定したのみだ。\nvelocityはプレイヤーキャラクター同様、_physics_processメソッド内で更新させる予定のため、一旦Vector2()を値にしている。これはx, y座標が(0, 0)の状態だ。\nspriteは「AnimatedSprite」ノードにアクセスするためのプロパティだ。子ノードが読み込まれてから定義する必要があるためonreadyキーワードを付けている。\n次に敵キャラクターが踏まれたら消える仕組みも、全ての敵キャラクターで共通にしたい。これには「HitBox」ノードの子「CollisionShape2D」ノードを利用する。コリジョン形状は敵キャラクターの頭のてっぺんあたりに配置することを想定している。キャラクターがこれに衝突した時に「HitBox」ノードからシグナルを発信して、それをトリガーにして敵が消える処理を実行するようにしていく。\nまずはシグナルの接続からだ。シーンドックで「HitBox」ノードを選択し、ノードドック＞シグナルを開き、「body_entered(body: Node)」シグナルをダブルクリック、または選択して右下の「接続」をクリックする。\nダイアログにて「Enemy.gd」スクリプトに接続しよう。「スクリプトに接続：」欄で「Enemy」を選択して下部の「接続」をクリックすればOKだ。\nすると、以下のようにシグナルをトリガーにして実行される_on_HitBox_body_enteredメソッドが追加されたはずだ。しかし、メソッドの中身は今のところ空っぽ（passのみ）だ。\nfunc _on_HitBox_body_entered(body): pass このメソッドの中身をコーディングする前に、先にやっておきたいのが、ノードのグループ設定だ。以下の手順で「Player」シーンの「Player」ノードを新しくノードグループ「Players」を作成してそれに追加しよう。また直近で必要なのは「Player」ノードのグループだが、ついでに「Enemy」シーンの「Enemy」ノードも「Enemies」を作成して追加しておこう。\n現在の「Enemy.tscn」シーンファイルは保存して、「Player.tscn」シーンファイルを開く。\nシーンドックで「Player」ルートノードを選択する。\nノードドック＞「グループ」タブを選択し、入力欄に「Players」とグループ名を入力して「追加」をクリックする。\nこれで「Player」ノードが「Players」ノードグループに追加された。\n今度は「Enemy.tscn」に切り替えて、同様の手順で「Enemy」ノードを「Enemies」ノードグループに追加しておく。\nそれでは今作ったグループを利用してさっきの_on_HitBox_body_enteredメソッドの中身をコーディングしていこう。このメソッドの引数bodyは、「HitBox」ノードと衝突したノードを指す。このbodyがプレイヤーキャラクターだった場合は、敵キャラクター自身を消す、という内容のコードを記述する。\nfunc _on_HitBox_body_entered(body): if body.is_in_group(\u0026#34;Players\u0026#34;): print(\u0026#34;Player entered in \u0026#34;, self.name) sprite.play(\u0026#34;hit\u0026#34;) yield(sprite, \u0026#34;animation_finished\u0026#34;) queue_free() print(self.name, \u0026#34;died\u0026#34;) if body.is_in_group(\u0026quot;Players\u0026quot;):で、『もしbodyが「Players」グループのノードだったら』という条件分岐になる。この条件に当てはまった場合に、以下を実行するプログラムになっている。\nデバッグとして、print関数でプレイヤーキャラクターが「HitBox」に衝突したことを出力する。 「AnimatedSprite」ノードの「hit」アニメーションを再生する（この名前のアニメーションを継承後のシーンで作成予定） yieldにて、「AnimatedSprite」ノードのアニメーションが終了するまでこれ以下のコードの読み込みを一時停止する。 queue_freeメソッドを実行し、この「Enemy」ノード自身を消す。 もう一度デバッグとして、print関数で敵キャラクターが消えたことを出力する。 公式オンラインドキュメント コルーチン(yield関数による) 「AnimatedSprite」のアニメーションはこれから、「Enemy」シーンを継承した個別のシーンで作成することになる。その時に、踏まれて消える時の「hit」という名前のアニメーションを用意しておく必要があるので、覚えておこう。\nさて、次に実装したいのは、敵キャラクターが画面外にいるときはその動作を停止し、画面内に入ったら動き出す、という仕組みだ。これには「VisibilityEnabler2D」ノードを利用する。このクラスのノードは、画面に表示されていない時は、ルートノードとそれ自身と同階層のノードの動きを停止してくれる。\n公式オンラインドキュメント VisibilityEnabler2D ただし、動きというのは、基本的にノードが「RigidBody2D」クラスの場合のノードの動きやアニメーションの動きを指す。このチュートリアルでの敵キャラクターのノードは「KinematicBody2D」クラスであるため、移動に関する制御は別途行う必要がある。\nそこで_readyメソッドで物理プロセスを停止させるようにする。\nfunc _ready(): set_physics_process(false) このように引数をfalseにしてset_physics_processメソッドを実行させれば、物理プロセスは停止する。「Enemy」シーンを継承した個別の敵キャラクターシーンでは_physics_processメソッドでノードを移動させる予定のため、これでゲーム開始時点でノードの動きを止めることができるはずだ。\n次に、画面に敵キャラクターが表示された時に動き出すようにする必要がある。これには「VisibilityEnabler2D」ノードのシグナルを利用する。「VisibilityEnabler2D」ノードを選択したら、ノードドック＞「シグナル」タブにて「screen_entered()」シグナルをスクリプトに接続する。接続するスクリプトは当然「Enemy.gd」スクリプトだ。\n生成されたメソッド_on_VisibilityEnabler2D_screen_enteredのブロック内に実行したいコードを記述しよう。\nfunc _on_VisibilityEnabler2D_screen_entered(): set_physics_process(true) 引数をtrueにして組み込みのset_physics_processメソッドを実行すると、停止していた物理プロセスが動き出す。これで、画面上に敵キャラクターが表示されたら、停止している物理プロセスが再開されようになった。\n同様にして、画面上から敵キャラクターが消えたら、その物理プロセスが停止するようにも設定しておこう。これには「VisibilityEnabler2D」ノードの別のシグナルを利用する。今度は「VisibilityEnabler2D」ノードを選択して、ノードドック＞「シグナル」タブにて「screen_exited()」シグナルを「Enemy.gd」スクリプトに接続しよう。\nfunc _on_VisibilityEnabler2D_screen_exited(): set_physics_process(false) 生成されたメソッド_on_VisibilityEnabler2D_screen_exitedのブロック内に引数をfalseにしてset_physics_processメソッドを記述しておけば、画面上から敵キャラクターが消えたら、物理プロセスが停止し、敵キャラクターの移動も停止するはずだ。\n「Enemy.tscn」シーンと「Enemy.gd」スクリプトを保存し、個別の敵キャラクターのシーンを作成し、おかしなところはそこで修正をかけていこう。\nEnemy シーンを継承して Mushroom シーンを作る ここからは先に作成した「Enemy.tscn」シーンを継承する形で、個別の敵キャラクターを作っていく。\nまずはゲームで最弱の敵キャラクターから作っていこう。スーパーマリオシリーズでいうところのクリボーのようなキャラクターだ。便宜上名前を「マッシュルーム」としておく。\nまず「シーン」メニュー＞「新しい継承シーン」を選択する。\nルートノードの名前を「Mushroom」に変更しておこう。\nこの時点で先にシーンを保存しておこう。この時、res://Enemies/ に「Mushroom」フォルダを作成して、その中に「Mushroom.tscn」のファイル名で保存しよう。つまりファイルパスは「res://Enemies/Mushroom/Mushroom.tscn」になる。\nMushroom シーンの各ノードの設定を更新する 継承したシーンではルートノード以外のノードがグレーアウトして表示されているが、全く編集できないわけではないので安心していただきたい。各ノードの編集を順番に行っていく。\nMushroom ルートノードの Script Variables を編集する まずはルートノードから編集しよう。\nScript Variables とはスクリプト内で定義した変数（プロパティ）のことだ。継承元の「Enemy」シーンですでに定義しておいた「gravity」と「speed」の2つにはexportキーワードをつけておいたので、継承先のシーンでもインスペクターから簡単に値を変更できる。\nシーンドックで「Mushroom」ルートノードを選択し、それぞれのプロパティを以下の値に変更しよう。\nGravity: 512 Speed: 32\nAnimatedSprite ノードのアニメーションを編集する 続いて「AnimatedSprite」ノードの編集を行う。\nシーンドックで「AnimatedSprite」ノードを選択したら、インスペクターから「Frames」プロパティで「SpriteFrames」をクリックし、メニューから 「ユニーク化」 を選択する。これにより、この「SpriteFrames」を編集しても、継承元の「Enemy」シーンには影響しない。その結果、今後作成予定の他の「Enemy」からの継承シーンにも影響しない。忘れがちだが、他のシーンへの影響を回避するために重要な操作なので早めの実施を心がけよう。\nここからはアニメーションを作成する。プレイヤーキャラクターでも一度やった作業なので、多少慣れた感じで進めていただけるだろう。\nまずシーンドックで「AnimatedSprite」ノードを選択する。エディタ下部で「スプライトフレーム」パネルが表示されるので、そこで編集していく。\n以下の3つのアニメーションを追加し、それぞれの速度を 24 FPS の設定にする。スプライトシートが「Asset」フォルダにあるので、それぞれに割り当てよう。\nアニメーション名: hit / スプライトシート: res://Assets/Enemies/Mushroom/Hit.png\nアニメーション名: idle / スプライトシート: res://Assets/Enemies/Mushroom/Idle (32x32).png\nアニメーション名: run / スプライトシート: res://Assets/Enemies/Mushroom/Run (32x32).png\nアニメーション「hit」だけはプレイヤーキャラクターに踏まれた時に一回だけ再生してノードを解放する（消す）予定のため、ループの設定をオフにしておこう。\nところで、もし追加したスプライトフレームの画像にブラーがかかっている（ぼやけている）感じであれば、ファイルシステムで、該当のスプライトシートを選択した状態で、インポートドックにて「2D Pixel」プリセットを読み込み、その設定で「再インポート」するとピクセルアート独特のエッジが効いた見た目に修正される。\n最後に、それぞれのアニメーションをチェックしておこう。\nCollisionShape2D ノードのコリジョン形状を設定する 「Mushroom」シーンには「CollisionShape2D」ノードが2つあるので、それぞれのコリジョン形状を順番に設定していく。\nまずは「Mushroom」ルートノード直下の「CollisionShape2D」ノードのコリジョン形状からやっていこう。このコリジョン形状は、敵キャラクター自身が地面や壁、プレイヤーキャラクターなど他のオブジェクトと衝突したことを検知するために使用する。そのため、できるだけスプライトテクスチャのデザインに近い形状にするのが理想だ。\nインスペクターから「Shape」プロパティの「CapsuleShape2D」をクリックし、また 「ユニーク化」 を選択して適用しておこう。継承元に影響を与えないためだ。\n「CapsuleShape2D」のコリジョン形状は、デフォルトでは縦長の楕円形になっている。「Mushroom」のスプライトテクスチャは、比較的平べったいデザインだ。スプライトテクスチャのデザインにもよるが、横長のデザインの場合は、コリジョン形状を90°回転すると調整しやすいことが多い。\n2Dワークスペースでドラッグ操作でコリジョン形状を調整する場合は、ツールバーの「スナップオプション」から「ピクセルスナップを使用」にチェックを入れておこう。\nだいたい以下のような形状になればOKだ。足が地面との衝突を正確に検知するため、テクスチャデザインの足の先にきっちり合わせておこう。頭のてっぺんには意図的に少しスペースを設けている。理由は、もう一つのコリジョン形状（プレイヤーキャラクターが敵キャラクターを踏んだことを判定するためのコリジョン形状）をそこに配置する予定だからだ。\nこのコリジョン形状の「Radius」と「Height」は以下の数値になっている。ドラッグ操作が煩わしい場合は、こちらに直接入力してもらっても構わない。\n続いて、もう一つの「HitBox」ノードの子になっている「CollisionShape2D」ノードの方を編集していく。作業自体は大体同じだ。まず、シーンドックで該当の「CollisionShape2D」ノードを選択した状態で、インスペクターから「Shape」プロパティの「RectangleShape2D」を選択する。ここでも忘れずに 「ユニーク化」 を適用しておこう。\n今回のコリジョン形状は大体以下のようになればOKだ。ポイントは、ルートノード直下の「CollisionShape2D」の幅より狭くし、それと重ならないようにしてスプライトテクスチャの頭のてっぺんに配置することだ。幅が広いと、踏まずともぶつかっただけでこの敵キャラクターを倒せてしまうし、頭のてっぺんのコリジョン形状が重なると、プレイヤーの方がぶつかられて、やられてしまうかもしれない。\nこのコリジョン形状の「Extents」プロパティは(8, 1)になっている。\nこれで、コリジョン形状の調整ができた。インスペクターで編集する内容はひとまずここまでだ。次はいよいよスクリプトの方を更新していく。\nEnemy.gd を継承した Mushroom.gd スクリプトをアタッチする 現時点で「Mushroom」ノードには「Enemy.gd」スクリプトがアタッチされている。「Enemy」シーンを継承しているので当然なのだが、このスクリプトは全敵キャラクター共用のスクリプトなので、「Mushroom」シーンのためだけに更新するわけにはいかない。\nひとまず「Enemy.gd」はデタッチ（紐付け解除）しよう。シーンドックで「Mushroom」ノードを右クリック＞「スクリプトをデタッチ」を選択する。これで簡単にアタッチされていたスクリプトが外れる。\n次に「Mushroom」を選択して、新しいスクリプトをアタッチする。この時、デフォルトの設定のまま作成してしまうと「KinematicBody2D」クラスを継承したスクリプトになってしまう。「継承元」の右側にあるフォルダアイコンをクリックしてみよう。\nすると、作成済みのスクリプトを選択できる。「res://Enemies/Enemy.gd」を選択して「開く」をクリックしてみよう。\nこれで「継承元」として「res://Enemies/Enemy.gd」が選択された状態になった。新しいスクリプトのファイルパスを「res://Enemies/Mushroom/Mushroom.gd」として「作成」をクリックしよう。\nスクリプトエディタに切り替わったら、一行目にextends \u0026quot;res://Enemies/Enemy.gd\u0026quot;という記述があることに気がつくだろう。これは先に作成した「Enemy」シーン用の「Enemy.gd」スクリプトを継承していることを示している。\nextends \u0026#34;res://Enemies/Enemy.gd\u0026#34; func _ready(): pass このように、自作のスクリプトも簡単に継承することができる。シーンを継承するときはスクリプトも別途継承できることを覚えておこう。\nMushroom.gd スクリプトを編集する まずは_readyメソッドから編集する。マッシュルームの移動時は「AnimatedSprite」ノードの「run」アニメーションを再生したいので、以下ように編集した。\nfunc _ready(): sprite.play(\u0026#34;run\u0026#34;) どのアニメーションを最初に再生するかはインスペクターで設定しておけるが、デバッグをしていると、他のアニメーションの再生中に終了して、そのアニメーションの設定がそのまま残ることがある。毎回ゲーム開始時に「run」アニメーションを再生するように_readyメソッド内でアニメーションを指定した。\nでは次に「Mushroom」の移動をスクリプトで制御していこう。例によって今回も_physics_processメソッドを利用する。\nfunc _physics_process(delta): マッシュルームは、最弱キャラでただ速くもないスピードで前進したり止まったりするだけのキャラクターとする。\nまずは基本として以下を満たすようにコーディングしていこう。\n毎フレームspeedプロパティの値だけ左方向に前進させる 高所から落ちる際は重力で加速しながら落下する func _physics_process(delta): velocity.x = -speed velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) このようなコードになる。velocityの x, y の値をそれぞれ設定し、そのvelocityをmove_and_slideメソッドの第一引数に代入することで、ノードの移動を制御する最低限のコードができた。\nさらに以下を満たすようにコードを追加しよう。\n壁にぶつかったら進行方向を左右反転する func _physics_process(delta): if is_on_wall(): speed *= -1 sprite.flip_h = !sprite.flip_h velocity.x = -speed velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) is_on_wallメソッドは壁に接していれば true を返す。つまり冒頭に追加した if 構文は『もしマッシュルームが壁に衝突したら』という条件分岐になる。\nこの条件を満たした場合、speedプロパティに -1 を乗算することで x 軸の反対方向に進むようにしている。sprite.flip_hプロパティが true の場合は、『水平方向に「AnimatedSprite」を反転させる』という意味になる。sprite.flip_hプロパティの値に!sprite.flip_hと指定することで、現在のsprite.flip_hの値とは逆の値（現在 true なら false）を設定する、というコードになる（!は not と同様の意味）。\nさてこれでマッシュルームの基本的な動きが出来上がったので、Level1 シーンにインスタンスをノードとして追加してみよう。忘れずに「Mushroom」シーンを保存しておこう。\nLevel1 シーンに Mushroom シーンのインスタンスノードを追加する ここまで作成してきた「Mushroom」シーンを「Level1」シーンのノードとしてインスタンス化して追加しよう。\nまずはシーンドックで「Level1」ルートノードを選択したら、チェーンのアイコンをクリックする。\n保存済みのシーンのファイルがリストアップされるので、「Mushroom.tscn」ファイルを選択して「開く」をクリックする。もしここで大量のファイルがある場合は上部の検索バーから検索も可能だ。\n「Mushroom.tscn」がインスタンス化されて「Level1」の子ノードになった。\nでは「Mushroom」ノードを2Dワークスペース上の任意の場所に移動しよう。すぐに挙動が確認できるように、ゲーム開始時のキャラクターの位置に程よく近く、しかしゲームスタート時は画面に入らないような場所が最適だ。\nここで一度プロジェクトを実行してマッシュルームの動きを確認しておこう。\n以下の動作について確認できた。\nマッシュルームがゲーム画面に入ってから動き出した 重力で下に高所から落下した 一定速度で「run」アニメーションを再生しながら前進した ゲーム画面外に出ると動きが止まった プレイヤーキャラクター（今回は壁の代わり）と衝突したら向きを反転した プレイヤーキャラクターに踏まれたら「hit」アニメーション再生後に消えた Mushroom シーンを編集して動きに変化をつける せっかく「AnimatedSprite」ノードで「idle」アニメーションを用意したので、これを使って、少しマッシュルームの動きに変化をつけてみよう。\n敵キャラクターに少し複雑な動きをつけたい時、「Timer」クラスのノードを追加すると非常に便利だ。では「Mushroom.tscn」シーンに切り替えて、「Mushroom」ルートノードに「Timer」ノードを追加しよう。\n次にインスペクターで「Timer」ノードのプロパティを以下のように設定しよう。\nWait Time: 4 Autostart: オン\nこれで4秒毎にタイムアウトするタイマーができた。そのタイムアウトのタイミングでプログラムを実行したいので、シグナルを接続しよう。「Timer」ノードを選択して、ノードドックの「シグナル」タブから「timeour()」シグナルを「Mushroom.gd」スクリプトに接続しよう。メソッド名などはデフォルトのままで良い。\n接続できたら、「Mushroom.gd」スクリプトに_on_Timer_timeoutメソッドが追加されただろうか。\nfunc _on_Timer_timeout(): pass 先に、コードをメンテナンスしやすくするために、以下のように変数timerとして「Timer」ノードの参照を定義しておこう。\nonready var timer = $Timer そして_on_Timer_timeoutメソッドの中身を以下のように更新しよう。\nfunc _on_Timer_timeout(): if is_on_floor(): timer.stop() set_physics_process(false) sprite.play(\u0026#34;idle\u0026#34;) yield(get_tree().create_timer(2), \u0026#34;timeout\u0026#34;) sprite.play(\u0026#34;run\u0026#34;) set_physics_process(true) timer.start() 実装したいのは「マッシュルームは最弱なのですぐに息が切れてしまう」という感じの動きだ。息切れを表現するのに「AnimatedSprite」の「idle」アニメーションを利用する。\n空中で息が切れるわけにはいかないので、if 構文でis_on_floorメソッドで true が帰ってきた場合（マッシュルームが地面に接している場合）のみ、それ以下のコードが実行されるようにした。\nif 条件式が true だった場合に、以下の内容を実行するコードになっている。これらの動きが 4 秒ごとに発生する。\n自動でカウントダウンし続ける「Timer」ノードのstopメソッドにより、タイマーのカウントダウンを停止する。 set_physics_processメソッドで引数に false を渡すことで物理プロセスを停止する。これにより「Mushroom.gd」スクリプト内の_physics_processメソッドが停止するのでマッシュルームは前進しない。 「AnimatedSprite」の「idle」アニメーションを再生する。 yieldにより、一時的な別のタイマーを作成し、待ち時間を2秒にし、これがタイムアウトするまで待つ。つまり「idle」アニメーションを 2 秒続ける。 一時的なタイマーがタイムアウトしたら、「AnimatedSprite」ノードの「run」アニメーションを再び再生させる。 set_physics_processメソッドで引数に true を渡すことで、停止していた物理プロセスを再開する。これでマッシュルームがまた前進を始める。 「Timer」ノードのstartメソッドにより、カウントダウンを再開する。 ではプロジェクトを実行して動きを確認してみよう。\n見事に息が切れている感じを表現できた。\nPart 4 で編集したスクリプトのコード 最後に今回の Part 4 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nEnemy.gd の全コード extends KinematicBody2D # Added @ Part 4 export var gravity: int export var speed: int var velocity = Vector2() onready var sprite = $AnimatedSprite func _ready(): set_physics_process(false) func _on_HitBox_body_entered(body): if body.is_in_group(\u0026#34;Players\u0026#34;): print(\u0026#34;Player entered in \u0026#34;, self.name) sprite.play(\u0026#34;hit\u0026#34;) yield(sprite, \u0026#34;animation_finished\u0026#34;) queue_free() print(self.name, \u0026#34;died\u0026#34;) func _on_VisibilityEnabler2D_screen_entered(): set_physics_process(true) func _on_VisibilityEnabler2D_screen_exited(): set_physics_process(false) Mushroom.gd の全コード extends \u0026#34;res://Enemies/Enemy.gd\u0026#34; # Added @ Part 4 onready var timer = $Timer func _ready(): sprite.play(\u0026#34;run\u0026#34;) # Set default animation func _physics_process(delta): if is_on_wall(): speed *= -1 sprite.flip_h = !sprite.flip_h velocity.x = -speed velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) func _on_Timer_timeout(): if is_on_floor(): timer.stop() set_physics_process(false) sprite.play(\u0026#34;idle\u0026#34;) yield(get_tree().create_timer(2), \u0026#34;timeout\u0026#34;) sprite.play(\u0026#34;run\u0026#34;) set_physics_process(true) timer.start() おわりに 以上で Part 4 は完了だ。今回はマッシュルームしか作れなかった割に、なかなかボリューミーな回となった。\n次回は、もう少し別の動きをする敵キャラクターを数種類追加して、「Level1」シーンに複数配置するところまでやって、敵キャラクターに関する手順を終える予定なのでお楽しみに。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_4/","summary":"第4回目の今回は、敵キャラクターの雛形となるシーンを作成し、それを継承する形で個別の敵キャラクターを一つ作っていく。そのあと、その敵キャラクターをレベルシーンに配置して、プレイヤーキャラクターに踏まれ","title":"Godot で作るプラットフォーマー Part 4：敵キャラクターを作ろう！"},{"content":"第5回目の今回は、さらに敵キャラクターの種類を増やしていく。それぞれの敵キャラクターの動きに違いを持たせ、それらをタイルマップ上に複数配置してゲームの難易度を高めていこう。具体的に今回は以下の敵キャラクターを作成していく。\nバニー（うさぎ） カメレオン プラント（植物） Memo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー Bunny シーンを作る まず追加する最初の敵キャラクターはバニーだ。Part 4 でマッシュルームを作った時のおさらいだと思って進めていこう。では「Enemy」シーンを継承して「Bunny」シーンを作るところから開始する。以下の手順でシーンを作成して保存しよう。\n「シーン」メニュー＞「新しい継承シーン」を選択する。 継承元として「Enemy.tscn」を選択して開く。 ルートノードを「Bunny」に変更する。 シーンを保存する。この時「res://Enemies/」に「Bunny」フォルダを作成して、そこに「Bunny.tscn」という名前で保存しよう。ファイルパスは「res://Enemies/Bunny/Bunny.tscn」になる。 これで「Bunny」シーンが用意できた。\n各ノードのプロパティを編集する ルートノードの Script Variables を編集する 「Bunny」ルートノードの Script Variables を以下のように変更しよう。\nGravity: 512 speed: 48 AnimatedSprite ノードのアニメーションを編集する まず忘れずに行いたいのが「AnimatedSprite」の「Frames」プロパティを 「ユニーク化」 することだ。ユニーク化できたら、「SpriteFrames」をクリックしてアニメーションを編集していく。\n以下の内容でアニメーションを用意しよう。\nアニメーション名: fall 速度: 24 FPS スプライトシート: res://Assets/Enemies/Bunny/Fall.png ループ: オン\nアニメーション名: hit 速度: 24 FPS スプライトシート: res://Assets/Enemies/Bunny/Hit (34x44).png ループ: オフ\nアニメーション名: jump 速度: 24 FPS スプライトシート: res://Assets/Enemies/Bunny/Jump.png ループ: オン\nアニメーション名: run 速度: 24 FPS スプライトシート: res://Assets/Enemies/Bunny/Run (34x44).png ループ: オン\nなお「res://Assets/Enemies/Bunny/」フォルダには「Idle (34x44).png」も用意してあるが、このチュートリアルでは不要だ。\nもしスプライトシートの画像にブラーがかかっている（ぼやけている）場合は、該当のファイルをファイルシステムドックで選択した状態で、インポートドックから「プリセット」＞「2D Pixel」選択 ＞ 「再インポート」を実施しておこう。\nCollisionShape2D ノードのコリジョン形状を設定する 「Bunny」ルートノード直下の「CollisionShape2D」ノードから編集する。こちらも忘れないうちに「Shape」プロパティの値を 「ユニーク化」 しておこう。\n続けて、コリジョン形状を調整する。バニーは少し縦長のデザインなので「CapsuleShape2D」の形を当てはめやすいだろう。\nスプライトテクスチャに対して、だいたい以下のような形、配置になればOKだ。前回のマッシュルーム同様、足先は地面との衝突検知のためにピッタリ合わせ、頭のてっぺんは別のHitBoxの方の「CollisionShape2D」を配置するので少し空けている。なお、便宜上、下の画像ではシーンドックで不要なノードを非表示にしてコリジョン形状を見やすくしている。\nこのコリジョン形状の編集によって、インスペクター上の関係するプロパティの値はそれぞれ、以下のようになっている。2Dワークスペースでの調整が苦手な場合は、これらの数値を直接インスペクターで入力しても構わない。\nRadius: 8 Height: 10\nPosition: (0, 9)\n次に「HitBox」ノードの子である「CollisionShape2D」ノードのコリジョン形状を編集する。まずは「Shape」プロパティの値を 「ユニーク化」 しておこう。\nこちらのコリジョン形状は、頭の上に配置し、先に設定したルートノード直下の「CollisionShape2D」より幅を狭くし、また形状が重ならないようにする。\nコリジョン形状の編集により関係するプロパティは以下のようになっている。\nExtents: (5, 2)\nPosition: (0, -6)\nVisibilityEnabler2D ノードの形状を設定する 最後に「VisibilityEnabler2D」ノードの形状も編集しておこう。調整作業自体は2Dワークスペースでドラッグ操作で行うのが直感的でわかりやすいだろう。下のスクリーンショットのように、だいたいバニーのスプライトテクスチャと同じくらいにした。\n関連するプロパティの具体的な値は以下のようになった。\nPosition: (0, 2) Scale: (0.875, 1.25)\n以上でプロパティの編集は終わりだ。次はスクリプトをアタッチして、コードで動きを制御していこう。\nBunny シーンに新しいノードを追加する 「Bunny」ルートノードに、「Enemy」シーンにはなかった「Area2D」ノードを追加しよう。この「Area2D」ノードには「CollisionShape2D」ノードを追加しよう。\nこれはバニーの動きに変化をつけるための簡単な仕掛けだ。バニーにプレイヤーキャラクターが一定の距離まで近づいたら、「Area2D」のシグナルを利用して、バニーの動きを変えるというものだ。具体的には、バニーがプレイヤーキャラクターから離れている間は「AnimatedSprite」の「run」アニメーションで走らせるが、一定距離内に近づくと「jump」＆「fall」アニメーションに切り替えて、ジャンプして移動させる。\nどれくらいの距離でアニメーションを切り替えるかは「Area2D」ノードの子「CollisionShape2D」のコリジョン形状を決定する「Radius」プロパティ次第だ。今回は値を 100 とした。「Position」プロパティはデフォルトの (0, 0) のままなので、単純にプレイヤーキャラクターが半径 100 px 以内に近づくとバニーがジャンプで移動し始めるという動きを想定している。\nBunny.gd スクリプトをアタッチして編集する 前回の Part 4 では、「Mushroom」シーンで「Mushroom」ノードから「Enemy.gd」スクリプトを最初にデタッチして、その後、「Enemy.gd」を継承した「Mushroom.gd」スクリプトをアタッチしていた。\nしかし、このあと数種類の敵キャラクターを作るごとに「Enemy.gd」スクリプトをデタッチする作業が煩わしいので、このタイミングで「Enemy」シーンの「Enemy」ルートノードからスクリプトをデタッチしておこう。そうすれば、「Enemy」シーンを継承して作成したシーンで、毎回スクリプトをデタッチする必要がなくなる。\nでは「Enemy.tscn」シーンを開いて、「Enemy」ルートノードを右クリックし、「スクリプトをデタッチ」を選択しよう。\n次に「Bunny.tscn」シーンを開いて、「Bunny」ルートノードにスクリプトをアタッチする。\n継承元を「res://Enemies/Enemy.gd」、ファイルパスを「res://Enemies/Bunny/Bunny.gd」としてスクリプトを作成してアタッチしよう。\nスクリプトがアタッチできたら、コードを編集していこう。\nextends \u0026#34;res://Enemies/Enemy.gd\u0026#34; export var jump_force = 200 # バニーのジャンプ力 var is_jumping = false # ジャンプで移動しているかどうかのステータス バニーはジャンプ移動するので、ジャンプ力を示すプロパティとしてjump_forceを定義した。値は200としている。プレイヤーキャラクターよりややジャンプ力を低くしている。\nis_jumpingプロパティは、走って移動しているのか、ジャンプして移動しているのかを示すステータスの役割として定義した。最初は走って移動なので値をfalseにしている。プレイヤーキャラクターが「Area2D」ノードの範囲に入ったらtrueに変更する予定だ。\n次に_readyメソッドで最初に再生するアニメーションとして、「run」アニメーションを指定した。\nfunc _ready(): sprite.play(\u0026#34;run\u0026#34;) 続いて_physics_processメソッドを編集していく。\nfunc _physics_process(delta): # Mushroom と同じ if is_on_wall(): speed *= -1 sprite.flip_h = !sprite.flip_h # ジャンプで移動中の場合 if is_jumping: if is_on_floor(): velocity.y = -jump_force else: if velocity.y \u0026lt; 0: sprite.play(\u0026#34;jump\u0026#34;) else: sprite.play(\u0026#34;fall\u0026#34;) # Mushroom と同じ velocity.x = -speed velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) if is_jumping:のブロックが Part 4 で作ったマッシュルームと違うところだ。\n冒頭で定義したis_jumpingプロパティの値がtrueだった場合にブロック内のコードを実行する。そしてすぐにネストされたif / else構文になる。\nif is_on_floor(): で地面に接している場合、ということになるが、この場合はvelocity.yにジャンプ力であるjump_forceに-をつけて代入している。これにより、バニーがジャンプする。\nジャンプしている間はis_on_floorメソッドの戻り値がfalseになるので、elseブロックに入る。ここでさらにネストされたif / else構文になっている。\n一旦ジャンプ力とイコールになったvelocity.yの値が、毎フレーム重力の影響を受け、やがて0に近づいていく。そして0になった時がジャンプの高さの頂点だ。つまりif velocity.y \u0026lt; 0: は『ジャンプの頂点に達するまでは』という条件であり、その間は「jump」アニメーションを再生するよう指定している。\nそしてelseブロックはvelociy.yの値が0以下、つまり『ジャンプの頂点から地面に落ちている間は』という条件になる。この間は「fall」アニメーションを再生するように指定している。\nさて、is_jumpingプロパティの値の切り替えを行うには、「Area2D」のシグナルを利用する。一旦、シーンドックに戻って「Area2D」ノードを選択し、ノードドック＞「シグナル」タブにて、以下の2つのシグナルを「Bunny.gd」スクリプトに接続しよう。\nbody_entered(body) body_exited(body) 接続すると、スクリプトにメソッドが追加されたはずだ。そのメソッドは以下のように編集する。\n# Area2D ノードのシグナル「body_entered(body)」を接続 func _on_Area2D_body_entered(body): if body.is_in_group(\u0026#34;Players\u0026#34;): is_jumping = true # Area2D ノードのシグナル「body_exited(body)」を接続 func _on_Area2D_body_exited(body): is_jumping = false sprite.play(\u0026#34;run\u0026#34;) どちらもメソッドのブロック内冒頭でif body.is_in_group(\u0026quot;Players\u0026quot;):を記述している。以前のチュートリアルで、「Player」シーンの「Player」ノードを「Players」ノードグループに追加したので、その設定を再利用している。プレイヤーキャラクター以外にも、他の敵キャラクターが近くにいる場合が想定できるので、この if 構文が必要なのだ。ちなみにif body.name == \u0026quot;Player\u0026quot;:としてもらっても良い（「Player」ノードの名前を変えない限り）。\nそして「Area2D」のコリジョン範囲に入ったらis_jumpingプロパティをtrueとしてジャンプでの移動に切り替え、範囲から出たらis_jumpingプロパティをfalseとしつつ「run」アニメーションを再生させている。\nここまでできたら「Bunny.tscn」および「Bunny.gd」を保存して、バニーの動きを確認していこう。\nLevel1 シーンに Bunny シーンのインスタンスノードを追加する では、バニーが想定通りの動きをするか見ていこう。「Level1」ノードに「Bunny.tscn」のインスタンスノードを追加する。\n今回もひとまず2Dワークスペースで、すぐに動作を確認できそうな位置に「Bunny」ノードを配置しよう。\n配置できたらプロジェクトを実行して挙動を確認してみよう。\nChameleon シーンを作る 次は別の敵キャラクターのカメレオンを作っていく。バニーの手順と同様にサクサク進めていこう。\n「シーン」メニュー＞「新しい継承シーン」を選択する。 継承元として「Enemy.tscn」を選択して開く。 ルートノードを「Chameleon」に変更する。 シーンを保存する。フォルダを作成して、ファイルパスは「res://Enemies/Chameleon/Chameleon.tscn」とする。 各ノードのプロパティを編集する スクリプトを作成してルートノードにアタッチする 「Enemy.gd」スクリプトに記述している Script Variables をカメレオンにも適用して、値を編集したいので、先に「Enemy.gd」を継承したスクリプトを作成、アタッチしよう。\n「Chameleon」ルートノードを選択して、スクリプトをアタッチする。以下の設定でスクリプトを作成すること。\n継承元: res://Enemies/Enemy.gd パス: res://Enemies/Chameleon/Chameleon.gd ルートノードの Script Variables を編集する 「Bunny」ルートノードの Script Variables を以下のように変更しよう。\nGravity: 512 speed: 16 AnimatedSprite ノードのアニメーションを編集する まずは「AnimatedSprite」の「Frames」プロパティを 「ユニーク化」 しよう。ユニーク化できたら、「SpriteFrames」をクリックしてアニメーションを編集していく。\n以下の内容でアニメーションを用意しよう。\nアニメーション名: attack 速度: 12 FPS スプライトシート: res://Assets/Enemies/Chameleon/Attack (84x38).png ループ: オン\nアニメーション名: hit 速度: 24 FPS スプライトシート: res://Assets/Enemies/Chameleon/Hit (84x38).png ループ: オフ\nアニメーション名: idle 速度: 24 FPS スプライトシート: res://Assets/Enemies/Chameleon/Idle (84x38).png ループ: オン\nアニメーション名: run 速度: 24 FPS スプライトシート: res://Assets/Enemies/Chameleon/Run (84x38).png ループ: オン\n繰り返しになるが、もしスプライトシートの画像にブラーがかかっている（ぼやけている）場合は、該当のファイルをファイルシステムドックで選択した状態で、インポートドックから「プリセット」＞「2D Pixel」選択 ＞ 「再インポート」を実施しておこう。\nあとは、カメレオンのスプライトテクスチャが、カメレオンの体をやや右寄りにデザインされているので、体の中心がだいたい y 軸上にくるように「AnimatedSprite」ノードの「Position」プロパティの x の値を -16 に変更しておく。\nCollisionShape2D ノードのコリジョン形状を設定する まずは「Chameleon」ルートノード直下の「CollisionShape2D」から編集する。\nカメレオンの体に合わせてコリジョン形状を編集する。「idle」アニメーション時の足元をピッタリ合わせて、頭のてっぺんは「HitBox」のコリジョン形状を配置のために少し空けておこおう。\nコリジョン形状に関わるプロパティの値は以下の通りだ。\nRadius: 11 Height: 2\nPosition: (7, 0)\n続けて「HitBox」ノード下の「CollisionShape2D」ノードのコリジョン形状を編集しよう。これまで通り、頭のてっぺんに配置し、幅をルートノード直下の「CollisionShape2D」より狭くして重ならないようにする。\nコリジョン形状に関わるプロパティの値は以下の通りだ。\nExtents: (7, 2)\nPosition: (0, -7)\nVisibilityEnabler2D ノードの形状を設定する 「VisibilityEnabler2D」ノードの形状もカメレオンのスプライトテクスチャに合わせて調整しよう。\n関連するプロパティの値は以下の通りだ。\nPosition: (4.5, 3) Scale: (1.031, 1)\nChameleon ノードに RayCast2D ノードを追加する 「AnimatedSprite」ノードの「attack」アニメーションを見てみると、カメレオンは舌を伸ばして攻撃してくるデザインだ。そこで、プレイヤーキャラクターが、カメレオンに対して水平（ x 軸）方向に一定距離近づくと、近寄ってきて、さらに一定距離近づくと舌を伸ばして攻撃してくる、という動きにしていく。\nプレイヤーキャラクターとの水平方向の距離を検知するために「Chameleon」ルートノードに「RayCast2D」クラスのノードを追加しよう。このノードは指定した直線距離での衝突判定機能を提供してくれるので非常に便利だ。\n「RayCast2D」は2Dワークスペース上では、矢印で表示されている。この矢印をカメレオンが「attack」アニメーションで出した時の舌の向きと位置に合わせる。この作業のために一時的に「AnimatedSprite」ノードのプロパティを以下のように編集しよう。\nAnimation: attack Frame: 6 Playing: オフ これで2Dワークスペース上には、舌を伸ばした状態のカメレオンのスプライトテクスチャが表示されているはずだ。このデザインに合わせて「RayCast2D」を調整していく。\n関係するプロパティを以下のように編集しよう。\nEnabled: オン \u0026gt; RayCast2Dが有効にする Cast To: （-120, 0）\u0026gt; 左向きの長さ 120 px の矢印にする\nPosition: (0, 6) \u0026gt; カメレオンの舌と同じ高さにする\n2Dワークスペース上では以下のスクリーンショットのようになっているはずだ。\nChameleon.gd スクリプトを編集する さっき追加した「RayCast2D」ノードを利用しつつ「Chameleon.gd」スクリプトをコーディングしていく。\nまずは必要なプロパティの定義から始めよう。「RayCast2D」ノードにアクセスしやすくするため、onreadyキーワード付きでraycastプロパティにこのノードの参照を渡した。\nextends \u0026#34;res://Enemies/Enemy.gd\u0026#34; onready var raycast = $RayCast2D 次に_readyメソッドで、「AnimatedSprite」ノードの最初のアニメーションを「idle」に指定した。\nfunc _ready(): sprite.play(\u0026#34;idle\u0026#34;) 続いて_physics_processメソッドを定義する。\nfunc _physics_process(delta): velocity.y += gravity * delta if raycast.is_colliding(): if raycast.get_collider().name == \u0026#34;Player\u0026#34;: if position.distance_to(raycast.get_collision_point()) \u0026gt; 80: run() else: attack() velocity.x = 0 else: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = 0 velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) 冒頭からif構文だ。\n「RayCast2D」のis_collidingメソッドは、「RayCast2D」ノードの矢印に何らかのオブジェクトが衝突していればtrue、そうでなければfalseを返す。つまり最初のif構文は、『「RayCast2D」の矢印にオブジェクトが衝突していれば』という条件だ。\n次のネストされたif構文を確認しよう。get_colliderメソッドは、衝突しているオブジェクトを返す。そのnameプロパティにはそのオブジェクトの名前が入っている。つまりこのif構文は、衝突したオブジェクトの名前が「Player」だったら、という条件になっている。ちなみにis_on_groupメソッドを使いたいところだが、生憎、get_colliderで取得するオブジェクトにはそのメソッドが含まれないので使用できない。\nそしてさらにネストされた3つ目のif構文を見てみよう。メソッドの引数に他のメソッドが入っているのでややこしく見えるが、一つずつ確認していく。\nまずpositionは「Chameleon」ノードの「Position」プロパティで、どこにカメレオンがいるのかを x, y 座標の Vector2 型の値で保持している。Vector2 クラスにはdistance_toというメソッドがある。このメソッドは自身の x, y 座標と、引数で渡した Vextor2 の座標までの長さ（直線距離）を float 型で返す。今回その引数には別のメソッドget_collision_pointを渡している。このメソッドは「RayCast2D」ノードがオブジェクトと衝突している位置を Vector2 型の値で返す。\nつまり、この3つ目のif構文は、『「Chameleon」ノードの位置から「RayCast2D」ノードがオブジェクトと衝突した位置までの距離が80px より大きかったら』という条件になっている。そのif条件を満たした場合、runメソッドが呼ばれる。このrunメソッドはこのあと定義する。\n一方、オブジェクトとカメレオンとの直線距離が80px 以下の場合はelseブロックに入り、「attack」メソッドが呼ばれる。このattackメソッドもこのあと定義する。そのすぐ後にvelociy.x = 0としている。舌で攻撃を仕掛けてくる時は移動はしない、ということだ。\nそして、2ブロック戻って、最初のif条件を満たさない場合、つまり「RayCast2D」ノードの矢印がオブジェクトに衝突していない場合は、ただ「idle」アニメーションを再生するのみで、移動もしない。\n一番外側のif / elseブロックを抜けると、velociy.yの値に重力を適用し、最後に現在のvelocityの値を引数にとってmove_and_slideメソッドによりカメレオンの動きが制御される。\nちなみにif構文を2つネストさせたが、andや\u0026amp;\u0026amp;でつないで全て一行のifブロックにすることも可能だ。今回は可読性を重視してこのような形にした。\nでは、次に新しいメソッドを定義しておく。まずはrunメソッドから。\nfunc run(): sprite.play(\u0026#34;run\u0026#34;) if is_on_wall(): speed *= -1 sprite.flip_h = !sprite.flip_h sprite.position.x *= -1 raycast.cast_to.x *= -1 velocity.x = -speed 実はこれは Part 4 で作ったマッシュルームの_physics_processメソッド内の内容とほとんど同じだ。このスクリプトの場合、_physics_processメソッド内のコード量が多くなり、ゴチャゴチャするので、スッキリさせるためにただ分離した格好だ。反対にメソッドに分けない方が良い人はこのメソッドを定義せず、中のコードをそのままrunを実行している箇所に移動させても良い。\n念のため、内容を確認しておこう。まず最初に「run」アニメーションを再生する。\n続いてis_on_wallで壁に当たったらという条件のifブロックに入る。壁に当たったら、進行方向を x 軸方向に反転、スプライトテクスチャも同じく反転、スプライトの位置も元々左に-16ずらしているので、sprite.position.x *= -1として反転させる。そして今回追加した「RayCast2D」ノードの矢印の向きも同じく反転させた（cast_to.x *= -1）。\nあとは、velociy.xは常にspeedプロパティの値で一定（左右の方向は変わる）、velociy.yには常に重力gravityがかかっている。このvelociyを引数にしてmove_and_slideメソッドによりカメレオンがゲーム画面上を移動することになる。\n繰り返しになるが、このメソッドはカメレオンの「RayCast2D」の矢印とプレイヤーキャラクターが衝突していて（矢印の長さ 120px 以下）、かつカメレオンとプレイヤーキャラクターとの距離が80pxより大きい場合に呼ばれる。\n続いてattackメソッドを定義しておこう。\nfunc attack(): sprite.play(\u0026#34;attack\u0026#34;) if sprite.frame == 6 or sprite.frame == 7: if raycast.is_colliding() and raycast.get_collider().name == \u0026#34;Player\u0026#34;: if position.distance_to(raycast.get_collision_point()) \u0026lt; 50: print(\u0026#34;Player is hit\u0026#34;) まず「attack」アニメーションを再生する。\n次はif構文だ。『attack」アニメーションのフレームが6か7だったら』という条件だがピンとくるだろうか。実は「attack」アニメーションのフレーム6と7だけがカメレオンが舌を伸ばしているデザインのスプライトテクスチャになっているのだ。\nネストされた2つ目のif構文を見ると、またis_collidingメソッドでオブジェクトと衝突しているか、get_collider().name == \u0026quot;Player\u0026quot;で衝突したオブジェクトの名前は「Player」かをチェックしている。これは厳密にカメレオンが舌を伸ばしている時に「RayCast2D」がプレイヤーキャラクターを捉えているか、を判定するためだ。\nそしてさらにネストされた３つ目のif構文だ。position.distance_to(raycast.get_collision_point()) はさっき_physics_process内にあったコードと同じだ。『カメレオンの位置からプレイヤーキャラクターの位置までの直線距離が50px 未満だったら』という条件になっている。この50px というのは実はフレーム6および7のスプライトテクスチャの伸ばしている舌の長さとほぼイコールなのだ。\nこの３つ目のif条件を満たした場合に、本来はプレイヤーキャラクターをゲームオーバーにするかライフを減らしたいところだが、そこはまだ未実装なので、今の時点ではprintメソッドで「Player is hit」とだけ出力されるようにした。\nLevel1 シーンに Chameleon シーンのインスタンスノードを追加する では、カメレオンが想定通りの動きをするか見ていこう。「Level1」ノードに「Chameleon.tscn」のインスタンスノードを追加する。「Mushroom」と「Bunny」は確認の邪魔になるので一時的に非表示にしておこう。\n今回もひとまず2Dワークスペースで、すぐに動作を確認できそうな位置に「Chameleon」ノードを配置しよう。\n配置できたらプロジェクトを実行して挙動を確認してみよう。\n以下の動きが確認できた。\nプレイヤーキャラクターとの距離が 120 px 以下になるまで「idle」アニメーションで移動はしない プレイヤーキャラクターとの距離が 120 - 80 px では「run」アニメーションで近づいてくる プレイヤーキャラクターとの距離が 80 px 以下で舌を伸ばしてくる（移動はしない） なお、舌がプレイヤーキャラクターに当たった時、出力パネルには以下のように表示された。本来ならゲームオーバーかもしれないが、動きとしては想定通りだ。\nこれでカメレオンはひとまず完成としておこう。なかなかタフなチュートリアルになってきた。まだ敵キャラクターを作るのかと、信じられない気持ちかもしれない。しかし頑張るのだ。\nPlant シーンを作る 次はプラントという敵キャラクターを作ろう。プラントはその名の通り植物のキャラクターだ。だから、移動はしない。その代わりに、遠隔攻撃を仕掛けてくる厄介なキャラクターにしよう。\nほとんどの手順はこれまでに作ってきた敵キャラクターと同じなので、スクリーンショットやすでに説明済みの内容は省かせていただく。\nでは以下の手順で「Plant」シーンを作成しよう。\n「Enemy.tscn」を継承してシーンを作成 ルートノードの名前を「Plant」に変更 「res://Enemies/Plant/Plant.tscn」のパスでシーンを保存 各ノードのプロパティを編集する スクリプトを作成してルートノードにアタッチする 「Plant」ルートノードにスクリプトをアタッチする この時、継承元として「Enemy.gd」を選択する パスは「res://Enemies/Plant/Plant.gd」とする ルートノードの Script Variables を編集する 以下の値で設定する。\nGravity: 512 Speed: 0 AnimatedSprite ノードのアニメーションを編集する まずは「Frames」プロパティの「SpriteFrames」をユニーク化しておこう。そのあとは以下の内容でアニメーションを作成しよう。\nattack 速度: 8 FPS スプライトシート: res://Assets/Enemies/Plant/Attack (44x42).png ループ: オン hit 速度: 24 FPS スプライトシート: res://Assets/Enemies/Plant/Hit (44x42).png ループ: オフ idle 速度: 12 FPS スプライトシート: res://Assets/Enemies/Plant/Idle (44x42).png ループ: オン プラントのスプライトテクスチャのデザインも若干右に本体が寄っているので、インスペクターで「Position」プロパティを(-4, 0)に変更しておこう。\nCollisionShape2D ノードのコリジョン形状を設定する まずは「Plant」ルートノード直下の「CollisionShape2D」ノードから編集する。\nRadius: 10 Height: 12 Position: (0, 5) 続いて「HitBox」直下の「CollisionShape2D」ノードを編集する。\nExtents: (6, 2) Position: (0, -13) VisibilityEnabler2D ノードの形状を設定する 「VisibilityEnabler2D」の形状もスプライトテクスチャに合わせておこう。\nPosition: (-4, 0) Scale: (1, 1) Plant ノードに RayCast2D ノードを追加する カメレオンの時と同様に「Plant」ルートノードに「RayCast2D」ノードを追加する。プロパティは以下の通りにする。カメレオンよりさらに矢印の射程を長くして「Cast To」プロパティの x の値を 300 px とした。矢印に衝突したら遠隔攻撃してくる仕様にする予定だ。\nEnabled: オン Cast To: (300, 0) Plant.gd スクリプトを編集する 「Plant.gd」スクリプトを編集してプラントの動きを作っていこう。スクリプトは以下のようになった。今回は説明を掻い摘んで、スクリプトに直接コメントで入れている。\nextends \u0026#34;res://Enemies/Enemy.gd\u0026#34; # RayCast2D ノードの参照を raycast プロパティに渡す onready var raycast = $RayCast2D # _ready メソッド func _ready(): # 最初は idle アニメーションを再生する sprite.play(\u0026#34;idle\u0026#34;) ＃＿physics _process メソッド func _physics_process(delta): # もし RayCast2D の矢印にオブジェクトが衝突して、それが「Player」だったら attack メソッドを呼び出す if raycast.is_colliding() and raycast.get_collider().name == \u0026#34;Player\u0026#34;: attack() # もし RayCast2D の矢印のオブジェクトに何も衝突しなければ idle アニメショーンを再生するのみ else: sprite.play(\u0026#34;idle\u0026#34;) # attack メソッド func attack(): # attack アニメーションを再生 sprite.play(\u0026#34;attack\u0026#34;) # スプライトのフレームが 4 だったら if sprite.frame == 4: # spawn_bullet メソッドを呼び出す spawn_bullet() # spawn_bullet メソッド func spawn_bullet(): # 一旦 print メソッドで書き出しのみ print(\u0026#34;Spawn Bullet!!!\u0026#34;) ということで、カメレオンの時よりシンプルなコードになった。attackメソッドにより「attack」アニメーションを再生し、そのフレームが4の時にspawn_bulletメソッドが呼ばれる。このspawn_bulletは後ほど更新するが、口から種を前方に飛ばすアクションだ。これには別途、種のシーンを作成し、そのインスタンスを都度「Plant」ルートノードに追加する必要があるが、その作業は一旦置いておいて、ここまでのコードに問題がないか確認しよう。\nLevel1 シーンに Plant シーンのインスタンスノードを追加する コード確認のため、ひとまず「Level1」シーンのわかりやすい位置に「Plant」シーンのインスタンスを作って追加しよう。\nではプロジェクトを実行してプラントの動きを確認しよう。今回は「デバッグ」メニュー＞「コリジョン形状を表示」をオンにして、「RayCast2D」の矢印が見えるようにしておこう。\nプレイヤーキャラクターが「RayCast2D」の矢印に当たっている時は、プラントの「attack」アニメーションが再生され、出力パネルには「Spawn Bullet!!!」が表示された。高台に乗って「RayCast2D」の矢印から逃れるとプラントの「idle」アニメーションが再生された。概ね問題なさそうだ。\nSeed シーンを作成する シーンを作成してノードを追加する プラントが口から飛ばす種のシーンとして「Seed」シーンを新規で作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する 「ルートノードを生成」で「その他のノード」を選択する 「Area2D」クラスのノードをルートノードにする 「Area2D」ノードの名前を「Seed」に変更する 「Seed」ルートノードに「Sprite」ノードを追加する 「Seed」ルートノードに「CollisionShape2D」ノードを追加する 「Seed」ルートノードに「VisibilityNotifier2D」ノードを追加する 「res://Enemies/Plant/Seed.tscn」をパスとしてシーンを保存する 必要なノードは揃ったので、それぞれのプロパティを編集していこう。\nノードのプロパティを編集する 以下の手順で「Seed」シーンのノードのプロパティを編集しよう。\n「Sprite」ノードの「Texture」プロパティにアセットの「res://Assets/Enemies/Plant/Bullet.png」を適用する 「CollisionShape2D」ノードの「Shape」プロパティに「新規 CircleShape2D」を適用する 「CollisionShape2D」ノードのコリジョン形状を調整する（「Radius」プロパティの値を 4 にする）\n「VisibilityNotifier2D」ノードの形状を調整する（「Scale」プロパティの値を(0.4, 0.4)にする）\nこれでインスペクターでのプロパティの編集は終わりだ。続けてスクリプトをアタッチして種の動きをコーディングしていこう。\nSeed.gd スクリプトをアタッチして編集する 「Seed」ルートノードに新規でスクリプトをアタッチする。パスは「res://Enemies/Plant/Seed.gd」としておこう。\nスクリプトの内容はひとまず以下のようにした。単純だがこれで種の移動はOKだ。\nextends Area2D # Added @ Part 5 # 種の移動速度（px/second) export var speed = 150 # 毎フレーム、種のx軸方向の位置が左に (spped * delta) 分だけ進む func _physics_process(delta): position.x -= speed * delta 続いて、以下のシグナルをスクリプトに接続する。\n「Seed」ルートノードの「body_entered(body)」シグナルを接続する 「VisibilityNotifier2D」ノードの「viewport_exited(viewport)」シグナルを接続する すると、スクリプトにそれぞれのシグナルによって呼ばれるメソッドが追加される。その中身を以下のようにコーディングする。\n# 種が何らかの body と衝突したらシグナル発信により呼ばれるメソッド func _on_Seed_body_entered(body): # プレイヤーキャラクターに衝突したら出力 if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Player is hit!!!\u0026#34;) # 種自体消える queue_free() # 画面から消えたらシグナル発信により呼ばれるメソッド func _on_VisibilityNotifier2D_viewport_exited(viewport): print(\u0026#34;viewport_exited method called\u0026#34;) # 種自体消える queue_free() 今はまだプレイヤーキャラクターのダメージやゲームオーバーの部分が未実装なので、ひとまず種がプレイヤーキャラクターに当たったらprintメソッドで「Player is hit!!!」とだけ出力されるようにしておく。その時、種も同時にqueue_freeメソッドが呼ばれて消える。\nまた、種が画面外に出た場合も「VisibilityNotifier2D」ノードのシグナルをきっかけにqueue_freeメソッドが呼ばれて消える。\nPlant シーンに Seed シーンのインスタンスノードを追加する 種はプラントの「attack」アニメーション中に画面上に初めて現れるので、最初からシーンドックで追加しておくわけにはいかない。スクリプトで「Seed.tscn」ファイルを読み込んでおき、必要なタイミングでそれをインスタンス化して「Plant.tscn」シーンに追加する、というスクリプトを記述する必要がある。\nでは「Plant.gd」スクリプトを改めて編集していく。\nまずはプロパティを2つ追加する。\nvar is_spawning = false # 追加 onready var spawned_seed = preload(\u0026#34;res://Enemies/Plant/Seed.tscn\u0026#34;) # 追加 attackアニメーションは 8 FPS（毎秒8フレームの速さ）に設定したが、一方、_physics_processメソッドの物理プロセスのフレームはデフォルトの設定が 60 FPS となっている。ということは、attackアニメーションの 1 フレームが描画されている間に_physics_processのフレームが複数回読み込まれる。そのため、「attack」アニメーションの 4 フレーム目で種を飛ばす、というコードにしているだけでは、4フレーム目が描画されている間に複数の種が飛んでしまうのだ。この問題を回避して、アニメーション一回につき種を一つだけ飛ばすために、このis_spawningというステータスプロパティを使用する。\nもう一つの追加したプロパティspawned_seedは、「Seed.tscn」シーンファイルを事前に読み込んでおくためのものだ。preloadが事前にリソースファイルを読み込んでおくためのメソッドになっている。ちなみにプロパティ名をseedとしたいところだが、GDScript の予約語と被ってしまうので使用できない。\n次にattackメソッドを少し更新した。\nfunc attack(): sprite.play(\u0026#34;attack\u0026#34;) if sprite.frame == 4 and is_spawning == false: spawn_bullet() is_spawning = true elif sprite.frame == 5 and is_spawning: is_spawning = false 「attack」アニメーションの 4 フレーム目で、かつis_spawningプロパティが false の場合にだけspawn_bulletメソッドが呼ばれて種を飛ばす、というコードになっている。種を飛ばしたあとすぐにis_spawningをtrueに変更する。そのあとアニメーションの 5 フレーム目になって、is_spawningがtrueの場合は（絶対そうなるのだが）、次のアニメーションに備えてis_spawningをもとのfalseに戻す。これで、アニメーション一回につき種を一つだけ飛ばす動きになる。\n最後にspawn_bulletメソッドを更新して、種を飛ばすコードを実装した。\nfunc spawn_bullet(): print(\u0026#34;Spawn Bullet!!!\u0026#34;) var seed_instance = spawned_seed.instance() add_child(seed_instance) seed_instance.global_position = Vector2(position.x - 24, position.y) 事前にspawned_seedプロパティで、「Seed.tscn」を読み込んでいるので、そのインスタンスを生成するのにinstance()メソッドを実行している。これをseed_instanceというプロパティに代入した。\nadd_childメソッドの引数にそのインスタンスを渡すことで、「Plant」ノードの子ノードとして「Seed.tscn」のインスタンスノードが追加される。\n子ノードに追加されたらすぐに、画面上の位置を指定している。プラントの種を飛ばすときのテクスチャデザインに合わせて、プラントのposition.xより左に24px ずらした位置に配置した。その位置に種が現れるとすぐにそこから真っ直ぐ左方向へ飛んでいく。\nそれではプロジェクトを実行して、最終的なプラントの動きを確認しておこう。\nアニメーション一回につき一つだけ種を飛ばした 種はちょうど良い速度で飛んでいる プラントの口から種が飛んでいるように見えるので種の最初の位置も問題ない viewport（画面）から消えたら「Seed.tscn」のインスタンスノードは消えている これでプラントは完成としよう。\nLevel1 シーンに敵キャラクターを複数配置する ここまでで Part 4 で作ったマッシュルームを含めて四種類の敵キャラクターを用意した。これらを「Level1」シーンに適当に配置して、実際にプレイしてみよう。\nすでにそれぞれの敵キャラクターの動作確認で「Level1」シーンに 1 つずつインスタンスノードを追加している。そのため、さらに敵キャラクターのインスタンスノードを追加するときは、シーンドックで追加したい同じ種類のインスタンスノードを選択してショートカットキー操作で複製（Windows: Ctrl + D / macOS: Cmd + D）すると簡単だ。ノードの名前も、例えば「Mushroom」ノードを複製したら「Mushroom2」という具合に、自動的に末尾に番号を追加してくれるので非常に便利だ。\n今回はそれぞれの敵キャラクターのインスタンスノードを2つずつ「Level1」シーンに追加して配置した。\nサンプルとして、以下のような配置にしている。これはもちろん、何度かプレイしてみて多少バランスを調整した後の配置だ。あなたもご自身で作ったタイルマップに合わせて、敵キャラクターの数や配置を調整してほしい。\n納得のいく敵キャラクターの配置になるまで、プロジェクトを実行しながら調整してみよう。\n上のGIF画像では、プラントの種やカメレオンの舌を何度かくらっているが、敵キャラクターの配置はひとまずこれで完了とする。\nPart 5 で編集したスクリプトのコード 最後に今回の Part 5 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nBunny.gd の全コード extends \u0026#34;res://Enemies/Enemy.gd\u0026#34; # Added @ Part 5 export var jump_force = 200 var is_jumping = false func _ready(): sprite.play(\u0026#34;run\u0026#34;) # Set default animation func _physics_process(delta): if is_on_wall(): speed *= -1 sprite.flip_h = !sprite.flip_h if is_jumping: if is_on_floor(): velocity.y = -jump_force else: if velocity.y \u0026lt; 0: sprite.play(\u0026#34;jump\u0026#34;) else: sprite.play(\u0026#34;fall\u0026#34;) velocity.x = -speed velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) func _on_Area2D_body_entered(body): if body.is_in_group(\u0026#34;Players\u0026#34;): is_jumping = true func _on_Area2D_body_exited(body): if body.is_in_group(\u0026#34;Players\u0026#34;): is_jumping = false sprite.play(\u0026#34;run\u0026#34;) Chameleon.gd の全コード extends \u0026#34;res://Enemies/Enemy.gd\u0026#34; # Added @ Part 5 onready var raycast = $RayCast2D func _ready(): sprite.play(\u0026#34;idle\u0026#34;) func _physics_process(delta): if raycast.is_colliding(): if raycast.get_collider().name == \u0026#34;Player\u0026#34;: if position.distance_to(raycast.get_collision_point()) \u0026gt; 80: run(delta) else: attack() else: sprite.play(\u0026#34;idle\u0026#34;) func run(delta): sprite.play(\u0026#34;run\u0026#34;) if is_on_wall(): speed *= -1 sprite.flip_h = !sprite.flip_h raycast.cast_to.x *= -1 velocity.x = -speed velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) func attack(): sprite.play(\u0026#34;attack\u0026#34;) if sprite.frame == 6 or sprite.frame == 7: if raycast.is_colliding() and raycast.get_collider().name == \u0026#34;Player\u0026#34;: if position.distance_to(raycast.get_collision_point()) \u0026lt; 50: print(\u0026#34;Player is hit\u0026#34;) Plant.gd の全コード extends \u0026#34;res://Enemies/Enemy.gd\u0026#34; # Added @ Part 5 var is_spawning = false onready var spawned_seed = preload(\u0026#34;res://Enemies/Plant/Seed.tscn\u0026#34;) onready var raycast = $RayCast2D func _ready(): sprite.play(\u0026#34;idle\u0026#34;) func _physics_process(delta): if raycast.is_colliding() and raycast.get_collider().name == \u0026#34;Player\u0026#34;: attack() else: sprite.play(\u0026#34;idle\u0026#34;) func attack(): sprite.play(\u0026#34;attack\u0026#34;) if sprite.frame == 4 and is_spawning == false: spawn_bullet() is_spawning = true elif sprite.frame == 5 and is_spawning: is_spawning = false func spawn_bullet(): print(\u0026#34;Spawn Bullet!!!\u0026#34;) var seed_instance = spawned_seed.instance() add_child(seed_instance) seed_instance.global_position = Vector2(position.x - 24, position.y) Seed.gd の全コード extends Area2D # Added @ Part 5 export var speed = 150 func _physics_process(delta): position.x -= speed * delta func _on_Seed_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Player is hit!!!\u0026#34;) queue_free() func _on_VisibilityNotifier2D_viewport_exited(viewport): print(\u0026#34;viewport_exited method called\u0026#34;) queue_free() おわりに 以上で Part 5 は完了だ。今回は敵キャラクターを 3 種類追加した。なかなかハードだったと思うが、その分、作業手順には慣れていただけたのではないだろうか。やはり敵キャラクターの種類が増えて、それぞれ動きが違ってくると、ゲームの奥深さは断然違ってくる。今回のチュートリアルで要領を得ていただけたなら幸いだ。\nところで、今のままだと、ただただ敵キャラクターが待ち受けている地獄のような世界になっているため、プレイヤーキャラクターにとって嬉しい要素があまりない。\nそこで次回のチュートリアルでは、レベルシーンにアイテム（スーパーマリオシリーズのコインのような）を追加して、ちょっとは嬉しい気持ちになれるようにゲームをアップデートする予定なので、お楽しみに。\nUPDATE:\n2022-02-25 「Chameleon.gd」スクリプトの_physics_processメソッド、runメソッドのコードを更新して、カメレオンが空中でも落下しない問題を修正\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_5/","summary":"第5回目の今回は、さらに敵キャラクターの種類を増やしていく。それぞれの敵キャラクターの動きに違いを持たせ、それらをタイルマップ上に複数配置してゲームの難易度を高めていこう。具体的に今回は以下の敵キャラ","title":"Godot で作るプラットフォーマー Part 5：さらに敵キャラクターを作ろう！"},{"content":"第6回目の今回は、アイテムを作る。アイテムというのは、ちょうどスーパーマリオシリーズのコインのような、当たるとポイントを獲得できてちょっと嬉しい存在だ。さらに、下から小突くとアイテムが出てくる箱、その名もアイテムボックスを作る。それぞれスクリプトで動作を制御し、最後はレベルシーンに配置するところまでやっていこう。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー Item シーンを作る Item シーンを作成してノードを追加する 敵キャラクターの作り方と同じく、アイテムについても、雛形となるシーンを作成して、それを継承する形で複数種類のアイテムのシーンを作っていく。\nまずは雛形として「Item」シーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する 「ルートノードを生成」で「その他のノード」を選択する 「Area2D」クラスのノードを選択する 「Area2D」ルートノードの名前を「Item」に変更する 「Items」フォルダを作成して、パスを「res://Items/Item.tscn」としてシーンを保存する\n続いて、ルートノードに必要な子ノードを追加していく。\n「Item」ルートノードに「AnimatedSprite」ノードを追加する 「Item」ルートノードに「CollisionShape2D」ノードを追加する 「Item」ルートノードに「Label」ノードを追加する 「Item」ルートノードに「AnimationPlayer」ノードを追加する 各ノードのプロパティを編集する 各ノードのプロパティをインスペクターで調整していく。\nAnimatedSprite の編集 「Frames」プロパティに「新規SpriteFrames」を割り当てる\nスプライトフレームパネルを開き、以下の手順でアニメーションを作成する\n「default」アニメーションの名前を「idle」に変更する 「idle」アニメーションに、仮のアニメーションフレームとして「res://Assets/Items/Fruits/Apple.png」のスプライトシートを割り当てる（フレーム 0 ~ 16） 速度を 24 FPS にする ループをオンにしておく\nインスペクターに戻って、「Animation」プロパティの値を「idle」にする\n「Playing」プロパティをオンにする\nCollisionShape2D の編集 「Shape」プロパティに「新規CapsuleShape2D」を割り当てる 2Dワークスペースでコリジョン形状をスプライトテクスチャに合わせて調整する Radius: 8 Height: 0 Label の編集 「Text」プロパティの値に、デフォルトのテキストとして「100」と入力する 「Align」プロパティを「Center」にする 「Valign」プロパティを「Center」にする 「Position」プロパティを（-32, -20）にする 「Size」プロパティを (64, 14) にする AnimationPlayer の編集 「AnimationPlayer」は「AnimatedSprite」のようなスプライトテクスチャのアニメーション以外にも、他のあらゆるプロパティの値をアニメーションさせながら変化させることができる。\n今回は、プレイヤーキャラクターがアイテムに当たった時に獲得ポイントを表示しながらアイテムが消えるアニメーションを新規作成する。以下の手順に沿って作ってみよう。\nアニメーションパネルを開いたら、パネル上部中央の「アニメーション」をクリックする\n「新規」を選択する\nアニメーションの名前を「hit」にする\nアニメーションの長さを「0.5」秒にする\nここからは（アニメーションさせるプロパティの）トラックを追加し、トラック上にいくつかキーを挿入し、キーごとに値を設定して、トラック上の値の変化によりアニメーションさせていく。キーを挿入するまでの手順は2パターンあるので、お好みの方でやってみてほしい。\n● パターン 1 : アニメーションパネル上でトラックを追加してそこにキー挿入する方法\nアニメーションパネルの左上「トラックを追加」をクリックし、トラックの種類から「プロパティトラック」を選択する。\nどのノードのプロパティなのかを選択する。ここでは「AnimatedSprite」を選択する\nどのプロパティのトラックを追加するのかを選択する。見つかりにくい時は上の検索ボックスを利用する。ここでは「modulate」プロパティを選択して開く\nアニメーションパネルに「AnimatedSprite」ノードの「modulate」プロパティのトラックが追加された。ここで上部タイムライン上の青い縦のバーを 0 秒の位置に持ってこよう。\nこの青いバーの位置にキーを挿入する。挿入するには「modulate」トラックの青いバーより少し横を右クリックし、「キーを挿入」メニューを選択しよう。\n● パターン 2 : インスペクター上の鍵アイコンをクリックし、トラックとキーを同時に挿入する\n事前にアニメーションパネルのタイムラインでキーを挿入したいタイミング（ひとまず最初は一番左の 0 秒の位置）に青い縦のバーを合わせておく シーンドックで「AnimatedSprite」を選択する\n「AnimatedSprite」ノードを選択した場合、エディター下部で自動的にスプライトフレームパネルが開くが、アニメーションパネルに切り替える\nインスペクターで、今回アニメーションのトラックとして追加したい「Modulate」プロパティの右側にある鍵アイコンをクリックする\n新規トラックを作成してキーを挿入するかどうかの確認のダイアログが表示されるので「作成」をクリックする\nここからの手順は共通。\n0.5秒の位置にも「modulate」トラックにキーを挿入しよう。 それぞれのキーの値を編集する。挿入したキーは四角いアイコンで表示されているので、それをクリックして選択する。\nインスペクターで「AnimationTrackKeyEdit」の「Value」の値を編集する。 0 秒: (r, g, b, a) = (255, 255, 255, 0) 0.5秒: (r, g, b, a) = (255, 255, 255, 255) ここまでの設定でアニメーションがどうなったのか見ていこう。アニメーションパネル左上にあるプレイバックアイコンを操作することで2Dワークスペース上で簡単に確認ができる。\nGIF画像のリピート再生だとわかりにくいかもしれないが、「Modulate」プロパティの値の透明度を 255 から 0 に変化させることによって、フェードアウトするアニメーションになった。\n同様にして、他にもいくつかのトラックを追加し、それぞれのトラックに対して、キーを挿入してアニメーションをより複雑にしていこう。\n● AnimatedSprite ノードのトラック\nmodulate プロパティ: アイテムの不透明度を MAX から 0 へ　*作成済み Time: 0 秒 / Value: (255, 255, 255, 255) Time: 0.5 秒 / Value: (255, 255, 255, 0) position プロパティ: アイテムの位置を上方向に 10 px 移動 Time: 0 秒 / Value: (0, 0) Time: 0 秒 / Value: (0, -10) scale プロパティ: アイテムの大きさを横方向に 5 倍広げて縦方向は 0 に Time: / Value: (1, 1) Time: / Value: (5, 0)\n● Label ノードのトラック\nmodulate プロパティ: 獲得ポイントの不透明度を最初の 0.1 秒で Max（表示）、最後の 0.1 秒で 0（非表示）へ Time: 0 秒 / Value: (255, 255, 255, 0) Time: 0.1 秒 / Value: (255, 255, 255, 255) Time: 0.4 秒 / Value: (255, 255, 255, 255) Time: 0.5 秒 / Value: (255, 255, 255, 0) rect_position プロパティ: 獲得ポイント表示をアイテムのやや上からさらに 20 px 上へ移動 Time: 0 秒 / Value: (-32, -20) Time: 0.5 秒 / Value: (-32, -40) アニメーションパネルは以下のスクリーンショットのようになったはずだ。\nでは、2Dワークスペース上でアニメーションを確認してみよう。\nだいたい意図した形になったので、アイテムのアニメーションは完成としよう。\nItem シーンにスクリプトをアタッチする それではアイテムシーンをスクリプトで制御していこう。\nさっそく、シーンドックで「Item」ルートノードを選択したら、スクリプトをアタッチする。継承元を「Area2D」、ファイルパスを「res://Items/Item.gd」としてスクリプトを作成しよう。\nスクリプトエディタが開いたら、いつも通り、まずはプロパティから定義していく。\nextends Area2D export var point = 100 # アイテムに当たった時の獲得ポイント onready var sprite = $AnimatedSprite # AnimatedSprite ノードの参照 onready var label = $Label # Label ノードの参照 onready var anim_player = $AnimationPlayer # AnimationPlayer ノードの参照 ここでpointというプロパティをデフォルトの値を100として定義した。これはプレイヤーキャラクターがアイテムに当たった時に獲得できるポイントだ。exportキーワード付きなので、継承後のシーンではインスペクターで気軽にポイントを変更できる。この値はアイテムの種類によって変える予定だ。取るのが難しいアイテムほど高得点にしたい。また、今後、スコア機能を実装する時にポイントがスコアに加算されるようにもしていく予定だ。また、このpointプロパティを画面上に表示させるため、_readyメソッドで「Label」ノードの「Text」プロパティにpointの値を適用するよう、このあと設定していく。\nでは_readyメソッドを定義していこう。\nfunc _ready(): sprite.modulate = Color(1, 1, 1, 1) sprite.position = Vector2.ZERO sprite.scale = Vector2.ONE label.modulate = Color(1, 1, 1, 0) label.rect_position = Vector2(-32, -20) label.text = str(point) 「AnimatedSprite」ノードのmodulate、position、scaleおよび「Label」ノードのmodulate、rect_positionは全て、さきほどアニメーションパネルで「hit」アニメーションに用いたプロパティだ。デバッグ作業をしていると、各プロパティがアニメーションを実行した後の値のままになってしまうので、最初に_readyメソッドで初期値を設定するようにした。\n最後の「Label」ノードのtextプロパティは、インスペクターで 100 と入力しておいた「Text」プロパティとイコールだ。上で定義したpointプロパティの値は int 型なのでstr関数により string 型（文字列型）に変換して、textプロパティの値として設定している。\nあとはプレイヤーキャラクターが当たったらアイテムが消える動きを作っていこう。\nここはまずシグナルを利用したいので、シーンドックに戻って「Item」ルートノードを選択し、ノードドック＞「シグナル」タブから「body_entered(body)」を接続しよう。接続先はもちろん「Item.gd」スクリプトだ。\n接続できたら_on_Item_body_enteredメソッドが追加されたはずだ。このメソッドを以下のように編集する。\nfunc _on_Item_body_entered(body): # もし衝突した body の名前が Player だったら if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Player hit Item\u0026#34;) # AnimationPlayer ノードの「hit」アニメーションを再生する anim_player.play(\u0026#34;hit\u0026#34;) # 「hit」アニメーションが終了するまで待機 yield(anim_player, \u0026#34;animation_finished\u0026#34;) # この「Item」ノードを開放する（消す） queue_free() ここで一旦テストとして「Item」シーンのインスタンスを「Level1」シーンに追加して、動作確認しておこう。確認できたら追加した「Item」ノードは不要なので削除すること。\n動作も概ね期待通りなので、雛形となる「Item.tscn」シーンはこれで完成としておこう。次はこの「Item.tscn」を継承して個々のアイテムのシーンを作っていく。\nItem シーンを継承して複数種類のアイテムのシーンを作る では次に「Item.tscn」シーンを継承して、個々のアイテムを作っていく。作業は基本的にスプライトシートを差し替えて、獲得ポイントを変更するだけだ。\n作成する個々のアイテムの種類と獲得ポイントは以下のように設定する（完全に適当なので、アイテムの種類数や割り当てるポイントの大きさはご自由にしていただいて構わない）。\nApple: 100 Bananas: 300 Cherries: 500 Kiwi: 700 Melon: 1000 Orange: 1200 Pineapple: 1500 Strawberry: 2000 上述の個々のアイテムのシーンを以下の手順で一つずつ順番に作成していこう。\n「シーン」メニュー＞「新しい継承シーン」を選択する。 継承元に「res://Items/Item.tscn」を選択する。 ルートノードの名前を「Item」から「Bananas」など個々のアイテムの名前に変更する ファイルパスを「res://Items/Bananas.tscn」などとして、シーン保存する ルートノードを選択し、インスペクターから「Point」プロパティの値を 300 など各アイテムに割り当てる予定のポイントに変更する（ Apple の場合は変更なし）\n「AnimatedSprite」ノードの「Frames」プロパティの値「SpriteFrames」の右横の ⌵ をクリックし、「ユニーク化」を選択する　*お忘れなきよう！ スプライトフレームパネルを開き、「idle」アニメーションのアニメーションフレームを全て削除して、新たに「res://Assets/Items/Fruits/Bananas.png」など各アイテムのスプライトシートを割り当てる（ Apple の場合は変更なし）\n必要な数だけ個々のアイテムのシーンを作成していただけただろうか。次は「Level1」シーンに作成したアイテムのインスタンスノードを追加して、マップに配置していこう。\nLevel1 シーンにアイテムを追加する シーンドックで「Level1」シーンを開こう。そして、作成した個々のアイテムシーンをインスタンス化して、「Level1」ルートノードの子ノードとして追加しよう。\nここではサンプルとして合計8種類のフルーツアイテムを一つずつ追加した。確認しやすくするため、一時的に敵キャラクターのノードは全て非表示にした。\nシーンドックで各アイテムを追加したら（もしくはしながら）、2Dワークスペース上で、タイルマップのどの位置にアイテムを置いたら面白いかを検討しつつ、一つずつ配置していこう。サンプルの配置場所は以下のとおりだ。\nではプロジェクトを実行して、プレイヤーキャラクターがアイテムに当たった時の挙動を確認しつつ、実際のプレイ画面上でも念のためにアイテムの配置を確認しておこう。なお、以下のGIF画像は 2 倍速にしている。\n各アイテムの「AnimatedSprite」の「idle」アニメーションがループ再生されており、プレイヤーキャラクターがアイテムに当たったら「AnimationPlayer」のアニメーションを実行してオブジェクトが削除された。概ね問題ないだろう。\nItemBox シーンを作る 次は下から小突くとフルーツアイテムが順番に出てくるアイテムボックスを作ってみよう。スーパーマリオシリーズの下から小突くとコインが繰り返し出てくるブロックのようなイメージだ。アイテムボックスの仕様は以下のようにする。\n衝突判定があり、プレイヤーキャラクターや敵キャラクターはボックスを透過しない 下からプレイヤーキャラクターが衝突した時しかアイテムは出ない 最初に下から衝突してから 4 秒経過すると、アイテムボックスは空っぽになる 最後の一つのアイテムが出ると、アイテムボックスは壊れて無くなる。 ItemBox シーンを作成してノードを追加する では以下の手順でシーンを作ろう。\n「シーン」メニュー＞「新規シーン」を選択 「ルートノードを生成」で「その他のノード」を選択する 「StaticBody2D」クラスをルートノードに設定する ルートノードの名前を「ItemBox」に変更する ファイルパスを「res://Items/ItemBox.tscn」として保存する なお、自ら動くことのない物理ボディには「StaticBody2D」が最適だ。\n続いて、上述の仕様を満たすために必要なノードを追加していく。 「ItemBox」ルートノードに「AnimatedSprite」ノードを追加する 「ItemBOx」ルートノードに「CollisionShape2D」ノードを追加する 「ItemBox」ルートノードに「Timer」ノードを追加する 「ItemBox」ルートノードに「Area2D」ノードを追加する 「Area2D」ノードに「CollisionShape2D」を追加する シーンドックは以下のようになっただろうか。 次はインスペクターでそれぞれのノードのプロパティを編集していく。\n各ノードのプロパティを編集する AnimatedSprite の編集 アセットにアニメーション用のスプライトシートが用意してあるので、それらを利用してアニメーションを設定する。\nインスペクターで「Frames」プロパティに「新規SpriteFrames」を割り当てる\nスプライトフレームパネルを開き、以下の2つのアニメーションを作成する\nアニメーション名: hit スプライトシート: res://Assets/Items/Boxes/Box2/Hit (28x24).png 速度: 24 FPS ループ: オフ アニメーション名: idle スプライトシート: res://Assets/Items/Boxes/Box2/Idle.png 速度: 24 FPS ループ: オン インスペクターに戻り「Animation」プロパティを「idle」に設定する\nルートノード直下の CollisionShape2D の編集 プレイヤー / 敵キャラクターとの衝突を検知するようにコリジョン形状を調整していく。\nインスペクターで「Shape」プロパティに「新規RectangleShape2D」を割り当てる 2Dワークスペースでコリジョン形状を編集し、「idle」アニメーションのスプライトテクスチャの一番下を 1 px だけ空けて、他はスプライトテクスチャにピッタリ合わせる\nインスペクター関連プロパティが以下のようになっているか確認する Extents: (10, 9.5) Position: (0, -0.5) Timer の編集 最初にアイテムボックスを下から小突いてから 4 秒経過後にアイテムボックスを空っぽにするにはタイマーの設定が必要だ。「Timer」ノードを以下のように設定しよう。\n「Wait Time」プロパティの値を 4 にする 「One Shot」プロパティを オン にする Area2D 直下の CollisionShape2D を編集する 下からプレイヤーキャラクターが衝突した時しかアイテムが出ないように、ボックスの下部にだけ、本体とは別のコリジョン形状を設定する。\nインスペクターで「Shape」プロパティに「新規RectangleShape2D」を割り当てる 2Dワークスペースでコリジョン形状を編集し、「idle」アニメーションのスプライトテクスチャの一番下から高さ 1 px の範囲に合わせる\nここまでで各ノードのプロパティ編集はひとまず完了だ。「ItemBox」ルートノードにスクリプトをアタッチしたいところだが、その前にもう一つ別のオマケのシーンを作成する。\nBrokenBox シーンを作成する アイテムボックスからアイテムが出尽くした時に箱が壊れる演出を入れたい。アイテムボックスが壊れる時に、BrokenBox シーンを ItemBox と同じ場所に配置したら、ItemBox は消しつつ BrokenBox シーンによって木片が飛び散るようにする。このような細かい複数の物体や流体を表現するにはパーティクルシステムを利用する。パーティクルとは小片とか粒という意味だ。\nでは手早く以下の手順で BrokenBox シーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択 「ルートノードを生成」で「その他のノード」を選択 「Particles2D」クラスのノードを選択 「Particles2D」ノードの名前を「BrokenBox」に変更する ファイルパスを「res://Items/BrokenBox.tscn」としてシーンを保存する BrokenBox ルートノードのプロパティを編集する ルートノードに設定した「Particles2D」ノードだが、このプラットフォーマーのチュートリアルでは初登場だ。「Paarticle2D」は2Dゲームで、例えば炎や雨、雪、煙、血飛沫など、細かな粒子の動きを表現するのによく利用される。なお、「Particles2D」クラスのノードについては、Godot の公式オンラインドキュメントも説明が比較的わかりやすいので、参考にしていただくのが良いだろう。\n公式オンラインドキュメント パーティクル・システム(2D) 「Particles2D」ノードにはプロパティの項目がたくさんある。最初は思い通りの動きにするのにやや骨が折れるが、慣れてしまえば本当に多くの表現に利用できる。インスペクターで必要なプロパティを上から順番に編集していこう。\nインスペクターで が値の左横にあるプロパティは、初期値から変更を加えているので目印にしてほしい。\nEmitting: オフ\nパーティクルを実行するかどうか。下の「One Shot」がオンなので、一度実行されたらオフになる。ボックスが破壊されたタイミングでスクリプトによってオンにする予定だ。 Amount: 16\nパーティクルの数。今回は16個 Time セクション:\nLifetime: 4\nパーティクルが存在する時間（秒）。今回は 4 秒後に消える設定。 One Shot: オン\n一回限りの実行かどうか。今回はボックスが壊れたらボックスは消えるのでオンにしておく。 Speed Scale\nパーティクルシステム実行時の速度 Explosiveness: 0.8\n1 に近づくほど、次回の実行までの時間が長くなる。したがって 1 はすべてのパーティクルが同時に表示される。今回は同時まではいかないが、同時にやや近い 0.8 に設定。\nProcess Material セクション:\nMaterial: 新規ParticlesMaterial\nパーティクルを処理するための素材。セットした「ParticlesMaterial」のプロパティを設定していくので、インスペクターで「ParticlesMaterial」をクリックする。\nParticlesMaterial のプロパティ:\nEmission Shape セクション\nShape: Box\nデフォルトの Point だと全てのパーティクルの開始位置が点になるが、Boxだと、四角い範囲内からの開始になる。\nFlags セクション\nDisable Z: オン\n2Dゲームなので、Z軸方向の位置は無効にする。\nDirection セクション\nDirection: (0, -1, 0)\nパーティクルの移動する方向、真っ直ぐ上方向にするため y の値を -1 とした。 Spread: 30\nパーティクルが広がる角度の設定。デフォルトは 45° だが、箱の破片があまり広く飛び散ってほしくないので、少し狭めの 30° にした。\nGravity セクション\nGravity: (0, 10, 0)\n重力の設定。真っ直ぐ下方向に重力をかけるため y の値を 10 とした。\nInitial Velocity セクション\nVelocity: 20\nパーティクルの速度の設定。下から小突いて壊れた時に飛び散る破片として違和感ない 20 とした。\nAngular Velocity セクション\nVelocity: 15\nパーティクルの 1 秒あたりの回転角度の設定。少しだけ回転するように 15° とした。\nScale セクション\nScale: 0.5\n箱の破片の大きさを実際のテクスチャの半分にして、細かな破片になるようにした。 Scale Random: 1\n0.5 ~ 1 の Scalse の間で完全にランダムになるよう値を 1 とした（1 は 100%）。\nAnimation セクション\nOffset: 1\nパーティクルのアニメーションのオフセット設定。アニメーションの開始フレームをずらすことができる。しかし今回は「Animation」セクションの「Speed」プロパティを 0 にしているため、そのままだとアニメーションはせず、全てのパーティクルがスプライトシートの 1 フレーム目のテクスチャになってしまう。それを回避するためにまずはこのプロパティの値を 1 とした。これにより、アニメーションの開始位置をスプライトシートの最後のフレームにずらすことができる。しかしこのままでは、全てのパーティクルがスプライトシートの最後のフレームのテクスチャになってしまうだけだ。そこで次の「Offset Random」を設定する。 Offset Random: 1\nアニメーションのオフセットのランダム率を 1（つまり 100%）とした。これにより、例えば 4 フレームのスプライトシートによるアニメーションなら、1 ~ 4 フレームのうちいずれかのテクスチャがアニメーションの開始位置として適用される。今回「Speed」プロパティが 0 なので、アニメーションせず、各パーティクルのテクスチャはランダムで決定され、かつ生成されてから消失するまで同じテクスチャが維持される。\nTextures セクション:\nファイルシステムドックから「res://Assets/Items/Boxes/Box2/Break.png」のスプライトテクスチャファイルをドラッグ\u0026amp;ドロップで適用する。\nMaterial セクション:\nMaterial: 新規CanvasItemMaterial を適用 Particle Animation: オン Particle Animation H Frames: 4 Particle Animation V Frames: 1 Particle Anim Loop: オフ\nこれでインスペクターでのプロパティの編集は完了だ。「Particles2D」クラスは「ParticlesMaterial」も含めて、プロパティが非常に多く、最初は難しく感じるだろう。どのプロパティが何に影響するのかは、いろいろ触っているうちにわかってくるところがある。このチュートリアルに限らず、是非あなた自身の手でパーティクルシステムにより様々な表現ができることを試してみて欲しい。\nBrokenBox にスクリプトをアタッチする 「BrokenBox」ルートノードに新規でスクリプトをアタッチしよう。ファイルパスを「res://Items/BrokenBox.gd」として作成しよう。\nこのスクリプトでやりたいことはシンプルに以下の2つだけだ。\nシーンツリーに追加されたらまず「Emitting」プロパティをオンにしてパーティクルシステムを最初から自動的に実行する パーティクルシステムが終了して「Emitting」プロパティがオフになったらこの「BrokenBox」ノードを解放（削除）する ということで、上記の2つを制御するための具体的なスクリプトは以下の通りだ。\nextends Particles2D # シーンツリーに追加されたらパーティクルシステムを実行 func _ready(): emitting = true # パーティクルシステムが終了したら BrokenBox ノードを解放 func _process(delta): if not emitting: queue_free() # デバッグ用 print(\u0026#34;BrokenBox removed.\u0026#34;) ItemBox シーンにスクリプトをアタッチする 当初予定していた仕様を満たすため、「ItemBox.gd」スクリプトに戻って、コードでアイテムボックスを制御していく。\nまずは「ItemBox」ルートノードを選択して、新規でスクリプトをアタッチする。スクリプトのファイルパスは「res://Items/ItemBox.gd」として作成しよう。\n「ItemBox.gd」スクリプトを開いたらさっそく編集していこう。まずはプロパティの定義からしていく。\nextends StaticBody2D # Timer ノードのタイマーを利用したことがなければ true var timer_unused = true # AnimatedSprite ノードの参照 onready var sprite = $AnimatedSprite # Timer ノードの参照 onready var timer = $Timer # 親ノードの参照 onready var parent = get_parent() # 事前に読み込んだ BrokenBox シーンファイル onready var broken_box_tscn = preload(\u0026#34;res://Items/BrokenBox.tscn\u0026#34;) # 事前に読み込んだ個々のアイテムのシーンファイルを配列（Array）に格納 onready var items = [ preload(\u0026#34;res://Items/Apple.tscn\u0026#34;), preload(\u0026#34;res://Items/Bananas.tscn\u0026#34;), preload(\u0026#34;res://Items/Cherries.tscn\u0026#34;), preload(\u0026#34;res://Items/Kiwi.tscn\u0026#34;), preload(\u0026#34;res://Items/Melon.tscn\u0026#34;), preload(\u0026#34;res://Items/Orange.tscn\u0026#34;), preload(\u0026#34;res://Items/Pineapple.tscn\u0026#34;), preload(\u0026#34;res://Items/Strawberry.tscn\u0026#34;), ] 今回、アイテムボックスの仕様を満たすには、「Timer」ノードのタイマーが発動済みか未使用かの区別が必要になる。そのステータス管理用のプロパティがtimer_unusedだ。\nonreadyキーワード付きのitems（~s と複数形になっていることに注意）プロパティは、このシリーズのチュートリアルでは初登場の 配列（Array） 型の値をとる。配列というのは、複数のオブジェクトを格納することができるデータ型だ。今回は、事前に読み込んだ個々のアイテムのシーンファイル .tscn を格納している。つまり、アイテムボックスから出現するアイテムの元となるシーンファイルをこの配列の要素にしている。要素の順番も重要だ。配列の前からポイントの低いアイテムの順番になっている。前から順に要素を取り出すようにすれば、ポイントの低いアイテムから順番に出現させることができる。\n配列（Array）は非常に便利なので、今後もできるだけ慣れ親しんでいきたいところだ。お時間があれば、ぜひ公式オンラインドキュメントもご参照いただきたい。\n公式オンラインドキュメント Array _readyメソッドでゲーム開始前に必要な準備をコーディングしよう。\nfunc _ready(): # AnimatedSprite ノードが idle アニメーションを再生 sprite.play(\u0026#34;idle\u0026#34;) ここで「Timer」ノードの「timeout()」シグナルをこのスクリプトに接続しておく。\nちなみに、先にインスペクターで「Timer」ノードの「Wait Time」プロパティを 4 秒に設定したので、タイマーがスタートしてから 4 秒でこのシグナルが発信される。\nシグナルを接続したら、以下の_on_Timer_timeoutメソッドが追加されたはずだ。メソッド内を編集していく。\nfunc _on_Timer_timeout(): # デバッグ用 print(\u0026#34;Item box timer time out\u0026#34;) # 配列 items が空っぽでなければ if not items.empty(): # 配列 items から全ての要素を消去 items.clear() # デバッグ：配列 items の要素数を確認 print(\u0026#34;items size: \u0026#34;, items.size()) 配列クラスには色々便利なメソッドが用意されているが、ここではひとまず、今回利用したメソッドに関してのみ説明しておこう。\nif構文で利用しているemptyメソッドでは、配列itemsが空っぽかどうかを確認できる。空っぽだったらtrue、空っぽでなければfalseを返す。\nifブロック内で実行しているclearメソッドは、配列内の要素を全て消去する。制限時間 4 秒が経過したらアイテムボックスは空っぽになる、というイメージだ。\nデバッグ用のprint関数内で使用されているsizeメソッドは、配列の要素数を返す。\n次に「Area2D」ノードの「body_entered(body)」シグナルをこのスクリプトに接続する。\n接続したらスクリプトに_on_Area2D_body_enteredメソッドが追加されたはずだ。ところで「Area2D」ノードのコリジョン形状はアイテムボックスの下部 1 px の部分にだけ配置したことは覚えているだろうか。そこにプレイヤーキャラクターが衝突した時に実行すべきコードをこの_on_Area2D_body_enteredメソッド内に記述していくというわけだ。\n具体的にコードは以下のようになった。\nfunc _on_Area2D_body_entered(body): # 衝突した body が Player という名前のノードだったら if body.name == \u0026#34;Player\u0026#34;: # timer_unused プロパティが true だったら if timer_unused: # Timer ノードのタイマーをスタートする timer.start() # timer_unused を false にする timer_unused = false # AnimatedSprite の play メソッドで hit アニメーションを再生 sprite.play(\u0026#34;hit\u0026#34;) # AnimatedSprite のアニメーションが終了するまで待機 yield(sprite, \u0026#34;animation_finished\u0026#34;) # AnimatedSprite の Play メソッドで idle アニメーションに戻して再生 sprite.play(\u0026#34;idle\u0026#34;) # もし配列 items が空っぽだったら if items.empty(): # デバッグ用 print(\u0026#34;Item box is empty.\u0026#34;) # AnimatedSpriteノードを非表示にしてアイテムボックスを画面から消す sprite.visible = false # BrokenBox シーンのインスタンスを変数に代入 var broken_box = broken_box_tscn.instance() # 親ノードの子ノード（ItemBox と同じ階層）として BrokenBox インスタンスを追加 parent.add_child(broken_box) # BrokenBox の位置を ItemBOx の位置と同じにする broken_box.position = position # ItemBox を解放（削除）する queue_free() # デバッグ用 print(self.name, \u0026#34; removed.\u0026#34;) # 配列 items が空っぽではなかったら else: # デバッグ用 print(\u0026#34;Item box is not empty.\u0026#34;) # 変数 item を定義 \u0026gt; 配列 items の最初の要素を取り出してインスタンス化 var item = items.pop_front().instance() # インスタンス化したアイテムのシーンを ItemBox の子ノードにする add_child(item) # アイテムのインスタンスノードの position の y の値を -12 する（箱より少し上にアイテムを出現させる） item.position.y -= 12 # アイテムのインスタンスノードの hit メソッドを実行 item.hit() 少し補足説明しておく。\nif timer_unused:の構文で、timer_unusedプロパティがtrueの場合（つまりタイマーが使われた事がない）だけ、タイマーをスタートさせている。その直後にこのtimer_unusedをfalse（タイマーが使われた事がある）に変更するので、初めてアイテムボックスを下から小突いた時にしかタイマーは開始しない仕組みになっている。\n次に「AnimatedSprite」の「hit」アニメーションを再生させている。\nさらにそのあとはif / else構文で条件分岐する。\nここでもまた配列itemsのemptyメソッドを利用している。ifとelseの条件が逆の方がわかりやすいかもしれないが、今回はif構文にnotを入れなくて済むようにした。\nif items.empty():の条件である『配列itemsが空っぽの場合』を満たしたらブロックの中に進む。これはつまりアイテムボックスからアイテムが出尽くした場合だ。その場合、以下のような順番で処理が進む。\n先に「AnimatedSprite」ノードを非表示にして、画面からアイテムボックスを消す。 「BrokenBox」シーンをインスタンス化する 「BrokenBox」のインスタンスを、親ノード に追加する（この時点でパーティクルシステムが実行される） 「BrokenBox」ノードの位置を「ItemBox」ノードの位置と同じにする 「ItemBox」ノードは解放（削除）する（解放しても「BrokenBox」は親ノードに紐づいているためパーティクル実行中でも影響されない） 順番が逆でややこしいかもしれないが、else:の条件は『配列itemsが空っぽでなければ』となる。アイテムボックスにまだアイテムが入っている場合だ。この場合は以下の順序でコードが実行される。\npop_frontメソッドにより、配列itemsの先頭の要素（アイテムのシーン）を取り出して、それをインスタンス化する（この時取り出した要素はitems内からは削除される） 取り出したシーンのインスタンスを「ItemBox」自身の子ノードとして追加する 子にしたアイテムのノードの位置を、「ItemsBox」自身の位置より y 軸上で -12ずらした位置に設定する アイテムのノードのhitメソッドを実行する これで「ItemBox.gd」スクリプトのコーディングは完成だ。\n「Level1」シーンにインスタンスを追加して、アイテムボックスが正しく動作するか確認しておこう。\nプロジェクトを実行して当初想定していた以下の仕様を満たしているか確認してみよう。\n衝突判定があり、プレイヤーキャラクターや敵キャラクターはボックスを透過しない 下からプレイヤーキャラクターが衝突した時しかアイテムは出ない 最初に下から衝突してから 4 秒経過すると、アイテムボックスは空っぽになる 最後の一つのアイテムが出ると、アイテムボックスは壊れて無くなる。 概ね問題ないが、アイテムボックスからアイテム（フルーツ）が出てきてすぐにぺちゃんこに変形してしまうので、何が出てきたのかわかりにくい。そこで「Item.tscn」シーンを開き、「AnimationPlayer」の「hit」アニメーションを編集しよう。\n「AnimatedSprite」\u0026gt;「modulate」トラック：0 秒の位置にあるキーの「Easing」プロパティを 1 から 3 に変更\n「AnimatedSprite」\u0026gt;「scale」トラック：0 秒の位置にあるキーの「Easing」プロパティを 1 から 4 に変更\nもう一度確認だ。\nさっきよりはフルーツの形状がわかりやすくなっただろう。これでアイテムボックスは完成としよう。\nLevel1 シーンにアイテムボックスを追加する では Part 6 最後の仕上げとして、完成したアイテムボックスを「Level1」シーンに追加しよう。どこに配置するかはあなたの自由なので、適当な場所に配置してほしい。\nあくまでサンプルだが、以下のスクリーンショットのような感じで、マップ上に3つ配置した。\n最後にプロジェクトを実行して、「Level1」シーン全体を確認してみよう。なお以下のGIF画像は 2.5 倍速にしている。\nPart 6 で編集したスクリプトのコード 最後に今回の Part 6 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nItem.gd の全コード extends Area2D # Added @ Part 6 export var point = 100 onready var sprite = $AnimatedSprite onready var label = $Label onready var anim_player = $AnimationPlayer func _ready(): sprite.modulate = Color(1, 1, 1, 1) sprite.position = Vector2.ZERO sprite.scale = Vector2.ONE label.modulate = Color(1, 1, 1, 0) label.rect_position = Vector2(-32, -20) label.text = str(point) func _on_Item_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Player hit Item\u0026#34;) hit() func hit(): print(\u0026#34;Got \u0026#34;, point, \u0026#34; point.\u0026#34;) anim_player.play(\u0026#34;hit\u0026#34;) yield(anim_player, \u0026#34;animation_finished\u0026#34;) queue_free() ItemBox.gd の全コード extends StaticBody2D # Added @ Part 6 var timer_unused = true onready var sprite = $AnimatedSprite onready var timer = $Timer onready var parent = get_parent() onready var broken_box_tscn = preload(\u0026#34;res://Items/BrokenBox.tscn\u0026#34;) onready var items = [ preload(\u0026#34;res://Items/Apple.tscn\u0026#34;), preload(\u0026#34;res://Items/Bananas.tscn\u0026#34;), preload(\u0026#34;res://Items/Cherries.tscn\u0026#34;), preload(\u0026#34;res://Items/Kiwi.tscn\u0026#34;), preload(\u0026#34;res://Items/Melon.tscn\u0026#34;), preload(\u0026#34;res://Items/Orange.tscn\u0026#34;), preload(\u0026#34;res://Items/Pineapple.tscn\u0026#34;), preload(\u0026#34;res://Items/Strawberry.tscn\u0026#34;), ] func _ready(): sprite.play(\u0026#34;idle\u0026#34;) func _on_Timer_timeout(): print(\u0026#34;ItemBox \u0026gt; Timer timeout\u0026#34;) if not items.empty(): items.clear() print(\u0026#34;items size: \u0026#34;, items.size()) func _on_Area2D_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;ItemBox \u0026gt; Area2D Player entered\u0026#34;) if timer_unused: timer.start() timer_unused = false sprite.play(\u0026#34;hit\u0026#34;) yield(sprite, \u0026#34;animation_finished\u0026#34;) sprite.play(\u0026#34;idle\u0026#34;) if items.empty(): print(\u0026#34;ItemBox is empty.\u0026#34;) sprite.visible = false var broken_box = broken_box_tscn.instance() parent.add_child(broken_box) broken_box.position = position queue_free() print(self.name, \u0026#34; removed.\u0026#34;) else: print(\u0026#34;ItemBox is not empty.\u0026#34;) var item = items.pop_front().instance() add_child(item) item.position.y -= 12 item.hit() BrokenBox.gd の全コード extends Particles2D # Added @ Part 6 func _ready(): emitting = true func _process(delta): if not emitting: queue_free() print(\u0026#34;BrokenBox removed.\u0026#34;) おわりに 以上で Part 6 は完了だ。今回はアイテムの雛形シーンを作り、それを継承して個々のアイテムシーンを作った。さらに、それらのアイテムが出てくるアイテムボックスを作り、アイテムボックスが壊れる時の演出をパーティクルシステムで実装した。ということで、今回もなかなかボリューミーな回になった。しかし、やった分だけゲームの楽しさは確実に増したはずだ。\n次回 Part 7 では、レベルクリア条件となるものを用意して、次のレベルへの遷移を実装する予定だ。それでは次回もお楽しみに。\nUPDATE:\n2022-02-25 「おわりに」の次回の内容を「HUD」から「次のレベルへの遷移」に変更\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_6/","summary":"第6回目の今回は、アイテムを作る。アイテムというのは、ちょうどスーパーマリオシリーズのコインのような、当たるとポイントを獲得できてちょっと嬉しい存在だ。さらに、下から小突くとアイテムが出てくる箱、その","title":"Godot で作るプラットフォーマー Part 6：アイテムを作ろう！"},{"content":"第7回目の今回は、レベルのマップ上にスタートポイント、中間のチェックポイント、そしてエンドポイントを配置し、エンドポイントに到達した時に次のレベルに遷移する仕組みを実装していく。併せて、現在レベルシーンは「Level1」だけなので、次の「Level2」シーンも作成していく。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー スタートポイント、 チェックポイント、 エンドポイントを作る 今回のチュートリアルのテーマはレベルクリアとそのあとの次のレベルへの遷移なので、必要なのは各レベルにゴールを用意することだが、せっかくなので以下の3つを作っていく。\nスタートポイント（ゲーム開始地点） チェックポイント（通過点） エンドポイント（レベルのゴール） それぞれのオブジェクトをスプライトテクスチャとコリジョン形状をつけて用意していく。特にエンドポイントについては、衝突判定をトリガーにして次のレベルに遷移するように、後ほどスクリプトで制御する予定だ。\nStartPoint シーンを作る シーンを新規作成してノードを追加する 以下の手順で「StartPoint」シーンを作成して、ノードを追加して保存しよう。\n「シーン」メニュー＞「新規シーン」を選択する 「ルートノードを生成」で「その他のノード」を選択する 「Area2D」クラスのノードをルートノードに選択する 「Area2D」ノードの名前を「StartPoint」に変更する 「StartPoint」ルートノードに以下の子ノードを追加する 「AnimatedSprite」ノード 「CollisionShape2D」ノード 「StaticBody2D」ノード 「StaticBody2D」ノードに「CollisionShape2D」ノーをを追加する ファイルパスが「res://Points/StartPoint.tscn」となるように、「Points」フォルダを作成しつつ、そこにファイルを作成する形でシーンを保存する シーンツリーに必要なノードは揃ったので、次はそれぞれのノードのプロパティを編集する。\n各ノードのプロパティを編集する まずは「AnimatedSprite」ノードのプロパティから編集していく。\nインスペクターで「Frames」プロパティに「新規SpriteFrames」を割り当てる 「SpriteFrames」をクリックし、スプライトフレームパネルを開く 以下の2つのアニメーションを作成する（片方は default の名前を変更して作成） アニメーション名: idle\nスプライトシー: res://Assets/Items/Checkpoints/Start/Start (Idle).png 速度: 1 FPS ループ: オフ\nアニメーション名: moving\nスプライトシート: res://Assets/Items/Checkpoints/Start/Start (Moving) (64x64).png 速度: 24 FPS ループ: オン\nインスペクターに戻り「Animation」プロパティを「idle」にする 「Playing」プロパティをオンにする 次に「CollisionShape2D」ノードのプロパティを編集する。このノードはプレイヤーキャラクターが当たったときに「moving」アニメーションを再生するための仕掛けだ。「Area2D」ルートノードは物理ボディではないので、コリジョン形状と接触しても透過する。\nインスペクターで「Shape」プロパティに「新規RectangleShape2D」を割り当てる コリジョン形状をスプライトテクスチャの市松模様の台の上に載せるような感じで配置する\nコリジョン形状の調整により関連プロパティの値が以下のようになっているか確認する Extents: (16, 1) Position: (11, 23) 最後に「StaticBody2D」ノードの子になっている方の「CollisionShape2D」のプロパティを編集しよう。こちらは台の上にプレイヤーキャラクターが乗れるようにするためのコリジョン形状だ。\nインスペクターで「Shape」プロパティに「新規RectangleShape2D」を割り当てる コリジョン形状をスプライトテクスチャの市松模様の台にピッタリ合わせるようにして配置する\nコリジョン形状の調整により関連プロパティの値が以下のようになっているか確認する Extents: (17, 4) Position: (11, 28) スクリプトをアタッチする 「StartPoint」ルートノードに新規でスクリプトをアタッチする。ファイルパスを「res://Points/StartPoint.gd」として開こう。\n今回のスクリプトはいたってシンプルだ。しかしシグナルの力を借りる必要がある。「StartPoint」ノードのシグナル「body_entered(body)」と「_body_exited(body)」を先にスクリプトに接続しておこう。\nでは具体的なスクリプトを確認していこう。今回は以下のようになった。\nextends Area2D # Added @ Part 7 # AnimatedSprite ノードの参照 onready var sprite = $AnimatedSprite func _ready(): # ゲーム開始時は idle アニメーションを再生 sprite.play(\u0026#34;idle\u0026#34;) # ボディが Area2D のコリジョン形状に入ったらシグナルでこのメソッドが呼ばれる func _on_StartPoint_body_entered(body): # もしボディの名前が Player だったら moving アニメーションを再生する if body.name == \u0026#34;Player\u0026#34;: sprite.play(\u0026#34;moving\u0026#34;) # ボディが Area2D のコリジョン形状から出たらシグナルでこのメソッドが呼ばれる func _on_StartPoint_body_exited(body): # もしボディの名前が Player だったら idle アニメーションを再生する if body.name == \u0026#34;Player\u0026#34;: sprite.play(\u0026#34;idle\u0026#34;) これで「StartPoint」シーンは完成だ。このあとさっそくインスタンス化して「level1」シーンに追加してみよう。\nLevel1 シーンにインスタンスを追加する では完成した「StartPoint」シーンをインスタンス化して「Level1」シーンに追加しよう。\n追加できたら、プロジェクトを実行して動作確認をしておこう。\nプレイヤーキャラクターが市松模様の台に乗った時だけ矢印の標が「moving」アニメーションにより動いた。台から離れると「idle」アニメーションで停止した。問題ないので次のチェックポイント作成の作業へ移ろう。\nCheckpoint シーンを作る シーンを新規作成してノードを追加する 以下の手順で「Checkpoint」シーンを作成して、ノードを追加して保存しよう。\n「シーン」メニュー＞「新規シーン」を選択する 「ルートノードを生成」で「その他のノード」を選択する 「Area2D」クラスのノードをルートノードに選択する 「Area2D」ノードの名前を「Checkpoint」に変更する 「Checkpoint」ルートノードに「AnimatedSprite」ノードと「CollisionShape2D」ノードを追加する ファイルパスを「res://Points/Checkpoint.tscn」としてシーンを保存する シーンツリーに必要なノードが揃った。さっきの「StartPoint」よりノードが少なくて簡単だ。\n各ノードのプロパティを編集する 「AnimatedSprite」ノードのプロパティを編集する。\nインスペクターで「Frames」プロパティに「新規SpriteFrames」を割り当てる 「SpriteFrames」をクリックし、スプライトフレームパネルを開く 以下の2つのアニメーションを作成する（片方は default の名前を変更して作成） アニメーション名: flag_idle\nスプライトシー: res://Assets/Items/Checkpoints/Checkpoint/Checkpoint (Flag Idle)(64x64).png 速度: 24 FPS ループ: オン\nアニメーション名: flag_out\nスプライトシート: res://Assets/Items/Checkpoints/Checkpoint/Checkpoint (Flag Out) (64x64).png 速度: 24 FPS ループ: オフ\nアニメーション名: no_flag\nスプライトシート: res://Assets/Items/Checkpoints/Checkpoint/Checkpoint (No Flag).png 速度: 24 FPS ループ: オフ\nインスペクターに戻り「Animation」プロパティを「flag_idle」にする 「Playing」プロパティをオンにする 次に「CollisionShape2D」ノードのプロパティを編集する。このノードはプレイヤーキャラクターが当たったときに「flag_out」アニメーションを再生したあと、そのまま「flag_idle」アニメーションを再生するために必要だ。「Area2D」ルートノードは物理ボディではないので、コリジョン形状と接触しても透過する。道中に立てるフラグとしては最適だ。\nインスペクターで「Shape」プロパティに「新規RectangleShape2D」を割り当てる コリジョン形状をスプライトテクスチャのフラグのポーツ部分にピッタリ合わせる感じで配置する\nコリジョン形状の調整により関連プロパティの値が以下のようになっているか確認する Extents: (1.5, 17.5) Position: (-8.5, 11) スクリプトをアタッチする ではチェックポイントを通過した時の「Checkpoint」のアニメーションをスクリプトで制御しよう。\nまずは「Checkpoint」ルートノードに新規スクリプトをアタッチする。パスを「res://Points/Checkpoint.gd」としてファイルを開こう。開いたら、以下のコード差し替えよう。コードはシンプルなので、解説はコード内のコメントをご覧いただきたい。\nextends Area2D # AnimatedSprite ノードの参照 onready var sprite = $AnimatedSprite # ゲーム開始時は no_flag アニメーションを再生 func _ready(): sprite.play(\u0026#34;no_flag\u0026#34;) func _on_Checkpoint_body_entered(body): # チェックポイントにプレイヤーキャラクターが当たったら if body.name == \u0026#34;Player\u0026#34;: # flag_out アニメーションを再生 sprite.play(\u0026#34;flag_out\u0026#34;, true) # アニメーションが終了するのを待つ yield(sprite, \u0026#34;animation_finished\u0026#34;) # flag_idle アニメーションを再生 sprite.play(\u0026#34;flag_idle\u0026#34;) Level1 シーンにインスタンスを追加する では「Checkpoint」シーンをインスタンス化して、「Level1」シーンに追加して動作を確認しよう。\n最初は「no_flag」アニメーションが再生されているので、ただポールが立っているだけだ。そのあと最初にプレイヤーキャラクターがチェックポイントに当たった時に、「flag_out」アニメーションが再生され、アニメーションが終了するとそのまま「flag_idle」アニメーションに切り替わった。そのあとはプレイヤーキャラクターがチェックポイントに当たっても何も起こらない。想定通りの動作が確認できたので、（少し休憩して）次のエンドポイント作成の手順に移ろう。\nEndPoint シーンを作る シーンを新規作成してノードを追加する 以下の手順で「EndPoint」シーンを作成して、ノードを追加して保存しよう。\n「シーン」メニュー＞「新規シーン」を選択する 「ルートノードを生成」で「その他のノード」を選択する 「Area2D」クラスのノードをルートノードに選択する 「Area2D」ノードの名前を「EndPoint」に変更する 「EndPoint」ルートノードに「AnimatedSprite」ノードを追加する 「EndPoint」ルートノードに「CollisionShape2D」ノードを追加する 「EndPoint」ルートノードに「StaticBody2D」ノードを追加する 「StaticBody2D」ノードに「CollisionPolygon2D」ノードを追加する 「Endpoint」ルートノードに「AnimationPlayer」ノードを追加する 「Endpoint」ルートノードに「Particles2D」ノードを追加する ファイルパスを「res://Points/EndPoint.tscn」としてシーンを保存する シーンツリーに必要なノードが揃ったので、次はそれぞれのノードを編集していく。\n各ノードのプロパティを編集する 「AnimatedSprite」ノードのプロパティを編集する。\nインスペクターで「Frames」プロパティに「新規SpriteFrames」を割り当てる\n「SpriteFrames」をクリックし、スプライトフレームパネルを開く\n以下の2つのアニメーションを作成する（片方は default の名前を変更して作成）\nアニメーション名: idle\nスプライトシー: res://Assets/Items/Checkpoints/End/End (Idle).png 速度: 24 FPS ループ: オフ\nアニメーション名: pressed\nスプライトシート: res://Assets/Items/Checkpoints/End/End (Pressed) (64x64).png 速度: 12 FPS ループ: オフ\nインスペクターに戻り「Animation」プロパティを「idle」にする\nなお、この「EndPoint」シーンの「AnimatedSprite」の「Playing」プロパティはオフのままにしておく。理由は「AnimatedSprite」のフレームをキーとして利用する形で、「AnimationPlayer」ノードの方でアニメーションさせたいからだ。\n次に「CollisionShape2D」ノードのプロパティを編集する。このノードはプレイヤーキャラクターが当たったときに「pressed」アニメーションを再生するために必要だ。といっても、ここでいう「pressed」というのは後ほど「AnimationPlayer」ノードで作成するアニメーションの方を指している（ややこしくて申し訳ない）。\nインスペクターで「Shape」プロパティに「新規RectangleShape2D」を割り当てる コリジョン形状をスプライトテクスチャのカップの真ん中より少し下あたりに合わせるようにして配置する\nコリジョン形状の調整により関連プロパティの値が以下のようになっているか確認する Extents: (12, 1) Position: (0, 8) 続けて「StaticBody2D」ノードの子である「CollisionPolygon2D」ノードのコリジョン形状を作っていく。いつもは「CollisionShape2D」の方を使用していたが、この優勝カップのような曲線や凹型の形状には合わせにくい。「CollisionPolygon2D」ならば、点を打って、点と点を線で繋げていくことで形状を作っていくので、複雑な形のスプライトテクスチャにも当てはめやすいのだ。\n公式オンラインドキュメント: CollisionPolygon2D 作業前にツールバーのアイコンを確認しておこう。\n緑の + がついたアイコン：「点を作成する」ツール。形状を作成するときに主に使用する。 青の ↑ がついたアイコン：「点を編集する」ツール。左クリックで点を移動、右クリックで点を削除する。 赤の × がついたアイコン：「点を消す」ツール。青のアイコンで右クリックするのと同じで、点を削除する。 併せて、点を打ちやすいようにツールバーでグリッドにスナップを有効にしておこう。またスナッピングオプション（縦に点が三つ並んだアイコン）＞スナップの設定を開き、グリッドのステップを　x、y ともに 4 px に設定する。\n「AnimatedSprite」で「Animation」プロパティを「idle」にしておき、この時のスプライトテクスチャに合わせてコリジョン形状を作成していく。\n2Dワークスペースでカップの断面を作るようにして点を打って線を繋いでいこう。最後の点を打ったあと、最初に打った点をクリックすれば最初と最後の点が繋がり、コリジョン形状の完成だ。以下のスクリーンショットでは、打った点の順番を記しているので参考にしてほしい。\n次は「AnimationPlayer」ノードでアニメーションを作成する。「AnimatedSprite」ノードとは別でこの「AnimationPlayer」を用意する理由を説明しておこう。今回のこのエンドポイントのシーンでは、「AnimatedSprite」の「pressed」アニメーション再生中に、プレイヤーキャラクターが乗っている「StaticBody2D」のコリジョン形状も動かす必要がある。なぜなら、画面上でプレイヤーキャラクターがカップの中に入っている状態でカップが上下動するので、キャラクターも一緒に上下動しないと、ゲームをプレイする人は違和感を感じてしまうからだ。\nでは「AnimationPlayer」ノードを選択してアニメーションパネルを開こう。\n新規アニメーションを「clear」という名前で作成する\nアニメーションの長さを 0.4 秒にする\n作業しやすいようにタイムラインのスナップを 0.05 秒にする\n作業しやすいようにタイムラインの拡大率を調整する\n以下の内容でそれぞれのトラックを追加・編集していき、アニメーションを作成する トラック 1: AnimatedSprite \u0026gt; animation プロパティ Time: 0 / Value: pressed / Easing: 1.00 Time: 0.4 / Value: idle / Easing: 1.00 トラック 2: AnimatedSprite \u0026gt; frame プロパティ Time: 0 / Value: 0 / Easing: 1.00 Time: 0.05 / Value: 1 / Easing: 1.00 Time: 0.1 / Value: 2 / Easing: 1.00 Time: 0.15 / Value: 3 / Easing: 1.00 Time: 0.2 / Value: 4 / Easing: 1.00 Time: 0.25 / Value: 5 / Easing: 1.00 Time: 0.3 / Value: 6 / Easing: 1.00 Time: 0.35 / Value: 7 / Easing: 1.00 Time: 0.4 / Value: 0 / Easing: 1.00 トラック 3: CollisionPolygon2D \u0026gt; position プロパティ Time: 0 / Value: (0, 0) / Easing: 1.00 Time: 0.15 / Value: (0, -1) / Easing: 1.00 Time: 0.2 / Value: (0, -4) / Easing: 1.00 Time: 0.3 / Value: (0, -5) / Easing: 1.00 Time: 0.4 / Value: (0, -4) / Easing: 1.00 最後に2Dワークスペース上でアニメーションを再生してみて動作確認する\n最後に「Particles2D」ノードを編集していこう。\nエンドポイントのカップにプレイヤーキャラクターが入ったらレベルクリアとなって、次のレベルに遷移させる。この時、多少かっこいい演出をしたいところだ。そこで、プレイヤーキャラクターがカップに入ったあと、カップからふわぁと光の粒子のようなものが舞い上がるような演出を作っていく。\n公式オンラインドキュメント: Particles2D ではプロパティの多い「Particles2D」だが、プロパティの設定を以下のようにしてほしい。\nAmount: 300 Time セクション Lifetime: 1.5 Process Material セクション Material: 新規ParticlesMaterial\nEmission Shape セクション Shape: Box Box Extents: (14, 1, 1) Direction セクション Direction: (0, -1, 0) Spread: 0 Gravity セクション Gravity: (0, -200, 0) Initial Velocity セクション Velocity: 50 Velocity Random: 0.5 Scale セクション Scale: 2 Scale Curve: 新規CurveTexture Curve: 新規Curve Min Value: 0 Max Value: 1 Bake Resolution: 100 Color セクション Color Ramp: 新規GradientTexture Gradient: 新規Gradient Colors: PoolColorArray (size 2) 0: #99e5ff 1: #5400ff Transform セクション Position: (0, -8) ここまでのプロパティでどのようなパーティクルになったか確認しておこう。\nパーティクルがスプライトテクスチャより前に表示されているので、「Particles2D」ノードを最背面に移動させてカップの中から粒子が上昇しているようにしよう。具体的にはシーンドックで「EndPoint」の子ノードのうち「Particles2D」を一番上に移動するだけだ。\nところで、「Particles2D」はプロパティの値を触れば触るほど慣れてきて、思い通りの表現ができるようになる。少し時間をかけて、一つ一つの変更で何がどう変わるのかをあなた自身の目で確かめてほしい。また、もっとこの方が良いと思うプロパティの設定があれば、積極的にアレンジいただければと思う。\nPlayer シーンにクリア時のアニメーションを実装する さて、ここでもう一つ素敵な演出を入れようではないか。エンドポイントのカップに入ったプレイヤーキャラクターが次のレベルにワープするような演出だ。パーティクルの粒子を浴びたあと、プレイヤーキャラクターがふわりと浮かび上がり、そのまま透明になりながら最後は一気に x 軸方向の幅が 0 、 y 軸方向には　20 倍に拡大して消える、というのを「AnimationPlayer」を利用して実装する。\nでは久しぶりに「Player.tscn」シーンのファイルを開こう。開いたら、「Player」ルートノードに「AnimationPlayer」ノードを追加しよう。\n「AnimationPlayer」ノードを選択して、アニメーションパネルを開いたら、新規で「clear」という名前でアニメーションを作成する。作成できたら、以下の手順でアニメーションを編集しよう。\nアニメーションの長さを 1 秒に設定する タイムラインのスナップを 1 秒に設定する 以下の内容でトラックを追加、編集する トラック1: AnimatedSprite ノード \u0026gt; position プロパティ Time: 0 / Value: (0, 0) / Easing: 1.00 Time: 1 / Value: (0, -64) / Easing: 1.00 トラック2: AnimatedSprite ノード \u0026gt; scale プロパティ Time: 0 / Value: (1, 1) / Easing: 30.0 Time: 1 / Value: (0, 20) / Easing: 1.00 トラック3: AnimatedSprite ノード \u0026gt; modulate プロパティ Time: 0 / Value: #ffffff / Easing: 3.0 Time: 1 / Value: #00ffffff / Easing: 30.0 アニメーションを再生してみよう。\nアニメーションを再生したあと、プロパティの値が変更されたままになってしまう。そこで、ゲーム開始時に初期値を設定するように、「Player.gd」スクリプトに以下のコードを追加しておこう。_readyメソッドなので、挿入箇所は各種プロパティを定義するコードのあとが一般的だ。\nfunc _ready(): sprite.position = Vector2(0, 0) sprite.scale = Vector2(1, 1) sprite.modulate = Color(1, 1, 1, 1) あとは、エンドポイント側にこのあとアタッチする予定のスクリプトで、「Player」シーンの「AnimationPlayer」のアニメーションを再生させたいので、以下のプロパティも「Player.gd」スクリプトに追加しておこう。\nonready var anim_player = $AnimationPlayer さてここまでで各ノードのプロパティの編集は完了だ。次はスクリプトでプレイヤーキャラクターがエンドポイントのカップの中に入った時の動作を制御していく。\nスクリプトをアタッチする 「EndPoint」ルートノードに新規でスクリプトをアタッチする。ファイルパスを「res://Points/EndPoint.gd」として作成しよう。\nスクリプトが作成できたら、以下のコードを記述しよう。\nextends Area2D # Paricle2D ノードの参照 onready var particle = $Particles2D # AnimatedSprite ノードの参照 onready var sprite = $AnimatedSprite # CollisionPolygon2D ノードの参照 onready var polygon = $StaticBody2D/CollisionPolygon2D # AnimationPlayer ノードの参照 onready var anim_player = $AnimationPlayer # ゲーム開始時にパーティクルの停止とアニメーションで変更されるプロパティの初期値を設定 func _ready(): particle.emitting = false sprite.play(\u0026#34;idle\u0026#34;) polygon.position = Vector2(0, -4) ここで例によって、「Area2D」クラスである「EndPoint」のシグナルを接続して、プレイヤーキャラクターがエンドポイントのカップの中に入った後の動作をコーディングしていく。\nまずは「body_entered(body)」シグナルをこのスクリプトに接続しよう。以下の_on_EndPoint_body_enteredメソッドが追加されたはずなので、そのメソッドのブロック内にコーディングしていこう。\n# プレイヤーキャラクターがカップの中に入ったら func _on_EndPoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: # AnimationPlayer ノードの clear アニメーションを再生 anim_player.play(\u0026#34;clear\u0026#34;) # clear アニメーションが終了するまで待機 yield(anim_player, \u0026#34;animation_finished\u0026#34;) # Particles2D ノードの emitting プロパティを有効にしてパーティクルシステム発動 particle.emitting = true # Player ノードの AnimationPlayer の clear アニメーションを再生 body.anim_player.play(\u0026#34;clear\u0026#34;) # clear アニメーションが終了するまで待機 yield(body.anim_player, \u0026#34;animation_finished\u0026#34;) # 次のレベルへ遷移（というのを一旦文字で出力し、Level2 シーン作成後に更新する） print(\u0026#34;Moving to the next level!\u0026#34;) これで「EndPoint.gd」スクリプトの編集は完了だ。少し休憩しよう。このあと、いよいよ「Level1」シーンに、先に用意したスタートポイント、チェックポイント、エンドポイントのインスタンスを追加していく。\nLevel1 シーンにインスタンスを追加する 「Level1.tscn」シーンを開いて、「EndPoint.tscn」をインスタンス化してルートノードに追加しよう。\n追加できたら、さっそくプロジェクトを実行して動作を確認してみよう。\n見ての通り、プレイヤーキャラクターのスプライトがエンドポイントのスプライトより手前に表示されているので、カップの中に入った状態を表現できていない。ここで、シーンドックで「Player」ノードを「EndPoint」ノードより上に配置すれば済むと思うだろう。確かにそれは正しい。しかし、今後毎回新しいレベルシーンを作るたびにこの順序を気にしなければならないのは少し面倒ではないか。そこで「EndPoint.tscn」シーンに戻って、インスペクターから「EndPoint」ルートノードの「Z Index」プロパティをデフォルトの 0 から 1 に変更してみよう。\nなんと、このプロパティは奥行きとしての順序を設定できるのだ。各ノードが Z 軸方向（奥行き）にレイヤー状に配置されているとして、全てのノードは最初 0 番目のレイヤーにある。0 番目のレイヤーの中の順序はシーンツリーの順序に従う。今回「EndPoint」ノードを 1 番目のレイヤーに設定したので、他のノードよりも必ず全面に配置される。これならば、シーンツリー上のノードの順番を気にせずに済むだろう。ちなみにインスペクターで「Z Index」の一つ下にある「Z As Relative」はデフォルトでオンになっているが、この場合、親ノードの「Z Index」の値にそのノード自身の「Z Index」の値を加算した値が、シーンツリー上の奥行きの順序となる。\nでは改めてプレイヤーキャラクターをエンドポイントのカップに入れてみよう。\nカップの中に入ってからふわりと浮かび上がって消えるまでの動きが確認できた。概ね問題なさそうなので、次の手順に進もう。\nLevel2 シーンを作る ひとまず、あまり凝ったマップデザインにせず、できるだけ短時間で「Level2」シーンを作ってしまおう。タイルマップのデザインや、敵キャラクター、アイテムの配置はあなたの思う通りにご自由にやってただいて構わない。\nLevel1 シーンを複製する Level2 を一から作るとなると、一通りの作業を経験しているとはいえ、なかなか手間がかかるだろう。そこで、すでに作成済みの「Level1」シーンを複製して、それを編集する方法を採用する。ちなみに、複製は単なるファイルのコピーでしかないので、継承とは別物だ。継承元の変更が反映される心配がないので気楽にやってほしい。以下の手順で複製できるのでやってみよう。\nファイルシステムドックで「res://Levels/Level1.tscn」を右クリックする 「複製」をクリックする\n「Level2.tscn」と名付けて複製する。\nルートノードの名前を「Level2」に変更する\nタイルマップをデザインする タイルマップをデザインする前に、敵キャラクターやアイテムのノードが邪魔になりそうだったら先に削除しておこう。後からでもシーンをインスタンス化して簡単に追加できる。\n「TileMap」ノードを選択したら、まず「Level1.tscn」で配置したタイルを全て削除する。これは選択ツールで選択してカットを繰り返しても良いし、バケツツールで選択した範囲を右クリックで削除しても構わない。効率が良いと思う方法で削除しよう。\nPart 2 のチュートリアルでタイルセットを用意した時に、石のブロックタイルのアトラスをせっかく作ったので、今回はそれを使ってダンジョンっぽいタイルマップをデザインするのも良いだろう。このチュートリアルではサンプルとして以下のようなタイルマップをデザインした。\nそれぞれのノードをマップ上に配置する タイルマップがデザインできたら、スタートポイント、チェックポイント、エンドポイントに加え、お好みの敵キャラクター、アイテム、アイテムボックスを配置しよう。「Level1」のように全ての種類のインスタンスを追加する必要はない。サンプルとして作ったタイルマップには、以下のようにマッシュルームばかりを配置した。マッシュルームの生息するジメジメしたダンジョンというイメージで作った（一匹だけプラントがいる\u0026hellip;）。\n注意しなければならないのは、敵キャラクターは基本的に左向きに作成していることだ。プレイヤーキャラクターが敵キャラクターの右側にいるからといって振り向くような動作は実装していない。壁にぶつかると左右反転する動作は実装しているが、少し違う。この点を考慮して配置していこう。\nシーンを実行しながら、おかしなところを都度修正しつつ、完成を目指そう。シーンを実行して最後まで特に問題がなければ「Level2」シーンの作成は完了だ。ちなみに下のGIF画像は尺が長いので3倍速にしている。\n今回のデバッグで、ブロックの端に立った時にプレイヤーキャラクターが滑って落ちてしまうことが多く、難易度が非常に高いと感じたので、「Player.tscn」の「Player」ルートノードの摩擦抵抗を表す「Friction」プロパティの値を 0.5 に変更した。\n次のレベルへの遷移を実装する ついに、今回のチュートリアルの最大のテーマである次のレベルへの遷移を実装していく。\nLevel1、Level2 さらに今後レベルシーンが増えることを前提にするならば、それらを管理する「Game」シーンがあったほうが制御しやすいだろう。\nではさっそく以下の手順で「Game」シーンを作成していこう。\n「シーン」メニュー＞「新規シーン」を選択 「Node」クラスをルートノードにしてシーンを作成 「Game」フォルダを「res://」の直下に作り、パスを「res://Game/Game.tscn」として保存 ということで、今のところルートノードだけのシーンツリーだ。\nいつものように「Level1」シーンをインスタンス化して「Game」ルートノードに追加したいところだが、今回それはシーンドック上では行わない。今回は「Level1」などのレベルシーンの追加（または削除）は全てスクリプト上で行う。\n次に「Game」ルートノードにスクリプトを新規でアタッチする。ファイルパスは「res://Game/Game.gd」として作成する。スクリプトのコードは以下のように記述しよう。\nextends Node # Added @ Part 7 # あとでレベルシーンのインスタンスノードの参照を代入予定のプロパティ、型だけ定義 var level: Node2D # 現在のレベル export var current_level = 1 # 最後のレベル（今のところ Level2 が最後なので 2） export var final_level = 2 func _ready(): # ゲーム開始時にこのメソッドを実行、メソッドはこのあと定義する add_level() # 現在のレベル数に応じたレベルシーンのインスタンスを Game ルートノードの子として追加するメソッド func add_level(): # レベルシーンのインスタンスを参照 level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() # レベルシーンのインスタンスの tree_exited シグナルをこのあと定義する change_level メソッドに接続 level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) # Game ルートノードにレベルシーンのインスタンスノードを追加 add_child(level) # レベルシーンのインスタンスノード解放時に発信される tree_exited シグナルによって呼ばれるメソッド func change_level(): print(\u0026#34;change_level() called.\u0026#34;) # もし現在のレベルが最後のレベルより低かったら if current_level \u0026lt; final_level: # デバッグ用 print(\u0026#34;change to next level.\u0026#34;) # 現在のレベルシーンを解放 level.queue_free() # 現在のレベルを一つ上げる current_level += 1 # 次のレベルシーンを子ノードとして Game ルートノードに追加 add_level() # もし現在のレベルが最後のレベルだったら else: # デバッグ用 print(\u0026#34;Game Clear! Congrats!\u0026#34;) # ゲームを終了 get_tree().quit() 最後に定義しているchange_levelメソッドの内容をざっくり説明すると、まだ最後のレベルに達していなければ次のレベルに遷移し、最後のレベルをクリアした場合はゲームを終了する、という内容になっている。\nところで「Level1.gd」スクリプトはもはや「Level1」ノードだけのものではなくなった。ということで、このタイミングでついでに「Level1.gd」スクリプトの名前を変更しておこう。ファイルシステムドックで「res://Levels/Level1.gd」を右クリックし、「名前を変更」を選択して変更する。わかりやすく「Level.gd」にしておこう。\n次に、プレイヤーキャラクターがエンドポイントのカップに入ったら次のレベルに遷移するコードを記述する。「Endpoint.gd」スクリプトを開いて、以下の「# 削除」と「# 追加」の行を更新しよう。\nextends Area2D # Added @ Part 7 # 途中省略 func _on_EndPoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: anim_player.play(\u0026#34;clear\u0026#34;) yield(anim_player, \u0026#34;animation_finished\u0026#34;) particle.emitting = true body.anim_player.play(\u0026#34;clear\u0026#34;) yield(body.anim_player, \u0026#34;animation_finished\u0026#34;) #print(\u0026#34;Moving to the next level!\u0026#34;) # 削除 # 親ノードである EndPoint ルートノードを解放する（この時 tree_exited シグナルが呼ばれる） get_parent().queue_free() # 追加 get_parentメソッドは、このスクリプトがアタッチされいるノードの親ノードを取得する。ここではすなわち「EndPoint」ノードの親なので「Level1」などのレベル数に応じたレベルシーンのルートノードがそれに当たる。その親ノードのqueue_freeメソッドを呼び出しているわけだ。\nということで、レベルクリアした時の最後の処理をまとめておこう。\nプレイヤーキャラクターがエンドポイントのカップに入る 「Level1」などその時のレベル数に応じたレベルシーンのルートノードが解放（削除）される。 「Game」シーンツリーから「Level_」ノードが消える レベルシーンの「tree_exited」シグナルが発信される シグナルが接続されている「Game.gd」スクリプトのchange_levelメソッドが呼ばれる まだ最後のレベルでなければ次のレベルに遷移し、最後のレベルならゲームを終了する これでようやく今回のチュートリアルのテーマである「次のレベルへの遷移」が実装できた。遷移の動作確認だけしやすいように、「EndPoint」ノードをプレイヤーキャラクターが登場する位置の近くに追加で配置しておこう。\n動作確認の前にプロジェクトのメインシーンの設定を変更する。「プロジェクト」メニュー＞「プロジェクト設定」を開き、「一般」タブ＞「Application＞Run」で、「Main Scene」を「res://Game/Game.tscn」に変更して閉じよう。\nメインシーンを変更できたら、プロジェクトを実行してみよう。\n「Level1」から「Level2」への遷移は想定通りの動きが確認できた。また「Level2」をクリアした時は最後のレベルなので、ゲームが終了してデバッグパネルが閉じた。これも問題ない。デバッグ用に配置したチェックポイントとエンドポイントは本番用の状態に戻しておこう。\nなお「Level1.tscn」は本番用として以下の配置にしている。\nレベルの遷移の動作確認は終えているので、通しでの確認をするかどうかはお好みだが、最初から最後まで問題ないか確認したい方は最後に改めてプロジェクトを実行してみよう。以下のGIF画像は尺が長いので5倍速にしている。\nPart 7 で編集したスクリプトのコード 最後に今回の Part 7 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nStartPoint.gd の全コード extends Area2D # Added @ Part 7 onready var sprite = $AnimatedSprite func _ready(): sprite.play(\u0026#34;idle\u0026#34;) func _on_StartPoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: sprite.play(\u0026#34;moving\u0026#34;) func _on_StartPoint_body_exited(body): if body.name == \u0026#34;Player\u0026#34;: sprite.play(\u0026#34;idle\u0026#34;) Checkpoint.gd の全コード extends Area2D # Added @ Part 7 var is_checked = false onready var sprite = $AnimatedSprite func _ready(): sprite.play(\u0026#34;no_flag\u0026#34;) func _on_Checkpoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34; and not is_checked: sprite.play(\u0026#34;flag_out\u0026#34;) yield(sprite, \u0026#34;animation_finished\u0026#34;) sprite.play(\u0026#34;flag_idle\u0026#34;) is_checked = true EndPoint.gd の全コード extends Area2D # Added @ Part 7 onready var particle = $Particles2D onready var sprite = $AnimatedSprite onready var polygon = $StaticBody2D/CollisionPolygon2D onready var anim_player = $AnimationPlayer func _ready(): particle.emitting = false sprite.play(\u0026#34;idle\u0026#34;) polygon.position = Vector2(0, -4) func _on_EndPoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: anim_player.play(\u0026#34;clear\u0026#34;) yield(anim_player, \u0026#34;animation_finished\u0026#34;) particle.emitting = true body.anim_player.play(\u0026#34;clear\u0026#34;) yield(body.anim_player, \u0026#34;animation_finished\u0026#34;) print(\u0026#34;Moving to the next level!\u0026#34;) get_parent().queue_free() Game.gd の全コード extends Node # Added @ Part 7 var level: Node2D export var current_level = 1 export var final_level = 2 func _ready(): add_level() func add_level(): level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) add_child(level) func change_level(): print(\u0026#34;change_level() called.\u0026#34;) if current_level \u0026lt; final_level: print(\u0026#34;change to next level.\u0026#34;) level.queue_free() current_level += 1 add_level() else: print(\u0026#34;Game Clear! Congrats!\u0026#34;) get_tree().quit() おわりに 以上で Part 7 は完了だ。今回は次のレベルへの遷移を実装した。その準備として（一部ついでだが）StartPoint、Checkpoint、EndPoint という新しいシーンを作成した。復習も兼ねて、 Particles2D や AnimationPlayer を使ったレベルクリア時の演出もちょっと凝ってみた。Godot の取り扱いに少しでも慣れていただけたなら嬉しい限りだ。\n次回のチュートリアルでは、HUD（ヘッズアップディスプレイ）を実装していく予定だ。これを実装するということは、ライフやスコアの仕組みも実装することになるので、また次も気合を入れて取り組んでいこう。では次回もお楽しみに。\nUPDATE:\n2022-03-04 プロジェクトのメインシーンを変更する手順を追加\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_7/","summary":"第7回目の今回は、レベルのマップ上にスタートポイント、中間のチェックポイント、そしてエンドポイントを配置し、エンドポイントに到達した時に次のレベルに遷移する仕組みを実装していく。併せて、現在レベルシー","title":"Godot で作るプラットフォーマー Part 7：次のレベルに遷移させよう！"},{"content":"第8回目の今回は、HUD を実装していく。\nHUD というのは、ヘッズアップディスプレイ（Heads Up Display）の略で、ゲームプレイ中に常に画面上に表示されている UI の一つだ。例えば、プレイヤーの残りのライフ（海外での呼称 Health に合わせてこれ以降はヘルスと呼ぶ）や、獲得したスコアなどがわかりやすいだろう。HUD を実装する目的は現在のゲームの状態を視覚的にわかりやすくすることだ。\nこのチュートリアルでは、プレイヤーキャラクターのヘルスとスコアと現在のレベルを画面の上部に表示する HUD を作っていく。プレイヤーキャラクターがダメージを受ける仕組みが未実装なので、その仕組みも併せて追加していく。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー フォントのアセットをファイルシステムに追加する HUD を作るにあたって、HUD 内に表示する文字のフォントもできればレトロゲーム風なものにしたいところだ。\nまずは Godot のアセットライブラリにアクセスして使えそうなフォントアセットをダウンロードしよう。Godot Engine エディタ上部の「AssetLib」からアクセス可能だ。\nアクセスできたら検索ボックスに「font」と入力して検索してみよう。すると「Open Font Package」というアセットが見つかるはずだ（2022/03/05 現在）。\n見つかったらそれをクリックしてダウンロードする。\nこの時、おそらく「icon.png」が競合していると警告される。競合するファイルはインストールする前にチェックを外しておこう。\nインストールが完了したら OK をクリックする。\nファイルシステムを覗いてみると、ダウンロードしたフォントアセットが見つかるはずだ。\nHUD シーンを作る 新規シーンを作成して必要なノードを追加する まずは新規で HUD のシーンを作ろう。\n「シーン」メニュー＞「新規シーン」を選択する 「ルートノードの生成」で「ユーザーインターフェース」を選択し、「Control」クラスのルートノードにし、名前を「HUD」に変更する 「HUD」に「HBoxContainer」を追加し、名前を「HUDHBox」にする 「HUDHBox」に「HBoxContainer」ノードを追加し、名前を「HealthHBox」にする 「HealthHBox」に「Label」ノードを追加し、名前を「HealthText」にする 「HealthHBox」に「TextureProgress」ノードを追加し、名前を「HealthBar」にする 「HUDHBox」に「Label」ノードを追加し、名前を「ScoreText」にする 「HUDHBox」に「HBoxContainer」ノードを追加し、名前を「LevelHBox」にする 「LevelHBox」に「Label」ノードを追加し、名前を「LevelText」にする 「LevelHBox」に「TextureRect」ノードを追加し、名前を「LevelTexture」にする 「UI」フォルダを作成し、ファイルパスを「res://UI/HUD.tscn」としてシーンを保存する シーンツリーに必要なノードは揃ったので、次はそれぞれのノードのプロパティを編集する。\n新しく登場するノードがあるので、それぞれ簡単に用途を説明しておこう。公式オンラインドキュメントのそれぞれのクラスの説明ページも必要に応じて確認いただきたい。\n「Control」クラスは全てのユーザーインターフェース（UI）系のクラス( ○ こういう緑色のアイコンのクラス)の継承元になっている基本のクラスだ。今回作成したシーンではルートノードとして利用したが、これは単に、子ノードが全てUI系のノードのため、不都合のない入れ物として使っているだけだ。\n公式オンラインドキュメント Control 「HBoxContainer」クラスの\u0026quot;H\u0026quot;は\u0026quot;Horizontal\u0026quot;の頭文字から来ており、その名の通り、水平方向に子ノードを並べて表示するための収納箱（コンテナ）のような役割をする。今回、HUD の要素は画面上部に横並びにしたかったので、このクラスのノードを利用している。お察しかもしれないが垂直方向（Vertical）用に「VBoxContainer」クラスもある。\n公式オンラインドキュメント HBoxContainer VBoxContainer 「Label」クラスは、UIに文字列を表示させたい時に利用する。このクラスは、シンプルに文字列にフォントファイルを適用して表示するだけのシンプルなものだ。リッチテキストを表示したい場合は「RichTextLabel」という別のクラスを利用する。このチュートリアルでは、「HEALTH」、「SCORE」、「LEVEL」という文字を HUD に表示するために利用する。\n公式オンラインドキュメント Label RichTextLabel 「TextureProgress」クラスは、プログレスバー系のクラスの一つで、割り当てたテクスチャを利用してプログレスバーを作成することができる。このチュートリアルではヘルスの状態を直感的にわかりやすく表示するのに利用する。これは割と一般的な使い方だ。別の「ProgressBar」というクラスもあるが、これはどちらかというとデータ読み込み中などに利用するものだ。\n公式オンラインドキュメント TextureProgress ProgressBar 「TextureRect」クラスは、四角い図形にテクスチャを割り当てて表示するクラスで、\u0026ldquo;Rect\u0026quot;は\u0026quot;Rectangle\u0026quot;の略だ。もちろんテクスチャの画像が透過部分のある PNG イメージなら、四角に限らずあらゆるイメージを表示できる。用途としては、テクスチャで画面全体を覆ってゲームの背景に利用することもあれば、HUD やインベントリシステムなど UI の一部のイメージとして使用したり、HUD の範囲だけの背景として使われることもあり、様々な場面で役に立つクラスだ。今回は、現在のレベルを示す数字を画像で表示するために利用する（元々用意したアセットにレベルの数字の画像があり、せっかくなので）。\n公式オンラインドキュメント TextureRect 各ノードのプロパティを編集する HUD ルートノード 「HUD」ルートノードを選択したら、ツールバーで「レイアウト」＞「Rect全面」を選択して、画面一杯に広げる\nHUDHBox ノード ツールバーで「レイアウト」＞「上伸長」を選択して、画面上部で横一杯に広げる 「HUDHBox」を選択してインスペクターから「Alignment」プロパティを「Center」にする 「Margin」プロパティを（Left: 8, Top: 8, Right: -8, Bottom: 0）にして画面端に少し余白を作る 「Theme Overrides」＞「Constants」＞「Separation」プロパティを 16 にする\nHealthHBox ノード このノードのプロパティは編集不要だ。\nHealthText ノード 「HealthText」ノードを選択して、インスペクターから「Text」プロパティに「health」と入力する 「Uppercase」プロパティをオンにする\n「Theme Overrides」＞「Fonts」＞「Font」プロパティに、ファイルシステムから「res://fonts/poco/Poco.tres」（事前に準備したフォント）をドラッグ\u0026amp;ドロップして適用する。 追加したフォントをクリックし、「Settings」＞「Size」プロパティを 16 にする さらに「Extra Spacing」＞「Top」プロパティを -8 にする\nHealthBar ノード 「HealthBar」ノードを選択したら、インスペクターで「Nine Patch Stretch」をオンにして、テクスチャのサイズを柔軟に変更できるようにする\n「Textures」＞「Under」にファイルシステムから「res://Assets/Background/Pink.png」をドラッグ\u0026amp;ドロップして適用する（ヘルスバー用のアセットがないのであり物でやりくりするのだ） 今回「Textures」＞「Over」プロパティは設定せずそのまま 同様に「Textures」＞「Progress」プロパティにファイルシステムから「res://Assets/Background/Green.png」をドラッグ\u0026amp;ドロップして適用する テクスチャの柄が目立たないように「Tint」\u0026gt;「Under」プロパティの値を # 000000 にして大幅に色を変える 同様に「Tint」＞「Progress」プロパティの値を # 26ab3c にする\n「Range」＞「Value」プロパティの値を 100 にする（この値に連動して「Progress」のテクスチャサイズが変化する）\n「Rect」＞「Min Size」プロパティの x の値を 100 にする\nScoreText ノード 「HealthText」ノードと同様の手順だ。\n「ScoreText」ノードを選択したら、インスペクターで「Text」プロパティに「score 0」と入力する 「Uppercase」プロパティをオンにする 「Size Flags」＞「Horizontal」で「Fill」と「Expand」にチェックを入れる\n「Theme Overrides」＞「Fonts」\u0026gt;「Font」プロパティに、ファイルシステムから「res://fonts/poco/Poco.tres」をドラッグ\u0026amp;ドロップして適用する。 LevelHBox ノード このノードのプロパティは編集不要だ。\nLevelText ノード 「HealthText」ノードや「ScoreText」と同様の手順だ。\n「LevelText」ノードを選択したら、インスペクターで「Text」プロパティに「level」と入力する 「Uppercase」プロパティをオンにする 「Theme Overrides」＞「Fonts」\u0026gt;「Font」プロパティに、ファイルシステムから「res://fonts/poco/Poco.tres」をドラッグ\u0026amp;ドロップして適用する。 LevelTexture ノード 「LevelTexture」ノードを選択したら、インスペクターで「Texture」プロパティに、ファイルシステムから「res://Assets/Menu/Levels/01.png」をドラッグ\u0026amp;ドロップして適用する\nちなみに画像にブラーがかかっていたら、インポートドックで Pixel 2D のプリセットを適用して再インポートしておこう。\nHUD シーンをインスタンス化して Game シーンに追加する それでは、ここまでに作成した「HUD」シーンを「Game」シーンに追加していこう。\nまずは「Game.tscn」を開く 「Game」ルートノードに「CanvasLayer」ノードを追加し、名前を「HUDLayer」に変更する 「HUDLayer」ノードに「HUD.tscn」シーンをインスタンス化して追加する シーンツリーが以下のようになればOKだ。\nちなみに「CanvasLayer」クラスのノードを追加した理由は、このゲームのカメラを担当する「Camera2D」ノードとはレイヤーを別ける必要があったからだ。そうしないと、プレイヤキャラクターを操作するやいなや、HUDの位置がズレていってしまう。「CanvasLayer」の子として「HUD」ノードを追加することで、HUD がカメラとは別レイヤーになり、常に画面上の指定の位置に HUD が固定された状態を維持できるのだ。\nでは実際にプロジェクトを実行して HUD の表示を確認してみよう。\nプレイヤーキャラクターが移動しても HUD は画面上部に固定されたままで、問題なさそうだ。小休止したら次のスクリプトの手順に進もう。\nHUD ノードにスクリプトをアタッチする 「HUD」ルートノードにスクリプトをアタッチしよう。ファイルパスを「res://UI/HUD.gd」として作成する。スクリプトエディタを開いたら、以下のコードを記述してほしい。\nextends Control # 値の変更が必要なプロパティをもつノードの参照 onready var health_bar = $HUDHBox/HealthHBox/HealthBar onready var score_text = $HUDHBox/ScoreText onready var level_texture = $HUDHBox/LevelHBox/LevelTexture # ゲーム開始時にヘルスバーを満タンにする func _ready(): health_bar.value = 100 # 以下の3つのこのメソッドは Game.gd から呼び出す予定 # HealthBar ノードの Value プロパティに引数 health の値を適用する func update_health(health): health_bar.value = health # ScoreText ノードの Text プロパティに引数 score の値を文字列に変換して適用する func update_score(score): score_text.text = \u0026#34;score \u0026#34; + str(score) # LevelTexture ノードの Texture プロパティに現在のレベル数と同じテクスチャ画像を適用する func update_level(level): # 文字列型のレベル数を格納するための変数を定義 var str_level # レベルが 10 未満だったら if level \u0026lt; 10: # 頭に 0 をつけた文字列型のレベル数表記に変換 str_level = \u0026#34;0\u0026#34; + str(level) # レベルが 10 以上 50 以下だったら（アセットが 50 までしかないため） elif level \u0026lt;= 50: # そのまま文字列型のレベル数表記に変換 str_level = str(level) # アセットのファイル名の数字の部分に str_level 変数の値を利用してテクスチャファイル読み込み var file = load(\u0026#34;res://Assets/Menu/Levels/\u0026#34; + str_level + \u0026#34;.png\u0026#34;) # LevelTexture ノードの Texture プロパティに読み込んだテクスチャを適用 level_texture.texture = file 上記「HUD.gd」スクリプトでは、値の変更が発生するプロパティを持つノードを参照するプロパティを3つ定義した。また、それらのプロパティを更新するためのメソッドもそれぞれ作成した。これら3つのメソッドは「Game.gd」スクリプト側から呼び出すことになる。理由は、「Game.gd」の方で、プレイヤーキャラクターのヘルス、スコア、および現在のレベル数を管理したいからだ。\nさて、ここから複数のノードのスクリプトが絡み合っていくのでちょっとややこしいかもしれない。こういう時は図を書くとわかりやすい。紙と鉛筆で良いので、以下のような図を書いて頭の中を整理してからコーディング作業を開始するのがおすすめだ。ちなみにこの図はhealthおよびscoreプロパティの値が最終的に HUD へ反映するまでの流れを示している。自分の頭が整理できさえすれば細かい図のクオリティを気にする必要はない（筆者も普段は鉛筆で大雑把に書く）。\nではこの流れでまずは「Game.gd」スクリプトを編集していこう。「Game.gd」を開いたら、冒頭の_readyメソッドまでのコードを以下の内容に更新する。「# 追加」とコメントしているところが更新箇所だ。\nextends Node # 現在のヘルスを格納するプロパティ var health: float = 100.0 # 追加 # 現在のスコアを格納するプロパティ var score: int = 0 # 追加 var level: Node2D # Player ノードの参照（予定） var player: KinematicBody2D # 追加 export var current_level = 1 export var final_level = 2 # HUD ノードの参照 onready var hud = $HUDLayer/HUD # 追加 func _ready(): add_level() # HUD ノードの update_health メソッドの引数に health プロパティの値を渡して実行 hud.update_health(health) # 追加 # HUD ノードの update_score メソッドの引数に score プロパティの値を渡して実行 hud.update_score(score) # 追加 # HUD ノードの update_level メソッドの引数に current_level プロパティの値を渡して実行 hud.update_level(current_level) # 追加 #　以下省略 今回「Game.gd」スクリプト内で、プレイヤーキャラクターのヘルスの管理用にhealthプロパティを、スコアの管理用にscoreプロパティを新たに定義した。\nそして、先に「HUD.gd」で定義した3つのメソッドも、さっそく「Game.gd」の_readyメソッドの中で実行している。これにより、ゲーム開始時にhealth、score、levelの3つのプロパティの初期値が HUD に反映される。\nHUD にプレイヤーキャラクターが受けたダメージを反映させる ここからは、プレイヤーのヘルス管理を実装していく。\nPlayer シーンに HitBox を追加する 長らく放置していた、プレイヤーキャラクターのダメージを受ける仕組みを作る時が来た。敵に当たった時にシグナルを発信させてダメージ処理を行いたいので、敵キャラクターと同様に、下記手順でプレイヤーキャラクターにも「HitBox」を作成するところから始めていこう。\n「Player.tscn」を開く 「Player」ルートノードに「Area2D」ノードを追加し、名前を「HitBox」に変更する 「HitBox」ノードに「CollisionShape2D」ノードを追加する\n追加した「CollisionShape2D」の「Shape」プロパティに「新規RectangleShape2D」を設定する。 追加した「CollisionShape2D」のコリジョン形状を編集する。「Player」直下の「CollisionShape2D」の形状より横幅が 1 px だけ大きくなるようにし、足元は敵キャラクターを踏む際にダメージを受けないように少し空けておく。関連プロパティは以下の値になった。 Extents: (7, 8.5) Position: (0, 3.5)\nスクリプトでプレイヤーキャラクターが敵キャラクターに当たった時のダメージ処理を実装をする Player.gd プレイヤーキャラクターが敵キャラクターに当たった時の処理をコーディングしていく。「Player.gd」スクリプトを開こう。\nまずは、プレイヤーが敵キャラクターに当たって、ダメージを受けた瞬間に HUD へ反映させるためには、シグナルが必要だ。残念ながら「Player」ルートノードのクラスである「KinematicBody2D」には、「Area2D」クラスの「body_entered(body)」のようなシグナルがない。そこで、ひとまず自分でシグナルを定義する。\nextends KinematicBody2D signal enemy_hit(damage) # 追加 # 以下省略 これでenemy_hitというシグナルが定義できた。(damage)というふうにシグナルに引数を定義しておくことで、シグナルを発信したときにこの引数の値を、接続先のメソッドの引数に渡すことができる。つまり、この引数damageに敵キャラクターから受けたダメージを入れてシグナルを発信し、シグナルの接続先メソッドへダメージの値を渡すことができるということだ。\n次に、先ほど追加した「HitBox」ノードのシグナルを接続する。「HitBox」ノードの「body_entered(body)」シグナルを「Player.gd」スクリプトに接続しよう。\nすると、「Player.gd」スクリプトに、_on_HitBox_body_enteredメソッドが追加されたはずだ。このメソッド内で、先に定義したenemy_hitシグナルを発信させる。具体的には以下のようにコードを更新しよう。\n# プレイヤーキャラクターに物理ボディが当たったら呼ばれるメソッド func _on_HitBox_body_entered(body): # 追加 # もし当たったのが敵キャラクターだったら if body.is_in_group(\u0026#34;Enemies\u0026#34;): # デバッグ用 print(\u0026#34;Enemy hit player. Damage is \u0026#34;, body.damage) # enemy_hit シグナルを発信する（敵キャラクターから受けるダメージの damage プロパティを引数に渡す） emit_signal(\u0026#34;enemy_hit\u0026#34;, body.damage) # AnimatedSprite の hit アニメーションを再生する sprite.play(\u0026#34;hit\u0026#34;) Enemy.gd さて上のスクリプトで先に登場している「Enemy」ノードのdamageプロパティだが、これはまだ定義していないので、さっそく「Enemy.gd」を開いて定義しよう。\nextends KinematicBody2D export var gravity: int export var speed: int export var damage: float # Added @ 追加 # 以下省略 値は何も入れずに、型だけ小数点を含む数値のfloatとして定義しておこう。exportキーワードを追加したので、「Enemy.tscn」を継承するそれぞれの敵キャラクターのシーンで、当たったときに受けるダメージの値をインスペクター上で設定する予定だ。\nところで、なぜdamageプロパティの型を整数のint型で定義しないのかというと、このdamageの値を「Game」ノードのfloat型で定義したhealthの値から減算することになるのだが、そのときに型が異なるとエラーになるからだ。ではなぜhealthプロパティもfloat型に定義したかというと、最終的にこの値を割り当てる先がfloat型の値をとる「HUD」シーンの「HealthBar」ノードの「Value」プロパティだからだ。\nプログラムで何らかの計算をさせるのに型を揃えるのは、プログラミング全般で共通のルールなので、この機会に覚えておこう。\nChameleon.gd ここで気をつけておきたい一つ目のポイントは、カメレオンだ。この敵キャラクターは舌を伸ばして攻撃してくる。この舌に当たるとプレイヤーはダメージを受けなければならないが、この舌の部分は「Chameleon」ルートノード（KinematicBody2Dクラス）直下の「CollisionShape2D」のコリジョン形状とは重なっておらず、当たっても物理ボディとは判定されない。この場合は、「Chameleon.gd」スクリプト側で「RayCast2D」ノードの衝突判定を利用して「Player」のenemy_hitシグナルを発動させる。では「Chameleon.gd」を開こう。\n更新は2箇所、ステータス管理用のプロパティを一つ追加することと、スクリプトの一番最後で定義しているattackメソッドを更新することだ。attackメソッド内の最後に追加したifブロック丸ごと追加している（「# 追加」とコメントしている行が更新箇所だ）。\nextends \u0026#34;res://Enemies/Enemy.gd\u0026#34; # 舌の当たり判定が有効かどうか（初期値は有効） var tongue_hit_enabled = true # 追加 # 中略 func attack(): sprite.play(\u0026#34;attack\u0026#34;) if sprite.frame == 6 or sprite.frame == 7: if raycast.is_colliding() and raycast.get_collider().name == \u0026#34;Player\u0026#34;: if position.distance_to(raycast.get_collision_point()) \u0026lt; 50: # 舌の当たり判定が有効な場合は if tongue_hit_enabled: # 追加 # デバッグ用 print(\u0026#34;Chameleon\u0026#39;s tongue hits player.\u0026#34;) # Player の enemy_hit シグナルを damage プロパティ付きで発信 raycast.get_collider().emit_signal(\u0026#34;enemy_hit\u0026#34;, damage) # 追加 # 舌の当たり判定を無効にする tongue_hit_enabled = false # 追加 # 0.83秒（attack アニメーションの約1回分の長さ）待つ yield(get_tree().create_timer(0.83), \u0026#34;timeout\u0026#34;) # 追加 # 舌の当たり判定を有効にする tongue_hit_enabled = true # 追加 今までのコードのままだと、_physics_processメソッド内でのattackメソッドが 60 FPS に合わせて 1 秒間に 60 回呼ばれる。つまり、1秒間に 60 回のペースで舌への当たり判定が発生し、プレイヤーのヘルスは一瞬で 0 になってしまう。\nこれを避けるために、舌の当たり判定のステータス管理用にtongue_hit_enabledというステータスを用意した。初期値はtrueで、その時は当たり判定が有効だ。この状態で、カメレオンの舌が一度プレイヤーキャラクターに当たると、「Chameleon.gd」スクリプト側から「Player」のenemy_hitシグナルが発信される。その後、直ちに舌の当たり判定をfalseにする。さらにそこから、カメレオンの「attack」アニメーション一周分のおおよその所要時間である 0.83 秒待機したら、また舌の当たり判定を有効にする。これにより、1回の舌を伸ばすアニメーションにつき1回しかダメージを受けない仕組みを作った。\nSeed.gd そして、もう一つ忘れてはいけないのが、プラントという敵キャラクターは種を飛ばしてくる。この種のシーンである「Seed.tscn」は「Enemy.tscn」を継承していないので、別途damageプロパティを定義しておく必要がある。また、「Enemies」グループに属しておらず、ルートノードが「Area2D」クラスであり物理ボディでもないので、ここで諸々の修正を行っておこう。\nでは「Seed.tscn」を開いてほしい。まずは「Seed」ノードを「Enemies」グループに追加しよう。\nシーンドックで「Seed」ルートノードを右クリックし、「型を変更」を選択する。そして「StaticBody2D」を選択しよう。これで種も物理ボディになった。\nしかし、スクリプトの方はまだ「Area2D」を継承した形になっているので、修正する。「Seed.gd」スクリプトを開き、以下のように更新しよう。ここでついでにdamageプロパティも定義しておく。\n#extends Area2D # 削除 extends StaticBody2D # 追加 export var speed = 150 export var damage: float = 32 # 追加 「StaticBody2D」ノードにはbody_entered(body)シグナルがないので、_on_Seed_body_enteredメソッドはひとまず削除しておこう。\n#func _on_Seed_body_entered(body): # 削除 #\tif body.name == \u0026#34;Player\u0026#34;: #\tprint(\u0026#34;Seed hits player.\u0026#34;) #\tqueue_free() しかし、このままでは種がプレイヤーキャラクターに当たっても消えず、そのまま物理ボディ同士の衝突により、押し続けてくる。そこで、子ノードとして改めて「Area2D」ノードを加え、物理ボディとの接触により種が解放されるようにする。\nまずはシーンドックで「Seed」ルートノードに「Area2D」ノードを追加。さらに「Area2D」ノードに「CollisionShape2D」ノードを追加する。\n「CollisionShape2D」のコリジョン形状を調整する。「Shape」プロパティに「新規 CircleShape2D」を割り当てる。2Dワークスペースで、「Seed」ルートノード直下の「CollisionShape2D」の形状より 1 px 大きめに設定した。「Radius」プロパティは 5 だ。\n「Area2D」ノードを選択した状態で、ノードドック＞「シグナル」タブから「body_entered」シグナルを「Seed.gd」スクリプトに接続する。\nこれで「Seed.gd」スクリプトに_on_Area2D_body_enteredメソッドが追加されたので、メソッドの中身を以下のように記述しよう。\nfunc _on_Area2D_body_entered(body): # 追加 if body.name != \u0026#34;Seed\u0026#34;: print(body.name, \u0026#34; hits seed.\u0026#34;) queue_free() if body.name != \u0026quot;Seed\u0026quot;:の!=は「一致しない」という意味だ。このif構文がなければ、種が自身の物理ボディとの衝突により、インスタンスが生成された瞬間にすぐ解放される事になる。\nこれで、種が物理ボディ（主にプレイヤーキャラクター）に当たったら消える仕組みが復元できた。\nGame.gd 最後に「Game.gd」スクリプトに戻って、必要な更新をしておこう。「# 追加」のコメントがある部分が更新箇所だ。\n# ここまで省略 func add_level(): level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) add_child(level) # Player ノードを参照するプロパティを定義 player = level.get_node(\u0026#34;Player\u0026#34;) # 追加 # enemy_hit シグナルを _on_Player_enemy_hit メソッドにコードで接続 player.connect(\u0026#34;enemy_hit\u0026#34;, self, \u0026#34;_on_Player_enemy_hit\u0026#34;) # 追加 func change_level(): #メソッド内省略 func _on_Player_enemy_hit(damage): # 追加 health -= damage hud.update_health(health) add_levelメソッドはゲーム開始時やレベルクリア時に次のレベルシーンのインスタンスを「Game」ルートノードに追加するためのメソッドだ。このメソッドが実行されるまでは「Game」シーンツリーに「Player」ノードは存在しない。そのため、このadd_levelメソッドで「Level_」シーンのインスタンスが「Game」シーンに追加されてから、「Player」ノードの自作のシグナルenemy_hitを、その後に新たに定義している_on_Player_enemy_hitメソッドに接続している。このようにconnectメソッドを使えばコードでシグナルを接続できる。\nそして新たに定義した_on_Player_enemy_hitメソッドだが、これは通常ノードドックからのシグナル接続時に生成されるメソッドと同じだと思っていただければわかりやすいだろう。メソッド名もそれっぽくしたが、実際には何でも良い。enemy_hitシグナル発信時にこのメソッドが呼ばれる。引数のdamageにはシグナル発信メソッドemit_signalの引数damageの値が入る。処理として、まずhealthプロパティの値から引数damageが減算される。そのあと「HUD」ノードのupdate_healthメソッドが呼ばれ、引数には更新されたhealthプロパティの値が渡される。update_healthメソッドが実行されると「HUD」シーンの「HealthBar」が更新される（つまり緑色のバーが減る）。\nそれぞれの敵キャラクターのダメージを設定する それぞれの敵キャラクターの.tscnファイルを開き、インスペクターで「Damege」プロパティの値を設定しよう。\nあなたのお好みの数値にしていただいて構わない。以下はサンプルとしてこのチュートリアル用に設定した値だ。\nMushroom - Damage: 8 Bunny - Damage: 32 Chameleon - Damage: 40 Plant - Damage: 24 Seed - Damage: 32 ここまでできたら、HUD のヘルスバーが正しく変動するか、一度プロジェクトを実行してみよう。\n敵キャラクター自体への衝突、カメレオンの舌との衝突、およびプラントの種との衝突でダメージの処理がうまくいっているようなので、良しとしよう。次はスコアの処理だ。ここらで一度、小休憩を入れようじゃないか。\nHUD に獲得したポイントの合計スコアを反映させる 以前 Part 6 のチュートリアルで「Item.gd」スクリプトにexportキーワード付きでpointというプロパティを用意し、インスペクター上でそれぞれのアイテム（フルーツ）のポイントを設定したことは覚えているだろうか。\nサイト内記事リンク： Godot で作るプラットフォーマー Part 6：アイテムを作ろう！ 今まではただプレイヤーキャラクターがアイテムに当たったらそのポイントがふわりと画面上に出て消えるだけだったが、今回は以下の流れを作っていく。\n「Player」ノードが「Item」ノードに当たる 「Player」ノードのitem_hitシグナルが発信される 発信されたitem_hitシグナルの引数にpointプロパティの値が渡される item_hitシグナルが接続されている「Game」ノードの_on_Player_item_hitメソッドが呼ばれる _on_Player_item_hitメソッドにより、「Game」ノードのscoreプロパティの値にpointの値が加算される 更新されたscoreプロパティの値が「HUD」ノードのupdate_scoreメソッドの引数として渡される update_scoreメソッドにより、「HUD」ノードの子である「ScoreText」ノードの「Text」プロパティの値に最新のscoreの値が反映される スクリプトでプレイヤーキャラクターがアイテムに当たった時の制御をする Item.gd まずは「Item.gd」スクリプト側で、プレイヤーキャラクターがアイテムに当たった時に「Player」ノードのitem_hitシグナルを発信する仕組みを実装する。\n「Item.gd」スクリプトを開いたら、以下のように編集しよう。\nfunc _on_Item_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Player hit Item\u0026#34;) hit(body) # 引数に body を追加 func hit(player): # 新たに引数 player を定義 print(\u0026#34;Got \u0026#34;, point, \u0026#34; point.\u0026#34;) player.emit_signal(\u0026#34;item_hit\u0026#34;, point) # 追加、Player の item_hit シグナルを発信 anim_player.play(\u0026#34;hit\u0026#34;) yield(anim_player, \u0026#34;animation_finished\u0026#34;) queue_free() コード上の表記と順番が逆になるが、先にhitメソッドを更新した。引数playerを追加し、その引数に「Player」ノードが代入されるのを前提に、player.emit_signalメソッドでitem_hitシグナルを発信するように更新した。\n次に、_on_Item_body_enteredメソッドの最後でhitメソッドが呼ばれるが、その引数には「Player」ノードとイコールであるbodyを代入している。\n実は、hitメソッドはアイテムボックスの方のスクリプトでも呼ばれている。「ItemBox.gd」スクリプトを確認してみよう。編集したのは、アイテムボックス下部をプレイヤーキャラクターが小突いた時にシグナルで呼ばれる_on_Area2D_body_enteredというメソッドだ。\nfunc _on_Area2D_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;ItemBox \u0026gt; Area2D entered by player\u0026#34;) if timer_unused: timer.start() timer_unused = false sprite.play(\u0026#34;hit\u0026#34;) yield(sprite, \u0026#34;animation_finished\u0026#34;) sprite.play(\u0026#34;idle\u0026#34;) if items.empty(): print(\u0026#34;ItemBox is empty.\u0026#34;) sprite.visible = false var broken_box = broken_box_tscn.instance() parent.add_child(broken_box) broken_box.position = position queue_free() print(self.name, \u0026#34; removed.\u0026#34;) else: print(\u0026#34;ItemBox is not empty.\u0026#34;) var item = items.pop_front().instance() add_child(item) item.position.y -= 12 item.hit(body) # 引数に body を追加 プレイヤーがアイテムボックス下部の「Area2D」のコリジョン形状に当たって、その時アイテムボックスが空っぽではなかった場合（一番最後のelseブロック）、最後に「Item」ノードのhitメソッドが呼ばれる。さっきちょうど更新したメソッドだ。ここでもbodyイコール「Player」ノードなので、hitメソッドの引数playerにbodyを代入して実行している。これで、アイテムボックスからアイテムが飛び出すたびに「Player」ノードのitem_hitシグナルが発信するようになった。\nGame.gd 次に「Game.gd」スクリプトを開いて編集しよう。\nadd_levelメソッドの編集から始める。\nfunc add_level(): level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) add_child(level) player = level.get_node(\u0026#34;Player\u0026#34;) # さっき追加した player.connect(\u0026#34;enemy_hit\u0026#34;, self, \u0026#34;_on_Player_enemy_hit\u0026#34;) # さっき追加した player.connect(\u0026#34;item_hit\u0026#34;, self, \u0026#34;_on_Player_item_hit\u0026#34;) # 追加 「Player」ノードのitem_hitシグナルを_on_Player_item_hitというメソッドに接続する。このメソッドはこの後定義する。\nfunc _on_Player_item_hit(point): # 追加 score += point hud.update_score(score) _on_Player_item_hitを定義した。このメソッドの引数にはitem_hitシグナルの引数pointの値が入る。scoreからそのpointが減算されて、更新されたscoreを引数として「HUD」ノードのupdate_scoreメソッドが呼ばれる。これで HUD のスコア表示に最新のscoreプロパティの値が反映する。\nではプロジェクトを実行して、アイテムに当たった時の HUD の変化を確認してみよう。\n（マッシュルームを踏んだ時にダメージをくらっているが）直接アイテムに当たった時も、アイテムボックスでアイテムが飛び出した時も、両方ともスコアに獲得したポイントが加算されたので、想定通りの挙動と言って良いだろう。\nHUD に現在のレベル数を反映させる HUD のレベル数の変化をスクリプトで制御していこう。と言っても、このセクションが一番簡単だから安心してほしい。「Game.gd」スクリプトを開いて、change_levelメソッドを以下のように編集しよう。「# 追加」とコメントしている行だ。\nfunc change_level(): print(\u0026#34;change_level() called.\u0026#34;) if current_level \u0026lt; final_level: print(\u0026#34;change to next level.\u0026#34;) level.queue_free() current_level += 1 hud.update_level(current_level) # 追加 add_level() else: print(\u0026#34;Game Clear! Congrats!\u0026#34;) get_tree().quit() 「HUD」ノードのupdate_levelメソッドは事前に定義済みなので、これでレベル1をクリアしてレベル2に遷移するときに HUD の Level の表記が更新されるはずだ。\nでは、実際にプロジェクトを実行して確認してみよう。\nきちんとレベルが 1 から 2 に切り替わったのが確認できた。問題ないだろう。以上で今回のチュートリアルの HUD 実装作業は完了だ。\nPart 8 で編集したスクリプトのコード 最後に今回の Part 8 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nHUD.gd の全コード extends Control var score = 0 onready var health_bar = $HUDHBox/HealthHBox/HealthBar onready var score_text = $HUDHBox/ScoreText onready var level_texture = $HUDHBox/LevelHBox/LevelTexture func _ready(): health_bar.value = 100 func update_health(health): health_bar.value = health func update_score(score): score_text.text = \u0026#34;score \u0026#34; + str(score) func update_level(level): var str_level if level \u0026lt; 10: str_level = \u0026#34;0\u0026#34; + str(level) elif level \u0026lt;= 51: str_level = str(level) var file = load(\u0026#34;res://Assets/Menu/Levels/\u0026#34; + str_level + \u0026#34;.png\u0026#34;) level_texture.texture = file Game.gd の全コード extends Node var health: float = 100.0 # 追加 var score: int = 0 # 追加 var level: Node2D var player: KinematicBody2D export var current_level = 1 export var final_level = 2 onready var hud = $HUDLayer/HUD # 追加 func _ready(): add_level() hud.update_health(health) # 追加 hud.update_score(score) # 追加 hud.update_level(current_level) # 追加 func add_level(): level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) add_child(level) player = level.get_node(\u0026#34;Player\u0026#34;) # 追加 player.connect(\u0026#34;enemy_hit\u0026#34;, self, \u0026#34;_on_Player_enemy_hit\u0026#34;) # 追加 player.connect(\u0026#34;item_hit\u0026#34;, self, \u0026#34;_on_Player_item_hit\u0026#34;) # 追加 func change_level(): print(\u0026#34;change_level() called.\u0026#34;) if current_level \u0026lt; final_level: print(\u0026#34;change to next level.\u0026#34;) level.queue_free() current_level += 1 hud.update_level(current_level) # 追加 add_level() else: print(\u0026#34;Game Clear! Congrats!\u0026#34;) get_tree().quit() func _on_Player_enemy_hit(damage): # 追加 print(\u0026#34;Health updated: \u0026#34;, health) health -= damage hud.update_health(health) func _on_Player_item_hit(point): # 追加 score += point hud.update_score(score) Player.gd の全コード extends KinematicBody2D # Created @ Part 1 signal enemy_hit(damage) # 追加 signal item_hit(point) # 追加 export var acceleration = 256 export var max_speed = 64 export var max_dash_speed = 200 export var friction = 0.1 export var gravity = 512 export var jump_force = 224 export var air_resistance = 0.02 var velocity = Vector2() onready var sprite = $AnimatedSprite onready var anim_player = $AnimationPlayer # Added @ Part 7 func _ready(): # Added @ Part 7 sprite.position = Vector2(0, 0) sprite.scale = Vector2(1, 1) sprite.modulate = Color(1, 1, 1, 1) func _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.flip_h = x_input \u0026lt; 0 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force else: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 velocity = move_and_slide(velocity, Vector2.UP) # Added @ Part 3 if position.x \u0026lt; 16: position.x = 16 func _on_HitBox_body_entered(body): # 追加 if body.is_in_group(\u0026#34;Enemies\u0026#34;): print(\u0026#34;Enemy hit player. Damage is \u0026#34;, body.damage) emit_signal(\u0026#34;enemy_hit\u0026#34;, body.damage) sprite.play(\u0026#34;hit\u0026#34;) Enemy.gd の全コード extends KinematicBody2D # Added @ Part 4 export var gravity: int export var speed: int export var damage: float # 追加 var velocity = Vector2() onready var sprite = $AnimatedSprite func _ready(): set_physics_process(false) func _on_HitBox_body_entered(body): if body.is_in_group(\u0026#34;Players\u0026#34;): print(\u0026#34;Player entered in \u0026#34;, self.name) sprite.play(\u0026#34;hit\u0026#34;) yield(sprite, \u0026#34;animation_finished\u0026#34;) queue_free() print(self.name, \u0026#34; died\u0026#34;) func _on_VisibilityEnabler2D_screen_entered(): set_physics_process(true) func _on_VisibilityEnabler2D_screen_exited(): set_physics_process(false) Seed.gd の全コード extends StaticBody2D # Added @ Part 5 / Modified @ Part 8 export var speed = 150 export var damage = 32 # 追加 func _physics_process(delta): position.x -= speed * delta #func _on_Seed_body_entered(body): # 削除 #\tif body.name == \u0026#34;Player\u0026#34;: #\tprint(\u0026#34;Seed hits player.\u0026#34;) #\tqueue_free() func _on_VisibilityNotifier2D_viewport_exited(viewport): print(\u0026#34;viewport_exited method called\u0026#34;) queue_free() func _on_Area2D_body_entered(body): # 追加 if body.name != \u0026#34;Seed\u0026#34;: print(body.name, \u0026#34; hits seed.\u0026#34;) queue_free() Chameleon.gd の全コード extends \u0026#34;res://Enemies/Enemy.gd\u0026#34; # Added @ Part 5 var tongue_hit_enabled = true # 追加 onready var raycast = $RayCast2D func _ready(): sprite.play(\u0026#34;idle\u0026#34;) func _physics_process(delta): if raycast.is_colliding(): if raycast.get_collider().name == \u0026#34;Player\u0026#34;: if position.distance_to(raycast.get_collision_point()) \u0026gt; 80: run() else: attack() velocity.x = 0 else: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = 0 velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) func run(): sprite.play(\u0026#34;run\u0026#34;) if is_on_wall(): speed *= -1 sprite.flip_h = !sprite.flip_h sprite.position.x *= -1 raycast.cast_to.x *= -1 velocity.x = -speed func attack(): sprite.play(\u0026#34;attack\u0026#34;) if sprite.frame == 6 or sprite.frame == 7: if raycast.is_colliding() and raycast.get_collider().name == \u0026#34;Player\u0026#34;: if position.distance_to(raycast.get_collision_point()) \u0026lt; 50: print(\u0026#34;Chameleon\u0026#39;s tongue hits player.\u0026#34;) if tongue_hit_enabled: # 追加 raycast.get_collider().emit_signal(\u0026#34;enemy_hit\u0026#34;, damage) tongue_hit_enabled = false yield(get_tree().create_timer(0.83), \u0026#34;timeout\u0026#34;) tongue_hit_enabled = true Item.gd の全コード extends Area2D # Added @ Part 6 export var point = 100 onready var sprite = $AnimatedSprite onready var label = $Label onready var anim_player = $AnimationPlayer func _ready(): sprite.modulate = Color(1, 1, 1, 1) sprite.position = Vector2.ZERO sprite.scale = Vector2.ONE label.modulate = Color(1, 1, 1, 0) label.rect_position = Vector2(-32, -20) label.text = str(point) func _on_Item_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Player hit Item\u0026#34;) hit(body) # 変更 func hit(body): # 変更 print(\u0026#34;Got \u0026#34;, point, \u0026#34; point.\u0026#34;) body.emit_signal(\u0026#34;item_hit\u0026#34;, point) # 追加 anim_player.play(\u0026#34;hit\u0026#34;) yield(anim_player, \u0026#34;animation_finished\u0026#34;) queue_free() ItemBox.gd の全コード extends StaticBody2D # Added @ Part 6 var timer_unused = true onready var sprite = $AnimatedSprite onready var timer = $Timer onready var parent = get_parent() onready var broken_box_tscn = preload(\u0026#34;res://Items/BrokenBox.tscn\u0026#34;) onready var items = [ preload(\u0026#34;res://Items/Apple.tscn\u0026#34;), preload(\u0026#34;res://Items/Bananas.tscn\u0026#34;), preload(\u0026#34;res://Items/Cherries.tscn\u0026#34;), preload(\u0026#34;res://Items/Kiwi.tscn\u0026#34;), preload(\u0026#34;res://Items/Melon.tscn\u0026#34;), preload(\u0026#34;res://Items/Orange.tscn\u0026#34;), preload(\u0026#34;res://Items/Pineapple.tscn\u0026#34;), preload(\u0026#34;res://Items/Strawberry.tscn\u0026#34;), ] func _ready(): sprite.play(\u0026#34;idle\u0026#34;) func _on_Timer_timeout(): print(\u0026#34;ItemBox \u0026gt; Timer timeout\u0026#34;) if not items.empty(): items.clear() print(\u0026#34;items size: \u0026#34;, items.size()) func _on_Area2D_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;ItemBox \u0026gt; Area2D entered by player\u0026#34;) if timer_unused: timer.start() timer_unused = false sprite.play(\u0026#34;hit\u0026#34;) yield(sprite, \u0026#34;animation_finished\u0026#34;) sprite.play(\u0026#34;idle\u0026#34;) if items.empty(): print(\u0026#34;ItemBox is empty.\u0026#34;) sprite.visible = false var broken_box = broken_box_tscn.instance() parent.add_child(broken_box) broken_box.position = position queue_free() print(self.name, \u0026#34; removed.\u0026#34;) else: print(\u0026#34;ItemBox is not empty.\u0026#34;) var item = items.pop_front().instance() add_child(item) item.position.y -= 12 item.hit(body) # 変更 おわりに 以上で Part 8 は完了だ。今回は HUD を実装した。HUD の見た目を作るまではそれなりにサクサクと進められたと思う。しかし、複数のスクリプトを跨いだデータの受け渡しは、なかなか複雑でややこしいと感じる人は多いのではないだろうか。今回のチュートリアルでもお伝えしたように、先に図や絵を描いて頭の中を整理すると、その後のコーディングもよりスムーズに進められることが多い。今後もしあなた自身のオリジナルプロジェクトを作る場面で役立ちそうであれば、ぜひお試しいただければと思う。急がば回れ、である。\nさて、次回のチュートリアルでは、ゲームオーバーの仕組みを実装していく。プレイヤーキャラクターのヘルスが 0 になるか、画面下に落下したらゲームオーバー画面が表示されるという仕組みを実装していく。\nでは次回もお楽しみに。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_8/","summary":"第8回目の今回は、HUD を実装していく。 HUD というのは、ヘッズアップディスプレイ（Heads Up Display）の略で、ゲームプレイ中に常に画面上に表示されている UI の一つだ。例えば、プレイヤーの残りのライ","title":"Godot で作るプラットフォーマー Part 8：HUD を追加しよう！"},{"content":"第9回目の今回は、ゲームオーバーの仕組みを実装していく。\n世に出ているプラットフォーマーゲームにはほぼ確実にゲームオーバーの仕組みが存在する。ゲームオーバーになるかもしれない緊張感がなければプラットフォーマーの面白さは激減する。だから、ゲームオーバーの実装は必要不可欠だ。さらに、ゲームオーバーの条件設定もまたゲームの難易度を左右するため非常に重要だ。\n一般的にゲームオーバーの条件としては、敵や敵の攻撃に一回でも当たるか、当たってヘルス（ライフ）が 0 になるか、画面下部に落下した時などにゲームオーバーになることが多い。\n今回のチュートリアルでは、ゲームーオーバーの仕組みとして以下の作業を行う。\nゲームオーバー画面のシーンを作る。 ゲームオーバー画面から再度ゲーム開始またはゲーム終了する仕組みを作る。 プレイヤーキャラクターが敵キャラクターに当たってヘルスが 0 になった時のゲームオーバー画面への遷移を実装する。 プレイヤーキャラクターが地面のないところから画面外へ落下した時のゲームオーバー画面への遷移を実装する。 Memo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー GameOver シーンを作る 新規シーンを作成して必要なノードを追加する それではまず以下の手順で「GameOver」シーンを新規作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」で「ユーザーインターフェース」を選択する。 「Control」ルートノードが追加されたら、名前を「GameOver」に変更する。 「GameOver」ルートノードに「TextureRect」ノードを追加する。 「TextureRect」ノードに「VBoxContainer」ノードを追加する。 「VBoxContainer」ノードに「Label」ノードを追加し、名前を「GameOverLabel」に変更する。 「VBoxContainer」ノードに「HBoxContainer」ノードを追加し、名前を「ButtonsHBox」に変更する。 「ButtonsHBox」ノードに「VBoxContainer」ノードを2つ追加し、名前をそれぞれ「RestartVBox」、および「QuitVBox」に変更する。 「RestartVBox」ノードに「TextureButton」ノードを追加し、名前を「RestartButton」に変更する。 同じく「RestartVBox」ノードに「Label」ノードを追加し、名前を「RestartLabel」に変更する。 「QuitVBox」ノードに「TextureButton」ノードを追加し、名前を「QuitButton」に変更する。 同じく「QuitVBox」ノードに「Label」ノードを追加し、名前を「QuitLabel」に変更する。 「GameOver」ルートノードに「ColorRect」ノードを追加する。 さらに「GameOver」ルートノードに「ConfirmationDialog」ノードを追加する。 ひとまずここまでで「GameOver」のシーンツリーは以下のようになった。\nシーンドックを見ると「ConfirmationDialog」ノードの右側に警告マークがついている。これをクリックすると、以下のダイアログが表示される。（日本語のローカライズ時にタイポがあった様子だが）このノードは基本的に非表示になるようだ。\nシーンドック上でこのノードの右側にある目のアイコンをクリックして非表示に切り替えれば、警告は消えるが、2Dワークスペース上にこのノードは表示されなくなる。お好みで表示/非表示を切り替えてほしい。\nさらに「Control」系ではないクラスのノードを2つ追加する。\n「GameOver」ルートノードに「Line2D」ノードを追加する。 「Line2D」ノードに「AnimationPlayer」ノードを追加する。 これでシーンツリーは以下のようになった。\nここまでできたらシーンを保存しておこう。とその前に、「GameOver」シーンは UI なので、このタイミングでファイルシステム上のフォルダ構成を編集しておく。「res://UI/」に「HUD」フォルダを作成し、以前作成した以下の HUD 関連ファイルをそこへ移動しよう。\nres://UI/HUD/HUD.gd res://UI/HUD/HUD.tscn さらに「res://UI/」に「GameOver」フォルダを作成し、今作ったシーンのファイルパスが「res://UI/GameOver/GameOver.tscn」となるように「GameOver.tscn」という名前で保存しよう。\n各ノードのプロパティを編集する では「GameOver」シーンのそれぞれのノードのプロパティを編集していこう。\nGameOver この「GameOver」シーンで、ルートノードは単なる子ノードの入れ物的役割にしているが、プロパティを一つ更新しておく。これは非常に重要だ。\nシーンドックで「GameOver」ルートノードを選択し、インスペクターで「Pause Mode」プロパティを「Process」に変更する\nこの設定の意味を説明しておこう。\nゲームオーバー画面を表示している間、メインのゲームは一時停止状態にしたい。その場合、「Game」ノードの「Paused」というプロパティを true にすることで、ゲームは一時停止させられる。\nしかし、基本的に全てのノードの「Pause Mode」プロパティは「Inherit」（継承という意味）の設定になっているので、親ノードの「Pause Mode」の値を継承する。つまり、ゲームを一時停止させようと思って、シーンツリーの最上位にある「Game」ノードの「Paused」プロパティを true にすると、ゲームオーバー画面を含むゲームの全てが停止してしまう。\nそこで、「GameOver」ブランチのみ機能させたい場合に、このノードの「Pause Mode」プロパティを「Process」に変更する。そうすると、親ノードの「Pause Mode」は継承されず、裏でゲームが停止中でもゲームオーバー画面だけは動作し操作可能となるのだ。\n公式オンラインドキュメント： ゲームの一時停止 TextureRect このノードはゲームオーバー画面の背景テクスチャを設定するためのものだ。\n「TextureRect」ノードを選択したら、2Dワークスペースのツールバー＞「レイアウト」にて「Rect全面」を選択する。 インスペクターの「Texture」プロパティの [空] 目掛けて、ファイルシステムドックから「res://Assets/Background/Gray.png」をドラッグ\u0026amp;ドロップする。 「Stretch Mode」プロパティを「Tile」に設定する。 以上で、グレーの菱形模様の背景が設定できた。\n公式オンラインドキュメント： TextureRect VBoxContainer このノードは自身の子ノードを垂直方向に並べるコンテナだ。子ノードを全て中央揃えにしたいので、設定は以下のみ。\nインスペクターで「Alignment」プロパティを「Center」にする。 公式オンラインドキュメント： VBoxContainer GameOverLabel このノードは「Game Over」という文字列を画面上に大きく表示するために使用する。\nインスペクターにて、「Text」プロパティの値として「game over」を入力する。 「Align」プロパティを「Center」にする。 「Uppercase」プロパティをオンにする。 「Theme Overrides」＞「Fonts」＞「Font」プロパティに「新規 DynamicFont」を割り当てる。 「Theme Overrides」＞「Fonts」＞「Font」プロパティの追加したフォントをクリックし、「Font」＞「Font Data」プロパティめがけて、ファイルシステムドックからフォントファイル「res://fonts/connection_ii/ConnectionII.tres」をドラッグ\u0026amp;ドロップする。 「Theme Overrides」＞「Fonts」＞「Font」プロパティの追加したフォントをクリックし、「Settings」＞「Size」プロパティを 64 にする。\n「Visibility」＞「Modulate」プロパティで色を # e44a4a （赤）に変更する。\nこれで、「Game Over」の赤い文字が中央揃えで大きく表示された。フォントも「ConnectionII.tres」により、レトロ感を演出できた。\n公式オンラインドキュメント： Label ButtonsHBox このノードは、子ノードである「RestartVBox」と「QuitVBox」を水平方向に格納するコンテナだ。それら2つの子ノードもまたコンテナだが、いずれも主な要素はボタンである。それらのボタンを2つ横並びに表示するためにこのノードを利用する。\nインスペクターで「Alignment」プロパティを「Center」にする。 「Theme Overrides」＞「Constants」＞「Separation」プロパティの値を 48 にする。 これでこのノードが中央揃えで配置され、格納する子ノードの間隔が 48 px で横並びになる。\n公式オンラインドキュメント： HBoxContainer RestartVBox このノードは、ゲームオーバーになった時に、ゲームをはじめから再開するための「Restart」ボタンとその説明用のラベルを格納するためのものだ。それらの子ノードは中央揃えにして、ボタンアイコンが上、説明用ラベルが下になるように並べる。VBox のため子ノードは自動的に縦並びに配置される。プロパティの編集は以下の1つだけだ。\nインスペクターで「Alignment」プロパティを「Center」にする。 公式オンラインドキュメント： VBoxContainer RestartButton このノードは「Restart」ボタンのアイコンを作るために使用する。「TextureButton」クラスは、ボタン機能を有しており、かつ見た目の設定としてテクスチャ画像ファイルを適用できる。\nインスペクターで「Expand」プロパティをオンにする。 「Stretch Mode」プロパティを「Keep Aspect Center」にする。 「Textures」＞「Normal」プロパティに、ファイルシステムドックから「res://Assets/Menu/Buttons/Restart.png」をドラッグ\u0026amp;ドロップする。\nなお、ボタンを押した時のテクスチャを設定する「Pressed」、カーソルがボタンに重なった時のテクスチャ「Hover」など細かく設定可能だが、今回はアセットの種類の関係で、「Normal」のみ設定する。 「Rect」＞「Min Size」プロパティを (56, 56) に設定する。 現在、「Restart」ボタンが水平方向で中央に配置されているが、後ほど「Quit」ボタンのテクスチャを設定すれば、2つのボタンの中間が中央に来るように自動的に調整されるので、現時点ではこのままで良い。\n公式オンラインドキュメント： TextureButton RestartLabel このノードは単なるボタンアイコンの説明だ。アイコンだけだと何のボタンかわかりにくいかもしれないので、ボタンの下に小さめの文字で「RESTART」と表示するために使用する。\nインスペクターで「Text」プロパティの値として「restart」と入力する。 「Align」プロパティを「Center」にする。 「Uppercase」プロパティをオンにする。 「Theme Overrides」＞「Fonts」＞「Font」プロパティに「新規 DynamicFont」を割り当てる。 「Theme Overrides」＞「Fonts」＞「Font」プロパティの追加したフォントをクリックし、「Font」＞「Font Data」プロパティめがけて、ファイルシステムドックからフォントファイル「res://fonts/poco/Poco.tres」をドラッグ\u0026amp;ドロップする。 「Font」＞「Font Data」プロパティの矢印「v」をクリックし「ユニーク化」する。\n「Visibility」＞「Modulate」プロパティで色を # 000000 （黒）に変更する。 公式オンラインドキュメント： Label QuitVBox このノードは、ゲームオーバーになった時に、ゲームを完全に終了するための「Quit」ボタンと説明用のラベルを格納するためのものだ。「RestartVBox」同様だが、それらの子ノードは中央揃えにして、ボタンアイコンが上、説明用ラベルが下になるように並べる。VBox なので、子ノードは自動的に縦並びに配置される。プロパティの編集は以下の1つだけだ。\nインスペクターで「Alignment」プロパティを「Center」にする。 公式オンラインドキュメント： VBoxContainer QuitButton このノードは「RestartButton」ノードと同様に「Quit」ボタンのアイコンを作るために使用する。\nインスペクターで「Expand」プロパティをオンにする。 「Stretch Mode」プロパティを「Keep Aspect Center」にする。 「Textures」＞「Normal」プロパティに、ファイルシステムドックから「res://Assets/Menu/Buttons/Close.png」をドラッグ\u0026amp;ドロップする。このノードもテクスチャは「Normal」プロパティのみ設定する。 「Rect」＞「Min Size」プロパティを (56, 56) に設定する。 「Quit」ボタンの垂直方向の位置が「Restart」ボタンより低いが、この後「QuitLabel」ノードの設定をすれば同じ高さになるので、今はこのままで良い。\n公式オンラインドキュメント： TextureButton QuitLabel このノードは、「RestartLabel」ノード同様、単なるボタンアイコンの説明だ。\nインスペクターで「Text」プロパティの値として「quit」と入力する。 「Align」プロパティを「Center」にする。 「Uppercase」プロパティをオンにする。 「Theme Overrides」＞「Fonts」＞「Font」プロパティに「新規 DynamicFont」を割り当てる。 「Theme Overrides」＞「Fonts」＞「Font」プロパティの追加したフォントをクリックし、「Font」＞「Font Data」プロパティめがけて、ファイルシステムドックからフォントファイル「res://fonts/poco/Poco.tres」をドラッグ\u0026amp;ドロップする。 「Font」＞「Font Data」プロパティの矢印「v」をクリックし「ユニーク化」する。\n「Visibility」＞「Modulate」プロパティで色を # 000000 （黒）に変更する。 公式オンラインドキュメント： Label ColorRect この後「Restart」または「Quit」のボタンを押した時にダイアログが表示されるようにするのだが、ダイアログに注目してもらうために、その時だけダイアログの後ろにあるゲームオーバー画面を暗くしたい。そこで、この「ColorRect」ノードで半透明の黒いスクリーンを作り、ゲームオーバー画面に重ねることで、後ろのゲームオーバー画面が暗くなったように見せる。\n2Dワークスペースのツールバー＞「レイアウト」＞「Rect全面」を選択する。 インスペクターから「Color」プロパティで色を # a0000000 （R:0, G:0, B:0, A: 160）に設定する。\nこのノードは、デフォルトでは非表示にしておき、ボタンを押した時だけ表示したいので、ひとまずシーンドック上で目のアイコンをクリックして非表示にしておく。\n公式オンラインドキュメント： ColorRect ConfirmationDialog Confirmation とは日本語で確認という意味だ。このノードはプレイヤーに対してダイアログで確認のメッセージを表示し、それに対して OK / Cancel のボタンを選択してもらうために使用する。「Restart」ボタンも「Quit」ボタンも、誤って押してしまった場合を考慮して、ボタンを押したら、本当にそれで良いのかプレイヤーに確認するダイアログが表示されるようにする。\nインスペクターで「Dialog」＞「Text」プロパティには何も入れずに置いておく。後ほど、スクリプトでどっちのボタンを押したかによって、このプロパティの値を切り替えるようにする。 「Dialog」＞「Hide On OK」プロパティはオフにする。ダイアログ上の「OK」ボタンをクリックした時の挙動をスクリプトで制御したいのでここはオフにする必要がある。 「Window Title」には「Confirmation」と入力する。これは単にダイアログ上部のタイトルだ。 「Popup」＞「Exclusive」プロパティはオフにする。これがオンだとダイアログの外をクリックすればキャンセル扱いになって便利ではある。しかし残念ながら、ダイアログのすぐ下あたりに「Restart」と「Quit」のボタンがあるため、ダイアログをキャンセルしようと思って外側をクリックしたつもりが、ボタンの上をクリックしてしまい、すぐさまダイアログが再表示されるという挙動になってしまう。ダイアログのサイズを大きくして背後のボタンを隠しても良いが、少し見た目に違和感があるため、今回はこのプロパティをオフにして対処することにした。 「Rect」＞「Min Size」を（200, 50）に設定する。 公式オンラインドキュメント： ConfirmationDialog Line2D このノードは選択しているボタンを囲う四角い枠を作るために利用する。「Line2D」は線を描画するためのノードだが、任意の数の点を打ち、その点を通る線を描画できる。つまり、長方形の角にあたる点を指定し、最初の点と最後の点が重なるようにすれば長方形になる。\nなお、四角い枠を作るなら「Sprite」ノードなどでテクスチャ画像を適用して利用する方法が早そうだが、アセットがなくても四角い枠くらいはノードだけで作成できるので、今回は敢えてこの「Line2D」というクラスのノードを利用する。\nインスペクターで、「Node2D」ラクスの「Position」プロパティの値を (108, 128) に変更する。これはノードの位置を「RestartButton」に合わせるためだ。\n次に、線の幅である「Line2D」クラスの「Width」プロパティを 4 にする。 「Default Color」プロパティを # ffffff（白）にする。 「Points」プロパティに適用されている「PoolVector2Array」をクリックし、「サイズ」プロパティを 5 にする。これは線が通る点の数だ。 続けて、それぞれの Point（0 ~ 4）の位置を以下の通りに設定する。\n0: (0, 0)\n1: (64, 0)\n2: (64, 64)\n3: (0, 64)\n4: (0, -2)\n左上の角が欠けた枠にならないように、Point 4 の位置を「Width」プロパティの半分にあたる 2 px だけ最初の点より上に設定した。\nこれで画面は以下のようになったはずだ。\n公式オンラインドキュメント： Line2D AnimationPlayer このノードは単に「Line2D」で作成した四角い枠を点滅させるために利用する。点滅させることで、プレイヤーに注目させ、四角い枠でボタンを選択することを促すことが狙いだ。\nインスペクターのプロパティは元々以下のようになっているはずなので、そのままで良い。\nアニメーションを一つ、以下の内容で作成しよう。\nアニメーションの名前: blink_square アニメーションの長さ(秒): 2 アニメーションループ: 有効 トラック: 「Line2D」ノード ＞「default color」プロパティ Time: 0 秒 / Value: # ffffff / Easing: 1.00 Time: 1 秒 / Value: # e44a4a / Easing: 1.00 Time: 2 秒 / Value: # ffffff / Easing: 1.00 アニメーションを再生してみよう。\n公式オンラインドキュメント： AnimationPlayer 以上で各ノードのプロパティの編集は完了だ。次はスクリプトで動的な制御を施していく。\nGameOver ノードにスクリプトをアタッチする それでは「GameOver」ルートノードにスクリプトを新規でアタッチしよう。ファイルパスを「res://UI/GameOver/GameOver.gd」としてスクリプトファイルを作成してほしい。\nスクリプトエディタで「GameOver.gd」を開いたら、まずは以下のコードを記述しよう。\nextends Control # Added @ Part 9 # どちらのボタンをクリックしたかわかるようにボタンの種類をenumで定義 enum { RESTART, QUIT, } # Line2D の四角い枠が2つのボタン囲う位置の配列 var square_pos = [ # Restart ボタンを囲う位置 Vector2(108, 128), # Quit ボタンを囲う位置 Vector2(212, 128) ] # 上のenumで定義したパラメータを格納する（ボタン押下前は null） var selected_option = null # Restart ボタンを押した時に ConfirmationDialog の dialog_text プロパティに適用するテキスト var restart_text = \u0026#34;Do you really want to restart the game?\u0026#34; # Quit ボタンを押した時に ConfirmationDialog の dialog_text プロパティに適用するテキスト var quit_text = \u0026#34;Do you really want to quit the game?\u0026#34; # RestartButton ノードの参照 onready var restart_btn = $VBoxContainer/ButtonsHBox/RestartVBox/RestartButton # QuitButton ノードの参照 onready var quit_btn = $VBoxContainer/ButtonsHBox/QuitVBox/QuitButton # ColorRect ノードの参照 onready var color_rect = $ColorRect # ConfirmationDialog ノードの参照 onready var confirmation = $ConfirmationDialog # Line2D ノードの参照 onready var line2d = $Line2D # AnimationPlayer ノードの参照 onready var anim_player = $Line2D/AnimationPlayer func _ready(): # ゲーム開始時は ColorRect ノードを非表示にする color_rect.visible = false # ゲーム開始時に AnimationPlayer のblink_square アニメーションを再生する anim_player.play(\u0026#34;blink_square\u0026#34;) ここから必要なシグナルをこのスクリプトに接続していく。\nまずはマウスカーソルが「Restart」ボタンまたは「Quit」ボタンに重なった時に「Line2D」の四角い枠をそのボタンの方に移動させる。これには「RestartButton」ノード、および「QuitButton」ノードの「mouse_entered()」シグナルを利用する。さっそくシグナルを「GameOver.gd」スクリプトに接続しよう。\n接続したら、生成されたメソッドにそれぞれ「Line2D」の位置を指定するコードを記述する。具体的には以下のようなコードになる。\nfunc _on_RestartButton_mouse_entered(): line2d.position = square_pos[0] func _on_QuitButton_mouse_entered(): line2d.position = square_pos[1] 次に「Restart」ボタンまたは「Quit」ボタンをクリックした時にシグナルを発信させ、それをトリガーにして「ConfirmationDialog」ノードのダイアログを表示させる。\nでは「RestartButton」ノードおよび「QuitButton」ノードの「button_up()」シグナルを「GameOver.gd」スクリプトに接続しよう。\nちなみに細かい話だが、このシグナルはボタンをクリックした時にクリックした指が離れたら発動される。逆にクリックした指が押し続けている間は発動しない。\nシグナルを接続して追加されたメソッドをそれぞれ以下のように編集しよう。\nfunc _on_RestartButton_button_up(): work_at_button_up(RESTART) func _on_QuitButton_button_up(): work_at_button_up(QUIT) 「Restart」ボタンまたは「Quit」ボタンをクリックしたら、work_at_button_upメソッドが呼ばれるようにした。このメソッドはあとで定義する。引数には定義済みの enum のパラメータを取る形式にする。\nでは、どちらのボタンをクリックした時も呼ばれるwork_at_button_upメソッドを定義しよう。メソッドにはボタンをクリックした時に実行してほしい処理をコーディングしていく。\n# ボタンをクリックした時に呼ばれるメソッドを定義 func work_at_button_up(option): # 押したボタンに応じた enum パラメータを保持する引数 option を渡す selected_option = option # ColorRect ノードを表示して後ろを暗くする color_rect.visible = true # もし Restart ボタンが押された場合 if selected_option == RESTART: # ConfirmationDialog ノードの Text プロパティに restart_text プロパティの文字列を適用する confirmation.dialog_text = restart_text # もし Quit ボタンが押された場合 elif selected_option == QUIT: # ConfirmationDialog ノードの Text プロパティに quit_text プロパティの文字列を適用する confirmation.dialog_text = quit_text # ConfirmationDialog を画面中央に表示する confirmation.popup_centered() これで、どちらのボタンを押しても、必要な設定を施したダイアログが表示されるようになった。\n次に「ConfirmationDialog」ノードのダイアログが表示された後の操作を制御していこう。そのためにはまずこのノードのシグナルを利用する。「ConfirmationDialog」ノードの「confirmed()」シグナルを「GameOver.gd」スクリプトに接続しよう。\nこのシグナルは、ダイアログ上の「OK」ボタンをクリックした時、または space か enter キーを押した時に発信される。つまり、「Restart」か「Quit」の選択を確定した時に発信されるのだ。\n_on_ConfirmationDialog_confirmedメソッドが生成されたら、その中に、選択を確定した時に必要な処理をコーディングしていこう。\nfunc _on_ConfirmationDialog_confirmed(): # Restart ボタンを押した場合 if selected_option == RESTART: # シーンツリーの一時停止を再開する（一時停止は Game.gd 側に実装予定） get_tree().paused = false # デバッグ用 print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) # Game.tscn シーンを読み込み直し、ゲームをはじめから再開する get_tree().change_scene(\u0026#34;res://Game/Game.tscn\u0026#34;) # デバッグ用 print(\u0026#34;The game is restarted.\u0026#34;) # Quit ボタンを押した場合 elif selected_option == QUIT: # ゲームを完全に終了する get_tree().quit() # デバッグ用 print(\u0026#34;The game is quited.\u0026#34;) これで「Restart」ボタン、「Quit」ボタンをクリックして選択を確定したあとの挙動が実装できた。\n続いて「Cancel」ボタンをクリックしてダイアログを閉じる時の挙動を制御していく。こちらもまずはシグナルを接続するところから始める。「ConfirmationDialog」ノードの「popup_hide()」シグナルをスクリプトに接続しよう。\n_on_ConfirmationDialog_popup_hideメソッドが生成されたら以下のように編集しよう。ダイアログが表示された時の設定を元に戻すようにコーディングしている。\nfunc _on_ConfirmationDialog_popup_hide(): # ボタン選択ステータスをリセットする（値なし状態にする） selected_option = null # ConfirmationDialog ノードの dialog_text プロパティのテキストを消す confirmation.dialog_text = \u0026#34;\u0026#34; # ColorRect ノードを非表示に戻す color_rect.visible = false 最後に_inputメソッドを追加する。このメソッドを利用すると、入力イベントを利用してゲームを制御することができる。ここまででマウス操作による制御は実装できているが、ゲームをキーボードでプレイしていることを考えると、そのままキーボードで操作できた方が良いので、キーボード入力に対してこのメソッドを利用して制御しようというわけだ。ユーザーエクスペリエンスに配慮するのはゲーム開発者として大事なことなのだ。\nfunc _input(event): # もし GameOver ノードが表示されていたら（ゲームオーバーになったら） if visible: # もし左矢印キーが押されてキーから指が離れたら if event.is_action_released(\u0026#34;ui_left\u0026#34;): # Line2D の四角い枠を Restart ボタンの方に配置する line2d.position = square_pos[0] # もし右矢印キーが押されてキーから指が離れたら elif event.is_action_released(\u0026#34;ui_right\u0026#34;): # Line2D の四角い枠を Quit ボタンの方に配置する line2d.position = square_pos[1] # もし space キーか enter キーが押されて指が離れてかつ ColorRect が非表示（まだダイアログが非表示）だったら elif event.is_action_released(\u0026#34;ui_accept\u0026#34;) and not color_rect.visible: # もし Line2D の四角い枠が Restart ボタンの方に配置されていたら if line2d.position == square_pos[0]: # Restart ボタンをクリックした時のメソッドを実行 _on_RestartButton_button_up() # もし Line2D の四角い枠が Quit ボタンの方に配置されていたら elif line2d.position == square_pos[1]: # Quit ボタンをクリックした時のメソッドを実行 _on_QuitButton_button_up() シーンを実行して挙動を確認しておこう。\n良い感じである。ここらで一度休憩しよう。\nGameOver シーンをインスタンス化して Game シーンに追加する 出来上がった「GameOver」シーンをインスタンス化して「Ggame」シーンツリーにブランチとして追加しよう。\nGame.gd スクリプトを編集する ゲームオーバーになって「Restart」を選択した場合、「Game.tscn」を読み込み直すようにコーディングしたが、この時「Level_」シーンも解放される。解放時にシグナル「tree_exited」が発信され、「Game.gd」スクリプト内でこのシグナルが接続されているchange_levelメソッドが呼ばれる。しかし、ゲームオーバーなので、このメソッドで次のレベルに遷移させる必要はないし、最後のレベルだった場合にはゲームクリアの判定になる上、get_treeメソッドを実行しようとしても解放されて「/root/」を取得できずnullが返され、エラーとなる。\nこれを回避するため「Game.gd」スクリプトのchange_levelメソッドを以下のように編集する。\nfunc change_level(): if get_tree(): # Added @ Part 9 print(\u0026#34;change_level() called.\u0026#34;) if current_level \u0026lt; final_level: print(\u0026#34;change to next level.\u0026#34;) level.queue_free() current_level += 1 hud.update_level(current_level) # Added @ Part 8 add_level() else: print(\u0026#34;Game Clear! Congrats!\u0026#34;) get_tree().quit() プレイヤーのヘルスが 0 になったらゲームオーバーになる仕組みを実装する ここからはスクリプトをコーディングして、プレイヤーのヘルスが 0 になった時にゲームオーバーになる仕組みを実装していく。\nプレイヤーのヘルスが 0 になった時のアニメーションを作る プレイヤーのヘルスが 0 になった時のアニメーションを追加したい。\n久しぶりに「Player.tscn」シーンを開き、エディタ下部のアニメーションパネルを開いたら、以下の内容で新しい「die」という名前のアニメーションを作成しよう。\nアニメーションの名前： die アニメーションの長さ（秒）：0.9 以下のトラックを追加 トラック 1: AnimatedSprite ノード \u0026gt; scale プロパティ Time: 0秒 / Value: (0, 0) / Easing: 50 Time: 0.9秒 / Value: (10, 0) / Easing: 1.00 トラック 2: AnimatedSprite ノード \u0026gt; modulate プロパティ Time: 0秒 / Value: # ffffff / Easing: 1.00 Time: 0.1秒 / Value: # 00ffffff / Easing: 1.00 Time: 0.2秒 / Value: # ffffff / Easing: 1.00 Time: 0.3秒 / Value: # 00ffffff / Easing: 1.00 Time: 0.4秒 / Value: # ffffff / Easing: 1.00 Time: 0.5秒 / Value: # 00ffffff / Easing: 1.00 Time: 0.6秒 / Value: # ffffff / Easing: 1.00 Time: 0.7秒 / Value: # 00ffffff / Easing: 1.00 Time: 0.8秒 / Value: # ffffff / Easing: 1.00 Time: 0.9秒 / Value: # 00ffffff / Easing: 1.00 補完モード: 近傍\nアニメーションパネルは以下のようになったはずだ。\nアニメーションの内容としては、まず modulate プロパティのトラックにて、プレイヤーキャラクターの透明度を 0 と 100 の間で 0.1 秒周期で切り替え、明滅したように見せる。さらに scale プロパティのトラックにては最後の 0.9 秒で一気に横に引き伸ばしつつ縦に潰すことで、プレイヤーキャラクターのテクスチャが消える。\nアニメーションを確認してみよう。\nこのあと、スクリプトで今作成したアニメーションをプレイヤーのヘルスが 0 になった時に再生させる。\nスクリプトで制御する スクリプトでプレイヤーのヘルスとゲームオーバーを連動させる。「Game.gd」スクリプトを開いたら、以下のようにコードをアップデートしよう。「# 追加」のコメントがある行が更新箇所だ。\nextends Node # 中略 onready var hud = $UI/HUD onready var gameover = $UI/GameOver # 追加：GameOver ノードの参照 func _ready(): gameover.visible = false # 追加：ゲーム開始時に GameOver ノードを非表示にする add_level() hud.update_health(health) hud.update_score(score) hud.update_level(current_level) # 以下省略 これでゲームプレイ中はゲームオーバー画面は非表示になった。\n続いて、いくつかのメソッドも編集する。\n# 中略 func _on_Player_enemy_hit(damage): manage_health(damage) # 変更 # 中略 func manage_health(damage): # 追加：引数にダメージの数値をとる health -= damage # 移動：_on_Player_enemy_hit()メソッドから print(\u0026#34;Health updated: \u0026#34;, health) # 移動：Moved from _on_Player_enemy_hit()メソッドから hud.update_health(health) # 移動： _on_Player_enemy_hit()メソッドから # もし ヘルスが 0 以下になったら if health \u0026lt;= 0: # 追加 # Player の AnimationPlayer ノードで「die」アニメーションを再生する player.anim_player.play(\u0026#34;die\u0026#34;) # アニメーションが終了するまで待つ yield(player.anim_player, \u0026#34;animation_finished\u0026#34;) # ゲームオーバー画面を表示する gameover.visible = true # デバッグ用 print(\u0026#34;Game over screen is shown up.\u0026#34;) # シーンツリーを一時停止する（GameOver ブランチは Process） get_tree().paused = true # デバッグ用 print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) 今回manage_health(damage)というメソッドを新たに作成し、そちらでプレイヤーのヘルスの更新を処理するようにした。メソッドの中身の前半は、以前_on_Player_enemy_hit()メソッドの中にあったコードだ。if health \u0026lt;= 0:ブロックが今回新しく追加した、ヘルスが 0 になった場合の処理だ。\nプロジェクトを実行して、挙動を確認してみよう。\n敵キャラクターに当たってヘルスが 0 になったら「die」アニメーションのあとゲームオーバー画面に遷移した。問題なさそうだ。ちなみに、裏では「GameOver」ノード以外は一時停止している。\nプレイヤーキャラクターが画面下に落下した時にゲームオーバーになる仕組みを実装する 画面下に落下した時もゲームオーバー画面を表示させたい。少ない工数で実装するには、ヘルスが 0 になった時の処理を流用するのが良いだろう。つまり、画面下に落下したらヘルスが 0 になるようにすれば良い。\n画面下部への落下の判定は、「Level.gd」スクリプトで行う。理由は、プレイヤーキャラクターの位置がカメラの位置の画面下方向のリミットを超えた場合（つまり、画面下方向に落下したキャラクターが画面から消えた場合）にゲームオーバーにすれば良いので、プレイヤーキャラクターとカメラの両方を子ノードとして持つ「Level_」ノードのスクリプトで制御するのが最適だからだ。\nでは「Level.gd」スクリプトを開いて、編集しよう。\nextends Node2D # オリジナルのシグナル：プレイヤーキャラクターが画面外へ落下した時に発信する signal player_dropped # 追加 # 中略 func _process(_delta): camera.global_position = player.global_position # プレイヤーキャラクターの位置の y 座標の値が、カメラの下方向のリミットより大きい場合 if player.global_position.y \u0026gt; camera.limit_bottom: # 追加: if ブロック # player_dropped シグナルを発信 emit_signal(\u0026#34;player_dropped\u0026#34;) # デバッグ用 print(\u0026#34;player dropped and die.\u0026#34;) # プロセスを停止してプレイヤーキャラクターが落下し続けるのを止める set_process(false) これで、プレイヤーキャラクターが落下してカメラの外に出てしまった時に、シグナルが発信するようになった。では「Game.gd」スクリプトへ戻ろう。\n# 中略 func add_level(): level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) # シグナル player_dropped をこのスクリプトの _on_Level_player_dropped メソッドに接続 level.connect(\u0026#34;player_dropped\u0026#34;, self, \u0026#34;_on_Level_player_dropped\u0026#34;) # 追加 add_child(level) player = level.get_node(\u0026#34;Player\u0026#34;) player.connect(\u0026#34;enemy_hit\u0026#34;, self, \u0026#34;_on_Player_enemy_hit\u0026#34;) player.connect(\u0026#34;item_hit\u0026#34;, self, \u0026#34;_on_Player_item_hit\u0026#34;) # 中略 # シグナル player_dropped で呼ばれるメソッド func _on_Level_player_dropped(): # 追加 # メソッド manage_helth の引数 damage に 100 を渡して実行 manage_health(100) これで以下の流れが出来上がった。\nGameノードへの「Level_」インスタンス追加時にシグナル「player_dropped」を「Game.gd」に接続する。 プレイヤーキャラクターが画面下に落下する。 シグナルが発信される。 ダメージを 100 受けヘルスが 0 以下になる。 ゲームオーバーになる ではプレイヤーキャラクターを落下させてみよう。\n落下直後、プレイヤーのヘルスは一気に 0 になり、そのあとすぐにゲームオーバー画面が表示された。想定通りだ。\nPart 9 で編集したスクリプトのコード 最後に今回の Part 9 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nGameOver.gd の全コード extends Control # Added @ Part 9 enum { RESTART, QUIT, } # Added later var square_pos = [ Vector2(108, 128), Vector2(212, 128) ] var selected_option = null var restart_text = \u0026#34;Do you really want to restart the game?\u0026#34; var quit_text = \u0026#34;Do you really want to quit the game?\u0026#34; onready var restart_btn = $VBoxContainer/ButtonsHBox/RestartVBox/RestartButton onready var quit_btn = $VBoxContainer/ButtonsHBox/QuitVBox/QuitButton onready var color_rect = $ColorRect onready var confirmation = $ConfirmationDialog onready var line2d = $Line2D # Added later onready var anim_player = $Line2D/AnimationPlayer # Added later func _ready(): color_rect.visible = false anim_player.play(\u0026#34;blink_square\u0026#34;) # Added later func _on_RestartButton_mouse_entered(): line2d.position = square_pos[0] func _on_QuitButton_mouse_entered(): line2d.position = square_pos[1] func _on_RestartButton_button_up(): work_at_button_up(RESTART) func _on_QuitButton_button_up(): work_at_button_up(QUIT) func work_at_button_up(option): selected_option = option color_rect.visible = true if selected_option == RESTART: confirmation.dialog_text = restart_text elif selected_option == QUIT: confirmation.dialog_text = quit_text confirmation.popup_centered() func _on_ConfirmationDialog_confirmed(): if selected_option == RESTART: get_tree().paused = false print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) get_tree().change_scene(\u0026#34;res://Game/Game.tscn\u0026#34;) print(\u0026#34;The game is restarted.\u0026#34;) elif selected_option == QUIT: get_tree().quit() print(\u0026#34;The game is quited.\u0026#34;) func _on_ConfirmationDialog_popup_hide(): selected_option = null confirmation.dialog_text = \u0026#34;\u0026#34; color_rect.visible = false func _input(event): # Added later if visible: if event.is_action_released(\u0026#34;ui_left\u0026#34;): line2d.position = square_pos[0] elif event.is_action_released(\u0026#34;ui_right\u0026#34;): line2d.position = square_pos[1] elif event.is_action_released(\u0026#34;ui_accept\u0026#34;) and not color_rect.visible: if line2d.position == square_pos[0]: _on_RestartButton_button_up() elif line2d.position == square_pos[1]: _on_QuitButton_button_up() Game.gd の全コード extends Node # Added @ Part 7 var health: float = 100.0 # Added @ Part 8 var score: int = 0 # Added @ Part 8 var level: Node2D var player: KinematicBody2D export var current_level = 1 export var final_level = 2 onready var hud = $UI/HUD # Added @ Part 8 onready var gameover = $UI/GameOver # Added @ Part 9 func _ready(): gameover.visible = false # Added @ Part 9 add_level() hud.update_health(health) # Added @ Part 8 hud.update_score(score) # Added @ Part 8 hud.update_level(current_level) # Added @ Part 8 func add_level(): level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) level.connect(\u0026#34;player_dropped\u0026#34;, self, \u0026#34;_on_Level_player_dropped\u0026#34;) # Added @ Part 9 add_child(level) player = level.get_node(\u0026#34;Player\u0026#34;) # Added @ Part 8 player.connect(\u0026#34;enemy_hit\u0026#34;, self, \u0026#34;_on_Player_enemy_hit\u0026#34;) # Added @ Part 8 player.connect(\u0026#34;item_hit\u0026#34;, self, \u0026#34;_on_Player_item_hit\u0026#34;) # Added @ Part 8 func change_level(): if get_tree(): # Added @ Part 9 print(\u0026#34;change_level() called.\u0026#34;) if current_level \u0026lt; final_level: print(\u0026#34;change to next level.\u0026#34;) level.queue_free() current_level += 1 hud.update_level(current_level) # Added @ Part 8 add_level() else: print(\u0026#34;Game Clear! Congrats!\u0026#34;) get_tree().quit() func _on_Player_enemy_hit(damage): # Added @ Part 8 manage_health(damage) # Modified @ Part 9 func _on_Player_item_hit(point): # Added @ Part 8 score += point hud.update_score(score) func _on_Level_player_dropped(): # Added @ Part 9 manage_health(100) func manage_health(damage): # Added @ Part 9 health -= damage # Moved from _on_Player_enemy_hit() @ Part 9 print(\u0026#34;Health updated: \u0026#34;, health) # Moved from _on_Player_enemy_hit() @ Part 9 hud.update_health(health) # Moved from _on_Player_enemy_hit() @ Part 9 # Added @ Part 9 if health \u0026lt;= 0: player.anim_player.play(\u0026#34;die\u0026#34;) yield(player.anim_player, \u0026#34;animation_finished\u0026#34;) gameover.visible = true print(\u0026#34;Game over screen is shown up.\u0026#34;) get_tree().paused = true print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) Level.gd の全コード extends Node2D # Created @ Part 3 signal player_dropped # Added @ Part 9 onready var player = $Player onready var map = $TileMap onready var camera = $Camera2D func _ready(): adjust_camera() func _process(_delta): camera.global_position = player.global_position if player.global_position.y \u0026gt; camera.limit_bottom: # Added @ Par 9 emit_signal(\u0026#34;player_dropped\u0026#34;) print(\u0026#34;player dropped and die.\u0026#34;) set_process(false) func adjust_camera(): var map_limits = map.get_used_rect() print(\u0026#34;map_limits\u0026#34;, map_limits) var map_cell_size = map.cell_size print(\u0026#34;map_cell_size\u0026#34;, map_cell_size) camera.limit_left = map_limits.position.x * map_cell_size.x camera.limit_right = map_limits.end.x * map_cell_size.x #camera.limit_top = map_limits.position.y * map_cell_size.y # 指定しない camera.limit_bottom = map_limits.end.y * map_cell_size.y camera.limit_smoothed = true おわりに 以上で Part 9 は完了だ。今回はゲームオーバーの仕組みを実装した。ゲームオーバー画面も UI の一つなので、「Control」系クラスのノードばかりで構成した。各クラスにはそれぞれ異なる機能が割り当てられているのがご理解いただけただろう。今回使用した以外にも「Control」系クラスはまだまだたくさんある。それぞれの役割を少しずつ覚えていけば、今後さまざまな UI を作れるようになるだろう。\nまた UI 上のプレイヤー操作に対するゲームの制御において、シグナルの役割は大きいことも実感いただけたのではないだろうか。何かをトリガーにして実行したい処理がある場合、シグナルを積極的に利用していこう。デフォルトで用意されているシグナルだけでなく、自作のシグナルもスクリプトなら簡単に利用できることを覚えておこう。\nさて、次回のチュートリアルでは、スタート画面を実装する予定だ（やっぱりな、というご意見が多そうだが）。ただ単にスタートボタンを押すだけの UI では面白くないので、プレイヤーキャラクターの種類を増やして、スタート画面でキャラクター選択もできるようにする予定だ。\nでは次回もお楽しみに。\nUPDATE:\n2022-03-16 公式オンラインドキュメント＞ゲームの一時停止のリンク追加\n2022-03-20 「# GameOver シーンを作る」に「Line2D」ノードのボタンを囲う四角い枠とキーボード入力でのボタン操作を追加し、それ以降の各種画像を差し替え\n2022-04-23 change_levelメソッド内の冒頭にif get_tree():を追加\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_9/","summary":"第9回目の今回は、ゲームオーバーの仕組みを実装していく。 世に出ているプラットフォーマーゲームにはほぼ確実にゲームオーバーの仕組みが存在する。ゲームオーバーになるかもしれない緊張感がなければプラットフォ","title":"Godot で作るプラットフォーマー Part 9：ゲームオーバーの仕組みを作ろう！"},{"content":"第10回目の今回は、ゲーム開始時に表示されるスタート画面を作る。タイトル画面、スタートメニューとも言う。\nそれだけだと、前回と比べて簡単すぎるので、ゲーム開始時にプレイヤーキャラクターを選択できる仕組みも実装する。画面遷移のイメージは以下の通りだ。\nまずゲームを始めるとスタート画面が表示される。 スタートボタンを押すとプレイヤーキャラクター選択画面に遷移する。 プレイヤーキャラクターを選択するとゲームプレイ開始。 ということで、今回の作業は以下の通りだ。\nスタート画面を作る プレイヤーキャラクターの種類（スプライトのテクスチャのみ）を増やす プレイヤーキャラクター選択画面を作る スタート画面とプレイヤーキャラクター選択画面をゲームに紐付ける では順番にやっていこう。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー スタート画面を作る シーンを作る まずはスタート画面を作っていく。画面のレイアウトはゲームオーバー画面と似た感じにしてしまおう。そうすればゲームオーバー画面のシーンを流用できる。\nということで、新規シーンは作らずに、ファイルシステムドック内でゲームオーバー画面のシーンを複製するところから作業を始める。では下記の手順でスタート画面のシーンを作成しよう。\nファイルシステムで「res://UI/GameOver/GameOver.tscn」を右クリック＞「複製」を選択する。\nシーンの名前を「GameStart.tscn」とする。 ファイルシステムで「res://UI/」で右クリック＞「新規フォルダー」を選択し、フォルダーの名前を「GameStart」とする。 「res://UI/GameStart」に「GameStart.tscn」をドラッグして移動する\nシーンツリーを編集する 「GameOver.tscn」から複製したばかりの「GameStart.tscn」を開いてみよう。\n見ての通り、「GameOver」シーンそのままの状態だ。これを以下の手順でスタート画面仕様に修正していく。\n「GameOver」ルートノードの名前を「GameStart」に変更する。 「GameStart」ノードを右クリック＞「スクリプトをデタッチ」する。 「GameOverLabel」ノードの名前を「TitleLabel」に変更する。 「RestartVBox」ノードの名前を「StartVBox」に変更する。 「RestartButton」ノードの名前を「StartButton」に変更する。 「RestartLabel」ノードの名前を「StartLabel」に変更する。 「StartVBox」ブランチを「ButtonsHBox」ノードから出して「VBoxContainer」の子にする（1階層上げる） 「ButtonsHBox」ブランチを削除する。 「ColorRect」ノードを削除する。 「ConfirmationDialog」ノードを削除する。 新たに「GameStart」ルートノードに「AnimationPlayer」ノードを追加する。 以上の作業でシーンツリーは以下のスクリーンショットのようになったはずだ。\n最後に「StartButton」ノードの「button_up()」シグナルを切断しておこう。\n続いて、各ノードのプロパティを更新していく。\n各ノードのプロパティを編集する 各ノードのプロパティの値も、シーンの複製元である「GameOver.tscn」の状態のままなのでスタート画面仕様に修正していく。シーンツリーの上から順番にやっていこう。\nGameStart 「Pause Mode」プロパティは、「GameOver」シーンの名残で「Process」のままになっているので、「Inherit」にしておく。その他のプロパティも編集は不要だ。\nTextureRect 「Texture」プロパティに割り当てるテクスチャ画像を差し替えて、ゲームオーバー画面と差別化する。ファイルシステムドックから「res://Assets/Background/Pink.png」をドラッグ\u0026amp;ドロップして適用する。\nVBoxContainer このノードのプロパティは編集不要だ。\nTitleLabel スタート画面は、ゲーム開始時に最初に表示される画面なので、ゲームのタイトルを大きめに表示させたい。また、文字の見た目も色を変えたりアウトラインをつけるなどして、ゲームオーバー画面と差別化する。\n「Text」プロパティに以下のゲームタイトルの文字列（改行あり）を入力する（あなたの好きなタイトルにしていただいて問題ない）。\nplatformer\ntutorial 「Theme Overrides」＞「Fonts」＞「Font」で「新規 DynamicFont」を選択する。 「Font」＞「Settings」＞「Size」プロパティを 48 にする。 「Font」＞「Settings」＞「Outline Size」プロパティを 5 にする。 「Font」＞「Settings」＞「Outline Color」プロパティで色を # 302e3e （濃いグレー）にする。 「Font」＞「Font」＞「Font Data」に「res://fonts/connection_ii/ConnectionII.otf」を適用する。\n「Visibility」＞「Modulate」プロパティで色を # 7ec8ff（水色）にする。\nStartVBox このノードのプロパティは編集不要だ。\nStartButton ボタンのアイコンをゲームプレイを開始するイメージに近いテクスチャ画像に差し替える。\n「Textures」＞「Normal」プロパティにファイルシステムドックから「res://Assets/Menu/Buttons/Play.png」をドラッグ\u0026amp;ドロップして画像を差し替える。\nStartLabel ボタンアイコンの説明書きがゲームオーバー画面仕様の「RESTART」になっているので「START」に更新する。\n「Text」プロパティに「press space or enter key」と入力する。 AnimationPlayer このノードは「Start」ボタンを押した時に、少し凹んだようなアニメーションを作るために用いる。インスペクターのプロパティはそのままで良い。\n新規アニメーションを以下の内容で作成しよう。\nアニメーション名: press_start アニメーションの長さ(秒): 0.1 アニメーションループ: 無効 トラック： 「StartButton」ノード ＞「modulate」プロパティ Time: 0秒 / Value: # ffffff / Easing: 1.00 Time: 0.05秒 / Value: # c8c8c8 / Easing: 1.00 Time: 0.1秒 / Value: # ffffff / Easing: 1.00 「StartButton」ノード ＞「rect_scale」プロパティ Time: 0秒 / Value: (1, 1) / Easing: 1.00 Time: 0.05秒 / Value: (0.9, 0.9) / Easing: 1.00 Time: 0秒 / Value: (1, 1) / Easing: 1.00 以上で、スタート画面のプロパティ編集作業は完了だ。一からシーンを作るよりは省エネで作業を終えられたのではないだろうか。ちなみに、シーンの見た目は以下のようになったはずだ。\nスクリプトをアタッチして編集する 続いて、スタート画面上のボタンをプレイヤーがクリックした時の動作をスクリプトで制御していく。\n「GameStart」ルートノードに新しいスクリプトをアタッチする。この時、スクリプトのファイルパスを「res://UI/GameStart/GameStart.gd」として作成する。\nスクリプトエディタで「GameStart.gd」スクリプトが開いたら、以下のように編集する。\nextends Control # StartButton ノードの参照 onready var start_button = $VBoxContainer/StartVBox/StartButton # AnimationPlayer ノードの参照 onready var anim_player = $AnimationPlayer func _ready(): # ゲーム開始時にアニメーションで変更されるプロパティを初期化 start_button.modulate = Color(1, 1, 1, 1) start_button.rect_scale = Vector2(1, 1) 次にシグナルを接続しよう。「StartButton」ノードの「button_up()」シグナルを「GameStart.gd」スクリプトに接続する。\nスクリプトに_on_StartButton_button_upメソッドが生成されたら、以下のように編集する。\n# Start ボタンをクリックした時のシグナルで呼ばれるメソッド func _on_StartButton_button_up(): # デバッグ用 print(\u0026#34;_on_StartButton_button_up called.\u0026#34;) # AnimationPlayer の press_start アニメーションを再生 anim_player.play(\u0026#34;press_start\u0026#34;) # アニメーションが終わるまで待機 yield(anim_player, \u0026#34;animation_finished\u0026#34;) # このノードを解放（削除）する queue_free() # デバッグ用 print(\u0026#34;GameStart scene is now freed.\u0026#34;) Start ボタンを押したら、次のプレイヤーキャラクター選択画面に遷移させる予定なので、この時点で「GameStart」シーンは用済みなのでqueue_freeメソッドで解放している。\n最後にキー入力での制御を実装しておく。インプットマップにデフォルトで登録されているアクション「ui_accept」に該当するスペースキー、またはエンターキーを押した時に、さっきシグナル接続で生成された_on_StartButton_button_upを実行するようにした。これでマウスでもキーボードでも同じ結果が得られるようになった。\nfunc _input(event): # スペースキーかエンターキーが押された場合 if event.is_action_pressed(\u0026#34;ui_accept\u0026#34;): # スタートボタンが押された時のメソッドを呼ぶ _on_StartButton_button_up() 「GameStart」シーンの作成はこれで完成なので、最後にシーンを実行して挙動を確認しておこう。\nスタートボタンを押すと、ルートノードが解放されて何もノードが存在しない状態になるので、グレーの画面が表示されるのは正常な動作だ。なお、GIF画像ではアニメーションが若干不自然だが、実際にはもう少し短い時間で自然にアニメーションするはずだ。\nプレイヤーキャラクターの種類を増やす ファイルシステムドックをご覧いただくと「res://Assets/Main Characters/」フォルダの中に4種類のプレイヤーキャラクターのアセットが見つかるだろう。ここまでのチュートリアルでは、4種類のうち「Pink Man」のスプライトシートのみを使ってきたが、ここで4種類全てのアセットを使用する時がきた。\nとはいえ、4種類のプレイヤーキャラクターのシーンを作る必要はなく、「Player」シーン＞「AnimatedSprite」ノード＞「Frames」プロパティに適用する「SpriteFrames」クラスのリソースファイルを4種類作成するだけで良い。つまり、キャラクター選択時に、「AnimatedSprite」ノードのテクスチャだけ差し替える、という作戦だ。\n（おさらいも兼ねて）事前確認として「Pink Man」以外のスプライトシートのアセットファイルにもしブラーがかかっていたら（ぼやけた感じがしたら）、ファイルシステムドックでファイルを選択して、インポートドックから「プリセット」＞「2D Pixel」を選択して「再インポート」をクリックしておこう。これでドット絵特有のエッジが効いた表示に更新される。\nでは順番にやっていこう。\nSpriteFrames リソースを作成する PinkMan ほぼ作業不要の「PinkMan」から「SpriteFrames」クラスのリソースファイルを作成する。\n「Player.tscn」を開く。 「AnimatedSprite」ノードの「Frames」プロパティの値になっている「SpriteFrames」を右クリック＞「保存」を選択する。\nファイルパスが「res://Player/PinkMan.tres」になるようにファイル名を「PinkMan.tres」として保存する。\nPinkMan の場合はすでにアニメーションフレームが作成済みなので、リソースファイル作成はこれで完了だ。\nMaskDude 次は「MaskDude」のリソースファイルを作成する。\nファイルシステムドックで、先に作成したPinkManのリソース「res://Player/PinkMan.tres」を右クリック＞「複製」を選択する。 ファイル名を「MaskDude.tres」とする。\nファイルシステムドックで作成した「MaskDude.tres」をダブルクリックしてスプライトフレームパネルを開く。 登録しているアニメーションを上から一つ選択する。\n既存のアニメーションフレームを全て削除する。\nスプライトシートアイコンをクリックする。\n適切なスプライトシートのファイルを選択し、アニメーションフレームに反映すればOK。\n次のアニメーションを選択して同様の作業を行う。全てのアニメーションのアニメーションフレームが更新できたら、リソースファイルの作成は完了とする。 NinjaFrog 作業は「MaskDude」シーンと同様だ。リソースのファイル名はもちろん「NinjaFrog.tres」にして保存する。\nVirtualGuy こちらも作業は「MaskDude」シーンと同様だ。リソースのファイル名はもちろん「VirtualGuy.tres」にして保存する。\n「VirtualGuy.tres」の編集が終われば、プレイヤーキャラクター4種類のリソースファイルの完成だ。ここらで一度休憩を入れよう。\nプレイヤーキャラクター選択画面を作る さて、ここからはプレイヤーキャラクターを選択する画面のシーンを作っていく。画面の仕様は以下のようにする。\n画面上部にプレイヤーキャラクターの名前を表示する。 画面中央にプレイヤーキャラクターのビジュアル（テクスチャ）をアニメーション付きで表示する。 キーボードの左右矢印キーか画面に表示されている矢印ボタンをクリックでキャラクターを切り替える。 キーボードのスペースキーまたはエンターキーでキャラクターを選択したらゲームプレイ開始。 では例によって、シーンを作成するところから始めよう。\nシーンを作る 以下の手順でプレイヤーキャラクター選択用のシーンを作っていく。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードの生成」で「ユーザーインターフェース」を選択して、「Control」クラスを選択する。 「Control」ルートノードが生成されたら、名前を「CharacterSelect」に変更する。 「res://UI」フォルダーに「CharacterSelect」フォルダーを新規作成し、ファイルパスを「res://UI/CharacterSelect/CharacterSelect.tscn」としてシーンを保存する。 必要なノードを追加する 続いて、作成した「CharacterSelect」シーンに必要なノードを追加していこう。\n「CharacterSelect」ルートノードに「TextureRect」ノードを追加する。 「CharacterSelect」ルートノードに「VBoxContainer」ノードを追加する。 「VBoxContainer」ノードに「Label」ノードを追加し、名前を「CharacterName」に変更する。 「VBoxContainer」ノードに「HBoxContainer」ノードを追加する。 「HBoxContainer」ノードに、「TextureButton」ノードを 2 つ追加し、それぞれの名前を「LeftButton」、「RightButton」に変更する。 「VBoxContainer」ノードに「Label」ノードを追加し、名前を「Caption」に変更する。 「CharacterSelect」ノードに「AnimatedSprite」ノードを追加する。 「CharacterSelect」ノードに「AnimationPlayer」ノードを追加する。 ここまででシーンツリーは以下のようになったはずだ。\n各ノードのプロパティを編集する 次に、インスペクターで各ノードのプロパティを編集して、プレイヤーキャラクター選択画面をデザインしていこう。\nCharacterSelect このルートノードは子ノードの入れ物として利用する。\n2Dワークスペースのツールバー＞「レイアウト」から「Rect全面」を選択して、ノードのサイズを前画面サイズに揃える。 TextureRect このノードは背景用に利用する。\n2Dワークスペースのツールバー＞「レイアウト」から「Rect全面」を選択して、画面全体に広げる。 「Texture」プロパティに、ファイルシステムから「res://Assets/Background/Yellow.png」をドラッグ\u0026amp;ドロップして適用する。 「Stretch Mode」プロパティを「Tile」にする。 VBoxContainer このノードはプレイヤーキャラクター選択画面に表示されるキャラクター名やキャラクターのスプライト、選択ボタン、操作説明を縦に整列させるためのコンテナとして利用するだけなので、プロパティの編集は少ない。\n2Dワークスペースのツールバー＞「レイアウト」から「Rect全面」を選択して、ノードのサイズを前画面サイズに揃える。 インスペクターで「Alignment」を「Center」にする。 「Theme Overrides」＞「Constants」＞「Separation」ノードを 48 にする。 CharacterName このノードは、現在選択しているキャラクターの名前を表示するのに利用する。表示位置は画面の上部中央になる予定だが、他のノードの設定がまだなので現時点では中央にされる。後から徐々に意図した形になるはずなので、位置はそのままにしておくこと。\nインスペクターで「Text」プロパティは仮に「Mask Dude」と入力する。 「Align」プロパティを「Center」にする。 「Theme Overrides」＞「Fonts」＞「Font」で「新規 DynamicFont」を選択する。 「Font」＞「Settings」＞「Size」プロパティを 32 にする。 「Font」＞「Settings」＞「Outline Size」プロパティを 5 にする。 「Font」＞「Settings」＞「Outline Color」プロパティで色を # 302e3e （濃いグレー）にする。 「Font」＞「Font」＞「Font Data」に「res://fonts/connection_ii/ConnectionII.otf」を適用する。 HBoxContainer このノードは水平方向に子ノードを横並びに配置するコンテナだ。左右の矢印ボタンアイコンを子ノードに持つので、それを横並びに配置する。またその左右の矢印ボタンの間に、プレイヤーキャラクターのスプライトを表示させたいので、ボタンとボタンの間をたっぷり目に空けておく必要がある。\nインスペクターで「Alignment」プロパティを「Center」にする。 「Theme Overrides」＞「Constants」＞「Separation」ノードを 156 にする。 LeftButton このノードは「TextureRect」クラスなので、ボタンにテクスチャ画像を割り当てることができる。名前の通り、左向き矢印ボタンを作るのに利用する。\nインスペクターで「Expand」プロパティをオンにする。 「Stretch Mode」プロパティを「Keep Aspect Centered」にする。 「Textures」＞「Normal」プロパティに、ファイルシステムドックから「res://Assets/Menu/Buttons/Previous.png」をドラッグ\u0026amp;ドロップして適用する。 「Control」クラスの「Rect」＞「Min Size」プロパティを (42, 40) にする。 RightButton このノードも「LeftButton」同様に「TextureRect」クラスで、右向き矢印ボタンを作るのに利用する。\nインスペクターで「Expand」プロパティをオンにする。 「Stretch Mode」プロパティを「Keep Aspect Centered」にする。 「Textures」＞「Normal」プロパティに、ファイルシステムドックから「res://Assets/Menu/Buttons/Next.png」をドラッグ\u0026amp;ドロップして適用する。 「Control」クラスの「Rect」＞「Min Size」プロパティを (42, 40) にする。 Caption このノードは、単なる「Label」クラスのノードである。プレイヤーキャラクター選択画面での操作説明を画面下部に表示させるために利用する。\nインスペクターで「Text」プロパティに以下の開業を含む文字列を入力する。\npress left or right key to select a character\npress enter or space key to confirm 「Align」プロパティを「Center」にする。 「Uppercase」プロパティをオンにする。 「Theme Overrides」＞「Fonts」＞「Font」プロパティに、ファイルシステムドックから「res://fonts/poco/Poco.tres」をドラッグ\u0026amp;ドロップして適用する。\n*このリソースファイルは他のシーンでも利用しているのでリソースのプロパティはそのままにしておくこと。もし編集したい場合は必ずリソースを「ユニーク化」して他のノードのデザインに影響しないようにすること。 「CanvasItem」クラスの「Visibility」＞「Modulate」プロパティで色を # 000000（黒）にする。 AnimatedSprite このノードは、先に作成した 4 種類のプレイヤーキャラクターの「SpriteFrames」クラスのリソースファイルを「Frames」プロパティに適用させて、画面上に実際にキャラクターのスプライトを表示するために利用する。\nインスペクターで「Frames」プロパティに、ファイルシステムドックから先に作った「res://Player/MaskDude.tres」をドラッグ\u0026amp;ドロップして適用させる。最初は「MaskDude」のスプライトで表示させるためだ。 「Animation」プロパティは「idle」を選択する。これが一番、2Dワークスペース上で位置を把握しやすいはずだ。 「Position」プロパティは (192, 124) にする。これがちょうど左右のボタンの中間にあたる位置だ。 AnimationPlayer このノードは「LeftButton」と「RightButton」をクリックした時に再生させる、ボタンが凹んだような簡単なアニメーションを作るのに利用する。\nインスペクターでのプロパティ編集は不要だ。 アニメーションパネルを開く。 まず左矢印ボタンのアニメーションを作成する。 アニメーション名: press_left アニメーションの長さ(秒): 0.1 アニメーションループ: 無効 トラック: 「LeftButton」ノード ＞「modulate」プロパティ Time: 0秒 / Value: # ffffff / Easing: 1.00 Time: 0.05秒 / Value: # c8c8c8 / Easing: 1.00 Time: 0.1秒 / Value: # ffffff / Easing: 1.00 「LeftButton」ノード ＞「rect_scale」プロパティ Time: 0秒 / Value: (1, 1) / Easing: 1.00 Time: 0.05秒 / Value: (0.9, 0.9) / Easing: 1.00 Time: 0.1秒 / Value: (1, 1) / Easing: 1.00 次に右矢印ボタンのアニメーションを作成する。トラックのノードが違うこと以外は先に作成した「press_left」アニメーションとほとんど同じだ。 アニメーション名: press_right アニメーションの長さ(秒): 0.1 アニメーションループ: 無効 トラック: 「RightButton」ノード ＞「modulate」プロパティ Time: 0秒 / Value: # ffffff / Easing: 1.00 Time: 0.05秒 / Value: # c8c8c8 / Easing: 1.00 Time: 0.1秒 / Value: # ffffff / Easing: 1.00 「RightButton」ノード ＞「rect_scale」プロパティ Time: 0秒 / Value: (1, 1) / Easing: 1.00 Time: 0.05秒 / Value: (0.9, 0.9) / Easing: 1.00 Time: 0.1秒 / Value: (1, 1) / Easing: 1.00 シングルトンを作る シングルトンというのはプログラミング用語で、インスタンスが1つしかないように設計されたクラスのことで、他の複数のクラスで何らかの共通したプロパティやメソッドを利用する必要がある場合に用いられる。詳しい定義や仕組み、使い方などは、以下のリンク先のリソースをご参照いただきたい。\nMemo: Wikipedia - Singleton パターン Godot 公式オンラインドキュメント - シングルトン(自動読み込み) このチュートリアルでシングルトンを使用する理由は、4種類のプレイヤーキャラクターの「SpriteFrames」のリソースをシングルトンのプロパティとして用意しておけば、「CharacterSelect」シーンの「AnimatedSprite」ノードにも、「Level」シーン＞「Player」＞「AnimatedSprite」ノードにもいつでも利用できるようになるからだ。\n仮に、「CharacterSelect」ノードのプロパティとして「SpriteFrames」のリソースを用意することの弊害が一つある。それは「CharacterSelect」インスタンスノードは用済みになったら「Game」シーンから解放（削除）させる、ということだ。解放してしまうと、リソースの参照先を見失って、プレイヤーキャラクターのスプライトにテクスチャを割り当てることができなくなる。その結果、プレイヤーキャラクターは透明人間状態になってしまう。\n一方、シングルトンのスクリプトで「SpriteFrames」リソースを定義しておけば、他の複数のノードからいつでもそれを参照することができる。\nシングルトンのスクリプトを作る 説明が長くなったが、ここからは以下の手順でシングルトンを実際に作成していこう。\nファイルシステムドックで「res://」フォルダを右クリック＞「新規スクリプト」を選択する。\n「スクリプト作成」ダイアログが表示されたら、継承元を必ず「Node」にして、ファイル名を「Global.gd」として作成する。\n「プロジェクト」メニュー＞「プロジェクト設定」を選択する。 「自動読み込み（AutoLoad）」タブを開きパス入力欄の右側にあるフォルダアイコンをクリックする（Global.gdのパスを直接打ち込んでも良い）。\n「Global.gd」スクリプトを選択して開く。\nパス入力欄に「Global.gd」のファイルパスが入ったら右側の「追加」をクリックする。\n自動読み込みに追加されたことを確認したら、ウインドウを閉じる。ちなみに「グローバル変数」とは他のどのスクリプトのどのスコープからでもアクセスできる変数のことだが、これを利用したいので有効のままで良い。\n以上の作業で、シングルトン「Global.gd」スクリプトがゲーム開始時に一番最初に読み込まれ、常にどのシーンのどのノードのスクリプトからでもシングルトンのプロパティやメソッドにアクセスできるようになった。ゲーム開始時に自動読み込みされる時、自動的に「Node」が作成され、これに「Global.gd」スクリプトがアタッチされる仕組みだ。つまり、このスクリプトに記述するプロパティにアクセスしたければ、この「Node」のプロパティを参照するようコーディングすれば良い。なお、「Node」は自動的にスクリプトと同じ「Global」という名前になるので、簡単にアクセスできる。\nシングルトンのスクリプトを編集する ではシングルトンの「Global.gd」スクリプトを開き、以下のコードを記述しよう。\nextends Node var spriteframes = [ preload(\u0026#34;res://Player/MaskDude.tres\u0026#34;), preload(\u0026#34;res://Player/NinjaFrog.tres\u0026#34;), preload(\u0026#34;res://Player/PinkMan.tres\u0026#34;), preload(\u0026#34;res://Player/VirtualGuy.tres\u0026#34;) ] プリロードされた4種類のプレイヤーキャラクターの「SpriteFrames」リソースを配列にまとめた。これで、プレイヤーキャラクターの4種類のリソースにどこからでも簡単にアクセスできる。\nCharacterSelect にスクリプトをアタッチして編集する 「CharacterSelect」ノードに新規スクリプトをアタッチしよう。ファイルパスは「res://UI/CharacterSelect/CharacterSelect.gd」となるようにする。\nでは作成したシングルトンを利用しつつ、コーディングしていこう。\nextends Control # カスタムシグナル、引数に SpriteFrames リソースの参照を渡す signal character_selected(sprite_frames) # 現在キャラクター選択中のフラグを立てる（true） var is_choosing = true # AnimatedSprite のアニメーションの現在のフレーム番号を保持 var frames_num = 0 # キャラクターの名前の配列（要素の順番はシングルトンの SpriteFrames の配列に合わせる） var characters = [\u0026#34;Mask Dude\u0026#34;, \u0026#34;Ninja Frog\u0026#34;, \u0026#34;Pink Man\u0026#34;, \u0026#34;Virtual Guy\u0026#34;] # シングルトンのノードの参照 onready var global = get_node(\u0026#34;/root/Global\u0026#34;) # CharacterName ノードの参照 onready var char_name = $VBoxContainer/CharacterName # LeftButton ノードの参照 onready var l_button = $VBoxContainer/HBoxContainer/LeftButton # RightButton ノードの参照 onready var r_button = $VBoxContainer/HBoxContainer/RightButton # AnimatedSprite ノードの参照 onready var sprite = $AnimatedSprite # AnimationPlayer ノードの参照 onready var anim_player = $AnimationPlayer func _ready(): # 以下4行: AnimationPlayer のアニメーションで変更されるプロパティに初期値を設定 l_button.modulate = Color(1, 1, 1, 1) l_button.rect_scale = Vector2(1, 1) r_button.modulate = Color(1, 1, 1, 1) r_button.rect_scale = Vector2(1, 1) # 以下のメソッドを呼ぶ（この後定義する） play_animations() # _ready で呼ばれる: AnimatedSprite のアニメーションを制御する func play_animations(): # アニメーションの名前の配列（Array型を指定しないと PoolStringArray 型になる） var animations: Array = sprite.frames.get_animation_names() # 現在再生中のアニメーションの上記配列内の順番 var anim_index = 0 # アニメーションのループ回数をカウントするための変数 var count = 0 # デバッグ用 print(\u0026#34;animations array is \u0026#34;, animations) # アニメーションの名前の配列から不要な要素を削除するため配列の要素でループ for anim in animations: # アニメーションが fall か jump の場合は配列から削除（フレームが1つしかなく面白くないため） if anim == \u0026#34;fall\u0026#34; or anim == \u0026#34;jump\u0026#34;: animations.remove(animations.find(anim)) print(\u0026#34;removed \u0026#34;, anim, \u0026#34; from animations array.\u0026#34;) # 現在キャラクター選択中のフラグが立っている間はループする while is_choosing: # アニメーションの名前の配列から現在の再生中のアニメーションを指定して再生 sprite.play(animations[anim_index]) # 最後のアニメーションフレーム終了まで待機 yield(sprite, \u0026#34;animation_finished\u0026#34;) # アニメーションを一度停止する sprite.stop() # アニメーションが 4 周するまで while ループ if count \u0026lt; 4: count += 1 continue # アニメーションが 4 周したらカウントを 0 にする count = 0 # 現在再生中のアニメーションの番号が、アニメーションの配列の要素数 - 1 より小さい場合は if anim_index \u0026lt; animations.size() - 1: # アニメーションの番号に 1　を加えて、次のアニメーションを再生するように仕込む anim_index += 1 # 現在再生中のアニメーションの番号が、アニメーションの配列の要素数 - 1 になったら else: # 全てのアニメーションを再生したので、アニメーションの番号を 0 に戻して、最初のアニメーションに戻る anim_index = 0 少しコードが長い印象を持たれたかもしれないが、やっていることは単に「AnimatedSprite」ノードに設定済みのアニメーションを自動的に順次再生させているだけである。アニメーションを4周再生したら、次のアニメーションを再生し、全てのアニメーションを4回ずつ再生したらまた最初のアニメーションの再生から始めるようにwhileループを利用して制御している。\n次はキャラクターを切り替える左右のボタンを押した時の制御を実装する。これにはシグナルを利用する。「LeftButton」ノードおよび「RightButton」ノードの「pressed()」シグナルを今編集している「CharacterSelect.gd」スクリプトに接続しよう。\n接続して自動生成されたメソッドを以下のように編集する。ちなみに左ボタンが逆送り、右ボタンが順送りでキャラクターを切り替えるように実装している。\nfunc _on_LeftButton_pressed(): # AnimationPlayer の press_left アニメーションを再生 anim_player.play(\u0026#34;press_left\u0026#34;) # シングルトンの SpriteFrames のリソースの配列から、 # 一つ前のキャラクターのものを AnimatedSprite ノードの frames プロパティに適用する # CharacterName の text プロパティにその SpriteFrames に合致したキャラクターの名前を入れる # 今、配列の最初のリソースを適用している時は配列の最後のリソースを適用する if frames_num \u0026gt; 0: frames_num -= 1 sprite.frames = global.spriteframes[frames_num] char_name.text = characters[frames_num] else: sprite.frames = global.spriteframes[global.spriteframes.size() -1] char_name.text = characters[characters.size() - 1] frames_num = global.spriteframes.size() -1 func _on_RightButton_pressed(): # AnimationPlayer の press_right アニメーションを再生 anim_player.play(\u0026#34;press_right\u0026#34;) # シングルトンの SpriteFrames のリソースの配列から、 # 次のキャラクターのものを AnimatedSprite ノードの frames プロパティに適用する # CharacterName の text プロパティにその SpriteFrames に合致したキャラクターの名前を入れる # 今、配列の最後のリソースを適用している時は配列の最初のリソースを適用する if frames_num \u0026lt; global.spriteframes.size() -1: frames_num += 1 sprite.frames = global.spriteframes[frames_num] char_name.text = characters[frames_num] else: sprite.frames = global.spriteframes[0] char_name.text = characters[0] frames_num = 0 キャラクターを切り替える操作のたびに「AnimatedSprite」の「Frames」プロパティに適切な「SpriteFrames」リソースを適用しているが、その時、シングルトンの「Global.gd」スクリプト内の配列spriteframes から当てはまる要素（SpriteFrames リソース）をピックアップして適用している。\n最後にキーボードでの入力も受け付けられるようにコードを追加する。_inputメソッドは GDScript の組み込み関数で、これを利用してあらゆる入力に対する制御を実装できる。引数のeventは「InputEvent」クラスのオブジェクトで、キーボード入力やマウスクリックなどの入力イベントを指す。さまざまなメソッドが用意されているので、非常に便利である。\n公式オンラインドキュメント: Using InputEvent void _input ( InputEvent event ) virtual InputEvent func _input(event): # 左矢印キーを押したら if event.is_action_pressed(\u0026#34;ui_left\u0026#34;): # 左ボタンアイコンをクリックした時に呼ばれるメソッドを呼ぶ _on_LeftButton_pressed() # 右矢印キーを押したら elif event.is_action_pressed(\u0026#34;ui_right\u0026#34;): # 右ボタンアイコンをクリックした時に呼ばれるメソッドを呼ぶ _on_RightButton_pressed() # スペースキーかエンターキーを押したら elif event.is_action_released(\u0026#34;ui_accept\u0026#34;): # キャラクター選択中のフラグを無効にする is_choosing = false emit_signal(\u0026#34;character_selected\u0026#34;, global.spriteframes[frames_num]) print(\u0026#34;emitted signal: character_selected\u0026#34;) queue_free() print(\u0026#34;CharacterSelect scene is now freed.\u0026#34;) これで「CharacterSelect」シーンの作成は完了だ。\nGame シーンに GameStart シーンと CharacterSelect シーンのインスタンスを追加する それではここまでで作成した「GameStart」シーンと「CharacterSelect」シーンをインスタンス化して「Game」シーンに追加しよう。\n\u0026hellip;といういつもの流れとは少し異なる手順で進める。\nGame シーンツリーを整理する 一旦「Game」シーンツリーを整理しよう。\n「Game」シーンに UI 系のブランチが多いと、各ブランチのスクリプトで制御している入力操作が同時に処理されてしまう可能性があり面倒だ。例えばスタート画面でキーボードのスペースキーでキャラクター選択画面に遷移させただけのつもりが、次の画面のキャラクター選択が同時に確定してしまい、キャラクターを選ぶ間もなく一気にゲームプレイ画面に遷移する、というような問題だ。\nスクリプトのコードを工夫すれば対処可能だが、この問題を完全に回避する分かりやす方法は、必要なノード以外をシーンツリー上に存在させないことだ。そこで、最初の画面である「GameStart」シーンのインスタンス、および入力操作の影響を受けない「HUD」シーンのインスタンスのみを「Game」シーンツリーに追加しておき、他のシーンのインスタンスはスクリプトで、必要な時に作成\u0026amp;追加することにする。\nということで、まずは「Game」シーンで、今回のチュートリアルで作成した「GameStart.tscn」のインスタンスを追加し、前回のチュートリアルで追加済みの「GameOver.tscn」のインスタンスノードを削除しよう。作業後の「Game」シーンツリーは以下のようになる。\nGame.gd スクリプトを更新する ここから「Game.gd」スクリプトで、不要になったノードを削除したり、必要になったノードを追加したり、選択されたキャラクターの「SpriteFrames」リソースを「Level」ブランチ内のプレイヤーキャラクターに適用したり、という処理を実装していく。若干複雑かもしれないが、頑張ってやっていこう。\nそれでは「Game.gd」スクリプトを開いてほしい。そして、まずはプロパティの定義と_readyメソッドまで見ていこう。「# 追加」や「# 削除」とコメントしている行が更新箇所だ。\nextends Node export var current_level = 1 export var final_level = 2 var health: float = 100.0 var score: int = 0 var level: Node2D var player: KinematicBody2D # 選択されたキャラクターの SpriteFrames リソースの参照用 var char_frames: SpriteFrames # 追加 # UI ノードの参照 onready var ui_layer = $UI # 追加 # GameStart ノードの参照 onready var gamestart = $UI/GameStart # 追加 onready var hud = $UI/HUD #onready var gameover = $UI/GameOver # Added @ Part 9 # 削除: シーンツリーから削除した func _ready(): #gameover.visible = false # Added @ Part 9 # 削除: シーンツリーから削除した # GameStart ノードが解放された時に発信されるシグナルを _on_GameStart_tree_exited メソッドに接続 gamestart.connect(\u0026#34;tree_exited\u0026#34;, self ,\u0026#34;_on_GameStart_tree_exited\u0026#34;) # 追加 # 以下 4 行：ゲーム開始時に呼ぶ必要がなくなったので別のメソッドへ移動 #add_level() #hud.update_health(health) #hud.update_score(score) #hud.update_level(current_level) 続いて、先にコード上で接続したシグナル「tree_exited()」の接続先メソッド_on_GameStart_tree_exitedを定義しよう。なお、このシグナルは「GameStart」シーンが解放された時に発信される。\nfunc _on_GameStart_tree_exited(): # CharacterSelect ノードのインスタンスを作成 var char_select = load(\u0026#34;res://UI/CharacterSelect/CharacterSelect.tscn\u0026#34;).instance() # CharacterSelect ノードの character_selected カスタムシグナルを _on_CharacterSelect_character_selected メソッドに接続 char_select.connect(\u0026#34;character_selected\u0026#34;, self ,\u0026#34;_on_CharacterSelect_character_selected\u0026#34;) # UI ノードの子として CharacterSelect インスタンスノードを追加 ui_layer.add_child(char_select) さらに、今しがた「CharacterSelect」ノードから「character_selected」シグナルを接続した_on_CharacterSelect_character_selectedメソッドを編集していく。ちなみにこのシグナルは、キャラクター選択が確定したら発信される。このシグナルは自作したシグナルで、引数sprite_framesを持っている。これを接続先のメソッドの引数に渡す格好だ。\nfunc _on_CharacterSelect_character_selected(sprite_frames): # このスクリプトのプロパティ char_frames に選択したキャラクターの SpriteFrames リソースを渡す char_frames = sprite_frames # 以下 4 行： _ready メソッドからこちらに移動させた add_level() hud.update_health(health) hud.update_score(score) hud.update_level(current_level) 「CharacterSelect.gd」スクリプトでは、「character_selected」シグナル発信後、まもなく「CharacterSelect」ノードは解放される。ここでシングルトンを作成したおかげで、char_framesプロパティは「CharacterSelect」ノードからバトンパスされたかのように、シングルトンの「SpriteFrames」リソースを参照した状態になる。\nキャラクター選択画面の次はゲームプレイの開始となるので、もともと_readyメソッドで実行していたadd_levelメソッドでの「Level」シーンのインスタンス追加や「HUD」ノードの各コンポーネントの初期設定メソッドをこのタイミングで実行させている。\nここでadd_levelメソッドに大事な 1 行を加えることを忘れてはいけない。「Level」ノード＞「Player」ノード＞「AnimatedSprite」ノードの「Frames」プロパティに、キャラクター選択画面で選択したキャラクターの「SpriteFrames」リソースを適用するための 1 行だ。これにより、ゲームプレイ画面のプレイヤーキャラクターが、キャラクター選択画面で選んだキャラクターと同じ見た目になるわけだ。\nfunc add_level(): level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) level.connect(\u0026#34;player_dropped\u0026#34;, self, \u0026#34;_on_Level_player_dropped\u0026#34;) call_deferred(\u0026#34;add_child\u0026#34;, level) # エラー解消のため修正 player = level.get_node(\u0026#34;Player\u0026#34;) player.connect(\u0026#34;enemy_hit\u0026#34;, self, \u0026#34;_on_Player_enemy_hit\u0026#34;) player.connect(\u0026#34;item_hit\u0026#34;, self, \u0026#34;_on_Player_item_hit\u0026#34;) # Player ノードの子 AnimatedSprite ノードに選択したキャラクターの SpriteFrames リソースを適用 player.get_node(\u0026#34;AnimatedSprite\u0026#34;).frames = char_frames # 追加 このあとmanage_healthメソッドまでのコードは今までと変わりない。manage_healthメソッドの変更内容を見ていこう。\n# 中略 func manage_health(damage): health -= damage # Moved from _on_Player_enemy_hit() print(\u0026#34;Health updated: \u0026#34;, health) # Moved from _on_Player_enemy_hit() hud.update_health(health) # Moved from _on_Player_enemy_hit() if health \u0026lt;= 0: player.anim_player.play(\u0026#34;die\u0026#34;) yield(player.anim_player, \u0026#34;animation_finished\u0026#34;) #gameover.visible = true # 削除: シーンツリーから削除しているため不要 # GameOver シーンをインスタンス化 var gameover = load(\u0026#34;res://UI/GameOver/GameOver.tscn\u0026#34;).instance() # 追加 # UI ノードに GameOver シーンのインスタンスノードを追加 ui_layer.add_child(gameover) # 追加 print(\u0026#34;Game over screen is shown up.\u0026#34;) get_tree().paused = true print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) これまでは「GameOver」シーンのインスタンスは最初から「Game」シーンツリーに追加してあったが、さっき削除したので、visibleプロパティの有効化は不要となった。反対に「GameOver」シーンのインスタンスをスクリプト上で追加する必要があるので、そのためのコードを追加した。インスタンスを子ノードにする作業はたった 2 行のコードで実装できるのだ。（子ノードの順番の入れ替えが必要な場合はもう1行必要だ）。\n以上で「Game.gd」スクリプトの編集は完了だ。\n最後にプロジェクトを実行して、今回作成した「GameStart」シーンと「CharacterSelect」シーンがプロジェクトの中でうまく動作するか確認しておこう。\n以下のポイントで問題なさそうなので、ここで今回の作業を終えよう。\n最初にスタート画面が表示された。 スペースキーを押すとプレイヤーキャラクター選択画面が表示された。 プレイヤーキャラクター選択画面で、マウスでの左右ボタンの操作、キーボードでの左右矢印キーの操作によって、キャラクターの名前とスプライトの見た目が順番に切り替わった。 プレイヤーキャラクター選択画面でキャラクターはアニメーションし続けた。 プレイヤーキャラクター選択画面でスペースキーを押すとゲームプレイ画面に遷移した。 ゲームプレイ画面にはプレイヤーキャラクター選択画面で最後に選択したキャラクターが登場した。 Part 10 で編集したスクリプトのコード 最後に今回の Part 10 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nGameStart.gd の全コード extends Control # Added @ Part 10 onready var start_button = $VBoxContainer/StartVBox/StartButton onready var anim_player = $AnimationPlayer func _ready(): start_button.modulate = Color(1, 1, 1, 1) start_button.rect_scale = Vector2(1, 1) func _on_StartButton_button_up(): #print(\u0026#34;_on_StartButton_button_up called.\u0026#34;) anim_player.play(\u0026#34;press_start\u0026#34;) yield(anim_player, \u0026#34;animation_finished\u0026#34;) queue_free() print(\u0026#34;GameStart scene is now freed.\u0026#34;) func _input(event): if event.is_action_released(\u0026#34;ui_accept\u0026#34;): _on_StartButton_button_up() CharacterSelect.gd の全コード extends Control # Added @ Part 10 signal character_selected(sprite_frames) var is_choosing = true var frames_num = 0 var characters = [\u0026#34;Mask Dude\u0026#34;, \u0026#34;Ninja Frog\u0026#34;, \u0026#34;Pink Man\u0026#34;, \u0026#34;Virtual Guy\u0026#34;] onready var global = get_node(\u0026#34;/root/Global\u0026#34;) onready var char_name = $VBoxContainer/CharacterName onready var l_button = $VBoxContainer/HBoxContainer/LeftButton onready var r_button = $VBoxContainer/HBoxContainer/RightButton onready var sprite = $AnimatedSprite onready var anim_player = $AnimationPlayer func _ready(): l_button.modulate = Color(1, 1, 1, 1) l_button.rect_scale = Vector2(1, 1) r_button.modulate = Color(1, 1, 1, 1) r_button.rect_scale = Vector2(1, 1) play_animations() func play_animations(): var animations: Array = sprite.frames.get_animation_names() var anim_index = 0 var count = 0 #print(\u0026#34;animations array is \u0026#34;, animations) for anim in animations: if anim == \u0026#34;fall\u0026#34; or anim == \u0026#34;jump\u0026#34;: animations.remove(animations.find(anim)) #print(\u0026#34;removed \u0026#34;, anim, \u0026#34; from animations array.\u0026#34;) while is_choosing: sprite.play(animations[anim_index]) yield(sprite, \u0026#34;animation_finished\u0026#34;) sprite.stop() if count \u0026lt; 4: count += 1 continue\tcount = 0 if anim_index \u0026lt; animations.size() - 1: anim_index += 1 else: anim_index = 0 func _on_LeftButton_pressed(): anim_player.play(\u0026#34;press_left\u0026#34;) if frames_num \u0026gt; 0: frames_num -= 1 sprite.frames = global.spriteframes[frames_num] char_name.text = characters[frames_num] else: sprite.frames = global.spriteframes[global.spriteframes.size() - 1] char_name.text = characters[characters.size() - 1] frames_num = global.spriteframes.size() - 1 func _on_RightButton_pressed(): anim_player.play(\u0026#34;press_right\u0026#34;) if frames_num \u0026lt; global.spriteframes.size() -1: frames_num += 1 sprite.frames = global.spriteframes[frames_num] char_name.text = characters[frames_num] else: sprite.frames = global.spriteframes[0] char_name.text = characters[0] frames_num = 0 func _input(event): if event.is_action_pressed(\u0026#34;ui_left\u0026#34;): _on_LeftButton_pressed() elif event.is_action_pressed(\u0026#34;ui_right\u0026#34;): _on_RightButton_pressed() elif event.is_action_released(\u0026#34;ui_accept\u0026#34;): is_choosing = false emit_signal(\u0026#34;character_selected\u0026#34;, global.spriteframes[frames_num]) #print(\u0026#34;emitted signal: character_selected\u0026#34;) queue_free() print(\u0026#34;CharacterSelect scene is now freed.\u0026#34;) Global.gd の全コード extends Node # Added @ Part 10 var spriteframes = [ preload(\u0026#34;res://Player/MaskDude.tres\u0026#34;), preload(\u0026#34;res://Player/NinjaFrog.tres\u0026#34;), preload(\u0026#34;res://Player/PinkMan.tres\u0026#34;), preload(\u0026#34;res://Player/VirtualGuy.tres\u0026#34;) ] Game.gd の全コード extends Node # Added @ Part 7 export var current_level = 1 export var final_level = 2 var health: float = 100.0 # Added @ Part 8 var score: int = 0 # Added @ Part 8 var level: Node2D var player: KinematicBody2D var char_frames: SpriteFrames # Added @ Part 10 onready var ui_layer = $UI # Added @ Part 10 onready var gamestart = $UI/GameStart # Added @ Part 10 onready var hud = $UI/HUD # Added @ Part 8 #onready var gameover = $UI/GameOver # Added @ Part 9 # Removed @ Part 10 func _ready(): #gameover.visible = false # Added @ Part 9 # Removed @ Part 10 gamestart.connect(\u0026#34;tree_exited\u0026#34;, self ,\u0026#34;_on_GameStart_tree_exited\u0026#34;) # Added @ Part 10 func _on_GameStart_tree_exited(): # Added @ Part 10 var char_select = load(\u0026#34;res://UI/CharacterSelect/CharacterSelect.tscn\u0026#34;).instance() char_select.connect(\u0026#34;character_selected\u0026#34;, self ,\u0026#34;_on_CharacterSelect_character_selected\u0026#34;) # Added @ Part 10 ui_layer.add_child(char_select) func _on_CharacterSelect_character_selected(sprite_frames): # Added @ Part 10 char_frames = sprite_frames add_level() # Moved @ Part 10 # Modified @ Part 10 hud.update_health(health) # Added @ Part 8 # Moved @ Part 10 hud.update_score(score) # Added @ Part 8 # Moved @ Part 10 hud.update_level(current_level) # Added @ Part 8 # Moved @ Part 10 func add_level(): # Modified @ Part 10 level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) level.connect(\u0026#34;player_dropped\u0026#34;, self, \u0026#34;_on_Level_player_dropped\u0026#34;) # Added @ Part 9 call_deferred(\u0026#34;add_child\u0026#34;, level) # Fixed error player = level.get_node(\u0026#34;Player\u0026#34;) # Added @ Part 8 player.connect(\u0026#34;enemy_hit\u0026#34;, self, \u0026#34;_on_Player_enemy_hit\u0026#34;) # Added @ Part 8 player.connect(\u0026#34;item_hit\u0026#34;, self, \u0026#34;_on_Player_item_hit\u0026#34;) # Added @ Part 8 player.get_node(\u0026#34;AnimatedSprite\u0026#34;).frames = char_frames # Added @ Part 10 func change_level(): if get_tree(): # Added @ Part 9 print(\u0026#34;change_level() called.\u0026#34;) if current_level \u0026lt; final_level: print(\u0026#34;change to next level.\u0026#34;) level.queue_free() current_level += 1 hud.update_level(current_level) # Added @ Part 8 add_level() else: print(\u0026#34;Game Clear! Congrats!\u0026#34;) get_tree().quit() func _on_Player_enemy_hit(damage): # Added @ Part 8 manage_health(damage) # Modified @ Part 9 func _on_Player_item_hit(point): # Added @ Part 8 score += point hud.update_score(score) func _on_Level_player_dropped(): # Added @ Part 9 manage_health(100) func manage_health(damage): # Added @ Part 9 health -= damage # Moved from _on_Player_enemy_hit() @ Part 9 print(\u0026#34;Health updated: \u0026#34;, health) # Moved from _on_Player_enemy_hit() @ Part 9 hud.update_health(health) # Moved from _on_Player_enemy_hit() @ Part 9 # Added @ Part 9 if health \u0026lt;= 0: player.anim_player.play(\u0026#34;die\u0026#34;) yield(player.anim_player, \u0026#34;animation_finished\u0026#34;) #gameover.visible = true # Removed @ Part 10 var gameover = load(\u0026#34;res://UI/GameOver/GameOver.tscn\u0026#34;).instance() # Added @ Part 10 ui_layer.add_child(gameover) # Added @ Part 10 print(\u0026#34;Game over screen is shown up.\u0026#34;) get_tree().paused = true print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) おわりに 以上で Part 10 は完了だ。\n今回はゲームスタート画面とその次のプレイヤーキャラクター選択画面を実装した。スタート画面に比べて、キャラクター選択画面の方は難しく感じられたかもしれない。シングルトンという何やら聞き慣れない単語も出てきたが、複数のシーンで同じデータにアクセスしたい時などに非常に有効な手段であると実感いただけたなら幸いだ。ゲーム開発に限らず、あらゆるオブジェクト指向プログラミングで多用されるデザインパターンなので、知っておいて損はないだろう。\nさて、次回のチュートリアルでは、ゲームプレイ画面に背景テクスチャを追加し、カメラが移動するときに近景のタイルマップは早く動き、遠景の背景テクスチャはゆっくり動く、といういわゆるパララックスエフェクト（視差効果）を実装して、ユーザーエクスペリエンスを高めてみよう。\nでは次回もお楽しみに。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_10/","summary":"第10回目の今回は、ゲーム開始時に表示されるスタート画面を作る。タイトル画面、スタートメニューとも言う。 それだけだと、前回と比べて簡単すぎるので、ゲーム開始時にプレイヤーキャラクターを選択できる仕組み","title":"Godot で作るプラットフォーマー Part 10：スタート画面を作ろう！"},{"content":"第11回目の今回は、ゲームプレイ画面の背景を作る。\n背景と言っても、ただテクスチャ画像を一枚ペタリと貼り付けて終わりだと面白くない。それに、カメラがどれだけ動いても背景が途切れなく繋がっている状態を作るには、ちょっとした工夫（というか Godot の機能）が必要だ。\nまた、プラットフォーマーのゲームでは、大抵、背景がいくつかのレイヤーに別れており、プレイヤー（カメラ）が動いた時に、遠景のレイヤーはゆっくり動き、近景のレイヤーは速く動く、という設定により背景の奥行きが感じられる表現が採用されている。これは、いわゆるパララックスエフェクト（視差効果）というものだ。ありがたいことに Godot にはこのパララックスエフェクトを背景に適用するためのクラスが最初から用意されているので、それらのノードを追加するだけでほとんど作業は完了できる。しかも、なんと言ってもスクリプトのコーディングが不要だ。\nではさっそく始めよう。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー 背景用のテクスチャ画像を用意する 以下のリンクから「Parallax.zip」を別途ダウンロードしてほしい。\nDownload Asset: Dropboxの共有フォルダ ＞ Parallax.zip ダウンロードできたら、zip ファイルを展開して中の「Parallax」フォルダごとファイルシステムの「res://Assets/」に追加しよう。\nなお、2022/03/25 以降に Part 1 でアセットをダウンロードされた方は、Godot のファイルシステムの「res://Assets/Parallax/」のフォルダとその中の背景用画像 4 つがすでに含まれているはずだ。\nこれで背景用のテクスチャ画像は用意できた。\n背景のシーンを作る ここからはパララックスエフェクトを備えた背景用のシーンを作成していく。今回はノードを追加しつつ、適宜そのプロパティを編集する、という流れで進めていく。\nシーンを作る それで以下の手順で、新しい背景用のシーンを作ろう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードの生成」で「その他のノード」を選択する。 「ParallaxBackground」クラスをルートノードとして選択し、名前を「Background」に変更する。 一旦、シーンを保存する。「res://」に「Background」フォルダを作成した上で、ファイルパスが「res://Background/Background.tscn」となるようにして保存する。 公式オンラインドキュメント: ParallaxBackground ノードを追加して適宜プロパティを編集する 続いて「Background」ルートノードに必要な子ノードを追加し、同時にプロパティも編集していく。\nシーンドックにて「ParallaxBackground」ルートノードに「ParallaxLayer」ノードを追加して、名前を「ParallaxLayer1」に変更する。\n「ParallaxLayer1」ノードの「Motion」＞「Mirroring」プロパティを (384, 256) にする。\nなお、この値はプロジェクト設定のウインドウサイズと同じだ。設定した x, y の位置で適用した背景用テクスチャが繰り返し表示されるようになる。ファイルシステムに追加した背景用テクスチャの画像はウインドウサイズと同じにしてあるので、途切れなくその画像が繰り返し表示されるようになるはずだ。テクスチャはのちほど適用するのでご安心を。\n「ParallaxLayer1」ノードに「Sprite」ノードを追加する。\n「Sprite」ノードの「Texture」プロパティの設定はあとで行うので、ここでは一旦置いておく。\n「Sprite」ノードの「Offset」＞「Centered」プロパティをオフにする。\n「Centered」プロパティをオフにすることにより、ノードの位置の基準が中央ではなく左上になる。背景用テクスチャを適用するための「Sprite」ノードなので、そのほうが好都合なのだ。\n「ParallaxLayer」ブランチ（子の「Sprite」を含む）を 3 回複製する。この操作はショートカットキーが便利だ（Windows: Ctrl + D / macOS: Cmd + D）。シーンツリーが以下のようになればOKだ。\n公式オンラインドキュメント ParallaxLayer ここからは、複製したそれぞれの「ParallaxLayer」ノードの子の「Sprite」ノードのプロパティを編集していく。と言っても編集するのは「Texture」プロパティと「Modulate」プロパティの2つだけだ。なお、「Texture」プロパティは、このチュートリアルの冒頭で用意した（もしくはチュートリアル Part 1 で用意した」テクスチャ画像をいつも通りファイルシステムドックからドラッグ\u0026amp;ドロップで適用すれば良い。\nでは、以下の内容でそれぞれのプロパティを編集しよう。\n「ParallaxLayer1」＞「Sprite」ノード 「Texture」プロパティ：「res://Assets/Parallax/Space.png」 「Visibility」＞「Modulate」プロパティ：デフォルトのまま変更しない 「ParallaxLayer2」＞「Sprite」ノード 「Texture」プロパティ：「res://Assets/Parallax/Stars_l.png」 「Visibility」＞「Modulate」プロパティ：# a0a0a0（グレー） 「ParallaxLayer3」＞「Sprite」ノード 「Texture」プロパティ：「res://Assets/Parallax/Stars_m.png」 「Visibility」＞「Modulate」プロパティ：# c8c8c8（薄いグレー） 「ParallaxLayer4」＞「Sprite」ノード 「Texture」プロパティ：「res://Assets/Parallax/Stars_s.png」 「Visibility」＞「Modulate」プロパティ：デフォルトのまま変更しない シーンを実行してみると、以下のような星空の背景ができたはずだ。\n続いて、キャラクター（カメラ）が移動した時に、遠景（小さな星々）はゆっくり、近景（やや大きめの星々）は少し速くスクロールするという仕組みを「ParallaxLayer」クラスのプロパティを編集して再現する。\nなお、一番後ろの「ParallaxLayer1」の「Sprite」に適用したテクスチャはベタ塗りの濃紺色の画像なので、このレイヤーの動きは気にする必要はない。\n「ParallaxLayer」2 ~ 4 の「Motion」＞「Scale」プロパティを以下のように編集する。\n「ParallaxLayer2」の「Motion」＞「Scale」プロパティ：(0.1, 0.1) 「ParallaxLayer3」の「Motion」＞「Scale」プロパティ：(0.2, 0.2) 「ParallaxLayer4」の「Motion」＞「Scale」プロパティ：(0.4, 0.4) なお、「Motion」＞「Scale」プロパティの値は 0 だと全くスクロールせず、1 だとカメラと同じ速度だ。「ParallaxLayer」の 1 が最背面、 4 が最前面の背景レイヤーになるので、星々のテクスチャを適用している 2 が通常のカメラの 1/10 の速度、3 が 1/5 の速度、4 が 2/5 の速度で動く設定とした。。\nこれでパララックスエフェクトが実装できたはずだ。\nGame シーンに Background シーンのインスタンスを追加する 作成した「Background」シーンをインスタンス化して「Game」シーンに追加しよう。まずは「Game.tscn」を開いて欲しい。\n「Game」ルートノードに「Background」シーンのインスタンスを追加し、「Game」の子の順番を「Background」ノードが一番最初（最背面）になるように変更する。\n「Game」シーンツリーは以下のようになったはずだ。\n2Dワークスペース上は以下のような表示になっているが、これで問題ない。\nではプロジェクトを実行してみよう。\nパララックスエフェクトを感じることができただろうか。今回の背景の実装は以上で完了だ。\nおわりに 以上で Part 11 は完了だ。\n今回はパララックスエフェクトを含む背景シーンを作成した。このチュートリアルで作成しているプラットフォーマーは完全に2Dだが、今回、パララックスエフェクトを含む背景を追加して、一気に空間が広がったような印象になったのを体感いただけたのではないだろうか。ゲームの仕組みに直接関わるところではないが、ビジュアル面でのユーザエクスペリエンスを向上させるための一つの手段として覚えておきたい。\nまた、今回は星空をイメージした背景にしたが、例えば、遠景に小さめの木々、中景にはやや大きめの木々、近景には画面をはみ出すほど大きい木や草花をそれぞれテクスチャとして用意すれば、森の中のような背景を作ることも簡単にできそうだ。他にもゲームの世界観に合わせてテクスチャを用意するだけで、あらゆる場面の背景が作成可能になるだろう。\nさて、次回のチュートリアルでは、同じくビジュアル面での機能追加になるが、光と影の演出をしてみたいと思う。\nそれでは次回もお楽しみに。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_11/","summary":"第11回目の今回は、ゲームプレイ画面の背景を作る。 背景と言っても、ただテクスチャ画像を一枚ペタリと貼り付けて終わりだと面白くない。それに、カメラがどれだけ動いても背景が途切れなく繋がっている状態を作る","title":"Godot で作るプラットフォーマー Part 11：背景を作ろう！"},{"content":"第12回目の今回は、ゲームプレイ画面に光と影の演出、というテーマでやっていく。前回に引き続き、ビジュアル面でのゲームのアップデートだ。結果が目に見えてわかりやすいのと、今回もスクリプト不要の内容なので、気楽にやっていこう。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー 公式オンラインドキュメントの「2Dライトとシャドウ」という項目の説明も、今回の内容と関連性が高くて参考になるのでご一読いただくことをお勧めする。\n公式オンラインドキュメント： 2Dライトとシャドウ Level2 シーンのタイルマップを確認する チュートリアル Part 7 で作成した「Level2」シーンがちょうどダンジョンっぽいタイルマップなので、このシーンを編集する形で、光と影の演出を加えることにしよう。もし、「Level2」シーンが未作成の場合は、以下のリンクからチュートリアル Part 7 を参考に、簡単なダンジョンのタイルマップを含むシーンを作成してほしい。\n関連チュートリアル： Godot で作るプラットフォーマー Part 7：次のレベルに遷移させよう！ #Level2 シーンを作る また、ダンジョンのタイルマップに使用しているグレーのブロックのタイルセットにオクルージョンの設定をしていない場合は、このタイミングで設定しておこう。手順は以下のリンクからチュートリアル Part 2 の「#タイルセットを作る」の項目をご参考いただきたい。\n関連チュートリアル： Godot で作るプラットフォーマー Part 2：タイルマップを作ろう！ #タイルセットを作る シーンを全体的に暗くする 世界は光がなければ真っ暗闇だ。光を追加する前に「Level2」シーン全体を十分に暗くしておく。\nノードごとの色の変更は、「Modulate」プロパティを編集すれば良い、というのは過去の作業で思いつきそうだが、さすがに一つ一つのノードの色を変えるのは手間がかかりすぎてやっていられないだろう。そこで便利なクラスがある。「CanvasModulate」だ。このクラスのノードをシーンに追加すれば、シーン全体の色調を変更することができるのだ。\n公式オンラインドキュメント： CanvasModulate それでは「Level2.tscn」を開いたら、以下の手順でシーン全体を暗くしよう。\nシーンドックで「Level2」ルートノードに「CanvasModulate」を追加する。\nインスペクターで「CanvasModulate」ノードの「Color」プロパティの値を # 0f4855 に変更する。ただし、チュートリアルのサンプルとして深めの緑色に設定したが、お好みで他の暗めの色にしていただいても問題ない。\nこれで「Level2」シーン全体が、明かりが欲しくなる程度には十分暗くなっただろう。次に光を追加していく。\nシーンに光を追加する プレイヤーキャラクターを光源として、その周りだけ少し明かりが届いている状態になるように調整していく。\nちなみに、プレイヤーキャラクターを光源にするのはプレイヤーキャラクターの視界を表現した演出であって、キャラクターが光を発しているというわけではない。実際に懐中電灯などの光源をキャラクターに持たせる方法なら違和感はないのだが、今回は本題から逸れるのを避けるため不採用とする。\n光のテクスチャ画像を取り込む ではここで、光のテクスチャ画像を用意する。\n以下のリンクから「Light.zip」を別途ダウンロードしてほしい。\nDownload Asset: Dropboxの共有フォルダ ＞ Light.zip ダウンロードできたら、zip ファイルを展開して中の「Light.png」ファイルをファイルシステムドック上で「res://Assets/Other/」にドラッグ\u0026amp;ドロップして追加しよう。\nなお、2022/03/26 以降に Part 1 でアセットをダウンロードされた方は、Godot のファイルシステムの「res://Assets/Other/」のフォルダに「Light.png」ファイルが最初から入っているはずだ。\nLight2D ノードを追加してプロパティを編集する では引き続き「Level2」シーンを編集していく。\n「Player」ノードに「Light2D」ノードを追加する。これはプレイヤーキャラクターと一緒に光源も移動させるためだ。\n「Light2D」ノードの「Texture」プロパティに、光のテクスチャである「res://Assets/Other/light.png」を適用する。 テクスチャ画像がやや大きめなため「Texture Scale」プロパティを 0.25 にする。 若干だが光が強すぎる印象のため「Energy」プロパティを 0.9 にする。 「Shadow」＞「Enabled」をオンにして、オクルージョンを設定している範囲に対して影を落とす機能を有効にする。\n以上で「Light2D」ノードのプロパティ編集は完了だ。ただし、今回触らなかったプロパティなど気になる場合は、公式オンラインドキュメントを参照いただきたい。\n公式オンラインドキュメント： 2Dライトとシャドウ Light2D シーンを実行する 一通りの作業を終えたので、最後に一度シーンを実行してみよう。ちなみに以下のGIF画像は 2 倍速だ。\nなんともGIF画像のライトが荒いが、実際のデバッグパネル上には滑らかに光が描画されている。これにて今回の光と影の実装は完了だ。\nおわりに 以上で Part 12 は完了だ。\n今回は光と影の演出を実装した。「CanvasModulate」ノードを追加してシーン全体の色味を変更する方法や、「Light2D」ノードを追加して光源の基本的な調整方法を学習した。これらを応用すれば、例えばダンジョン内の松明を「Light2D」と「Particle2D」を合わせて表現したり、夜の街並みの街路灯を量産することができるだろう。視覚的な表現なので、ゲームデザインに直接は関わらないものの、使い所はかなり多いはずなので、ぜひ覚えておきたい内容だ。\nさて、次回のチュートリアルでは、SFX（サウンドエフェクト）や BGM などの音をゲームに追加していく。\nそれでは次回もお楽しみに。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_12/","summary":"第12回目の今回は、ゲームプレイ画面に光と影の演出、というテーマでやっていく。前回に引き続き、ビジュアル面でのゲームのアップデートだ。結果が目に見えてわかりやすいのと、今回もスクリプト不要の内容なので","title":"Godot で作るプラットフォーマー Part 12：光と影を演出しよう！"},{"content":"第13回目の今回は、ゲームにサウンドを追加する。ゲームに使われるサウンドというのは、大きく分けて2種類ある。バックグラウンドミュージック（BGM）と効果音（サウンドエフェクト：SFX）だ。Godot Engine ではどちらも追加する方法に大きな違いはない。素材さえ用意すれば、追加するのは比較的簡単だ。特定のタイミングでサウンドを鳴らしたい時、例えば、プレイヤーキャラクターがジャンプした時にジャンプの効果音を鳴らしたい場合などには、プログラミングして制御する必要があるが、複雑なコードにはならないので安心してほしい。\n今回のチュートリアルには GIF 画像ではなく mp4 フォーマットの動画を載せている。この記事の閲覧環境は様々だと思われるため、デフォルトではサウンドをミュートしている。動画のコントローラでミュート解除していただきつつ、確認いただきたい。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー 以下の公式オンラインドキュメントのページに、サウンド関係のリンクがまとまっている。今回このチュートリアルで扱う内容以外の有益な情報も含まれるので、併せて目を通していただくとよりわかりやすいだろう。\n公式オンラインドキュメント： オーディオ サウンドの素材を準備する サウンドの素材をファイルシステムに追加する ゲームにサウンドを追加するには、まずサウンドの素材を用意する必要がある。ご自身で作曲する場合もあれば、アセットストアなどで誰かが作曲したものをダウンロードする場合もあるだろう。\n今回はチュートリアル用に音源ファイルを用意しているので、以下のリンクから「Audio.zip」をダウンロードしてほしい。\nDownload Asset: Dropboxの共有フォルダ ＞ Audio.zip ダウンロードできたら、.zip ファイルを展開して中の「Audio」フォルダを取り出してほしい。プロジェクトのファイルシステムドックで「res://Assets/」フォルダを選択した状態にし、そのフォルダ目掛けて「Audio」フォルダごとドラッグ\u0026amp;ドロップで追加しよう。\nなお、2022/04/06 以降に Part 1 でアセットをダウンロードされた方は、Godot のファイルシステムの「res://Assets/」のフォルダに各種オーディオファイルを格納した「Audio」フォルダが最初から入っているはずだ。\nBGM 用の素材のループ設定を調整する SFX は、特定のタイミングで都度、一回サウンドを鳴らすだけだが、BGM に関しては曲が最後まで終わったらまた頭から再生する、つまりループさせる必要がある。\n.ogg や .mp3 フォーマットのリソースだと、デフォルトでループの設定が有効になっており、.wav フォーマットだとループは無効になっているようだ。\nゲームのサウンドに関しては一般的に、BGM 用の曲は長いので、ファイルサイズの関係から、圧縮した .ogg または .mp3 が推奨されている。一方、SFX 用のサウンドは短いので、非圧縮形式の .wav フォーマットであることが多い。ループのデフォルトの設定は、この背景に由来する仕様だと考えられる。\n先ほど追加していただいたこのチュートリアル用のサウンド素材についても、BGM 用は .ogg フォーマット、SFX 用は .wav フォーマットにしているので、どれがどっちの素材かはファイル名の拡張子を見ればすぐに判別していただけるだろう。\n具体的に、それぞれのサウンド素材のループの設定を確認する手順は以下の通りだ。\nファイルシステムドックで音源ファイルを選択する\nそのままインポートドックでループの設定を確認する BGM 用 .ogg ファイルの場合：\nSFX 用 .wav ファイルの場合：\nもしループの設定がおかしい（BGM 用なのにループが無効、または SFX 用なのにループが有効）場合は、ループの設定のチェックを切り替えて、「再インポート」ボタンをクリックすれば、設定が変更された状態で素材ファイルが再インポートされる。\n公式オンラインドキュメント： オーディオサンプルのインポート ところで、今回インポートしていただいた素材のうち、BGM 用のサウンド素材で 1 つだけループ開始位置を編集する必要がある。「Level1」シーンで使用する予定の「Land.ogg」だ。イントロは初回のみ再生され、それ以降ループされて再生位置が前に戻るときは、曲の頭ではなくイントロ部分を省いた位置から再生されるようにしたい。これも Godot エディタ上で調整できる。以下の手順で実際に編集しよう。\nファイルシステムドックで「res://Assets/Audio/Land.ogg」を選択し、インポートドックを開く 「Loop Offset」のパラメータをイントロが終わる秒数「9.142」に設定して、「再インポート」ボタンをクリック\nちなみに、今後、ご自身で作曲される場合に役立つのでループ開始位置の計算方法もお伝えしておく。\nまず曲全体の長さを確認する。Godot エディタ上で確認する場合は、ファイルシステムで該当のファイルをダブルクリックすると、インスペクターにファイルの情報が表示される。この時、一番右下に表示されている秒数が曲の長さだ。「Land.ogg」の場合は 32.00 秒となっている（単位の s は seconds の略）。\n「曲の長さ」÷「曲全体の小節数」=「1小節の長さ」が求められる。 「1小節の長さ」×「イントロの小節数」でイントロの長さが求められる。 「Land.ogg」の場合「曲全体の小節数」は 28 小節「イントロの小節数」は 8 小節なので\n32.00 ÷ 28 × 8 = 9.142\u0026hellip;\nと、割り切れない場合は、小数点以下第3位までで切り捨て、または小数点以下第4位で四捨五入する。0.001秒の差はほとんど気にならないからどちらでも大丈夫だ。 さて、これでサウンド素材の下準備は完了だ。ここからの全体的な作業の流れとしては、先にゲームのパーツになる SFX のみ必要なシーン（「Player」や「Item」など）から編集し、そのあと画面を構成する大きなシーン（「GameStart」や「Level1」など）に BGM、SFX を追加していく。\nシーンごとの作業は以下の順番で進めていこう。\nノードの追加 ノードのプロパティの編集 スクリプトのアタッチ＆コーディング Player シーン それではまずはじめに「Player.tscn」を開いてサウンドを追加していこう。このシーンに必要な SFX は、以下の4種類だ。\nプレイヤーキャラクターの足音 プレイヤーキャラクターがジャンプする音 プレイヤーキャラクターが敵に当たってダメージを受けた時の音 プレイヤーキャラクターのヘルスがゼロになった時の音 AudioStreamPlayer2D ノードを追加する 「Player」ルートノードに「AudioStreamPlayer2D」クラスのノードを4つ追加して、それぞれ「StepSFX」「JumpSFX」「DamageSFX」「DieSFX」という名前にそれぞれ変更しよう。これらのノードは先述した 4 つの効果音ごとに分けて利用する。\nなお、「AudioStreamPlayer」は位置に関係なくサウンドを再生するが、「AudioStreamPlayer2D」は画面上の位置を利用して、カメラとの距離が遠ければ音量を小さくするなどできる。このチュートリアルではその辺りの細かな演出をする機会はないが、画面上に配置するオブジェクトのシーンであれば「AudioStreamPlayer2D」を利用するという認識を持っておいて良いだろう。\n公式オンラインドキュメント： AudioStreamPlayer2D AudioStreamPlayer AudioStreamPlayer2D ノードを編集する 以下のノードとリソースの組み合わせで、それぞれのノードの「Stream」プロパティに適切なサウンドリソースを適用しよう。ファイルシステムドックから下記のリソースファイルをインスペクター上の「Stream」プロパティめがけてドラッグ\u0026amp;ドロップする。\n「StepSFX」ノード：res://Assets/Audio/FootStep.wav 「JumpSFX」ノード：res://Assets/Audio/Jump.wav 「DamageSFX」ノード：res://Assets/Audio/TakeDamage.wav 「DieSFX」ノード：res://Assets/Audio/Die.wav この「Player」シーンを含めて、基本的に「Stream」プロパティ以外の編集が不要なシーンが多いが、音量が大きすぎる、または小さすぎると感じる場合は、適宜「Volume Db」プロパティの値で調整して欲しい。音量の確認は「Stream」プロパティの適用済みリソースをクリックし、インスペクター下部の再生/停止ボタンを利用するのが良いだろう。\nスクリプトを編集して SFX の再生を制御する 「Player.gd」スクリプトを編集してサウンド再生を制御する。\nまずは以下の 4 つの「AudioStreamPlayer2D」ノードを参照するプロパティを定義する。\nonready var step_sfx = $StepSFX # 追加 onready var jump_sfx = $JumpSFX # 追加 onready var damage_sfx = $DamageSFX # 追加 onready var die_sfx = $DieSFX # 追加 足音 まずはプレイヤーキャラクターが走っている時の足音から追加しよう。\n「StepSFX」のサウンドは、「AnimatedSprite」ノードの「run」アニメーションでキャラクターのテクスチャの足が地面についたタイミングでだけ再生したい。アニメーションを確認すると、Frame 4 と 10 がそれに該当することがわかる。\nこれを実現するには、Frame が変わるたびに発信されるシグナルを利用し、if構文で「run」アニメーション再生時の Frame の数を指定すれば良い。\nさっそくシグナルの接続を行おう。「AnimatedSprite」ノードの「frame_changed()」シグナルを「Player.gd」スクリプトに接続すればOKだ。\nスクリプトに_on_AnimatedSprite_frame_changedメソッドが追加されたら、それを以下のように編集しよう。\nfunc _on_AnimatedSprite_frame_changed(): if sprite.animation == \u0026#34;run\u0026#34;: if sprite.frame == 4 or sprite.frame == 10: step_sfx.play() これで足音の SFX が追加できたはずだ。「Level1」シーンで確認してみよう。\nYour browser does not support the video tag. ジャンプする音 次はプレイヤーキャラクターがジャンプした時の音を追加する。これには_physics_processメソッド内でジャンプを制御しているコードの箇所にサウンド再生のコードを追加すれば良い。以下のコードの「# 追加」のコメントがあるたった 1 行が更新箇所だ。\nfunc _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.flip_h = x_input \u0026lt; 0 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force # JumpSFXノードのサウンドを再生する（ジャンプ音） jump_sfx.play() # 追加 else: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 velocity = move_and_slide(velocity, Vector2.UP) # Added @ Part 3 if position.x \u0026lt; 16: position.x = 16 「Level1」シーンで確認してみよう。\nYour browser does not support the video tag. 敵に当たってダメージを受けた時の音 続いて、プレイヤーキャラクターが敵キャラクターに当たってダメージを受けた時のサウンド再生を制御する。これは既存の_on_HitBox_body_enteredメソッドにサウンド再生のコードを少し足すだけだ。このメソッドは「HitBox」ノードのコリジョン形状に敵キャラクターを含む物理ボディが当たったら呼ばれる。\n# HitBox ノードのコリジョン形状に物理ボディが当たった時に呼ばれるメソッド func _on_HitBox_body_entered(body): if body.is_in_group(\u0026#34;Enemies\u0026#34;): print(\u0026#34;Enemy hit player. Damage is \u0026#34;, body.damage) emit_signal(\u0026#34;enemy_hit\u0026#34;, body.damage) sprite.play(\u0026#34;hit\u0026#34;) # DamageSFX ノードのサウンドを再生する damage_sfx.play() # 追加 「Level1」シーンで確認してみよう。\nYour browser does not support the video tag. ヘルスがゼロになって死んだ時の音 プレイヤーキャラクターに実装する最後の SFX は死亡した時のサウンドだ。敵に当たるか、画面下へ落下してヘルスバーが 0 になった場合に再生されるようにする。ヘルスバーの制御は「Game.gd」スクリプトの方でやっているので、そちらを編集しよう。\n「Game.gd」スクリプトを開いたらmanage_healthメソッドに 1 行追加するだけだ。「# 追加」のコメントをしている箇所だ。\nfunc manage_health(damage): health -= damage print(\u0026#34;Health updated: \u0026#34;, health) hud.update_health(health) if health \u0026lt;= 0: player.anim_player.play(\u0026#34;die\u0026#34;) # Player インスタンスノードの DieSFX ノードのサウンドを再生 player.die_sfx.play() # 追加 yield(player.anim_player, \u0026#34;animation_finished\u0026#34;) var gameover = load(\u0026#34;res://UI/GameOver/GameOver.tscn\u0026#34;).instance() ui_layer.add_child(gameover) print(\u0026#34;Game over screen is shown up.\u0026#34;) get_tree().paused = true print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) ヘルスが 0 以下になった時に「die」アニメーションと同時に SFX も再生される。そして、再生が終了するまで待機してからゲームオーバー画面に遷移する。\nでは実際にプロジェクトを実行して挙動を確認しておこう。\nYour browser does not support the video tag. Enemy シーン 続いて敵キャラクターのサウンドを実装する。敵キャラクターのサウンドはプレイヤーキャラクターに踏まれた時の SFX のみだ。では「Enemy.tscn」シーンファイルを開いて編集していこう。\nAudioStreamPlayer2D ノードを追加してプロパティを編集する 「Enemy」ルートノードに「AudioStreamPlayer2D」クラスのノードを 1 つ追加しよう。同じクラスのノードは他にないので、名前はそのままにしておこう。\n「AudioStreamPlayer2D」ノードの「Stream」プロパティに「res://Assets/Audio/HitEnemy.wav」を適用しよう。必要に応じて「Volume Db」プロパティで音量を調整してほしい。\nスクリプトを編集して SFX の再生を制御する 「Enemy.gd」スクリプトを開いて、編集していこう。SFX の再生を制御する。\nまずはこれまで同様、「AudioStreamPlayer2D」ノードを参照するプロパティを定義しよう。\n# AudioStreamPlayer2D ノードの参照 onready var audio_player = $AudioStreamPlayer2D 続けて、プレイヤーキャラクターを含む物理ボディが、「HitBox」のコリジョン形状に入った時に呼ばれる_on_HitBox_body_enteredメソッドを更新する。「# 追加」とコメントしている行が更新箇所だ。\n# 物理ボディが HitBox に入ったら呼ばれるメソッド func _on_HitBox_body_entered(body): if body.is_in_group(\u0026#34;Players\u0026#34;): print(\u0026#34;Player entered in \u0026#34;, self.name) sprite.play(\u0026#34;hit\u0026#34;) # AudioStreamPlayer2D ノードのサウンドを再生 audio_player.play() # 追加 yield(sprite, \u0026#34;animation_finished\u0026#34;) # AudioStreamPlayer2D のサウンド再生が終了するまで待機 yield(audio_player, \u0026#34;finished\u0026#34;) # 追加 queue_free() print(self.name, \u0026#34; died\u0026#34;) これで、プレイヤーキャラクターが敵キャラクターを踏んづけた時に、SFX が再生され、再生が終了してからqueue_freeメソッドにて敵キャラクターオブジェクトが解放される。\nでは「Level1」シーンを実行して動作確認をしておこう。\nYour browser does not support the video tag. Item シーン 続いてアイテムのサウンドを実装する。アイテムのサウンドはプレイヤーキャラクターが当たった時の SFX のみだ。ちょうどスーパーマリオがコインを取った時の「キラン」という SFX と同様の演出だ。では「Item.tscn」シーンファイルを開いて編集していこう。\nAudioStreamPlayer2D ノードを追加してプロパティを編集する 「Item」ルートノードに「AudioStreamPlayer2D」クラスのノードを1つ追加しよう。同じクラスのノードは他にないので、今回も名前はそのままだ。\n「AudioStreamPlayer2D」ノードの「Stream」プロパティに「res://Assets/Audio/GetItem.wav」を適用しよう。必要に応じて「Volume Db」プロパティで音量を調整しよう。\nスクリプトを編集して SFX の再生を制御する では「Item.gd」スクリプトを編集して SFX を制御していく。\n例によって、まずは「AudioStreamPlayer2D」ノードを参照するプロパティを定義しよう。\n# AudioStreamPlayer2D ノードの参照 onready var audio_player = $AudioStreamPlayer2D # 追加 続けて、プレイヤーキャラクターを含む物理ボディが、「Item」のコリジョン形状に入った時に呼ばれるメソッドを更新する。「# 追加」とコメントしている行が更新箇所だ。\nfunc hit(body): print(\u0026#34;Got \u0026#34;, point, \u0026#34; point.\u0026#34;) body.emit_signal(\u0026#34;item_hit\u0026#34;, point) anim_player.play(\u0026#34;hit\u0026#34;) # AudioStreamPlayer2D ノードのサウンドを再生する audio_player.play() # 追加 yield(anim_player, \u0026#34;animation_finished\u0026#34;) # AudioStreamPlayer2D のサウンド再生が終了するまで待機 yield(audio_player, \u0026#34;finished\u0026#34;) # 追加 queue_free() これで、アイテムを取ったら、SFX が再生されてからアイテムが解放されるようになったはずだ。\nこのまま続けて「BrokenBox」シーンのサウンドも追加していこう。\nBrokenBox シーン アイテムボックスに追加するサウンドは、壊れた時の SFX だ。「ItemBox.tscn」シーンファイルを編集したいところだが、一番簡単なのは、壊れた時に「ItemBox」シーンツリーにそのインスタンスが追加される「BrokenBox.tscn」の方だ。ではこのシーンを開いて編集していこう。\nAudioStreamPlayer2D ノードを追加してプロパティを編集する 「BrokenBox」ルートノードに「AudioStreamPlayer2D」ノードを追加しよう。\n追加した「AudioStreamPlayer2D」ノードにの「Stream」プロパティにリソース「res://Assets/Audio/BreakBox.wav」を適用しよう。\nスクリプトを編集して SFX の再生を制御する 続けて「BrokenBox.gd」スクリプトを以下のように編集する。\nまずは「AudioStreamPlayer2D」ノードを参照するプロパティを定義。\n# AudioStreamPlayer2D ノードの参照 onready var audio_player = $AudioStreamPlayer2D 次に_readyメソッド内にサウンド再生のコードを追加し、シーンが読み込まれたらサウンを再生するようにする。\nfunc _ready(): emitting = true # ノードが読み込まれたら AudioStreamPlayer2D ノードのサウンドを再生 audio_player.play() これで箱が壊れた瞬間にこのシーンが読み込まれ、同時に SFX が再生されるはずだ。\nではアイテムを取った時の音とアイテムボックスが壊れた時の音がそれぞれ正しく再生されるか、「Level1」シーンでまとめて確認してみよう。\nYour browser does not support the video tag. StartPoint シーン スタートポイントはそれぞれのレベルでプレイヤーキャラクターが最初に降り立つ場所に設置している市松模様の台と右向き矢印の標識がテクスチャのシーンだ。市松模様の台の上にコリジョン形状を設定しているので、そこに乗ったら、適当な SFX が鳴るようにする。\nでは「StartPoint.tscn」シーンファイルを開いて編集していこう。\nAudioStreamPlayer ノードを追加してプロパティを編集する 「StartPoint」ルートノードに「AudioStreamPlayer2D」クラスのノードを1つ追加しよう。同じクラスのノードは他にないので、名前はそのままでも良いだろう。\n次に、インスペクタードックで「AudioStreamPlayer2D」ノードのプロパティを編集する。「Stream」プロパティにリソースファイル「res://Assets/Audio/StartPoint.wav」を適用しよう。\nスクリプトを編集して SFX の再生を制御する 「StartPoing.gd」スクリプトを編集してサウンド再生を制御する。\nまずは「AudioStreamPlayer2D」ノードを参照するプロパティを定義する。\n# AudioStreamPlayer2D ノードの参照 onready var audio_player = $AudioStreamPlayer2D # 追加 次に以下のメソッドを更新しよう。「# 追加」のコメントの行が更新箇所だ。\n# 物理ボディが Area2D ノードのコリジョン形状に入ったら呼ばれるメソッド func _on_StartPoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: sprite.play(\u0026#34;moving\u0026#34;) # AudioStreamPlayer2D ノードのサウンドを再生 audio_player.play() # 追加 これで、スタートポイントの台にプレイヤーキャラクターが乗ったら SFX が再生されるようになったはずだ。\n「Level1」シーンを再生して確認してみよう。\nYour browser does not support the video tag. Checkpoint シーン チェックポイントは、各レベルの真ん中くらいに設置している通過点で、最初はただのポールだが、プレイヤーキャラクターが当たるとポールに市松模様のフラグがつく。これも当たった時に適当な SFX が鳴るようにする。\nでは「Checkpoint.tscn」シーンファイルを開いてサウンドを追加していこう。\nAudioStreamPlayer2D ノードを追加してプロパティを編集する 「Checkpoint」ルートノードに「AudioStreamPlayer2D」クラスのノードを1つ追加しよう。\n続けて「AudioStreamPlayer2D」ノードの「Stream」プロパティにリソース「res://Assets/Audio/Checkpoint.wav」を適用する。\nスクリプトを編集して SFX の再生を制御する 「Checkpoint.gd」スクリプトを編集してサウンド再生を制御する。\nまずは以下のプロパティを追加する。\n# AudioStreamPlayer2D ノードの参照 onready var audio_player = $AudioStreamPlayer2D # 追加 次に以下のメソッドを更新しよう。\n# 物理ボディがコリジョン形状に入ったら呼ばれるメソッド func _on_Checkpoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34; and not is_checked: sprite.play(\u0026#34;flag_out\u0026#34;) # AudioStreamPlayer2D ノードのサウンドを再生 audio_player.play() # 追加 yield(sprite, \u0026#34;animation_finished\u0026#34;) sprite.play(\u0026#34;flag_idle\u0026#34;) is_checked = true これで、プレイヤーキャラクターがチェックポイントのフラグに当たると SFX が再生されるはずだ。これも「Level1」シーンで確認してみよう。\nYour browser does not support the video tag. EndPoint シーン エンドポイントは各レベルのゴールとして用意している、優勝カップのようなテクスチャのオブジェクトだ。このカップにプレイヤーキャラクターが入ると次のシーンにワープするような演出のアニメーションが再生される。これに合わせるようにして、ワープっぽい SFX を同時に再生させよう。\nでは「EndPoint.tscn」シーンファイルを開いて編集していく。\nAudioStreamPlayer2D ノードを追加してプロパティを編集する 「EndPoint」ルートノードに「AudioStreamPlayer2D」クラスのノードを1つ追加しよう。\n「AudioStreamPlayer2D」ノードの「Stream」プロパティにリソース「res://Assets/Audio/Warp2.wav」を適用しよう。ただ、ワープ用の SFX リソースを 3 つ用意している。「Warp2.wav」が（個人的には）一番しっくりくるので、このチュートリアルではこれを採用するが、あなたのお好みのものを適用していただければOKだ。\nスクリプトを編集して SFX の再生を制御する 「EndPoint.gd」スクリプトを編集してサウンド再生を制御する。\nまずはこれまで同様「AudioStreamPlayer2D」ノードの参照プロパティを定義する。\n# AudioStreamPlayer2D ノードの参照 onready var audio_player = $AudioStreamPlayer2D # 追加 そして、プレイヤーキャラクターを含む物理ボディが当たったら呼ばれるメソッド内で、サウンドの再生と再生が終了するまで待つコードを追加する。「# 追加」のコメントがある行だ。\n# 物理ボディがコリジョン形状に入ったら呼ばれるメソッド func _on_EndPoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: anim_player.play(\u0026#34;clear\u0026#34;) yield(anim_player, \u0026#34;animation_finished\u0026#34;) particle.emitting = true body.anim_player.play(\u0026#34;clear\u0026#34;) # AudioStreamPlayer2D ノードのサウンドを再生 audio_player.play() # 追加 yield(body.anim_player, \u0026#34;animation_finished\u0026#34;) # AudioStreamPlayer2D ノードのサウンド再生が終了するまで待機 yield(audio_player, \u0026#34;finished\u0026#34;) # 追加 print(\u0026#34;Moving to the next level!\u0026#34;) get_parent().queue_free() これでプレイヤーキャラクターがエンドポイントの優勝カップに入ったら、ワープのアニメーションとともにワープっぽい SFX が再生され、アニメーションとサウンドが終了次第、現在のレベルシーンが解放され、次のレベルシーンに画面遷移する。\n「Level1」シーンで SFX の再生と再生後の「Level1」シーンの解放まで確認しよう。最後までプレイするのが面倒なので、「EndPoint2」インスタンスノードを「Level1」ルートノードに追加してスタートポイント付近に設置してテストするのが手っ取り早い。テストが終わったら追加したインスタンスノードを削除すればOKだ。\nYour browser does not support the video tag. ここまででパーツ的なシーンのサウンド追加作業は完了だ。少し休憩しよう。休憩後は BGM が必要なシーンを順番に編集していく。\nGameStart シーン ここからは BGM の追加が必要なシーンを編集していく。\nまずはスタート画面から編集する。「GameStart.tscn」シーンが読み込まれた瞬間から BGM を流したい。ゲームの一番最初に流れる BGM だ。そして、ゲームを開始するためにスペースキーやエンターキーを押した時に再生される SFX も追加しよう。\nAudioStreamPlayer ノードを追加する 「GameStart」ルートノードに「AudioStreamPlayer」クラスのノードを2つ追加して、それぞれ「BGMPlayer」「SFXPlayer」という名前に変更しよう。その名の通り、BGM を鳴らすためのノードと SFX を鳴らすためのノードを別々で追加した。理由は、後ろで BGM が鳴っている間に効果音を鳴らす必要があるからだ。\nBGMPlayer ノードを編集する 「BGMPlayer」ノードのプロパティを以下の手順で編集していこう。\nインスペクターの「Stream」プロパティへファイルシステムドックから「res://Assets/Audio/TitleScreen.ogg」をドラッグ\u0026amp;ドロップして素材を追加しよう。 最後に「Autoplay」プロパティをオンにしよう。シーンが読み込まれた瞬間からBGM が自動的に再生されるようにするためだ。\nSFXPlayer ノードを編集する 次は「SFXPlayer」ノードのプロパティを同様の手順で編集していこう。\nインスペクターの「Stream」プロパティへファイルシステムドックから「res://Assets/Audio/PressEnter.wav」をドラッグ\u0026amp;ドロップして素材を追加しよう。 もし音量が大きすぎる、または小さすぎると感じる場合は「Volume Db」プロパティの値を調整しよう。 「Autoplay」プロパティは オフ にしておく。SFX の再生のタイミングはスクリプトで制御するからだ。\nスクリプトを編集して SFX の再生を制御する では SFX の再生をスクリプトで制御する。「GameStart.gd」スクリプトを開いて編集していこう。\nまずは「SFXPlayer」ノードを参照するプロパティを追加する。\n# SFXPlayer ノードの参照 onready var sfx_player = $SFXPlayer 続いて_on_StartButton_button_upメソッドを編集する。「# 追加」とコメントしている行が更新した箇所だ。\nfunc _on_StartButton_button_up(): #print(\u0026#34;_on_StartButton_button_up called.\u0026#34;) anim_player.play(\u0026#34;press_start\u0026#34;) sfx_player.play() # 追加 yield(anim_player, \u0026#34;animation_finished\u0026#34;) yield(sfx_player, \u0026#34;finished\u0026#34;) # 追加 queue_free() print(\u0026#34;GameStart scene is now freed.\u0026#34;) 「SFXPlayer」ノードのplayメソッドで「Stream」プロパティにセットされている音源を再生する。yield関数により、その SFX の再生が終了するまで待機する。そのあとqueue_freeメソッドによりスタート画面のインスタンスノードが解放される流れだ。\nこれで、スタート画面でスタートボタンをクリック、またはスペースキーまたはエンターキーを押したら、SFX が再生されるようになったはずだ。\nシーンを再生して動作確認をしておこう。下の動画では次の項目を確認している。\nシーンが読み込まれて BGM が自動再生されるか BGM がループ再生されるか スペースキーを押して SFX が再生されるか Your browser does not support the video tag. CharacterSelect シーン 次はプレイヤーキャラクター選択画面だ。\n「CharacterSelect.tscn」シーンでも、画面が読み込まれた瞬間から BGM を流したい。いよいよゲームが始まるぞ、とワクワクする感じのドラムマーチ的な音楽を適用しよう。\n一方、この画面上の操作に合わせて SFX も追加したい。まず必要なのは、左右矢印キー（または画面上のアイコンをクリック）で、キャラクターを切り替える時の SFX 。それに、好きなキャラクターを選んだあと、スペースキーかエンターキーを押して確定させた時の SFX。これはスタート画面と同じ SFX で良いだろう。\nでは「CharacterSelect.tscn」シーンファイルを開いてサウンドを追加していこう。\nAudioStreamPlayer ノードを追加する 「CharacterSelect」ルートノードに「AudioStreamPlayer」クラスのノードを2つ追加して、それぞれ「BGMPlayer」「SFXPlayer」という名前に変更しよう。\nBGMPlayer ノードを編集する 「BGMPlayer」ノードのプロパティを編集する。\nインスペクターの「Stream」プロパティへファイルシステムドックから「res://Assets/Audio/CharacterSelect.ogg」をドラッグ\u0026amp;ドロップして素材を追加する。 必要に応じて、音量を「Volume Db」プロパティの値を上げ下げして調節する。この音源の場合 -5 ~ -10 くらいがちょうど良いかもしれない。 「Autoplay」プロパティをオンにする。 SFXPlayer ノードを編集する 次に「SFXPlayer」ノードのプロパティ編集だが、インスペクターで編集することは特にない。今までリソースファイルを適用していた「Stream」プロパティの値も今回は[空]にしておいて良い。このあとスクリプトで特定のタイミングで適切なリソースファイルを適用するようにコーディングする。\nスクリプトを編集して SFX の再生を制御する では「CharacterSelect.gd」スクリプトを編集して SFX を制御していく。\nまずはプロパティを 2 つ追加する。\n# SFXPlayer ノードの参照 onready var sfx_player = $SFXPlayer # 追加 # SFXPlayer の Stream プロパティに適用する2種類の音源リソースを辞書型データにして定義 onready var sfx_res = { \u0026#34;select\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressSelect.wav\u0026#34;), \u0026#34;enter\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressEnter.wav\u0026#34;) } # 追加 まず「SFXPlayer」ノードを参照するプロパティsfx_playerを定義している。\nもう一つのプロパティsfx_resは辞書型データで、2種類の音源リソースファイルのpreloadデータを格納する。sfx_resには左右の矢印キーを押した時のサウンドと確定キー（スペースキー、エンターキー）を押した時のサウンドの2種類が格納されている。それぞれselectおよびonreadyのキーで辞書内の値を呼び出すことができる。\nそして、以下の3つのメソッド内に適切な音源リソースを「SFXPlayer」ノードの「Stream」プロパティに割り当てて、再生するためのコードを追加した。\nfunc _on_LeftButton_pressed(): anim_player.play(\u0026#34;press_left\u0026#34;) print(sfx_res[\u0026#34;select\u0026#34;]) # SFXPlayer ノードの Stream プロパティに res://Assets/Audio/PressSelect.wav を適用 sfx_player.stream = sfx_res[\u0026#34;select\u0026#34;] # 追加 # SFXPlayer のサウンドを再生 sfx_player.play() # 追加 if frames_num \u0026gt; 0: # 以下省略 func _on_RightButton_pressed(): anim_player.play(\u0026#34;press_right\u0026#34;) # SFXPlayer ノードの Stream プロパティに res://Assets/Audio/PressSelect.wav を適用 sfx_player.stream = sfx_res[\u0026#34;select\u0026#34;] # 追加 # SFXPlayer のサウンドを再生 sfx_player.play() # 追加 if frames_num \u0026lt; global.spriteframes.size() -1: # 以下省略 unc _input(event): if event.is_action_pressed(\u0026#34;ui_left\u0026#34;): _on_LeftButton_pressed() elif event.is_action_pressed(\u0026#34;ui_right\u0026#34;): _on_RightButton_pressed() elif event.is_action_released(\u0026#34;ui_accept\u0026#34;): is_choosing = false # SFXPlayer ノードの Stream プロパティに res://Assets/Audio/PressEnter.wav を適用 sfx_player.stream = sfx_res[\u0026#34;enter\u0026#34;] # 追加 # SFXPlayer のサウンドを再生 sfx_player.play() # 追加 # SFXPlayer ノードのサウンドの再生が終了するまで待機 yield(sfx_player, \u0026#34;finished\u0026#34;) # 追加 emit_signal(\u0026#34;character_selected\u0026#34;, global.spriteframes[frames_num]) #print(\u0026#34;emitted signal: character_selected\u0026#34;) queue_free() print(\u0026#34;CharacterSelect scene is now freed.\u0026#34;) 「SFXPlayer」ノードは一つだが、スクリプトでサウンドリソースを切り替えることで 2 つの SFX の再生をカバーしている。もちろん、AudioStreamPlayer2D ノードを複数用意してそれぞれに別々のリソースを割り当てても良い。特に今回のチュートリアルのように少ないサウンドリソースしか使わない場合は、ノードを必要数追加する方法の方がわかりやすいかもしれない。もっと大きなプロジェクトで大量の音を扱うことがあれば、シーンツリーをスッキリさせるために、スクリプトで切り替える方法を採用するのも一つだ。\nさて、これで左右矢印ボタンアイコンをクリックまたはキーボードの左右矢印キーを押した時はプレイヤーキャラクターが切り替わると同時に「res://Assets/Audio/PressSelect.wav」を再生し、スペースキーまたはエンターキーを押した時は使用キャラクター確定と同時に「res://Assets/Audio/PressEnter.wav」を再生するようになった。\nそれではシーンを再生して動作確認をしておこう。下の動画では次の項目を確認している。\nシーンが読み込まれて BGM が自動再生されるか BGM がループ再生されるか 左右矢印キーを押してキャラクター選択の SFX が再生されるか スペースキーを押してキャラクター確定の SFX が再生されるか Your browser does not support the video tag. GameOver シーン 続いてゲームオーバー画面のサウンドを追加する。ゲームオーバー画面も表示された瞬間から BGM を流したい。ちょっと暗い残念な感じの曲を長そう。\nSFX としては、以下の 3 種類が必要だ。\nRestart か Quit かを切り替える音（キャラクター選択時と同じで良い） 選択を確定する音（これまでの確定の音と同じで良い） 確定した選択をキャンセルする音（これは新しく追加） では「GameOver.tscn」シーンファイルを開いてそれぞれのサウンドを追加しよう。\nAudioStreamPlayer ノードを追加する 「GameOver」ルートノードに「AudioStreamPlayer」クラスのノードを2つ追加して、それぞれ「BGMPlayer」「SFXPlayer」という名前に変更しよう。\nBGMPlayer ノードを編集する これまでと同様の手順で「BGMPlayer」ノードのプロパティを編集する。\nインスペクターの「Stream」プロパティへファイルシステムドックから「res://Assets/Audio/GameOver.ogg」をドラッグ\u0026amp;ドロップして素材を追加する。 必要に応じて、音量を「Volume Db」プロパティの値を上げ下げして調節する。 「Autoplay」プロパティをオンにする。 SFXPlayer ノードを編集する 続けて「SFXPlayer」ノードのプロパティを編集しよう。\n「Stream」プロパティの値は[空]のままにしておく。 もし音量が大きすぎたり小さすぎる場合は「Volume Db」プロパティの値を調整する。 「Autoplay」プロパティは オフ にしておく。 スクリプトを編集して SFX の再生を制御する では「GameOver.gd」スクリプトを開いて編集していく。\nまずは、プロパティから定義しよう。\n# SFXPlayer ノードの参照 onready var sfx_player = $SFXPlayer # 追加 # SFXPlayer の Stream プロパティに適用する3種類の音源リソースを辞書型データにして定義 onready var sfx_res = { \u0026#34;select\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressSelect.wav\u0026#34;), \u0026#34;enter\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressEnter.wav\u0026#34;), \u0026#34;cancel\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressCancel.wav\u0026#34;) } # 追加 次に、4 つのメソッド内に SFX 再生のコードを追加しよう。「# 追加」と記載している行が今回追加した箇所だ。\n# Restart ボタンまたは Quit ボタンを押した時に呼ばれるメソッド func work_at_button_up(option): # SFXPlayer の Stream プロパティに res://Assets/Audio/PressEnter.wav を適用 sfx_player.stream = sfx_res[\u0026#34;enter\u0026#34;] # 追加 # SFXPlayer のサウンドを再生 sfx_player.play() # 追加 selected_option = option color_rect.visible = true if selected_option == RESTART: confirmation.dialog_text = restart_text elif selected_option == QUIT: confirmation.dialog_text = quit_text confirmation.popup_centered() # 確認ダイアログで OK ボタンを押して確定した時に呼ばれるメソッド func _on_ConfirmationDialog_confirmed(): # SFXPlayer の Stream プロパティに res://Assets/Audio/PressEnter.wav を適用 sfx_player.stream = sfx_res[\u0026#34;enter\u0026#34;] # 追加 # SFXPlayer のサウンドを再生 sfx_player.play() # 追加 # SFXPlayer のサウンド再生が終了するまで待機 yield(sfx_player, \u0026#34;finished\u0026#34;) # 追加 if selected_option == RESTART: get_tree().paused = false print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) get_tree().change_scene(\u0026#34;res://Game/Game.tscn\u0026#34;) print(\u0026#34;The game is restarted.\u0026#34;) elif selected_option == QUIT: get_tree().quit() print(\u0026#34;The game is quited.\u0026#34;) # 確認ダイアログが非表示になった時に呼ばれるメソッド func _on_ConfirmationDialog_popup_hide(): # SFXPlayer の Stream プロパティに res://Assets/Audio/PressCancel.wav を適用 sfx_player.stream = sfx_res[\u0026#34;cancel\u0026#34;] # 追加 # SFXPlayer のサウンドを再生 sfx_player.play() # 追加 selected_option = null confirmation.dialog_text = \u0026#34;\u0026#34; color_rect.visible = false # キーボードやマウスのインプット操作を行った時に呼ばれるメソッド func _input(event): if visible: if event.is_action_released(\u0026#34;ui_left\u0026#34;): # SFXPlayer の Stream プロパティに res://Assets/Audio/PressSelect.wav を適用 sfx_player.stream = sfx_res[\u0026#34;select\u0026#34;] # 追加 # SFXPlayer のサウンドを再生 sfx_player.play() # 追加 line2d.position = square_pos[0] elif event.is_action_released(\u0026#34;ui_right\u0026#34;): # SFXPlayer の Stream プロパティに res://Assets/Audio/PressSelect.wav を適用 sfx_player.stream = sfx_res[\u0026#34;select\u0026#34;] # 追加 # SFXPlayer のサウンドを再生 sfx_player.play() # 追加 line2d.position = square_pos[1] elif event.is_action_released(\u0026#34;ui_accept\u0026#34;) and not color_rect.visible: if line2d.position == square_pos[0]: _on_RestartButton_button_up() elif line2d.position == square_pos[1]: _on_QuitButton_button_up() 「SFXPlayer」ノードは一つだが、スクリプトで音源リソースを切り替えることで 3 つの SFX の再生をカバーしている。\nこれで以下の場面で SFX が再生されるようになったはずだ。\n「Restart」と「Quit」を選択する際に「PressSelect.wav」が再生される 「Restart」と「Quit」どちらかの選択を確定したら「PressEnter.wav」が再生される 確認ダイアログで「OK」を押して確定した時も「「PressEnter.wav」が再生される 確認ダイアログで「Cancel」を押した時に「PressCancel.wav」が再生される 上記内容に加えて、BGM の音源が正しく再生されるか、正しくループするかも併せて、実際にシーンを実行してみよう。\nYour browser does not support the video tag. Level1 シーン いよいよゲームプレイ中の BGM の追加だ。「Level1」シーンは外なので明るいややアップテンポの曲が最適だ。「Level1.tscn」シーンファイルを開いてサウンドを追加しよう。ちなみにこのシーンに SFX は不要なので、スクリプトの編集も不要だ。1分で作業を終えられるかもしれない。\nAudioStreamPlayer ノードを追加する 「Level1」ルートノードに「AudioStreamPlayer」クラスのノードを1つ追加して「BGMPlayer」という名前に変更しよう。\nBGMPlayer ノードを編集する 「BGMPlayer」ノードのプロパティを編集する。\nインスペクターの「Stream」プロパティへファイルシステムドックから「res://Assets/Audio/Land.ogg」をドラッグ\u0026amp;ドロップして素材を追加する。 必要に応じて、音量を「Volume Db」プロパティの値を上げ下げして調節する。 「Autoplay」プロパティをオンにする。 では BGM の自動再生とループを確認しておこう。なお、このリソースのみループ開始位置を調整しているので、開始位置に戻った時に違和感がないかはよく聴いて確認する必要がある。以下の動画では 0:31 のタイミングでループ開始位置に戻っている。\nYour browser does not support the video tag. Level2 シーン ようやく最後のシーンだ。「Level2」シーンはジメジメした（キノコが大量に生息する）ダンジョンの中なので、少しおどろおどろしい（ややホラーっぽい）曲が似合うはずだ。「Level2.tscn」シーンファイルを開いてサウンドを追加しよう。このシーンも SFX は不要なので、「Level1.tscn」の編集とほとんど同じ作業だ。\nAudioStreamPlayer ノードを追加する 「Level2」ルートノードに「AudioStreamPlayer」クラスのノードを1つ追加して「BGMPlayer」という名前に変更しよう。\nBGMPlayer ノードを編集する 「BGMPlayer」ノードのプロパティを編集する。\nインスペクターの「Stream」プロパティへファイルシステムドックから「res://Assets/Audio/Dungeon.ogg」をドラッグ\u0026amp;ドロップして素材を追加する。 必要に応じて、音量を「Volume Db」プロパティの値を上げ下げして調節する。 「Autoplay」プロパティをオンにする。 では BGM の自動再生とループを確認しておこう。以下の動画では 0:49 のタイミングでループ開始位置に戻っている。\nYour browser does not support the video tag. これでサウンドの追加が必要なシーンの編集作業は完了した。最後にプロジェクト全体を通して音の確認をして今回の作業を終えよう。\nYour browser does not support the video tag. Part 13 で編集したスクリプトのコード 最後に今回の Part 13 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nPlayer.gd の全コード extends KinematicBody2D # Created @ Part 1 signal enemy_hit(damage) # Added @ Part 8 signal item_hit(point) # Added @ Part 8 export var acceleration = 256 export var max_speed = 64 export var max_dash_speed = 200 export var friction = 0.1 export var gravity = 512 export var jump_force = 224 export var air_resistance = 0.02 var velocity = Vector2() onready var sprite = $AnimatedSprite onready var anim_player = $AnimationPlayer # Added @ Part 7 onready var step_sfx = $StepSFX # Added @ Part 13 onready var jump_sfx = $JumpSFX # Added @ Part 13 onready var damage_sfx = $DamageSFX # Added @ Part 13 onready var die_sfx = $DieSFX # Added @ Part 13 func _ready(): # Added @ Part 7 sprite.position = Vector2(0, 0) sprite.scale = Vector2(1, 1) sprite.modulate = Color(1, 1, 1, 1) func _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.flip_h = x_input \u0026lt; 0 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force jump_sfx.play() # Added @ Part 13 else: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 velocity = move_and_slide(velocity, Vector2.UP) # Added @ Part 3 if position.x \u0026lt; 16: position.x = 16 func _on_HitBox_body_entered(body): # Added @ Part 8 if body.is_in_group(\u0026#34;Enemies\u0026#34;): print(\u0026#34;Enemy hit player. Damage is \u0026#34;, body.damage) emit_signal(\u0026#34;enemy_hit\u0026#34;, body.damage) sprite.play(\u0026#34;hit\u0026#34;) damage_sfx.play() # Added @ Part 13 func _on_AnimatedSprite_frame_changed(): # Added @ Part 13 if sprite.animation == \u0026#34;run\u0026#34;: if sprite.frame == 4 or sprite.frame == 10: step_sfx.play() Game.gd の全コード extends Node # Added @ Part 7 export var current_level = 1 export var final_level = 2 var health: float = 100.0 # Added @ Part 8 var score: int = 0 # Added @ Part 8 var level: Node2D var player: KinematicBody2D var char_frames: SpriteFrames # Added @ Part 10 onready var ui_layer = $UI # Added @ Part 10 onready var gamestart = $UI/GameStart # Added @ Part 10 onready var hud = $UI/HUD # Added @ Part 8 #onready var gameover = $UI/GameOver # Added @ Part 9 # Removed @ Part 10 func _ready(): #gameover.visible = false # Added @ Part 9 # Removed @ Part 10 gamestart.connect(\u0026#34;tree_exited\u0026#34;, self ,\u0026#34;_on_GameStart_tree_exited\u0026#34;) # Added @ Part 10 func _on_GameStart_tree_exited(): # Added @ Part 10 var char_select = load(\u0026#34;res://UI/CharacterSelect/CharacterSelect.tscn\u0026#34;).instance() char_select.connect(\u0026#34;character_selected\u0026#34;, self ,\u0026#34;_on_CharacterSelect_character_selected\u0026#34;) # Added @ Part 10 ui_layer.add_child(char_select) func _on_CharacterSelect_character_selected(sprite_frames): # Added @ Part 10 char_frames = sprite_frames add_level() # Moved @ Part 10 # Modified @ Part 10 hud.update_health(health) # Added @ Part 8 # Moved @ Part 10 hud.update_score(score) # Added @ Part 8 # Moved @ Part 10 hud.update_level(current_level) # Added @ Part 8 # Moved @ Part 10 func add_level(): # Modified @ Part 10 level = load(\u0026#34;res://Levels/Level\u0026#34; + str(current_level) + \u0026#34;.tscn\u0026#34;).instance() level.connect(\u0026#34;tree_exited\u0026#34;, self, \u0026#34;change_level\u0026#34;) level.connect(\u0026#34;player_dropped\u0026#34;, self, \u0026#34;_on_Level_player_dropped\u0026#34;) # Added @ Part 9 call_deferred(\u0026#34;add_child\u0026#34;, level) # Fixed error player = level.get_node(\u0026#34;Player\u0026#34;) # Added @ Part 8 player.connect(\u0026#34;enemy_hit\u0026#34;, self, \u0026#34;_on_Player_enemy_hit\u0026#34;) # Added @ Part 8 player.connect(\u0026#34;item_hit\u0026#34;, self, \u0026#34;_on_Player_item_hit\u0026#34;) # Added @ Part 8 player.get_node(\u0026#34;AnimatedSprite\u0026#34;).frames = char_frames # Added @ Part 10 func change_level(): if get_tree(): # Added @ Part 9 print(\u0026#34;change_level() called.\u0026#34;) if current_level \u0026lt; final_level: print(\u0026#34;change to next level.\u0026#34;) level.queue_free() current_level += 1 hud.update_level(current_level) # Added @ Part 8 add_level() else: print(\u0026#34;Game Clear! Congrats!\u0026#34;) get_tree().quit() func _on_Player_enemy_hit(damage): # Added @ Part 8 manage_health(damage) # Modified @ Part 9 func _on_Player_item_hit(point): # Added @ Part 8 score += point hud.update_score(score) func _on_Level_player_dropped(): # Added @ Part 9 manage_health(100) func manage_health(damage): # Added @ Part 9 health -= damage # Moved from _on_Player_enemy_hit() @ Part 9 print(\u0026#34;Health updated: \u0026#34;, health) # Moved from _on_Player_enemy_hit() @ Part 9 hud.update_health(health) # Moved from _on_Player_enemy_hit() @ Part 9 # Added @ Part 9 if health \u0026lt;= 0: player.anim_player.play(\u0026#34;die\u0026#34;) player.die_sfx.play() # Added @ Part 13 yield(player.anim_player, \u0026#34;animation_finished\u0026#34;) #gameover.visible = true # Removed @ Part 10 var gameover = load(\u0026#34;res://UI/GameOver/GameOver.tscn\u0026#34;).instance() # Added @ Part 10 ui_layer.add_child(gameover) # Added @ Part 10 print(\u0026#34;Game over screen is shown up.\u0026#34;) get_tree().paused = true print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) .Enemygd の全コード extends KinematicBody2D # Added @ Part 4 export var gravity: int export var speed: int export var damage: float # Added @ Part 8 var velocity = Vector2() onready var sprite = $AnimatedSprite onready var audio_player = $AudioStreamPlayer2D func _ready(): set_physics_process(false) func _on_HitBox_body_entered(body): if body.is_in_group(\u0026#34;Players\u0026#34;): print(\u0026#34;Player entered in \u0026#34;, self.name) sprite.play(\u0026#34;hit\u0026#34;) audio_player.play() # Added @ Part 13 yield(sprite, \u0026#34;animation_finished\u0026#34;) yield(audio_player, \u0026#34;finished\u0026#34;) # Added @ Part 13 queue_free() print(self.name, \u0026#34; died\u0026#34;) func _on_VisibilityEnabler2D_screen_entered(): set_physics_process(true) func _on_VisibilityEnabler2D_screen_exited(): set_physics_process(false) Item.gd の全コード extends Area2D # Added @ Part 6 export var point = 100 onready var sprite = $AnimatedSprite onready var label = $Label onready var anim_player = $AnimationPlayer onready var audio_player = $AudioStreamPlayer2D # Added @ Part 13 func _ready(): sprite.modulate = Color(1, 1, 1, 1) sprite.position = Vector2.ZERO sprite.scale = Vector2.ONE label.modulate = Color(1, 1, 1, 0) label.rect_position = Vector2(-32, -20) label.text = str(point) func _on_Item_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Player hit Item\u0026#34;) hit(body) # Modified @ Part 8 func hit(body): # Modified @ Part 8 print(\u0026#34;Got \u0026#34;, point, \u0026#34; point.\u0026#34;) body.emit_signal(\u0026#34;item_hit\u0026#34;, point) # Added @ Part 8 anim_player.play(\u0026#34;hit\u0026#34;) audio_player.play() # Added @ Part 13 yield(anim_player, \u0026#34;animation_finished\u0026#34;) yield(audio_player, \u0026#34;finished\u0026#34;) # Added @ Part 13 queue_free() BrokenBox.gd の全コード extends Particles2D # Added @ Part 6 onready var audio_player = $AudioStreamPlayer2D func _ready(): emitting = true audio_player.play() func _process(delta): if not emitting: queue_free() print(\u0026#34;BrokenBox removed.\u0026#34;) StartPoint.gd の全コード extends Area2D # Added @ Part 7 onready var sprite = $AnimatedSprite onready var audio_player = $AudioStreamPlayer2D # Added @ Part 13 func _ready(): sprite.play(\u0026#34;idle\u0026#34;) func _on_StartPoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: sprite.play(\u0026#34;moving\u0026#34;) audio_player.play() # Added @ Part 13 func _on_StartPoint_body_exited(body): if body.name == \u0026#34;Player\u0026#34;: sprite.play(\u0026#34;idle\u0026#34;) Checkpoint.gd の全コード extends Area2D # Added @ Part 7 var is_checked = false onready var sprite = $AnimatedSprite onready var audio_player = $AudioStreamPlayer2D # Added @ Part 13 func _ready(): sprite.play(\u0026#34;no_flag\u0026#34;) func _on_Checkpoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34; and not is_checked: sprite.play(\u0026#34;flag_out\u0026#34;) audio_player.play() # Added @ Part 13 yield(sprite, \u0026#34;animation_finished\u0026#34;) sprite.play(\u0026#34;flag_idle\u0026#34;) is_checked = true EndPoint.gd の全コード extends Area2D # Added @ Part 7 onready var particle = $Particles2D onready var sprite = $AnimatedSprite onready var polygon = $StaticBody2D/CollisionPolygon2D onready var anim_player = $AnimationPlayer onready var audio_player = $AudioStreamPlayer2D # Added @ Part 13 func _ready(): particle.emitting = false sprite.play(\u0026#34;idle\u0026#34;) polygon.position = Vector2(0, -4) func _on_EndPoint_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: anim_player.play(\u0026#34;clear\u0026#34;) yield(anim_player, \u0026#34;animation_finished\u0026#34;) particle.emitting = true body.anim_player.play(\u0026#34;clear\u0026#34;) audio_player.play() # Added @ Part 13 yield(body.anim_player, \u0026#34;animation_finished\u0026#34;) yield(audio_player, \u0026#34;finished\u0026#34;) # Added @ Part 13 print(\u0026#34;Moving to the next level!\u0026#34;) get_parent().queue_free() GameStart.gd の全コード extends Control # Added @ Part 10 onready var start_button = $VBoxContainer/StartVBox/StartButton onready var anim_player = $AnimationPlayer onready var sfx_player = $SFXPlayer # Added @ Part 13 func _ready(): start_button.modulate = Color(1, 1, 1, 1) start_button.rect_scale = Vector2(1, 1) func _on_StartButton_button_up(): #print(\u0026#34;_on_StartButton_button_up called.\u0026#34;) anim_player.play(\u0026#34;press_start\u0026#34;) sfx_player.play() # Added @ Part 13 yield(anim_player, \u0026#34;animation_finished\u0026#34;) yield(sfx_player, \u0026#34;finished\u0026#34;) # Added @ Part 13 queue_free() print(\u0026#34;GameStart scene is now freed.\u0026#34;) func _input(event): if event.is_action_released(\u0026#34;ui_accept\u0026#34;): _on_StartButton_button_up() CharacterSelect.gd の全コード extends Control # Added @ Part 10 signal character_selected(sprite_frames) var is_choosing = true var frames_num = 0 var characters = [\u0026#34;Mask Dude\u0026#34;, \u0026#34;Ninja Frog\u0026#34;, \u0026#34;Pink Man\u0026#34;, \u0026#34;Virtual Guy\u0026#34;] onready var global = get_node(\u0026#34;/root/Global\u0026#34;) onready var char_name = $VBoxContainer/CharacterName onready var l_button = $VBoxContainer/HBoxContainer/LeftButton onready var r_button = $VBoxContainer/HBoxContainer/RightButton onready var sprite = $AnimatedSprite onready var anim_player = $AnimationPlayer onready var sfx_player = $SFXPlayer # Added @ Part 13 onready var sfx_res = { \u0026#34;select\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressSelect.wav\u0026#34;), \u0026#34;enter\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressEnter.wav\u0026#34;) } # Added @ Part 13 func _ready(): l_button.modulate = Color(1, 1, 1, 1) l_button.rect_scale = Vector2(1, 1) r_button.modulate = Color(1, 1, 1, 1) r_button.rect_scale = Vector2(1, 1) play_animations() func play_animations(): var animations: Array = sprite.frames.get_animation_names() var anim_index = 0 var count = 0 #print(\u0026#34;animations array is \u0026#34;, animations) for anim in animations: if anim == \u0026#34;fall\u0026#34; or anim == \u0026#34;jump\u0026#34;: animations.remove(animations.find(anim)) #print(\u0026#34;removed \u0026#34;, anim, \u0026#34; from animations array.\u0026#34;) while is_choosing: sprite.play(animations[anim_index]) yield(sprite, \u0026#34;animation_finished\u0026#34;) sprite.stop() if count \u0026lt; 4: count += 1 continue\tcount = 0 if anim_index \u0026lt; animations.size() - 1: anim_index += 1 else: anim_index = 0 func _on_LeftButton_pressed(): anim_player.play(\u0026#34;press_left\u0026#34;) print(sfx_res[\u0026#34;select\u0026#34;]) sfx_player.stream = sfx_res[\u0026#34;select\u0026#34;] # Added @ Part 13 sfx_player.play() # Added @ Part 13 if frames_num \u0026gt; 0: frames_num -= 1 sprite.frames = global.spriteframes[frames_num] char_name.text = characters[frames_num] else: sprite.frames = global.spriteframes[global.spriteframes.size() - 1] char_name.text = characters[characters.size() - 1] frames_num = global.spriteframes.size() - 1 func _on_RightButton_pressed(): anim_player.play(\u0026#34;press_right\u0026#34;) sfx_player.stream = sfx_res[\u0026#34;select\u0026#34;] # Added @ Part 13 sfx_player.play() # Added @ Part 13 if frames_num \u0026lt; global.spriteframes.size() -1: frames_num += 1 sprite.frames = global.spriteframes[frames_num] char_name.text = characters[frames_num] else: sprite.frames = global.spriteframes[0] char_name.text = characters[0] frames_num = 0 func _input(event): if event.is_action_pressed(\u0026#34;ui_left\u0026#34;): _on_LeftButton_pressed() elif event.is_action_pressed(\u0026#34;ui_right\u0026#34;): _on_RightButton_pressed() elif event.is_action_released(\u0026#34;ui_accept\u0026#34;): is_choosing = false sfx_player.stream = sfx_res[\u0026#34;enter\u0026#34;] # Added @ Part 13 sfx_player.play() # Added @ Part 13 yield(sfx_player, \u0026#34;finished\u0026#34;) # Added @ Part 13 emit_signal(\u0026#34;character_selected\u0026#34;, global.spriteframes[frames_num]) #print(\u0026#34;emitted signal: character_selected\u0026#34;) queue_free() print(\u0026#34;CharacterSelect scene is now freed.\u0026#34;) GameOver.gd の全コード extends Control # Added @ Part 9 enum { RESTART, QUIT, } # Added @ Part 9 after var square_pos = [ Vector2(108, 128), Vector2(212, 128) ] var selected_option = null var restart_text = \u0026#34;Do you really want to restart the game?\u0026#34; var quit_text = \u0026#34;Do you really want to quit the game?\u0026#34; onready var restart_btn = $VBoxContainer/ButtonsHBox/RestartVBox/RestartButton onready var quit_btn = $VBoxContainer/ButtonsHBox/QuitVBox/QuitButton onready var color_rect = $ColorRect onready var confirmation = $ConfirmationDialog onready var line2d = $Line2D # Added @ Part 9 after onready var anim_player = $Line2D/AnimationPlayer # Added @ Part 9 after onready var sfx_player = $SFXPlayer # Added @ Part 13 onready var sfx_res = { \u0026#34;select\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressSelect.wav\u0026#34;), \u0026#34;enter\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressEnter.wav\u0026#34;), \u0026#34;cancel\u0026#34;: preload(\u0026#34;res://Assets/Audio/PressCancel.wav\u0026#34;) } # Added @ Part 13 func _ready(): color_rect.visible = false anim_player.play(\u0026#34;blink_square\u0026#34;) # Added @ Part 9 after func _on_RestartButton_mouse_entered(): line2d.position = square_pos[0] func _on_QuitButton_mouse_entered(): line2d.position = square_pos[1] func _on_RestartButton_button_up(): work_at_button_up(RESTART) func _on_QuitButton_button_up(): work_at_button_up(QUIT) func work_at_button_up(option): sfx_player.stream = sfx_res[\u0026#34;enter\u0026#34;] # Added @ Part 13 sfx_player.play() # Added @ Part 13 selected_option = option color_rect.visible = true if selected_option == RESTART: confirmation.dialog_text = restart_text elif selected_option == QUIT: confirmation.dialog_text = quit_text confirmation.popup_centered() func _on_ConfirmationDialog_confirmed(): sfx_player.stream = sfx_res[\u0026#34;enter\u0026#34;] # Added @ Part 13 sfx_player.play() # Added @ Part 13 yield(sfx_player, \u0026#34;finished\u0026#34;) # Added @ Part 13 if selected_option == RESTART: get_tree().paused = false print(\u0026#34;Scene tree paused: \u0026#34;, get_tree().paused) get_tree().change_scene(\u0026#34;res://Game/Game.tscn\u0026#34;) print(\u0026#34;The game is restarted.\u0026#34;) elif selected_option == QUIT: get_tree().quit() print(\u0026#34;The game is quited.\u0026#34;) func _on_ConfirmationDialog_popup_hide(): sfx_player.stream = sfx_res[\u0026#34;cancel\u0026#34;] # Added @ Part 13 sfx_player.play() # Added @ Part 13 selected_option = null confirmation.dialog_text = \u0026#34;\u0026#34; color_rect.visible = false func _input(event): # Added @ Part 9 after if visible: if event.is_action_released(\u0026#34;ui_left\u0026#34;): sfx_player.stream = sfx_res[\u0026#34;select\u0026#34;] # Added @ Part 13 sfx_player.play() # Added @ Part 13 line2d.position = square_pos[0] elif event.is_action_released(\u0026#34;ui_right\u0026#34;): sfx_player.stream = sfx_res[\u0026#34;select\u0026#34;] # Added @ Part 13 sfx_player.play() # Added @ Part 13 line2d.position = square_pos[1] elif event.is_action_released(\u0026#34;ui_accept\u0026#34;) and not color_rect.visible: if line2d.position == square_pos[0]: _on_RestartButton_button_up() elif line2d.position == square_pos[1]: _on_QuitButton_button_up() おわりに 以上で Part 13 は完了だ。\n今回はゲームに BGM や SFX のサウンドを追加した。「AudioStreamPlayer」の基本的なプロパティ、例えば「Stream」、「Volume Db」、「Autoplay」などの編集や、スクリプトでのサウンドリソースの割り当て、サウンドの再生を経験した。\n「AudioStreamPlayer」系クラスのノードは、一つのサウンドリソースしか割り当てられない。そのため、最初から複数のノードを追加しておくべきか、スクリプトでリソースを都度切り替えて割り当てるべきか、ちょっと悩ましい。スクリプトが苦手な方は無理をせず、最初はノードを複数追加し、それぞれに異なるサウンドリソースを割り当てる方法で問題ない。今後、ゲーム開発の腕が上がり、一つのシーンで大量のサウンドリソースを扱うようなプロジェクトの開発をすることがあれば、その時はスクリプトでの制御が有効かもしれない。\nところで今回、私自身このチュートリアルのために初めて BGM の作曲を試みた。気に入っていただけたら幸いだ。\nさて、次回のチュートリアルでは、キャラクターのアクションをアップデートする予定だ。例えば、ジャンプして落下する時は別のアニメーションを再生したり、2段ジャンプや壁ジャンプをしたり、走っている時は砂埃がまったり、ゴーストエフェクト（残像）を追加したり、といった内容だ。\nそれでは次回もお楽しみに。\nUPDATE:\n2022/04/16　画面下落下時にゲームオーバー画面に遷移しない問題の修正のため Game.gd スクリプトのmanage_healthメソッドからyield(player.die_sfx, \u0026quot;finished\u0026quot;) の行を削除\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_13/","summary":"第13回目の今回は、ゲームにサウンドを追加する。ゲームに使われるサウンドというのは、大きく分けて2種類ある。バックグラウンドミュージック（BGM）と効果音（サウンドエフェクト：SFX）だ。Godot Engine","title":"Godot で作るプラットフォーマー Part 13：サウンドを追加しよう！"},{"content":"第14回目の今回は、プレイヤーキャラクターのアクションをアップデートしていく。具体的には以下にリストアップしたジャンプとダッシュの動きや演出を追加していく。\n落下時のアニメーション 壁ジャンプ ダブルジャンプ（2段ジャンプ） 走っている時の砂埃 ダッシュ時のゴーストエフェクト（残像効果） おまけのような内容だが、作って実際にプレイすると非常に楽しいところなので、是非やってみてほしい。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー 落下時のアニメーション 実はチュートリアル Part 1 で実装しておけばいいのに放置したままなのが、この落下時のプレイヤーキャラクターのアニメーションだ。例えば、プレイヤーキャラクターがジャンプした時、現時点では地面から離れてまた地面に着地するまでずっと同じアニメーションだ。しかし今回、プレイヤーキャラクターがジャンプして一番高い位置まで達したあと、次に地面に着地するまでは別のアニメーションを再生するようにアップデートする。\n実はアニメーション自体はチュートリアル Part 1 で、「Player」シーンの「AnimatedSprite」ノードに「fall」というアニメーションを作成済みだ。\nMemo: Godot で作るプラットフォーマー Part 1：プレイヤーキャラクターを作ろう！ この作成済みのアニメーションを特定のタイミングで再生するようにスクリプトで制御する。\nでは「Player.gd」スクリプトを開いて編集しよう。編集するのはスクリプトの中の_physics_processメソッドだ。このメソッドの最後の方に「# 追加」とコメントしているところが更新箇所だ。\nfunc _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.flip_h = x_input \u0026lt; 0 # 地面にいる場合 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force jump_sfx.play() # 空中にいる場合 else: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 # y軸方向の速度が 0 より大きければ（下向きに落下）「fall」アニメーションを再生 if velocity.y \u0026gt; 0: # 追加 sprite.play(\u0026#34;fall\u0026#34;) velocity = move_and_slide(velocity, Vector2.UP) if position.x \u0026lt; 16: position.x = 16 コードの編集はこれだけだ。「Level1.tscn」シーンファイルを開いてシーンを実行して確認してみよう。一番高い位置までジャンプしたあとの落下時は「fall」アニメーションが再生されているのがわかるだろう。\n壁ジャンプを実装する 壁ジャンプというのは、プレイヤーキャラクターが壁に接触している状態からジャンプすることだ。これを利用して、マップによっては左右の壁を蹴りながら上方向に進むことができたり、画面下に落下しそうになった時に壁ジャンプで難を逃れたりすることができる。\n壁ジャンプのアニメーションも、チュートリアル Part 1 ですでに作成済みだ。「Player」シーンの「AnimatedSprite」ノードの「wall_jump」アニメーションがそれだ。特定のタイミングでこのアニメーションを再生するように、のちほどスクリプトを編集する。\nところで、壁ジャンプを実装するにはプレイヤーキャラクターが壁に接触しているかどうかを判定する必要がある。これには「KinematicBody2D」クラスでもともと用意されているis_on_wallメソッドを使えば良い、と考えてしまいそうだが、実は少し扱いにくい。\nこのメソッドは、move_and_slideメソッドが最後に呼ばれた時（_physics_processメソッドで1フレーム前に呼ばれる）に壁と衝突していたらtrueを返すようだ。実際に検証してみたところ、常に壁に向かってプレイヤーキャラクターが移動しようとしている状態でなければ、検知し続けてくれないようだ。例えば、右側の壁にジャンプしてis_on_wallメソッドでtrueを返させるにはには、空中で右矢印キーを押し続けなければならないが、壁ジャンプする時は壁と反対側にジャンプしたいものだ。右を押し続けている状態からジャンプすると、その直後はまだ右を押しているので、反対の左へ飛びにくい。この操作性の悪さから、このチュートリアルではis_on_wallメソッドを利用する方法は不採用だ。\n代わりの方法としてよく使われているのが、「Area2D」または「RayCast2D」クラスで壁との衝突を検出する方法だ。このチュートリアルでは、ちょうど「Player」ルートノードに「HitBox」という「Area2D」クラスのノードを追加している。このコリジョン形状は元々敵キャラクターとの衝突を検出するために利用しているが、壁との衝突にも流用してしまおうというわけだ。\nでは「Player.gd」スクリプトを更新していく。\nまずは壁ジャンプが可能かどうかのステートを格納するプロパティcan_wall_jumpを定義する。\n# 壁ジャンプ可能かどうかを示すプロパティ（壁ジャンプ可能な場合は true） var can_wall_jump = false # 追加 次に、壁が「Area2D」のコリジョン形状に入った時と出た時に発信されるシグナルを利用して、プレイヤーキャラクターが壁に接触しているかどうかを判定させたい。壁がコリジョン形状に入った時のシグナル「body_entered」はすでに接続済みだ。出た時のシグナル「body_exited」を新たにスクリプトに接続しよう。\nこれで_on_HitBox_body_entered(body)メソッドと、_on_HitBox_body_exited(body)メソッドの2つがスクリプト上で定義されている状態になったはずだ。\nなお、タイルマップに使っているタイルセットの内、ブロック系のタイルはコリジョン形状を設定済み（チュートリアル Part 2 ）なので、物理ボディとして検知可能である。\nではそれぞれのメソッドを以下のように編集してほしい。\n# 物理ボディがコリジョン形状に入った時に呼ばれるメソッド func _on_HitBox_body_entered(body): if body.is_in_group(\u0026#34;Enemies\u0026#34;): print(\u0026#34;Enemy hit player. Damage is \u0026#34;, body.damage) emit_signal(\u0026#34;enemy_hit\u0026#34;, body.damage) sprite.play(\u0026#34;hit\u0026#34;) damage_sfx.play() # 衝突した物理ボディがプレイヤーキャラクター自身ではなかったら elif not body.name == \u0026#34;Player\u0026#34;:: # 追加 # 地面に衝突していなければ（空中だったら） if not is_on_floor(): # 壁ジャンプが可能な状態なのでステートを true にする can_wall_jump = true # 物理ボディがコリジョン形状から出て行った時に呼ばれるメソッド func _on_HitBox_body_exited(body): # 追加 # 壁ジャンプが不可の状態なのでステートを false にする can_wall_jump = false elif not body.name == \u0026quot;Player\u0026quot;:の部分がわかりにくいかもしれないので少し詳しく解説しておきたいと思う。\n「Player」シーンにおいて、「Player」ルートノードは「KinematicBody2D」クラス、つまり物理ボディだ。この「Player」のコリジョン形状は、壁の検知に再利用している「HitBox」のコリジョン形状と重なっている。そのため「HitBox」には常にこの「Player」が物理ボディとして検知されている状態になる。壁のみを検知したいので、elifの条件を『検知されたボディが「Player」以外だったら』という内容にしている。\nちなみに、もしこのelifの条件文がただのelse文だと、空中だったらいつでも壁ジャンプができてしまう状態になるので、スーパーマリオブラザーズ3のしっぽマリオのように、ジャンプボタンを連打しておけば壁ジャンプで永遠に飛行できてしまうのだ。それはそれで面白いので、その状態を GIF 画像でお見せしておこう。\nでは_physics_processメソッドを更新して、適切なタイミングでのみ壁ジャンプができるようにしていこう。「# 追加」のコメント箇所をみていただきたい。if is_on_floor() / elseのelseブロックの中にif can_wall_jumpブロックを追加した。\nfunc _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.flip_h = x_input \u0026lt; 0 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force jump_sfx.play() else: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 if velocity.y \u0026gt; 0: sprite.play(\u0026#34;fall\u0026#34;) # 壁ジャンプ可能ステートであれば if can_wall_jump: # 追加 # jump キー（上矢印）を押したら if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): # 速度のy軸方向の値にジャンプ力（上方向なのでマイナス）を適用する velocity.y = -jump_force # 壁ジャンプのアニメーションを再生する sprite.play(\u0026#34;wall_jump\u0026#34;) # ジャンプ時の SFX を再生する jump_sfx.play() velocity = move_and_slide(velocity, Vector2.UP) if position.x \u0026lt; 16: position.x = 16 壁ジャンプがうまく実装できたか「Level1」シーンを実行して見てみよう。テスト用に「Level1」シーンの「TileMap」ノードに適当な幅でブロックの壁を左右に作ると確認しやすい。\nダブルジャンプを実装する ダブルジャンプ（2段ジャンプ）は、ジャンプ中に空中でさらにもう一回ジャンプするという、2Dアクションゲームではよく使われる定番のアクションである。\nダブルジャンプのアニメーションも、チュートリアル Part 1 ですでに作成済みだ。特定のタイミングで「AnimatedSprite」ノードの該当のアニメーションを再生するように、のちほどスクリプトを編集する。\nダブルジャンプがいつでも何回でもできてしまわないように、プレイヤーキャラクターが空中にいる間に一回だけできるように制御する必要がある。\nでは「Player.gd」スクリプトを編集していこう。\nまずは、壁ジャンプと同様にダブルジャンプのステート用にプロパティを1つ定義する。\n# ダブルジャンプ可能かどうかを示すプロパティ（可能な場合は true） var can_double_jump = false # 追加 続いて_physics_processメソッドをさらに更新する。ちょっとコードが長くなってきたが更新箇所は2箇所だけだ。「# 追加」のコメントを目印にして確認してほしい。\nfunc _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.flip_h = x_input \u0026lt; 0 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): # ダブルジャンプ可能ステートに変更 can_double_jump = true # 追加 sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force jump_sfx.play() else: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 if velocity.y \u0026gt; 0: sprite.play(\u0026#34;fall\u0026#34;) if can_wall_jump: if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): velocity.y = -jump_force sprite.play(\u0026#34;wall_jump\u0026#34;) jump_sfx.play() else: # 追加 # もしダブルジャンプ可能ステートだったら if can_double_jump: # jump アクションのキーを押したら if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): # ダブルジャンプ不可ステートに変更 can_double_jump = false # AnimatedSprite ノードの double_jump アニメーションを再生 sprite.play(\u0026#34;double_jump\u0026#34;) # 速度のy軸方向の値にジャンプ力を適用 velocity.y = -jump_force # ジャンプの SFX を再生 jump_sfx.play() まずif is_on_floor() / else構文のifブロック内でネストされたif Input.is_action_just_pressed(\u0026quot;jump\u0026quot;)ブロックにて、can_double_jumpプロパティをtrueにしてダブルジャンプ可能ステートにしている。これで、地面に接している状態からジャンプするときにダブルジャンプ可能ステートにリセットされる仕組みだ。\nif is_on_floor() / else構文のelseブロック内でネストされているif can_wall_jumpの箇所にelseブロックを追加した。そしてそこにif can_double_jumpの条件分岐をさらにネストした。これは空中ではダブルジャンプより壁ジャンプを優先するためだ。\nif can_double_jumpのブロック内で、さらにネストしたif Input.is_action_just_pressed(\u0026quot;jump\u0026quot;)（jump アクションキーを押したら）の条件分岐を追加した。このif構文のブロック内にダブルジャンプ実行時に必要なコードを記述した。処理内容の詳細はコード内のコメントを参照いただきたい。\nさてこれでダブルジャンプが実装できたはずだ。空中で1回だけダブルジャンプできるか「Level1」シーンで試してみよう。\n走っている時の砂埃を実装する 次は砂埃だ。現実には走って砂埃が大袈裟に舞うことはあまりないが、わかりやすい演出なので、プラットフォーマーゲームではよく採用されている。\n実装の流れとしては、まず、砂埃のシーンを「Particles2D」クラスのノードで作成する。続いて、スクリプトで、走っている時だけ砂埃のシーンをインスタンス化して画面上に表示させる。\nではまず砂埃のシーン作成からやっていこう。\n砂埃のシーンを作る 「シーン」＞「新規シーン」で表示される「ルートノード生成」で「その他のノード」を選択し、「Particles2D」クラスのノードをルートノードとして追加しよう。名前は「Dust」に変更する。これ以外のノードは不要だ。\n名前を変更したら、そのままシーンを保存しておこう。ファイルパスを「res://Player/Dust.tscn」として保存しよう。\nDust ノードのプロパティを編集する 「Particles2D」クラスはプロパティが多いので少し大変だが、以下の通りに編集してみてほしい。編集するプロパティ以外はデフォルトのままにしておくこと。\nまずは「Particles2D」クラスのプロパティから編集する。パーティクルの見た目や動きに関わる部分だ。\nEmitting: オフ（他のプロパティの設定が終わるまでは確認しやすいようにオンしておいて良い）\nAmount: 4\nTime:\nLifetime: 0.2 One Shot: オン（他のプロパティの設定が終わるまでは確認しやすいようにオフにしておいて良い） Speed Scale: 0.2\nTextures:\nTexture: ファイルシステムからリソース「res://Assets/Other/Dust Particle.png」を適用する\n*インスペクターでは少し下の方にあるプロパティだが 2D ワークスペースで見た目を確認するには先に設定すべき項目である\nProcess Material:\nMaterial: 新規 ParticlesMaterial を適用する\n以下は「Material」プロパティに適用したリソースのプロパティ編集 Gravity: Gravity: (0, -32, 0)\nInitial velocity: Velocity: 160\nScale: Scale: 2 Scale Random: 1\nColor: Color: #a0ffffff Color Ramp: 新規 GradientTexture を適用する\n以下は「Color Ramp」プロパティに適用したリソースのプロパティ編集 Gradient: 新規 Gradient\n以下は「Gradient」プロパティに適用したリソースのプロパティ編集 Offset: PoolFloatArray(size 3) サイズ: 3 0: 0.003 1: 0.711 2: 1\nColors: PoolColorArray(size 3) サイズ: 3 0: #00ffffff 1: #50ffffff 2: #4affffff\n最後に「Node2D」クラスのプロパティを編集する。これはプレイヤーキャラクターより常に背面に表示させるための設定だ。\nZ Index:\nZ Index: -1\n2Dワークスペースでは以下のようなアニメーションになっているはずだ。\n確認し終わったら「Emitting」プロパティをオフに、「Time」＞「One Shot」プロパティをオンすることを忘れないようにしよう。\nでは今作った「Dust.tscn」シーンのインスタンスを「Player」シーンに追加する。ただし、プレイヤーキャラクターが走っている時だけ都度インスタンスを追加したいので、「Player.gd」スクリプト内にそれをコーディングしよう。\n「Player.gd」スクリプトを開いたら、まずはpreloadした「Dust.tscn」シーンファイルを参照するプロパティを定義しよう。\n# Dust.tscn シーンのプリロード onready var dust_tscn = preload(\u0026#34;res://Player/Dust.tscn\u0026#34;) # 追加 次に以下のspawn_dustメソッドを新たに定義する。\n# 砂埃を生み出すメソッド func spawn_dust(): # プリロードした Dust.tscn シーンをインスタンス化 var dust = dust_tscn.instance() # Player ノードではなくその親（Level_ノード）の子として Dust.tscn のインスタンスノードを追加 get_parent().add_child(dust) # Dust の位置を Player の位置の y 軸方向に 11 だけ下の位置に配置（足元に来るように） dust.global_position = Vector2(global_position.x, global_position.y + 11) # ダッシュ中の場合 if Input.is_action_pressed(\u0026#34;dash\u0026#34;): # 砂埃のマテリアルのサイズを最大4倍にする dust.process_material.scale = 4 # ダッシュ中ではない場合 else: # 砂埃のマテリアルのサイズを最大2倍にする dust.process_material.scale = 2 # Dust の Emitting プロパティをオンにする dust.emitting = true # Dust の One Shot の Emitting が終わるまで待機 yield(get_tree().create_timer(dust.amount * dust.lifetime), \u0026#34;timeout\u0026#34;) # 追加した Dust のインスタンスを解放 dust.queue_free() このメソッドを少し解説しておく。まず「Dust」シーンをインスタンス化した後、それを「Player」ノードではなく「Player」の親ノード（つまり「Level_」ノード）の子として追加されている。つまり「Player」ノードと「Dust」ノードはシーンツリー上、同階層になる。\nなぜ「Player」ノードに直接追加しないかというと、子ノードの位置は親ノードとの相対的な位置を維持し続けるため、もし「Player」ノードの子として「Dust」ノードを追加すると、プレイヤーキャラクターの位置が移動するのに連動して、生成された砂埃も一緒に移動してしまうからだ。砂埃には生成されたらその場に止まってもらう必要があるので、敢えて「Player」ではなく一階層上の「Level_」シーンのルートノードの子にしているというわけだ。\nさて、ここからはまた_physics_processメソッドを編集する。\n上記spawn_dustメソッドをプレイヤーキャラクターが走っている時に呼ぶようにするには、if is_on_floor()ブロック内でネストされたif x_input == 0 / else構文のelseブロック内のsprite.play(\u0026quot;run\u0026quot;)のコードの後にspawn_dustメソッドを追加しよう。これで、走っている間だけ砂埃が舞うようになる。\nif x_input != 0ブロックのネストされたif Input.is_action_pressed(\u0026quot;dash\u0026quot;)ブロックのコードを、ダッシュ時は「AnimatedSprite」の「run」アニメーションが2倍速で再生されるように更新しておく。これで「プレイヤーキャラクターの動きが速くなったから砂埃も増えた」という演出になる。「# 追加」とコメントしている箇所を確認してほしい。\nfunc _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) # ダッシュ時はAnimatedSpriteのアニメーションのスピードを2倍にする sprite.speed_scale = 2 # 追加 else: velocity.x = clamp(velocity.x, -max_speed, max_speed) # ダッシュしていない時はAnimatedSpriteのアニメーションのスピードを通常にする sprite.speed_scale = 1 # 追加 sprite.flip_h = x_input \u0026lt; 0 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) # 砂埃を発生するメソッドを呼ぶ spawn_dust() # 追加 if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): # 中略 else: # 中略 velocity = move_and_slide(velocity, Vector2.UP) if position.x \u0026lt; 16: position.x = 16 では「Level1」シーンで確認してみよう。下のGIF画像は 12 FPS なので少しわかりづらいところがあるが、実際のダッシュ時のアニメーションはスムーズだ。\nダッシュ時にゴーストエフェクトを追加する さて、最後はゴーストエフェクトだ。残像効果とも言う。プラットフォーマー、メトロイドバニア、キャッスルバニアなど横スクロールアクションのジャンルで多用される、視覚的にとてもかっこいい演出だ。\nこちらも砂埃を実装した時と考え方は同様で、まずゴーストの雛形となるシーンを作成し、そのインスタンスをダッシュ時にキャラクターの位置に配置し、一定時間経過後に追加したインスタンスを解放するという手法だ。\nではシーンを作るところから始めよう。\nゴーストのシーンを作る 「シーン」＞「新規シーン」で表示される「ルートノード生成」で「その他のノード」を選択し、「Player」シーンのノードに合わせて、「AnimatedSprite」クラスのノードをルートノードとして追加しよう。名前を「Ghost」に変更したら、ファイルパスを「res://Player/Ghost.tscn」としてシーンを保存しよう。\n次に「Ghost」ルートノードに「Tween」クラスのノードを一つ追加する。このノードはシンプルなアニメーション（トランジション）をお手軽に実装するためによく使用される。\n公式オンラインドキュメント Tween シーンツリーは以下のスクリーンショットのようになったはずだ。\nノードのプロパティを編集する シーンツリードックを見ると「Ghost」ルートノードに⚠️マークが表示されている。これは「AnimatedSprite」クラスのノードには「Frames」プロパティに「SpriteFrames」リソースを適用する必要があるからだ。しかし、今回はシーンをインスタンス化する時に、スクリプトでリソースを適用するので、インスペクター上「Frames」プロパティは[空]のままで良い。\n少し詳しく解説しておこう。ゴーストエフェクトは、ゴーストが生成される時点でのプレイヤーキャラクターの見た目、位置、向きをそのままコピーして生成する必要がある。つまり「Ghost」シーンをインスタンス化するタイミングで、「Player」シーンの「AnimatedSprite」ノードの下記プロパティの値を「Ghost」ルートノードの同じプロパティに割り当てる必要があるのだ。\n「Frames」プロパティの値（「SpriteFrames」リソース） 「Animation」プロパティの値（「run」アニメーション） 「Frame」プロパティの値 「Position」プロパティの値（正確には「global_position」プロパティの値） 「Flip H」プロパティの値 これらの値はゴーストが生成されるその時々によって変わるため、前もってインスペクター上で設定することができないのだ。\n一方、インスペクター上で編集すべきプロパティはあるので順番に見ていこう。\n「Z Index」＞「Z Index」プロパティの値を -2 にしておく。これはプレイヤーキャラクターより背面に表示させている砂埃のインスタンス（こちらの「Z Index」は -1）よりさらに背面に表示させたいからだ。\nそして生成されるゴーストの色味も設定しておきたい。「Visibility」＞「Modulate」プロパティの値を変更しよう。あなたのお好みの色に設定していただいて構わない。このチュートリアルでは、#5073a0ff を選択した。不透明度を下げた寒色系の色だ。\nGhost ルートノードにスクリプトをアタッチする 「Ghost」ルートノードにスクリプトをアタッチしよう。少しコーディングして以下の制御を実装する。\nゴーストが生成されたら徐々に消えるアニメーションを演出する ゴーストが完全に消えたらゴーストのインスタンスを解放する 先にも少し説明したが「Tween」クラスは特定のノードにおける一つのプロパティの値を滑らかに変化させるアニメーションが得意だ。シンプルなアニメーションなら、わざわざ「AnimationPlayer」クラスを利用しなくても「Tween」で表現できるということだ。\nでは「Ghost」ルートノードにスクリプトを新規作成してアタッチしよう。スクリプトのパスは「res://Player/Ghost.gd」とする。\nスクリプトエディタが開いたら、そのままコーディングしていこう。\nextends AnimatedSprite # Tween ノードの参照 onready var tween = $Tween func _ready(): # Ghost ノードの Modulate プロパティを #c85578b4 から #00ffffff へ　0.5秒かけて変化させる設定 tween.interpolate_property(self, \u0026#34;modulate\u0026#34;, Color(\u0026#34;c85578b4\u0026#34;), Color(\u0026#34;00ffffff\u0026#34;), 0.5) # tween を開始 tween.start() これで「Ghost」シーンのインスタンスが生成された瞬間からゴーストの色味が次第に透明になる。「Tween」ノードのinterpolate_propertyメソッドの引数の多さに引き気味になりそうなのでこれを少し解説しておこう。\n第1引数: アニメーションさせたい対象のノードを指定する。ここではselfつまりこのスクリプトがアタッチされている「Ghost」ルートノードを指定している。 第2引数: 対象のプロパティを指定する。ここでは「Modulate」プロパティを指定した。 第3引数: アニメーション開始時のプロパティの値を指定する。ここでは先ほどインスペクターで編集した色と同じ #c85578b4 を指定している。 第4引数: アニメーション終了時のプロパティの値を指定する。今回、ゴーストには最終的に完全に消えて欲しいので、不透明度が 0 の #00ffffff を指定した。 第5引数: アニメーションにかける時間を秒単位で指定する。ここでは 0.5 秒とした。 第6引数（今回は省略）: アニメーションのトランジションタイプを組み込みの enum のパラメータから指定する。デフォルトで 0 が指定されている。0 は　TRANS_LINEAR で、常に一定の変化でアニメーションする。 第7引数（今回は省略）: アニメーションのイーズタイプを組み込みの enum のパラメータから指定する。デフォルトでは 2 が指定されている。2 は EASE_IN_OUT で、アニメーションの最初と最後の変化がゆっくりになる。 第8引数（今回は省略）: どれくらいアニメーションの再生を遅らせるかを秒単位で指定する。デフォルトで 0 が指定されている。 そして、生成された「Ghost」シーンのインスタンスをそのまま放置すると見た目は透明で見えなくても、実際には一つ一つのゴーストがメモリを消費したままの状態になる。これを避けるために、完全に透明になったらインスタンスを解放するようにしたい。ありがたいことに「Tween」には、アニメーション終了時に発信するシグナルが備わっているので、これを利用する。\nでは「Tween」ノードの「tween_completed(object: Object, key: NodePath)」を「Ghost.gd」スクリプトに接続しよう。接続したら自動生成された_on_Tween_tween_completedメソッドを以下のように編集して欲しい。\n# Tween ノードの tween が完了したらシグナルで呼ばれるメソッド func _on_Tween_tween_completed(object, key): # Ghost ノードを解放する queue_free() これで、ゴーストが透明になったらそのインスタンス（とメモリ）が解放される。\n以上で、「Ghost.gd」スクリプトの編集は完了だ。\nPlayer シーンに Timer を追加する 次に、一定間隔でゴーストを生成するためのタイマーを用意する。「Player」シーンの「Player」ルートノードに「Timer」クラスのノードを追加しよう。名前は「GhostTimer」に変更しておく。\nインスペクターで「GhostTimer」ノードのプロパティを以下のように編集する。\nWait Time: 0.1 One Shot: オン Player.gd スクリプトを編集する ではここから「Player.gd」スクリプトを編集していこう。ここで制御したいのは、プレイヤーキャラクターがダッシュしている間は、「GhostTimer」の残り時間が 0 秒になるたびに（0.1秒おきに）「Ghost」シーンのインスタンスを生成する、という内容だ。\nまずはプロパティを2つ新たに定義する。\n# GhostTimerノードの参照 onready var ghost_timer = $GhostTimer # 追加 # Ghost.tscnリソースファイルのプリロード onready var ghost_tscn = preload(\u0026#34;res://Player/Ghost.tscn\u0026#34;) # 追加 続いて「Ghost」シーンのインスタンスを生成するメソッドspawn_ghostを新たに定義する。\nfunc spawn_ghost(): # プリロードしていた Ghost.tscn シーンをインスタンス化 var ghost = ghost_tscn.instance() # Ghost インスタンスノードを親ノード（Level_ノード）の子として追加 get_parent().add_child(ghost) # Ghost ノードの位置を Player ノードと同じにする ghost.global_position = global_position # Ghost ノードの Frames プロパティ（SpriteFramesリソース）を Player シーンの AnimatedSprite ノードと同じにする ghost.frames = sprite.frames # Ghost ノードの Animation プロパティを Player シーンの AnimatedSprite ノードと同じにする ghost.animation = sprite.animation # Ghost ノードの Frame プロパティを Player シーンの AnimatedSprite ノードと同じにする ghost.frame = sprite.frame # Ghost ノードの Flip H プロパティを Player シーンの AnimatedSprite ノードと同じにする ghost.flip_h = sprite.flip_h # GhostTimer ノードのタイマーを開始する ghost_timer.start() 「Ghost」シーンをインスタンス化した後、それを「Player」ノードではなく「Player」の親ノード（つまり「Level_」ノード）の子として追加しているのは、砂埃の時と同様だ。つまり、プレイヤーキャラクターの位置が移動しても、生成されたゴーストにはその場に止まってもらうようにするためだ。\nその後の処理としては、「Ghost」ノードの位置や「AnimatedSprite」クラスのプロパティである「SpriteFrames」のリソース、再生するアニメーション、アニメーションのフレーム数、そして左右反転するかどうかの「Flip H」プロパティの値を、「Player」ノードの子「AnimatedSprite」ノードのそれらの値と同じにしている。これで、その瞬間のプレイヤーキャラクターの見た目、位置、向きをそっくりそのまま適用したゴーストを生成することができる。\nそして最後に「GhostTimer」をスタートさせている。\n次に、定義したspawn_ghostメソッドを呼び出すあたりを実装していこう。編集するのは今回も_physics_processメソッドだ。\nfunc _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) sprite.speed_scale = 2 # ダッシュ時に GhostTimer の残り時間が 0 の時にゴーストを生成する if ghost_timer.time_left \u0026lt;= 0: # 追加 spawn_ghost() else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.speed_scale = 1 sprite.flip_h = x_input \u0026lt; 0 # 以下省略 上記編集により、プレイヤーキャラクターがダッシュしている間だけ、「GhostTimer」ノードの残り時間が 0 になるたび（0.1秒おき）にゴーストが生成される。\n以上でゴーストエフェクトに関するコーディングは完了だ。これも「Level1」シーンを実行して動作を確認しておこう。\n最後にプロジェクトを実行して、今回実装した以下のプレイヤーキャラクターの追加要素をまとめて確認してみよう。\n落下時のアニメーション 壁ジャンプ ダブルジャンプ 砂埃 ゴーストエフェクト Part 14 で編集したスクリプトのコード 最後に今回の Part 14 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\nPlayer.gd の全コード extends KinematicBody2D # Created @ Part 1 signal enemy_hit(damage) # Added @ Part 8 signal item_hit(point) # Added @ Part 8 export var acceleration = 256 export var max_speed = 64 export var max_dash_speed = 200 export var friction = 0.1 export var gravity = 512 export var jump_force = 224 export var air_resistance = 0.02 var velocity = Vector2() var can_wall_jump = false # Added @ Part 14 var can_double_jump = false # Added @ Part 14 onready var sprite = $AnimatedSprite onready var anim_player = $AnimationPlayer # Added @ Part 7 onready var step_sfx = $StepSFX # Added @ Part 13 onready var jump_sfx = $JumpSFX # Added @ Part 13 onready var damage_sfx = $DamageSFX # Added @ Part 13 onready var die_sfx = $DieSFX # Added @ Part 13 onready var ghost_timer = $GhostTimer # Added @ Part 14 onready var ghost_tscn = preload(\u0026#34;res://Player/Ghost.tscn\u0026#34;) # Added @ Part 14 onready var dust_tscn = preload(\u0026#34;res://Player/Dust.tscn\u0026#34;) # Added @ Part 14 func _ready(): # Added @ Part 7 sprite.position = Vector2(0, 0) sprite.scale = Vector2(1, 1) sprite.modulate = Color(1, 1, 1, 1) func _physics_process(delta): velocity.y += gravity * delta var x_input = Input.get_action_strength(\u0026#34;move_right\u0026#34;) - Input.get_action_strength(\u0026#34;move_left\u0026#34;) if x_input != 0: velocity.x += x_input * acceleration if Input.is_action_pressed(\u0026#34;dash\u0026#34;): velocity.x = clamp(velocity.x, -max_dash_speed, max_dash_speed) sprite.speed_scale = 2 # Added @ Part 14 if ghost_timer.time_left \u0026lt;= 0: # Added @ Part 14 spawn_ghost() else: velocity.x = clamp(velocity.x, -max_speed, max_speed) sprite.speed_scale = 1 # Added @ Part 14 sprite.flip_h = x_input \u0026lt; 0 if is_on_floor(): if x_input == 0: sprite.play(\u0026#34;idle\u0026#34;) velocity.x = lerp(velocity.x, 0, friction) else: sprite.play(\u0026#34;run\u0026#34;) spawn_dust() # Added @ Part 14 if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): can_double_jump = true # Added @ Part 14 sprite.play(\u0026#34;jump\u0026#34;) velocity.y = -jump_force jump_sfx.play() # Added @ Part 13 else: if x_input == 0: velocity.x = lerp(velocity.x, 0, air_resistance) if Input.is_action_just_released(\u0026#34;jump\u0026#34;) and velocity.y \u0026lt; -jump_force / 2: velocity.y = -jump_force / 2 if velocity.y \u0026gt; 0: # Added @ Part 14 sprite.play(\u0026#34;fall\u0026#34;) if can_wall_jump: # Added @ Part 14 if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): print(\u0026#34;wall jumped.\u0026#34;) velocity.y = -jump_force sprite.play(\u0026#34;wall_jump\u0026#34;) jump_sfx.play() else: # Added @ Part 14 if can_double_jump: if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): print(\u0026#34;double jumped.\u0026#34;) can_double_jump = false sprite.play(\u0026#34;double_jump\u0026#34;) velocity.y = -jump_force jump_sfx.play() velocity = move_and_slide(velocity, Vector2.UP) # Added @ Part 3 if position.x \u0026lt; 16: position.x = 16 func _on_HitBox_body_entered(body): # Added @ Part 8 if body.is_in_group(\u0026#34;Enemies\u0026#34;): print(\u0026#34;Enemy hit player. Damage is \u0026#34;, body.damage) emit_signal(\u0026#34;enemy_hit\u0026#34;, body.damage) sprite.play(\u0026#34;hit\u0026#34;) damage_sfx.play() # Added @ Part 13 elif not body.name == \u0026#34;Player\u0026#34;: # Added @ Part 14 if not is_on_floor(): can_wall_jump = true #print(\u0026#34;can_wall_jump: \u0026#34;, can_wall_jump) func _on_HitBox_body_exited(body): # Added @ Part 14 can_wall_jump = false #print(\u0026#34;can_wall_jump: \u0026#34;, can_wall_jump) func _on_AnimatedSprite_frame_changed(): # Added @ Part 13 if sprite.animation == \u0026#34;run\u0026#34;: if sprite.frame == 4 or sprite.frame == 10: step_sfx.play() func spawn_dust(): var dust = dust_tscn.instance() get_parent().add_child(dust) dust.global_position = Vector2(global_position.x, global_position.y + 11) if Input.is_action_pressed(\u0026#34;dash\u0026#34;): dust.process_material.scale = 4 else: dust.process_material.scale = 2 dust.emitting = true yield(get_tree().create_timer(dust.amount * dust.lifetime), \u0026#34;timeout\u0026#34;) dust.queue_free() func spawn_ghost(): # Added @ Part 14 var ghost = ghost_tscn.instance() get_parent().add_child(ghost) ghost.global_position = global_position ghost.frames = sprite.frames ghost.animation = sprite.animation ghost.frame = sprite.frame ghost.flip_h = sprite.flip_h ghost_timer.start() Ghost.gd の全コード extends AnimatedSprite onready var tween = $Tween func _ready(): tween.interpolate_property(self, \u0026#34;modulate\u0026#34;, Color(\u0026#34;c85578b4\u0026#34;), Color(\u0026#34;00ffffff\u0026#34;), 0.5) tween.start() func _on_Tween_tween_completed(object, key): queue_free() おわりに 以上で Part 14 は完了だ。\n今回はプレイヤーキャラクターの動きをアップデートする要素をいくつか追加で実装した。壁ジャンプ、ダブルジャンプ、砂埃、ゴーストエフェクト、はどれもプラットフォーマーゲームでは定番のアクションだ。実装してプレイしてみると、操作している時の爽快感が飛躍的に上がる印象を受けた方は多いのではないだろうか。デベロッパーがこぞって実装したくなる理由を体感いただけたのではないだろうか。\n壁ジャンプとダブルジャンプは、それぞれのステート用の bool 型プロパティを用意し、該当のジャンプアクションが可能な時とそうでない時で true と false を切り替えて制御した。このようにステート用のプロパティを用いてプログラムを作ることはゲームのジャンルを問わずかなり多い。true と false の2択では賄えないステートを扱う場合は enum を利用したりもする。ちなみに、ステートによってキャラクターの動きを制御するようなプログラムをステートマシンまたはステートデザインパターンと呼ぶ。Google で検索すると資料がたくさん出てくるので、興味があれば是非確認してみよう。\n公式オンラインドキュメント: State design pattern 一方、砂埃やゴーストエフェクトは、オブジェクトのシーンを別で用意しておき、然るべきタイミングでそれらのインスタンスを連続的に追加し、一定時間後に解放する、という方法で実装した。砂埃の方は「Particles2D」のインスタンスは一つにして「One Shot」プロパティをオフにしても実装できそうだ。ゴーストエフェクトでは、インスタンスを敢えて「Player」ノードではなくその親ノードに追加した。プログラムの複雑さはできるだけ抑えたいものだが、目的に合わせて柔軟にプログラミングすることも重要である。\nさて、次回は最終回になる予定だ。内容は、ゲームクリア画面やポーズ画面という案もあったが、スタート画面やゲームオーバー画面の応用でしかないので、却下だ。データ保存やゲームのエクスポートもプラットフォーマーじゃなくてもできることなので却下だ。せっかくプラットフォーマーのチュートリアルなので、最後はステージ上にいくつかのギミックを追加してみようと思う。例えば、動く床、火が出る装置、スパイク、バネ仕掛けの床などはインポート済みのアセットにテクスチャがあるので、ボリュームが大きくなりすぎない範囲で実装してみたいと思う。\nそれでは次回もお楽しみに。\nReferences: How to make a Wall jump properly ? - Godot Engine - Q\u0026amp;A\nGodot 3 - Make Your Character Double Jump / UmaiPixel - YouTube\n【Godot】残像エフェクトの作り方 / 2dgames.jp - Blog\n【Godot】Timerを使った残像エフェクトの作り方【Ghost Trail】/ tatsuya_ゲーム制作 - note\nMake a 2D Ghost effect in Godot / Mister Taft Creates - YouTube\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_14/","summary":"第14回目の今回は、プレイヤーキャラクターのアクションをアップデートしていく。具体的には以下にリストアップしたジャンプとダッシュの動きや演出を追加していく。 落下時のアニメーション 壁ジャンプ ダブルジャン","title":"Godot で作るプラットフォーマー Part 14：プレイヤーキャラクターのアクションをアップデートしよう！"},{"content":"第15回目の今回はいよいよこのチュートリアルのシリーズの最終回だ。最終回はプラットフォーマーのレベルデザインに比較的よく使われるいくつかの仕掛けを追加していく。具体的には以下にリストアップしたトラップやギミックの類だ。\n動く床 落ちる床 高く飛べる床 火が出る装置 飛んでくる鉄球 今回は Part 1 でインポート済みのアセットからたくさんのスプライトシートを利用する。例によって、見た目にブラーがかかっている（ピクセルアート特有のエッジが効いた画像ではない）場合は、ファイルシステム上で利用するアセットファイルを選択し、インポートドックから「プリセット」＞「2D Pixel」を選択し、「再インポート」をクリックして修正しよう。\nMemo： 過去のシリーズをまだご覧になっていない方は、そちらを先にご覧いただくことをおすすめします。\nGodot で作るプラットフォーマー 動く床 名前の通り、プレイヤーキャラクターがそこに乗っているだけで移動できる、動く床を作成する。日本語で『床』としたが、英語でいうところのプラットフォームだ。まさにプラットフォーマーというジャンルに相応しい定番の仕掛けである。\nシーンを作成する 「Node2D」をルートノードにして新規でシーンを作成する。 ルートノードの名前は「MovingPlatform」とする。 ファイルパスを「res://Traps/MovingPlatform/MovingPlatform.tscn」として保存する。 次に、以下のスクリーンショットと同じシーンツリーになるように、必要なノードを追加する。なお、ノードの名前変更はルートノード以外必要ない。\nノードのプロパティを編集する シーンツリーに追加したノードうち、いくつかのプロパティを編集していこう。\nPath2D ノード このノードは、動く床の経路となるパスを作成する。ここではひとまず雛形としてシンプルな直線のパスを作成するが、インスタンス化した先のシーンでパスの形状は編集可能だ。\nインスペクターで「Resource」＞「Local To Scene」にチェックを入れてオンにする。 シーンツリードックで「Path2D」が選択されている状態だと、2D ワークスペース上にパスを描画するツール（以下のスクリーンショット）が表示される。それぞれのアイコンにカーソルを合わせると説明が見れるので確認しておこう。\n2D ワークスペース上に点を2つ以上打つことでパスを描いていく。左から3番目の「+」のついたアイコンをクリックして点を追加しよう。点は(0, 0)と、もう一つ真っ直ぐ上の適当な場所、(0, -128)あたりに打っておこう。これで縦に真っ直ぐのパスができたはずだ。\n公式オンラインドキュメント: ベジェ、曲線、パス Path2D Curve2D PathFollow2D ノード このノードは、親である「Path2D」ノードのパスを経路として、それに沿って子ノード（ここでは「KinematicBody2D」）を移動させる役割をする。経路に沿った移動に関わるプロパティについて少し解説しておく。\n「Offset」プロパティでピクセル単位の値でパスの原点からの距離を指定するか、「Unit Offset」プロパティで原点からの距離を割合（0 ~ 1）で指定することで、経路上の位置を決めることができる。この位置を常に変化させることで、経路上をオブジェクトが移動する動きを作ることができるわけだ。この位置の変化はのちほど「AnimationPlayer」ノードのアニメーションとスクリプトで制御するので、ここで今直接編集する必要はない。\n「Rotate」プロパティをオフにしておく。インスペクターで唯一変更するプロパティだ。\nパスが y 軸に対して平行な直線ではない場合に、パスをたどるオブジェクト（ここでは動く床）の向きもデフォルトでは回転するが、このプロパティをオフにすることで固定できる。床がパスの角度に合わせて回転してしまうと、プレイヤーキャラクターはそこに乗っていられなくなる（敢えてそういうトラップとしてオンにしておくのもアイデアだが）。\n公式オンラインドキュメント: PathFollow2D AnimatedSprite ノード 親の「KinematicBody2D」ノードに「SpriteFrames」リソースを適用して見た目（テクスチャ）を作る。\nインスペクタードックで「Frames」プロパティに「新規 SpriteFrames」リソースを割り当てる。 スプライトフレームパネルで以下のアニメーションを作成する。 アニメーション名: off\n速度: 1 FPS ループ: オフ アニメーションフレームリソース: res://Assets/Traps/Platforms/Brown Off.png\nアニメーション名: on\n速度: 16 FPS ループ: オン アニメーションフレームリソース: res://Assets/Traps/Platforms/Brown On (32x8).png\nAnimationPlayer ノード このノードは重要だ。いつものような楽しい演出としての使用ではなく、このノードによって「PathFollow2D」ノードの「Unit Offset」プロパティの値を徐々に変更することで、「KinematicBody2D」が「Path2D」の経路を辿るようにする。\nアニメーションパネルで以下の内容のアニメーションを新規作成する アニメーション名: move 読み込み後自動再生: オン アニメーションの長さ(秒): 4 リピート再生: オン トラック：PathFollow2D ノード ＞ unit_offset プロパティ Time: 0 秒 / Value: 0 / Easing: 1.00 Time: 2 秒 / Value: 0.99 / Easing: 1.00\n*Value を 1 にすると経路を折り返すタイミングで一瞬弾けるような現象が生じるので 0.99 としている\nチェーンのシーンを作成する 次は動く床の経路がわかるように、経路に沿ってチェーンを配置したい。そこで今回はチェーンのセグメント１つ分のシーンを作成し、動く床が読み込まれた時に、スクリプトで画面上に必要な数だけチェーンをインスタンス化する方向で進める。ではシーンを作成しよう。\nルートノードに「Sprite」クラスを指定して新規でシーンを作成する。 ルートノードの名前は「MovingPlatformChain」に変更する。 「MovingPlatformChain」ルートノードの「Texture」プロパティにリソース「res://Assets/Traps/Platforms/Chain.png」を適用する。 ファイルパスを「res://Traps/MovingPlatform/MovingPlatformChain.tscn」としてシーンを保存する。\nスクリプトをアタッチして編集する それではスクリプトで「MovingPlatform」が読み込まれたらチェーンを表示するようにコーディングしていこう。\n「MovingPlatform」ルートノードにスクリプトをアタッチしてほしい。この時、ファイルパスを「res://Traps/MovingPlatform/MovingPlatform.gd」としてスクリプトを作成しよう。\nアタッチできたら、「MovingPlatform.gd」スクリプトを以下のように編集してほしい。\nextends Node2D # Path2D の参照 onready var path = $Path2D # MovingPlatformChainシーンをプリロード onready var chain_scn = preload(\u0026#34;res://Traps/MovingPlatform/MovingPlatformChain.tscn\u0026#34;) # ノードが読み込まれる時に実行 func _ready(): make_chain() # チェーンを Path2D の経路に合わせて必要数インスタンス化して配置するメソッド func make_chain(): # Path2D のキャッシュされた点（の位置）を取得 var points = path.curve.get_baked_points() # Path2D の全てのキャッシュされた点にチェーンのインスタンスを配置 for point in points: var chain = chain_scn.instance() add_child(chain) move_child(chain, 0) chain.z_index = -1 chain.position = point 「Path2D」ノードのリソース「Curve2D」クラスのメソッドget_baked_pointsで、キャッシュされた点を取得できる。このキャッシュされた点はパスを作成した時の点とは別物である。パスをゲーム画面上に描画するときに、パスの形状を複数の点に置き換えてキャッシュ（一時保存）しているのだ。ちなみに、キャッシュされた点と点の間隔は、「Bake Interval」プロパティで設定でき、値が小さいほどパスのカーブなどの形状を滑らかに描画できるが、その分コンピュータのメモリを消費するので注意が必要だ。\n今回はこのキャッシュされた点の位置を利用して、そこにチェーンを配置するようにしたというわけだ。\n公式オンラインドキュメント: Curve2D Level3 シーンにインスタンスを追加する 今回のチュートリアル用に「Level3」シーンを作成しておこう。「Level1」シーンを複製（継承ではない）して、敵キャラクターやアイテムなどの不要なノードは一旦全て削除し、TileMapも簡単なものを新しく作成しよう。\n続けて、先ほど作成した「MovingPlatformtscn」をインスタンス化して追加しよう。\n以下のように確認しやすい配置にするだけでOKだ。\n「MovingPlatform」のインスタンスの「Path2D」のパスを以下の手順で編集してみよう。\nシーンツリードックで「MovingPlatform」を右クリックし、「編集可能な子」にチェックを入れよう。\nそのままシーンツリードックで「MovingPlatform」の子の「Path2D」ノードを選択する。\nインスペクターで「Curve」プロパティの「Curve2D」リソースをユニーク化する。\n2D ワークスペースでツールバーのパス描画ツールを切り替えながらパスを編集してみよう。例えば「点を空きスペースに追加」ツールで点を追加し、「曲線を閉じる」ツールでパスの端と端を繋いで、「コントロールポイントを選ぶ」ツールで既存の点をドラッグして滑らかなカーブにしてみよう。\n最後にシーンを実行して動作確認をしておこう。\n床の動きが速すぎる場合は、「MovingPlatform」の子「AnimationPlayer」ノードを選択し、インスペクターで「Playback Options」＞「Speed」プロパティを編集する。遅くしたい場合は値を 1 より小さくする。\n応用： 回転ノコギリ 動く床のロジックを応用して「回転ノコギリ」のトラップを作ることができる。\n「Path2D」のパスを辿る回転するノコギリで、当たるとダメージを受ける、というトラップだ。\n「AnimatedSprite」の「Frames」プロパティに適用する「SpriteFrames」リソースのアニメーション用アセットは「res://Assets/Traps/Saw/」にまとまっている。\n「KinematicBody2D」の代わりに「Area2D」を使用し、そのシグナル「body_entered」をスクリプトに接続して、プレイヤーキャラクターがコリジョン形状に入ったらダメージを与えるように制御すればOKだ。\n今回のチュートリアルでは、ボリュームの都合で詳細な解説は割愛させていただく。\n落ちる床 落ちる床は、プロペラで空中に浮かんでおり、プレイヤーキャラクターが飛び乗ると、そのあとすぐにグラグラして落下するという仕掛けだ。飛び乗ったあとすぐに離れないと、画面下に落下してゲームオーバーになってしまう、というのがよくある使い方だ。\nシーンを作成する ルートノードに「KinematicBody2D」クラスを指定してシーンを新規作成する。このクラスを選択する理由は、スクリプトのコードにより重力を加えて落下させるためだ。 ルートノードの名前は「FallingPlatform」に変更する。 ファイルパスを「res://Traps/FallingPlatform/FallingPlatform.tscn」としてシーンを保存する。 以下のスクリーンショットのようなシーンツリーになるように必要なノードを追加しよう。\nなお、以下のノードはどちらも「CollisionShape2D」クラスのため、名前を変更している。 「BodyCollision」ノード 「AreaCollision」ノード ノードのプロパティを編集する AnimatedSprite ノード このノードを編集して落ちる床のルートノードの見た目を作る。\nインスペクターで「Frames」プロパティに「新規 SpriteFrames」リソースを適用する。 スプライトフレームパネルで以下のアニメーションを作成する アニメーション名: Off 速度: 1 FPS ループ: オフ アニメーションフレームリソース: res://Assets/Traps/Falling Platforms/Off.png\nアニメーション名: on 速度: 16 FPS ループ: オン アニメーションフレームリソース: res://Assets/Traps/Falling Platforms/On (32x10).png\nインスペクターに戻って、「Animation」プロパティの値として「on」を選択する。 続けて「Playing」プロパティをオンにする。 BodyCollision ノード このノードを編集して、ルートノードのコリジョン形状を設定する。ルートノードは「KinematicBody2D」（つまり物理ボディ）なので、コリジョン形状を作れば、プレイヤーキャラクターがそこに乗ることができるようになる。\nインスペクターで「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。 2D ワークスペース上でコリジョン形状を、「SpriteFrames」のテクスチャの床部分に合わせて調整する。\n「RectangleShape2D」リソースの「Extents」プロパティは (16, 2.5) になったはずだ。\nAreaCollision ノード このノードは、プレイヤーキャラクターが落ちる床に乗ったことを検知するために、親ノードの「Area2D」にコリジョン形状をを提供する。プレイヤーキャラクターの足が床に接したことを検知したいので、床のすぐ上に 1 px 程度の浅いコリジョン形状を配置する必要がある。なお、作業手順は先の「BodyCollision」ノードと同様だ。\nインスペクターで「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。 2D ワークスペース上でコリジョン形状を、床部分の上に乗せるような形で調整する。\n「RectangleShape2D」リソースの「Extents」プロパティは (15, 1) になったはずだ。\nAnimationPlayer ノード このノードのアニメーションで、プレイヤーキャラクターが乗った直後に落ちる床が左右にグラグラ震える演出を追加する。のちほど、このアニメーションが再生された後に床が落下するようにスクリプトで制御していく。\nアニメーションパネルを開き、以下の内容で新規アニメーションを作成する。 アニメーション名: shaking 読み込み後、自動再生: オフ アニメーションの長さ(秒): 0.4 アニメーションループ: オフ トラック: AnimatedSprite ノード ＞ offset プロパティ Time: 0 / Value: (-1, 0) / Easing: 1.00 Time: 0.05 / Value: (1, 0) / Easing: 1.00 Time: 0.1 / Value: (-1, 0) / Easing: 1.00 Time: 0.15 / Value: (1, 0) / Easing: 1.00 Time: 0.2 / Value: (-1, 0) / Easing: 1.00 Time: 0.25 / Value: (1, 0) / Easing: 1.00 Time: 0.3 / Value: (-1, 0) / Easing: 1.00 Time: 0.35 / Value: (1, 0) / Easing: 1.00 Time: 0.4 / Value: (-1, 0) / Easing: 1.00 以下のGIF画像ように、一瞬震えるアニメーションになればOKだ。\nTimer ノード このタイマーは、落下してから一定時間経過後に落ちる床のインスタンスを解放するために利用する。\nインスペクターで「Wait Time」プロパティの値はデフォルトの 1 秒のままにしておく。この時間が落下開始してから解放するまでの時間になる。 「One Shot」プロパティをオンにする。タイマーは一回しか使わない。 「Autostart」プロパティはオフのままだ。のちほどスクリプトでプレイヤーが床に乗ってからスタートするよう調整する。 スクリプトをアタッチして編集する ここからは、プレイヤーキャラクターが乗ったら落ちる床が本当に落ちるようにプログラミングしていく。ルートノード「FallingPlatform」にスクリプトをアタッチしてほしい。ファイルパスを「res://Traps/FallingPlatform/FallingPlatform.gd」として作成しよう。\nアタッチできたら「FallingPlatform.gd」スクリプトを以下のように編集しよう。\nextends KinematicBody2D # 重力のプロパティ var gravity = 512 # 速度のプロパティ、初期値は(0, 0) var velocity = Vector2() # AnimationPlayer ノードの参照 onready var anim_player = $AnimationPlayer # Timer ノードの参照 onready var timer = $Timer func _ready(): # シーンが読み込まれたら物理プロセスを停止しておく set_physics_process(false) func _physics_process(delta): # 速度のy軸方向の値に重力を加算する velocity.y += gravity * delta # 速度に合わせて KinematicBody2D のルートノードを動かす（落下させる） move_and_slide(velocity, Vector2.UP) 少し解説しておくと、まず_readyメソッドにより、set_physics_process(false)が呼ばれるので、シーンが読み込まれる際に物理プロセスは停止状態になる。\nそのため、すぐ下の_physics_processメソッドで、落ちる床が重力により落下するように定義しているが、これは物理プロセスが次に再開された時に初めて実行されることになる。\n次に「Area2D」ノードのシグナル「body_entered」をスクリプトに接続する。プレイヤーキャラクターが落ちる床に乗ったら発信されるシグナルだ。接続後、追加された_on_Area2D_body_enteredメソッドを以下のように編集しよう。\n# 物理ボディが Area2D のコリジョン形状に入った時に発信されるシグナルで呼ばれるメソッド func _on_Area2D_body_entered(body): # プレイヤーキャラクターが床に乗ったら if body.name == \u0026#34;Player\u0026#34;: # AnimationPlayer ノードの shaking アニメーションを再生する anim_player.play(\u0026#34;shaking\u0026#34;) これで落ちる床に乗ったら、「AnimationPlayer」の「shaking」アニメーションが再生されるようになった。さらに「AnimationPlayer」ノードのシグナル「animation_finished」をスクリプトに接続しよう。追加された_on_AnimationPlayer_animation_finishedメソッドを以下のように編集してほしい。\nfunc _on_AnimationPlayer_animation_finished(anim_name): # 終了したアニメーションが shaking だったら if anim_name == \u0026#34;shaking\u0026#34;: # 物理プロセスを再開する（自動的に重力で床が落下する） set_physics_process(true) # タイマーをスタートする timer.start() これでアニメーション「shaking」が終了した直後、物理プロセスが再開され、重力により自動的に床が落下する。\n最後に「Timer」ノードのシグナル「timeout」をスクリプトに接続して、_on_Timer_timeoutメソッドを以下のように編集しよう。\nfunc _on_Timer_timeout(): # FallingPlatform ノードを解放する queue_free() これで完全にゲームの世界から落ちる床が消える。以上でスクリプトの編集は完了だ。\nLevel3 シーンにインスタンスを追加する 作成した「FallingPlatform.tscn」のインスタンスを「Level3」シーンに追加し、シーンを実行して動作を確認してみよう。\n問題なさそうだ。これを実際にレベルデザインする際に下に地面がないところに配置するとよりスリリングで効果的だ。\n高く飛べる床 次は「高く飛べる床」を作る。トランポリンやバネのような仕掛けだ。タイルマップで、これを利用しないと辿り着けないような高い位置に地面を作ると効果的だ。\nシーンを作成する 「StaticBody2D」クラスをルートノードにしてシーンを新規作成する。 ルートノードの名前を「Spring」に変更する。 ファイルパスを「res://Traps/Spring/Spring.tscn」としてシーンを保存する。 以下のスクリーンショットのようなシーンツリーになるように必要なノードを追加する。\nなお、以下のノードは同じ「CollisionShape2D」クラスのためノードの名前を変更している。 「BodyCollision」ノード 「AreaCollision」ノード ノードのプロパティを編集する AnimatedSprite ノード ルートノードの「Spring」に見た目を提供する。\nインスペクターで「Frames」プロパティに「新規 SpriteFrames」リソースを適用する。 スプライトフレームパネルで以下の２つのアニメーションを作成する。 アニメーション名: idle 速度: 1 FPS ループ: オフ アニメーションフレームリソース: res://Assets/Traps/Trampoline/Idle.png\nアニメーション名: jump 速度: 8 FPS ループ: オフ アニメーションフレームリソース: res://Assets/Traps/Trampoline/Jump (28x28).png\nインスペクターに戻って「Animation」プロパティを「idle」に設定する。 「Playing」プロパティをオンに設定する。 BodyCollision ノード ルートノードにコリジョン形状を適用する。「AnimatedSprite」のテクスチャ画像の赤い台の位置に合わせてコリジョン形状を設定し、プレイヤーキャラクターがそこに乗れるようにする。\nインスペクターで「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。 2D ワークスペースで「AnimatedSprite」の「idle」のアニメーションフレームの赤い台の形に合わせてコリジョン形状を調整する。ピッタリ形を合わせた場合は「RectangleShape2D」＞「Extents」プロパティは (11.5, 2.5) になる。\nAreaCollision ノード このノードは、プレイヤーキャラクターが床に乗ったかどうかを検知するための親ノード「Area2D」にコリジョン形状を適用する。プレイヤーキャラクターの足を検出するため、赤い台のすぐ上に浅く配置するのがポイントだ。\nインスペクターで「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。 2D ワークスペースで、「AnimatedSprite」の「idle」のアニメーションフレームの赤い台のすぐ上の部分に浅くコリジョン形状を配置する。「RectangleShape2D」＞「Extents」プロパティは (10.5, 1.5) になる。\nスクリプトをアタッチして編集する ルートノード「Spring」にスクリプトをアタッチする。ファイルパスを「res://Traps/Spring/Spring.gd」として作成する。\nスクリプトがアタッチできたら、例によってまずはプロパティから定義する。\nextends StaticBody2D # Player ノードの参照用（最初は名前のみ定義） var player # AnimatedSprite ノードの参照 onready var sprite = $AnimatedSprite さてここで、プレイヤーキャラクターが「Area2D」ノードのコリジョン形状に入ったタイミング発信されるシグナルを利用したいので、「Area2D」ノードの「body_entered」シグナルを「Spring.gd」スクリプトに接続しておこう。\nスクリプトに_on_Area2D_body_enteredメソッドが追加されたら以下のように編集する。\nfunc _on_Area2D_body_entered(body): # AnimatedSpriteのアニメーションのフレームを 0 にする sprite.frame = 0 # Player ノードを検知したら if body.name == \u0026#34;Player\u0026#34;: # デバッグ用 print(\u0026#34;Player entered Spring area\u0026#34;) # プロパティ player に body(Playerノード)を代入 player = body # AnimatedSpriteの jump アニメーションを再生する sprite.play(\u0026#34;jump\u0026#34;) これで、プレイヤーキャラクターが高く飛ぶ床に乗ったら、床がアニメーションするようになった。ちなみにメソッドの外で定義されているplayerプロパティにbodyを代入したのは、このメソッド以外で「Player」ノードを制御したいからだ。\nでは、肝心のプレイヤーを高く飛ばすためのコードを作っていこう。床のアニメーションの特定のタイミングに合わせてプレイヤーキャラクターを高く飛ばしたい。そこで「AnimatedSprite」ノードのシグナル「frame_changed」をスクリプトに接続して利用する。\nこのシグナルはアニメーションのフレームが変わるたびにシグナルが発信される。アニメーション「jump」のフレームが 1 の時に一番床が高くなるので、それを条件にif構文を使って、このフレームが 1 のタイミングでプレイヤーを高く飛ばそう。ではシグナルを接続して追加された_on_AnimatedSprite_frame_changedメソッドを以下のように編集しよう。\nfunc _on_AnimatedSprite_frame_changed(): # AnimatedSprite のアニメーションが jump でかつフレームが 1 でかつ　player プロパティが空っぽでない場合 if sprite.animation == \u0026#34;jump\u0026#34; and sprite.frame == 1 and player != null: # Player ノードの y 軸方向の速度をプレイヤーキャラクターのジャンプ力の2倍にする player.velocity.y = - player.jump_force * 2 # Player ノードのダブルジャンプを可能にする player.can_double_jump = true Level3 シーンにインスタンスを追加する 作成した「Spring.tscn」のインスタンスを「Level3」シーンに追加し、シーンを実行して動作を確認してみよう。\n十分高く飛ばすことができた。高さを調整したい時はplayer.velocity.y = - player.jump_force * 2の最後の 2 を別の数値に変更して調整いただければと思う。これを使って、高い足場に移動するようなレベルのデザインをすると効果的だ。\n火が出る装置 踏むと足元から火が出る装置を作る。例えば、この装置を足元にずらりと並べて、どこに着地しても火が出るようなスリリングなステージを構成することができる。\nシーンを作成する 「StaticBody2D」クラスをルートノードにしてシーンを新規作成する。 ルートノードの名前は「FirePod」に変更する。 ファイルパスを「res://Traps/FirePod/FirePod.gd」としてシーンを保存する。 以下のスクリーンショットのようなシーンツリーになるように必要なノードを追加する（ほとんど落ちる床や高く飛べる床と同じ構成だ）。\nなお、以下のノードは同じ「CollisionShape2D」クラスのため名前を変更している。 「BodyCollision」ノード 「AreaCollision」ノード ノードのプロパティを編集する AnimatedSprite ノード ルートノードの見た目を作る。\nインスペクターで「Frames」プロパティに「新規 SpriteFrames」リソースを適用する。 スプライトフレームパネルで以下のアニメーションを作成する。 アニメーション名: hit 速度: 8 FPS ループ: オフ アニメーションフレームリソース: res://Assets/Traps/Fire/Hit (16x32).png\nアニメーション名: off 速度: 1 FPS ループ: オフ アニメーションフレームリソース: res://Assets/Traps/Fire/Off.png\nアニメーション名: on 速度: 8 FPS ループ: オン アニメーションフレームリソース: res://Assets/Traps/Fire/On (16x32).png\nインスペクターに戻って「Animation」プロパティで「off」を選択する。 「Playing」プロパティをオンにする。 BodyCollision ノード ルートノードにコリジョン形状を適用する。\nインスペクターで「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。 2D ワークスペースで、「AnimatedSprite」の「off」のアニメーションフレームの装置のサイズに合わせてコリジョン形状を調整する。ピッタリ形を合わせた場合は「RectangleShape2D」＞「Extents」プロパティは (8, 8) になる。\nAreaCollision ノード このノードは、以下の２つを検知するために親ノードの「Area2D」にコリジョン形状を適用する。\nプレイヤーキャラクターが装置の上に乗ったこと 火が出た時にプレイヤーキャラクターが火に当たったこと いずれもプレイヤーキャラクターの足を検出する必要があるため、装置のすぐ上にコリジョン形状を配置する。\nインスペクターで「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。 2D ワークスペースで、「AnimatedSprite」の「off」アニメーションフレームの装置のすぐ上の部分にコリジョン形状を配置する。「RectangleShape2D」＞「Extents」プロパティは (5, 3) になる。\nTimer ノード 火が出る装置の火が出ている時間はこのノードのタイマーで管理する。\nインスペクターで「Wait Time」プロパティはデフォルトの 1 のままにしておく。火が出るのは 1 秒くらいがちょうど良いだろう。 「One Shot」プロパティをオンにしよう。 「Autostart」プロパティはデフォルトのオフのままにしておく。プレイヤーキャラクターが装置に乗ったことを検知してから火を出したいので、スクリプトでタイマーをスタートさせるようのちほどコーディングする。 スクリプトをアタッチして編集する ルートノード「FirePod」にスクリプトをアタッチしよう。この時、ファイルパスを「res://Traps/FirePod/FirePod.gd」として作成する。\nなお、火が出る装置には以下の基本動作を繰り返すように制御しつつ、「on」アニメーション時に装置の上にプレイヤーキャラクターが乗っていたら（火に当たったら）ダメージを与えるように制御していく。\nプレイヤーキャラクターが乗った時に「Area2D」のシグナル発信 シグナルをトリガーに「off」アニメーションを「hit」アニメーションに切り替え 「hit」アニメーションが終了した時に「AnimatedSprite」のシグナル発信 シグナルをトリガーに「on」アニメーションに切り替え 「on」アニメーション開始時に「Timer」のタイマー開始 タイムアウトした時に「Timer」のシグナル発信 シグナルをトリガーに「off」アニメーションに戻る アタッチできたら、さっそく「FirePod.gd」スクリプトを編集していこう。まずはプロパティから定義する。\nextends StaticBody2D # プレイヤーキャラクターが受けるダメージ var damage: float = 20.0 # AnimatedSprite ノードの参照 onready var sprite = $AnimatedSprite # AreaCollision ノードの参照 onready var area_collision = $Area2D/AreaCollision # Timer ノードの参照 onready var timer = $Timer 続いて「Area2D」のシグナル「body_entered」を「FirePod.gd」スクリプトに接続しよう。\n接続できたら、追加された_on_Area2D_body_enteredメソッドを編集する。\n# Area2D ノードが物理ボディを検知した時に発信されるシグナルで呼ばれるメソッド func _on_Area2D_body_entered(body): # プレイヤーキャラクターが乗ったら if body.name == \u0026#34;Player\u0026#34;: # AnimatedSprite ノードのアニメーションが現在「off」の場合 if sprite.animation == \u0026#34;off\u0026#34;: # デバッグ用 print(\u0026#34;Player entered when FirePod off.\u0026#34;) # アニメーション「hit」を再生する sprite.play(\u0026#34;hit\u0026#34;) # AreaCollision ノードの Disabled プロパティをオン（衝突判定を無効）にする area_collision.set_deferred(\u0026#34;disabled\u0026#34;, true) # AnimatedSprite ノードのアニメーションが現在「on」の場合 elif sprite.animation == \u0026#34;on\u0026#34;: # デバッグ用 print(\u0026#34;Player entered when FirePod on.\u0026#34;) # Player ノードの「enemy_hit」シグナルを引数にダメージを渡して発信 body.emit_signal(\u0026#34;enemy_hit\u0026#34;, damage) # Player ノードの　AnimatedSprite ノードのアニメーション「hit」を再生する body.sprite.play(\u0026#34;hit\u0026#34;) # Player ノードの DamageSFX ノードのサウンド（ダメージの効果音）を再生する body.damage_sfx.play() 次は「AnimatedSprite」ノードのアニメーションが終了した時に発信されるシグナル「animation_finished」をスクリプトに接続しよう。追加されたメソッド_on_AnimatedSprite_animation_finishedを以下のように編集する。\nfunc _on_AnimatedSprite_animation_finished(): # AnimatedSprite ノードのアニメーションが現在「hit」の場合 if sprite.animation == \u0026#34;hit\u0026#34;: # Timer ノードのタイマーをスタートさせる timer.start() # AnimatedSprite ノードのアニメーション「on」を再生する sprite.play(\u0026#34;on\u0026#34;) # AreaCollision ノードの Disabled プロパティをオフ（衝突判定を有効）に戻す area_collision.set_deferred(\u0026#34;disabled\u0026#34;, false) 最後に「Timer」ノードのタイマーがタイムアウトした時に発信されるシグナル「timeout」をスクリプトに接続しよう。追加されたメソッド_on_Timer_timeoutを以下のように編集する。\nfunc _on_Timer_timeout(): # AnimatedSprite ノードのアニメーションが現在「on」の場合 if sprite.animation == \u0026#34;on\u0026#34;: # AnimatedSprite ノードのアニメーション「off」を再生する sprite.play(\u0026#34;off\u0026#34;) 以上で「FirePod.gd」スクリプトのコーディングは完了だ。\nLevel3 シーンにインスタンスを追加する 作成した「FirePod.tscn」のインスタンスを「Level3」シーンに追加しよう。今回は5、6個のインスタンスをずらりと並べてその上にアイテムボックスを置いてみた。ダメージ判定も確認したいのでプロジェクトを実行して動作を確認してみよう。\n概ね想定通りの挙動だ。実際にレベルデザインでも、この火が出る装置を連続的に複数並べると効果的だ。走り抜けたら何も怖くない装置だが、途中にアイテムボックスの誘惑を用意しておくと、このトラップの効果が発揮されるだろう。\n応用: スパイク もっと簡単なトラップとして、プラットフォーマーでよく用いられるのが、刺さると痛いスパイク（トゲ）だ。アニメーションも必要もないので、今回の火の当たり判定の部分を応用すれば簡単にシーンを作成できるだろう。\nシーンツリーは、ルートノードを「Area2D」にして、それに「Sprite」と「CollisionShape2D」を追加するだけで済むはずだ。「Sprite」ノードの「Texture」プロパティには「res://Assets/Traps/Spikes/Idle.png」のリソースファイルを適用すると良いだろう。\n詳細な説明は、このチュートリアルのボリュームの関係で割愛させていただく。\n飛んでくる鉄球 今回のチュートリアルではこれが最後の仕掛けになる。難易度も一番高いので頑張ろう。レベル上の任意の場所にチェーンで繋がれたトゲトゲの鉄球だ。仕様としては以下の通りだ。\n鉄球にプレイヤーキャラクターが一定距離まで近づくとプレイヤーキャラクターを検知する 検知した時点のプレイヤーキャラクターの位置を目掛けて鉄球が飛んでくる（追尾はしない） 鉄球はチェーンに繋がれているので一定の距離までしか飛んでこない チェーンが伸びきったら自動的に元の位置に戻る 元の位置に戻った時に 1 の動作を再開する 鉄球に当たるとプレイヤーキャラクターはダメージを受ける シーンを作成する 「Node2D」クラスをルートノードにしてシーンを新規作成する。 ルートノードの名前を「SpikedBall」に変更する。 ファイルパスを「res://Traps/SpikedBall/SpikedBall.tscn」としてシーンを保存する。 以下のスクリーンショットのようなシーンツリーになるように必要なノードを追加していく。\nなお、名前を変更しているノードとそのクラスは以下の通りだ。 「BallArea」ノード: 「Area2D」クラス 「BallCollision」ノード: 「CollisionShape2D」クラス 「DetectionArea」ノード: 「Area2D」クラス 「DetectionCollision」ノード: 「CollisionShape2D」クラス シーンツリーはここまでに作ってきた仕掛けの要素を色々まとめたような構造になっている。動く床と同様に「Path2D」と「PathFollow2D」を利用して鉄球を移動させている。動く床では「AnimationPlayer」を利用したが、鉄球では「Tween」を利用する。また、「Area2D」ブランチは、プレイヤーキャラクターを検知する範囲を設定するためのノードで、仕組みとしては、落ちる床や火が出る装置と同様だ。\nノードのプロパティを編集する Path2D ノード 動く床の時は 2D ワークスペースでパスを描いたが、今回はスクリプトでパスを描くことになるので、ここでは作業不要だ。\nインスペクターで「Resource」＞「Local To Scene」にチェックを入れてオンにする。 Sprite ノード このノードは鉄球のテクスチャ用だ。「BallArea」ノードが鉄球そのものだと考えるとわかりやすいだろう。\nインスペクターで「Texture」プロパティにリソース「res://Assets/Traps/Spiked Ball/Spiked Ball.png」を適用する。 「Offset」の値を (-0.5, -0.5) とする。ドット絵の都合でテクスチャが 1 px だけ右下に寄っているため、中央に配置するよう補正した形だ。 BallCollision ノード このノードは鉄球である「BallArea」ノードにコリジョン形状を適用する。\nインスペクターで「Shape」プロパティに「新規 CircleShape2D」リソースを適用する。 2D ワークスペースで「Sprite」のテクスチャに合わせてコリジョン形状を調整する。トゲの範囲までコリジョン形状を広げるか、内側のボール部分のみにするかで若干ゲームの難易度は変わる。このチュートリアルでは、以下のスクリーンショットのようにボール部分のみとした。「CircleShape2D」リソースのプロパティ「Radius」の値は 10 、「Custom Solver Bias」は 0 になる。\nDetectionCollision ノード こちらの「CollisionShape2D」クラスのノードは、プレイヤーキャラクターの検知用だ。いわば鉄球トラップのテリトリーと言っても良いだろう。半径 80 px の円で形成する。\nインスペクターで「Shape」プロパティに「新規 CircleShape2D」リソースを適用する。 こちらは 2D ワークスペースでは作業せず、インスペクターにそのまま半径の値を入力する。「CircleShape2D」リソースの「Radius」プロパティの値を 80 にする。「Custom Solver Bias」は 0 のまま。2D ワークスペースでは以下のスクリーンショットのようになったはずだ。\nチェーンのシーンを作成する 鉄球はチェーンで地面に繋がれている。この長いチェーンを構成するチェーンのセグメントをシーンとして作成する。ちょうど動く床と同じパターンだ。\nルートノードに「Sprite」クラスを指定して新規でシーンを作成する。 ルートノードの名前は「SpikedBallChain」に変更する。 「MovingPlatformChain」ルートノードの「Texture」プロパティにリソース「res://Assets/Traps/Spiked Ball/Chain.png」を適用する。 ファイルパスを「res://Traps/SpikedBall/SpikedBallChain.tscn」としてシーンを保存する。 スクリプトをアタッチして編集する ではスクリプトをルートノードの「SpikedBall」にアタッチしよう。ファイルパスを「res://Traps/SpikedBall/SpikedBall.gd」として作成する。\nここからは大まかに以下の仕様を形にしていく。\n鉄球のシーンが読み込まれた時にチェーンを作成する 「Area2D」ノードでプレイヤーキャラクターを検知して発信するシグナルをトリガーにして 「Path2D」パスを作成する 鉄球を移動させる 鉄球の位置に合わせて常にチェーン全体の長さ（各チェーンセグメントの位置）を変化させる プレイヤーキャラクターが鉄球に当たったらダメージを与える では「SpikedBall.gd」をスクリプトを編集していこう。まずはプロパティの定義からだ。\nextends Node2D # チェーンの最大の長さ var chain_length = 80 # チェーンセグメントの数 var chain_num = 10 # プレイヤーキャラクターが受けるダメージ var damage = 20.0 # Path2D ノードの参照 onready var path = $Path2D # PathFollow2D ノードの参照 onready var path_follow = $Path2D/PathFollow2D # BallArea ノードの参照 onready var ball_area = $Path2D/PathFollow2D/BallArea # DetectionArea ノードの参照 onready var detection_area = $DetectionArea # DetectionCollision ノードの参照 onready var detection_collision = $DetectionArea/DetectionCollision # Tween ノードの参照 onready var tween = $Tween # チェーンのシーンファイルのプリロードの参照 onready var chain_scn = preload(\u0026#34;res://Traps/SpikedBall/SpikedBallChain.tscn\u0026#34;) # チェーンセグメントのコンテナとして利用する配列 onready var chain_container = [] 次に鉄球シーンが読み込まれる際にチェーンを作成するコードを記述する。\n# シーン読み込み時に呼ばれるメソッド func _ready(): # チェーンを作成するメソッドを呼ぶ make_chain() # チェーンを作成するメソッドを定義 func make_chain(): # チェーンのセグメントの数（10）だけループ処理 for i in range(chain_num): # チェーンのシーンをインスタンス化 var chain = chain_scn.instance() # チェーンのインスタンスを子ノードとして SpikedBall ルートノードに追加 add_child(chain) # 子に追加したインスタンスノードを 0 番目に移動 move_child(chain, 0) # インスタンスノードを背面に移動 chain.z_index = -1 # チェーンセグメントのコンテナ用配列に追加 chain_container.append(chain) 次に_processメソッドを利用して毎フレーム、チェーンの長さ（チェーンセグメントの個々の位置）を更新するようにする。\n# Tips：引数 delta を使用しない時は _delta とするとアラートが出ない func _process(_delta): # チェーンを再配置するメソッドを呼ぶ relocate_chain() # チェーンを再配置するメソッドを定義する func relocate_chain(): # ルートノードの位置から現在の鉄球の位置に対する方向を取得 var direction = global_position.direction_to(ball_area.global_position) # ルートノードの位置から現在の鉄球の位置までの距離をチェーンセグメントの数で割って... # ...セグメント１つ分の長さを取得する var segment_length = global_position.distance_to(ball_area.global_position) / chain_num # チェーンセグメントの数（10）だけループ処理 for i in range(chain_num - 1): # コンテナから順番に取り出したチェーンセグメントの位置を次の計算式で指定する... # ... 方向 × セグメントの長さ × コンテナの順番 chain_container[i].position = direction * segment_length * i 次に「DetectionArea」ノードのコリジョン形状の範囲にプレイヤーキャラクターが入った時の挙動を作っていく。まず「Area2D」がプレイヤーキャラクターを検知した時に発信されるシグナル「body_entered」をスクリプトに接続しよう。\nシグナルが接続できたら、追加されたメソッド_on_DetectionArea_body_enteredと、その中で呼ばれる２つのメソッドを記述していく。その２つのメソッドのうち、１つは「Path2D」ノードに2つの点を打って直線のパスを作成するメソッド。もう一つは「Path2D」ノードで作成されたパスの経路を辿って鉄球が移動するアニメーションを制御するメソッドだ。\n# DetectionArea ノードのコリジョン形状に物理ボディが入った時に発信されるシグナルで呼ばれるメソッド func _on_DetectionArea_body_entered(body): # デバッグ用 print(\u0026#34;_on_DetectionArea_body_entered called\u0026#34;) # 検知した物理ボディが Player ノードだったら if body.name == \u0026#34;Player\u0026#34;: # Path2Dのパスを作成するメソッドを呼ぶ set_path_points(body) # 鉄球をパスに沿って動かすメソッドを呼ぶ move_ball() # DetectionCollision ノードの衝突判定を無効化する detection_collision.set_deferred(\u0026#34;disabled\u0026#34;, true) # Path2Dのパスを作成するメソッドを定義 func set_path_points(body): # デバッグ用 print(\u0026#34;set_path_points called\u0026#34;) # 一度 Path2D のパスの点を全て消去してリセットする path.curve.clear_points() # まず鉄球のデフォルトの位置である原点(0, 0)にパスの点を追加する path.curve.add_point(Vector2.ZERO) # 鉄球の現在の位置から衝突した物理ボディ（「Player」ノードのこと）に対する方向を取得 var direction = global_position.direction_to(body.global_position) # 鉄球から物理ボディへの方向にチェーンの最大長を乗算した位置を鉄球がこれから目指す位置とする var directed_point = direction * chain_length # 鉄球が目指す位置を Path2D ノードのパスの２つ目の点として追加する path.curve.add_point(directed_point) # 鉄球をパスに沿って移動させるメソッドを定義 func move_ball(): # デバッグ用 print(\u0026#34;move_ball called\u0026#34;) # PathFollow2D の Unit Offset プロパティを 0 から 1 へ 0.5 秒かけて変化させる Tween の設定 tween.interpolate_property(path_follow, \u0026#34;unit_offset\u0026#34;, 0, 1, 0.5) # Tween ノードのアニメーションを開始する tween.start() # Tween ノードの tween_completed を利用してアニメーション（移動）が終わるのを待つ yield(tween,\u0026#34;tween_completed\u0026#34;) # PathFollow2D の Unit Offset プロパティを 1 から 0 へ 1 秒かけて変化させる Tween の設定 tween.interpolate_property(path_follow, \u0026#34;unit_offset\u0026#34;, 1, 0, 1) # Tween ノードのアニメーションを開始する tween.start() # アニメーション（移動）が終わるのを待つ yield(tween,\u0026#34;tween_completed\u0026#34;) # DetectionCollision ノードの衝突判定を有効化する detection_collision.set_deferred(\u0026#34;disabled\u0026#34;, false) 改めて解説すると、メソッドset_path_pointsは、「Path2D」ノードに原点 (0, 0) とプレイヤーキャラクターを検知した位置の２つの点を追加して直線のパスを作る。次にメソッドmove_ballで、そのパスの両端を「Tween」ノードを利用して鉄球が行って戻ってくる動作を処理している。\n最後に鉄球にプレイヤーキャラクターが当たった時のダメージ処理をコーディングする。まず先に、鉄球「BallArea」ノードのコリジョン形状にプレイヤーキャラクターが入った時に発信されるシグナル「body_entered」をスクリプトに接続しよう。\n接続できたら、追加された_on_BallArea_body_enteredメソッドを以下のように編集する。\n# BodyArea に物理ボディが入った時に呼ばれるメソッド func _on_BallArea_body_entered(body): # 物理ボディが Player ノードだったら if body.name == \u0026#34;Player\u0026#34;: # Player ノードのシグナル「enemy_hit」を引数にダメージを渡して発信 body.emit_signal(\u0026#34;enemy_hit\u0026#34;, damage) # Player シーンの AnimatedSprite ノードのアニメーション「hit」を再生 body.sprite.play(\u0026#34;hit\u0026#34;) # Player シーンの DamageSFX ノードのサウンド（効果音）を再生する body.damage_sfx.play() これで飛んでくる鉄球のコーディングは完了だ。\nLevel3 シーンにインスタンスを追加する 出来上がった飛んでくる鉄球のシーン「Spikes.tscn」のインスタンスを「Level3」シーンに追加して動作確認してみよう。今回もダメージ判定を含めて確認するため、プロジェクトを実行しよう。\nちょうどうまく操作すればかわせる程度のスピードで鉄球が飛んでくるように調整できた。チェーンが最大長まで伸びきったら鉄球は元の位置に戻る。飛んでくる時は0.5秒で移動するが、戻るときは1秒かかる。この辺りも丁度良い塩梅になったのではないだろうか。\nLevel3 のレベルデザインをする ここまでに作った装置を全て使用して「Level3」シーンをデザインしてみよう。\n「MovingPlatform」のインスタンスを追加した時は、そのノードを右クリックして「編集可能な子」にして「Path2D」のパスの形も色々作ってみよう。ただし、その前に「Curve」プロパティの「Curve2D」リソースをユニーク化することをお忘れなく。\nまた、応用編として紹介した回転ノコギリやスパイクのシーンも作成している場合は、それらのインスタンスも追加しよう。\nこのチュートリアルではサンプルとして以下のようなデザインにした。\nタイルマップのデザインや今回作ったそれぞれの装置の配置をして「Level3」のデザインが完成したら、プロジェクトを実行してゲームを遊んでみよう。\nPart 15 で編集したスクリプトのコード 最後に今回の Part 15 で編集したスクリプトのコードを共有しておくので、必要に応じて確認してほしい。\n.MovingPlatform.gd の全コード extends Node2D onready var path = $Path2D onready var chain_scn = preload(\u0026#34;res://Traps/MovingPlatform/MovingPlatformChain.tscn\u0026#34;) func _ready(): make_chain() func make_chain(): var points = path.curve.get_baked_points() for point in points: var chain = chain_scn.instance() add_child(chain) move_child(chain, 0) chain.z_index = -1 chain.position = point FallingPlatform.gd の全コード extends KinematicBody2D var gravity = 512 var velocity = Vector2() onready var anim_player = $AnimationPlayer onready var timer = $Timer func _ready(): set_physics_process(false) func _physics_process(delta): velocity.y += gravity * delta move_and_slide(velocity, Vector2.UP) func _on_Area2D_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: anim_player.play(\u0026#34;shaking\u0026#34;) func _on_AnimationPlayer_animation_finished(anim_name): if anim_name == \u0026#34;shaking\u0026#34;: set_physics_process(true) timer.start() func _on_Timer_timeout(): queue_free() Spring.gd の全コード extends StaticBody2D var player onready var sprite = $AnimatedSprite func _on_Area2D_body_entered(body): sprite.frame = 0 if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Player entered Spring area\u0026#34;) player = body sprite.play(\u0026#34;jump\u0026#34;) func _on_AnimatedSprite_frame_changed(): if sprite.animation == \u0026#34;jump\u0026#34; and sprite.frame == 1 and player != null: player.velocity.y = - player.jump_force * 2 player.can_double_jump = true FirePod.gd の全コード extends StaticBody2D var damage: float = 20.0 onready var sprite = $AnimatedSprite onready var area_collision = $Area2D/AreaCollision onready var timer = $Timer func _on_Area2D_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: if sprite.animation == \u0026#34;off\u0026#34;: print(\u0026#34;Player entered when FirePod off.\u0026#34;) sprite.play(\u0026#34;hit\u0026#34;) area_collision.set_deferred(\u0026#34;disabled\u0026#34;, true) elif sprite.animation == \u0026#34;on\u0026#34;: print(\u0026#34;Player entered when FirePod on.\u0026#34;) body.emit_signal(\u0026#34;enemy_hit\u0026#34;, damage) body.sprite.play(\u0026#34;hit\u0026#34;) body.damage_sfx.play() func _on_AnimatedSprite_animation_finished(): if sprite.animation == \u0026#34;hit\u0026#34;: timer.start() sprite.play(\u0026#34;on\u0026#34;) area_collision.set_deferred(\u0026#34;disabled\u0026#34;, false) func _on_Timer_timeout(): if sprite.animation == \u0026#34;on\u0026#34;: sprite.play(\u0026#34;off\u0026#34;) SpikedBall.gd の全コード extends Node2D var chain_length = 80 var chain_num = 10 var damage = 20.0 onready var path = $Path2D onready var path_follow = $Path2D/PathFollow2D onready var ball_area = $Path2D/PathFollow2D/BallArea onready var detection_area = $DetectionArea onready var detection_collision = $DetectionArea/DetectionCollision onready var tween = $Tween onready var chain_scn = preload(\u0026#34;res://Traps/SpikedBall/SpikedBallChain.tscn\u0026#34;) onready var chain_container = [] func _ready(): make_chain() func make_chain(): for i in range(chain_num): var chain = chain_scn.instance() add_child(chain) move_child(chain, 0) chain.z_index = -1 chain_container.append(chain) func _process(_delta): relocate_chain() func relocate_chain(): var direction = global_position.direction_to(ball_area.global_position) var segment_length = global_position.distance_to(ball_area.global_position) / chain_num for i in range(chain_num - 1): chain_container[i].position = direction * segment_length * i func _on_DetectionArea_body_entered(body): print(\u0026#34;_on_DetectionArea_body_entered called\u0026#34;) if body.name == \u0026#34;Player\u0026#34;: set_path_points(body) move_ball() detection_collision.set_deferred(\u0026#34;disabled\u0026#34;, true) func set_path_points(body): print(\u0026#34;set_path_points called\u0026#34;) path.curve.clear_points() path.curve.add_point(Vector2.ZERO) var direction = global_position.direction_to(body.global_position) var directed_point = direction * chain_length path.curve.add_point(directed_point) func move_ball(): print(\u0026#34;move_ball called\u0026#34;) tween.interpolate_property(path_follow, \u0026#34;unit_offset\u0026#34;, 0, 1, 0.5) tween.start() yield(tween,\u0026#34;tween_completed\u0026#34;) tween.interpolate_property(path_follow, \u0026#34;unit_offset\u0026#34;, 1, 0, 1) tween.start() yield(tween,\u0026#34;tween_completed\u0026#34;) detection_collision.set_deferred(\u0026#34;disabled\u0026#34;, false) func _on_BallArea_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: body.emit_signal(\u0026#34;enemy_hit\u0026#34;, damage) body.sprite.play(\u0026#34;hit\u0026#34;) body.damage_sfx.play() おわりに 以上で Part 15 は完了だ。\n今回はステージ上の様々な仕掛けを作った。オーソドックスな仕掛けでも、タイルマップとの組み合わせ、敵キャラクターの組み合わせ、仕掛け同士の組み合わせによって、楽しく、そして難しいレベルデザインが可能になるだろう。プレイヤーにどうやって先に進めるのかを考える機会を与え、考えた結果、難しい場面を乗り越えられたときにある種の快感を提供することができるはずだ。\nさて、今回の Part 15 にて「Godot で作るプラットフォーマー」のチュートリアルシリーズは終了だ。このシリーズを通して、プラットフォーマーのゲームを作るための基本的なところは網羅できただろう。チュートリアルを参考にしてくださった方々には感謝申し上げたい。また、このチュートリアルがこれからゲーム開発に挑戦したいと考えている方々に少しでもお役に立てたならば幸いだ。\nところで、面白いことに、自分でプラットフォーマーのゲームを作ってみたあと、改めて往年のスーパーマリオブラザーズシリーズなどをプレイしてみると、あらゆる部分でゲームが緻密に設計されているのがよくわかる。ジャンプひとつとっても絶妙のバランスだ。世界的にゲームが大ヒットする理由の一つはやはりゲームデザインなのだと思い知らされる。ゲームデザインは十分条件ではないが、必要条件であると言っても過言ではないだろう。\n今後も Godot を使った別のチュートリアルシリーズや、Godot を使う上での Tips 的なブログを投稿していくので、これからも Peanuts-code.com のコンテンツをどうぞお楽しみに。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0005_platformer/platformer_15/","summary":"第15回目の今回はいよいよこのチュートリアルのシリーズの最終回だ。最終回はプラットフォーマーのレベルデザインに比較的よく使われるいくつかの仕掛けを追加していく。具体的には以下にリストアップしたトラップ","title":"Godot で作るプラットフォーマー Part 15：いろいろな仕掛けを追加しよう！"},{"content":"この記事では、「AudioStreamPlayer」ノード 1 つで複数のサウンドリソース（音楽や効果音のファイル）を切り替えて再生する方法を説明する。\n基本的に、「AudioStreamPlayer」系のクラスは、ノード１つに対して、設定できるサウンドリソースは１つだけだ。つまり、サウンドリソースの数だけシーンツリー内に「AudioStreamPlayer」ノードを追加しなければならない。サウンドリソース以外全て同じ設定のノードがシーンツリー内に複数存在する（以下のスクリーンショットのような）状況には無駄を感じるだろうし、またシーンドックの視認性が悪くて少し嫌になるかもしれない。\nそこで、同時に鳴らすことがない複数のサウンドリソースがある場合（例えば、キャラクターの攻撃の種類に応じた複数の効果音やUI上のボタンの種類に応じた複数の効果音など）、プロジェクトには用途ごとに必要最小限の「AudioStreamPlayer」ノードだけ追加しておき、それぞれスクリプトから状況に応じてサウンドリソースを切り替えれば無駄がなく、シーンドックの見た目もスッキリするはずだ。\nということで、ここからのチュートリアルでは、「AudioStreamPlayer」ノードは１つだけ用意して、そこに適用するサウンドリソースをスクリプトから切り替えて、再生できるように制御していく。\nEnvironment Godot のバージョン: 3.5.1\nコンピュータのOS: macOS 12.6\nBasic Articles 以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 準備 プロジェクト設定 新規プロジェクトを立ち上げたら、「プロジェクト」メニュー＞「プロジェクト設定」から以下の設定を行なう。\n「一般」タブ ＞ サイドバー「Display」＞「Window」＞「Size」セクションにて、ウインドウサイズを以下のように設定する。\nサウンドリソースのダウンロード 以下のDropboxの共有フォルダに ６ つの .wav ファイル（効果音）を用意している。\nDropbox - 共有フォルダ ダウンロードした「audio」フォルダごとファイルシステムドックへドラッグ\u0026amp;ドロップしてプロジェクトへ追加する。\nシーンの作成 以下のようなシーンツリーを作る。今回は過去最高にシンプルなツリーである。\nUI (Control) SoundLabel (Label) AudioStreamPlayer シーンツリーの作成が完了したら、ファイル名を「UI.tscn」として保存しておく。\nノードの編集 UI (Control) ルートノード このルートノードの「Anchor」を画面サイズと同じになるよう拡げておく。理由は、このあと子ノードの「SoundLabel」を画面の中央に配置したいからだ。\n2D ワークスペースのツールバーから「Layout」＞「全画面(Full Rect)」を選択する。これで「Anchor」プロパティは自動的に調整され、2D ワークスペース上も以下のようになる。\nSoundLabel (Label) ノード このノードは、現在「AudioStreamPlayer」ノードの「Stream」プロパティに適用されているサウンドリソースのパスを表示するために利用する。これにより、プロジェクトを実行して動作確認をする時に、今どのリソースファイルを適用および再生しているのかがひと目でわかる。\nインスペクターにて「Text」プロパティには一旦「no sound」と仮に入れておく。\n「Align」プロパティを「Center」に変更する。これで「Text」の文字列が水平方向で中央に表示される。\n「Control」クラスの「Grow Direction」＞「Horizontal」プロパティを「Both」に変更する。これで「Text」の文字数が増えても左右両方向に拡大するので、常に画面中央に表示される。\n2D ワークスペースのツールバーから「Layout」＞「中央」を選択する。2D ワークスペース上も以下のようになる。\nAudioStreamPlayer ノード このノードはサウンドリソースを適用して、それを再生するためのノードだ。ノードの作りとして、もともと１つのサウンドリソースしか設定できない仕様であるが、今回のチュートリアルでは、このノード１つで、複数のサウンドリソースを切り替えて再生させる。その制御はのちほどスクリプトにて行うことになるが、ここではひとまずノードの設定をしておく。\nファイルシステムドックから先にインポートしておいたサウンドリソースファイルのうち「res://auido/coin.wav」を、インスペクターの「Stream」プロパティへドラッグ\u0026amp;ドロップして適用する。ひとまずこれをデフォルトのサウンドリソースとする。 UI ルートノードにスクリプトをアタッチする いよいよ、サウンドリソースを設定と再生を制御するためのスクリプトを作成していく。まずはルートノード「UI」に新規でスクリプトをアタッチする。このときスクリプトのファイル名は「UI.gd」としておく。スクリプトをアタッチして、スクリプトエディタが開いたら、以下のようにコードを編集する。\nextends Control # 定数としてプリロードしたサウンドリソースを配列にしておく const sounds = [ # デフォルトのリソースを1番目の要素にしている preload(\u0026#34;res://auido/coin.wav\u0026#34;), preload(\u0026#34;res://auido/heal.wav\u0026#34;), preload(\u0026#34;res://auido/hurt.wav\u0026#34;), preload(\u0026#34;res://auido/shoot1.wav\u0026#34;), preload(\u0026#34;res://auido/shoot2.wav\u0026#34;), preload(\u0026#34;res://auido/shoot3.wav\u0026#34;), ] # 配列 sounds の要素のうち AudioStreamPlayer に設定する # リソースを指定するためのインデックス(0 から 5 まで) var index: int = 0 # SoundLabel の参照 onready var sound_label = $SoundLabel # AudioStreamPlayer の参照 onready var player = $AudioStreamPlayer # ノードが読み込まれたら実行される組込み関数 func _ready(): # サウンドを再生するメソッドを呼び出す（あとで定義） play_sound() # 組み込みプロセス関数（毎フレーム呼び出される） func _process(_delta): # 右矢印キーが押されたら if Input.is_action_just_pressed(\u0026#34;ui_right\u0026#34;): # 現在のインデックスが配列 sounds の最後のインデックス(5) # より小さければ現在のインデックスに 1 を足す if index \u0026lt; sounds.size() - 1: index += 1 # 現在のインデックスが配列 sounds の最後のインデックス(5) # であればインデックスを 0 に戻す else: index = 0 # サウンドを再生するメソッドを呼び出す（あとで定義） play_sound() # 左矢印キーが押されたら if Input.is_action_just_pressed(\u0026#34;ui_left\u0026#34;): # 現在のインデックスが 0 より大きければ # 現在のインデックスから 1 を引く if index \u0026gt; 0: index -= 1 # 現在のインデックスが 0 であれば # インデックスを配列 sounds の最後のインデックスと同じ(5)にする else: index = sounds.size() - 1 # サウンドを再生するメソッドを呼び出す（あとで定義） play_sound() # スペースバーかエンターキーが押されたら if Input.is_action_just_pressed(\u0026#34;ui_accept\u0026#34;): # サウンドを再生するメソッドを呼び出す（あとで定義） play_sound() # サウンドを再生するメソッド func play_sound(): # 配列 sounds から現在のインデックスに該当する要素を取得して # AudioStreamPlayer の Stream プロパティに適用する player.stream = sounds[index] # AudioStreamPlayer の Stream プロパティのリソースパスを # SoundLabel の Text プロパティに 設定する sound_label.text = player.stream.resource_path # AudioStreamPlayer の Stream プロパティのサウンドリソースを再生 player.play() これでスクリプトの編集は完了だ。\nなお、今回はpreloadを利用して、ノードが読み込まれるタイミングでサウンドリソースも読み込んでおくようにした。これは、処理の多いゲームの場合、動作遅延回避策になるだろう。反対に、大して処理が多くないのであればloadを利用して、再生する直前にリソースファイルを読み込んでも問題ないだろう。詳しくは以下の記事が大変参考になるので併せてご覧いただきたい。\n2dgames.jp -【Godot】サウンドを動的にロードして再生する方法 動作確認 最後にプロジェクトまたはシーンを実行して動作確認しておく。\nここまでで実装した通り、以下のキーボード操作でサウンドリソースを切り替え、再生できる。\n右矢印キー: 「UI.gd」スクリプトの配列sounds上の次のサウンドリソースに切り替えて再生 左矢印キー: 「UI.gd」スクリプトの配列sounds上の前のサウンドリソースに切り替えて再生 スペースバー / エンターキー: 現在設定されているサウンドリソースを再生 Your browser does not support the video tag. おわりに 今回のチュートリアルは、１つの「AudioStreamPlayer」ノードで複数のサウンドリソースを切り替えて再生する方法についてお伝えした。大事なポイントをまとめておこう。\n「AudioStreamPlayer」１つで複数のサウンドリソースを切り替えて再生できる。 上記手法は、設定がほとんど同じ複数の「AudioStreamPlayer」ノードを追加する無駄を回避し、シーンツリーの視認性を向上する目的で実装する。 サウンドの切り替えと再生はスクリプトで制御する。 もちろん、プログラミングが苦手な場合は、サウンドリソースの数だけ「AudioStreamPlayer」ノードをシーンに追加しても全く問題ない。今回紹介したのは、あくまで一つの方法論に過ぎないので、特にインディー開発の場合は自由にやっていただきたい。\n参考 Godot Docs - オーディオストリーム Godot Docs - AudioStreamPlayer 2dgames.jp -【Godot】サウンドを動的にロードして再生する方法 ","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0020_switching_sound_resources/","summary":"この記事では、「AudioStreamPlayer」ノード 1 つで複数のサウンドリソース（音楽や効果音のファイル）を切り替えて再生する方法を説明する。 基本的に、「AudioStreamPlayer」系の","title":"Godot3 のサウンドリソースをプログラムで切り替える方法"},{"content":"今回のテーマは 2D ゲームのアニメーションステートマシンの実装だ。ステートとは「状態」のことで、ステートマシンというのは、キャラクターのある状態からある状態への遷移を制御する仕組みのことだ。\nある状態からは限られた状態にしか遷移できなかったり、状態によって今のアニメーションが終了してから次の状態に遷移させるのか、ただちに遷移させるのかの違いがある。例えば、「idle（待機）」と「run（移動）」はただちに双方向に遷移するが、「idle」から「attack（攻撃）」へはただちに遷移しても「attack」から「run」へは遷移せず、また「attack」から「idle」へは「attack」のアニメーションが終わってから遷移する、といった具合だ。\nこれらの制御を全てスクリプトでコーディングすると、コードがやや長く、複雑になりがちである。一方、Godot の「AnimationTree」ノードを利用すれば、スクリプトのコード量が減って可読性を高めることができるのだ。今回はこの「AnimationTree」ノードを使ったステートマシンの実装方法を紹介していく。\nEnvironment Godot のバージョン: 3.5.1\nコンピュータのOS: macOS 12.6\nBasic Articles 以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 準備 プロジェクト設定 新規プロジェクトを立ち上げたら、下準備としてプロジェクト設定をしておく。\nウインドウサイズは以下のように設定した。\nインプットマップに、プレイヤーキャラクターの移動と攻撃のアクションを以下のとおりに追加した。\nアセットをダンロードする 今回は以下のリンク先からアセットパックをダウンロードさせていただいた。\nitch.io - mystic woods ダウンロードしたフォルダの中にある「player.png」「slime.png」「objects.png」の3つのスプライトシートを利用する。この素晴らしいアセットに感謝せずにはいられない。\n３つのスプライトシート（.pngファイル）は、Godot のファイルシステムへドラッグ\u0026amp;ドロップしてプロジェクトに追加する。\n追加した画像がぼやけた感じで表示されていたら（デフォルトではそうなる）、インポートしたファイルを選択して、「インポート」タブから「プリセット」＞「2D Pixel」を選択して、再インポートすること。これでドット絵特有のエッジの効いた状態で表示される。\nPlayer シーンを作る プレイヤーキャラクター用に「Player」シーンを作成する。シーンツリーは以下のようになる。\nPlayer (KinematicBody2D) Sprite BodyCollisionShape (CollisionShape2D) HitBox (Area2D) HitBoxCollisionShape (CollisionShape2D) AnimationPlayer AnimationTree Player シーンのノードを編集する Sprite ノード インスペクターにて「Texture」プロパティに先にインポートしておいたリソース「player.png」を適用する。\n「Animation」＞「Hframes」プロパティの値を 6 に、「Vframes」プロパティの値を 5 にする。これは適用したスプライトシートが水平方向に 6 列、垂直方向に 5 行で構成されているので、それに合わせた格好だ。無料版のスプライトシートなので 4 行目がないが気にしないでほしい。のちほど「AnimationPlayer」ノードで、このフレーム数を変化させることでアニメーションを作成していく。\n「Offset」＞「Offset」プロパティを (0, -17) に変更する。これでプレイヤーキャラクターのテクスチャの足元がちょうど座標 (0, 0) にくる。これはゲーム画面上で他のオブジェクトと重なった時にそれぞれの y 座標を比較して、手前の（y 座標が大きい）オブジェクトの方が前面に表示されるようにするための措置だ。\nBodyCollisionShape (CollisionShape2D) ノード インスペクターにて「Shape」プロパティに「CircleShape2D」リソースを適用して、以下のようにサイズと位置を調整した。\nHitBox (Area2D) ノード このノードは近接攻撃のための Hit Box 用のノードだ。このノードは特に編集の必要はない。なお、近接攻撃の実装について詳しくは以下の記事で解説している。\nGodot3 で作る 2D ゲームの近接攻撃の当たり判定 HitBoxCollisionShape (CollisionShape2D) ノード 「Shape」プロパティに「RectangleShape2D」リソースを適用する。このノードで Hit Box の衝突形状を設定するわけだが、そのサイズや位置は「AnimationPlayer」ノードのアニメーションの中で変化させるので、ここではいったんそのままにしておき、アニメーション作成時に設定することにする。「Disabled」プロパティもまた攻撃用のアニメーションの中で変更することになるが、攻撃時以外は Hit Box を無効にする必要があるので、オンにしておく。\nAnimationPlayer ノード インスペクターで「Root Node」が「Player」ノードに設定されていることを確認する。\nアニメーションを作る アニメーションパネルにて、以下の 6 種類のアニメーションを作る。\nidle\n待機中のアニメーション。「Sprite」ノードの「Frame」プロパティを変化させるだけ。ループはオン。\nrun\n移動中のアニメーション。「Sprite」ノードの「Frame」プロパティを変化させるだけ。ループはオン。\nattack1\n攻撃時のアニメーションその1。「Sprite」ノードの「Frame」プロパティを変化させるのに加えて、「BodyCollisionShape」と「HitBoxCollisionShape」の「Disabled」プロパティのオンオフを切り替える。ループはオフ。このタイミングで「HitBoxCollisionShape」の衝突形状の位置とサイズをスプライトの剣の軌跡に合せて設定しておくこと。\nattack2\n攻撃時のアニメーションその2。その1のアニメーション再生中に攻撃操作をするとその2が再生され、連続攻撃しているような演出にする。「attack1」を逆再生させているだけ。ループはオフ。\nhurt\nダメージを受けた時のアニメーション。スプライトシートにダメージを受けた時のテクスチャはないので色を点滅させて表現する。「Sprite」ノードの「Modulate」プロパティを 白 ⇄ 赤（半透明）の2色間で複数回切り替えている。パネル左上の「+Add Track」をクリックして「Call Method Track」を２つ追加した。一つは、アニメーションの最後でset_physics_process()メソッドを呼び出すようにした。インスペクターで「Args」＞「0」＞「Value」をオンにする。これはこのメソッドの引数にtrue を渡しているという意味だ。ループはオフ。もう一つは、後ほどスクリプトでメソッドを定義してから追加することになる（ここでは追加後の状態を示している）。die_on_hurt_anim()メソッドを呼び出すようにした。これはライフが 0 になったら「die」アニメーションへ遷移させるメソッドになるが、スクリプトを作成する際にもう一度説明する。\ndie\n死んだ時のアニメーション。「Sprite」ノードの「Frame」プロパティを変化させるだけ。ループはオフ。\nなお、「attack1」や「attack2」という命名規則は以下の動画を参考にしている。\nYouTube - Name Files Logically AnimationTree ノード このノードを使って、「AnimationPlayer」で用意したアニメーションを制御するステートマシンを作っていく。\nインスペクターにて「Tree Root」プロパティで「新規 AnimationNodeStateMachine」を選択する。アニメーションの状態管理をできるようするための設定だ。 「Anim Player」プロパティで「AnimationPlayer」ノードが選択されている状態にする。 「Active」プロパティをオンにする。オンにしないとこのノードは機能しない。ただし「AnimationPlayer」ノードの方でアニメーションを追加したり編集したりする時、オフにしてアニメーションの再生を止める必要があるかもしれない。\nステートマシンのアニメーションツリーを作る ここからはアニメーションパネル上での作業になる。ステートマシンを担うアニメーションツリーを構成していく。\nアニメーションツリーパネルを開く。\n選択・移動ツールでパネル内を右クリックするか、\nノード作成ツールでパネル内をクリックすると、\n「AnimationPlayer」で作成したアニメーションの中からノードとして追加したいアニメーションを選択できる。\nひとまず「AnimationPlayer」で作成したアニメーションを全て、アニメーションツリーのノードとして追加する。以下のスクリーンショットではノードが整頓されているが、実際のアニメーションツリー作成では、ノード同士を接続していきながら、都度、見やすい配置に調整することになるだろう。\n続いて、選択・移動ツールで Shift キーを押しながら、\nまたはノード接続ツールで\nノードからノードへドラッグ操作をすると、ノード同士を接続することができる。\n接続した矢印を選択した状態でインスペクターを見ると「AnimationNodeStateMachineTransition」というリソースであることがわかる。このリソースの「Switch Mode」プロパティをデフォルトの「Immediate」から「AtEnd」に変更すると、そのノードのアニメーションが終了してから次のノードのアニメーションへ遷移させることができる。この時やパネル内の矢印は線が入った表示になる。 さらに「Auto Advance」プロパティをオンにしておけば、スクリプトで制御せずとも自動的に遷移させることができる。この場合、矢印は緑色になる。\n例えば、プレイヤーキャラクターが敵からダメージを受けた時は、ただちに「idle」から「hurt」へアニメーションを切り替えるが、「hurt」のアニメーションが終了したら自動的に「idle」へ遷移させたい。この場合は以下のようになる。\nゲーム開始時の最初のアニメーションは自動再生させたいので「idle」アニメーションのノードを選択して自動再生を有効にしておく。\n同様に、プレイヤーキャラクターが死んだ時の「die」アニメーションのノードを選択して最後のノードとして設定しておく。\n最終的に以下のような構成とした。今回は移動中は攻撃できないようにしている。\nPlayer ノードにスクリプトをアタッチする 「Player」ノードにスクリプトをアタッチして、以下のように編集する。\n###Player.gd### extends KinematicBody2D # ライフ var life: int = 3 # 速さ var speed := 80.0 # 速度（方向を含む） var velocity: Vector2 # Spriteノードの参照 onready var sprite = $Sprite # AnimationTree ノードの Parameters \u0026gt; Playback プロパティ # つまり AnimationNodeStateMachinePlayback リソース onready var state_machine = $AnimationTree.get(\u0026#34;parameters/playback\u0026#34;) func _physics_process(_delta): get_input() velocity = move_and_slide(velocity) # プレイヤーの入力に関するメソッド func get_input(): # 現在のステートを取得 var current_state = state_machine.get_current_node() # 攻撃の入力 if Input.is_action_just_pressed(\u0026#34;attack\u0026#34;): # 今のステートが attack1 でなければ attack1 へ遷移 if current_state != \u0026#34;attack1\u0026#34;: state_machine.travel(\u0026#34;attack1\u0026#34;) # 今のステートが attack1 の場合は attack2 へ遷移 else: state_machine.travel(\u0026#34;attack2\u0026#34;) # 攻撃の入力した場合、移動の入力は受け付けずに終了 return # 移動の入力 velocity = Vector2() if Input.is_action_pressed(\u0026#34;right\u0026#34;): velocity.x += 1 sprite.flip_h = false if Input.is_action_pressed(\u0026#34;left\u0026#34;): velocity.x -= 1 sprite.flip_h = true if Input.is_action_pressed(\u0026#34;down\u0026#34;): velocity.y += 1 if Input.is_action_pressed(\u0026#34;up\u0026#34;): velocity.y -= 1 velocity = velocity.normalized() * speed # 移動速度の長さが 0 の場合はステートを idle へ遷移 if velocity.length() == 0: state_machine.travel(\u0026#34;idle\u0026#34;) # 移動速度の長さが 0 より大きい場合はステートを run へ遷移 if velocity.length() \u0026gt; 0: state_machine.travel(\u0026#34;run\u0026#34;) # ダメージを受けた時に呼び出されるメソッド func hurt(): # ライフが 1 減る life -= 1 # 物理プロセスを停止して入力を受け付けなくする set_physics_process(false) # ステートを hurt へ遷移 state_machine.travel(\u0026#34;hurt\u0026#34;) # hurt アニメーションの最後で呼び出される func die_on_hurt_anim(): # ライフが 0 より大きければ何もせず終了 if life \u0026gt; 0: return # ステートを die へ遷移 state_machine.travel(\u0026#34;die\u0026#34;) # 物理プロセスを停止して入力を受け付けなくする set_physics_process(false) 先にも述べたが、die_on_hurt_animのメソッドは「hurt」アニメーション内で呼び出す必要がある。このタイミングで一度アニメーションパネルに戻って「AnimationPlayer」ノードの「hurt」アニメーションを編集しておくこと。\n「AnimationTree」ノードの「Parameters」＞「Playback」プロパティの値になっている「AnimationNodeStateMachinePlayback」リソースのクラスにはget_current_nodeというメソッドが用意されており、これを呼び出すと現在のアニメーションノードを取得することができる。if文で現在のノードによって条件分岐させたい場合に便利だ。また、travelメソッドは引数に遷移させたいアニメーションノードの名前を文字列で渡すことで、アニメーションの遷移をスクリプトで制御することができる。もちろん、アニメーションツリー上で遷移する設定（矢印でつながっている状態）にしておく必要がある。\nスクリプトの最後に「HitBox (Area2D)」ノードの「body_entered」シグナルを接続して、生成されたメソッドを以下のように編集する。\n###Player.gd### func _on_HitBox_body_entered(body): # 剣に当たったボディオブジェクトの hurt メソッドを呼び出す body.hurt() 動作確認 今回は動作確認用に別途「Tree」シーンと「Slime」シーンを作成した。どちらも「Player」シーンの「HitBox」との衝突でダメージを与えることができる。また「Slime」シーンの方にも「HitBox」ノードを用意し、「Player」が「Slime」に当たるとプレイヤー側がダメージを受けてライフが１つ減る仕様だ。「Player」のlifeプロパティは 3 に設定しているので、「Slime」に3回当たると死ぬようになっている。\n「World」シーンを用意し、「Player」、「Tree」、「Slime」それぞれのシーンのインスタンスを追加した。動作確認のため、「World」シーンをメインシーンに設定してプロジェクトを実行する。\nステートマシンによって、状況に合わせてアニメーションが円滑に遷移しているのがおわかりいただけるだろうか。\nおわりに 今回はステートマシンを利用して、プレイヤーキャラクターのアニメーション（状態）を遷移させる方法について説明した。作業のポイントを振り返っておこう。\nゲームで使用する状態を先に洗い出しておく 「AnimationPlayer」で状態ごとにアニメーションを作る 「AnimationTree」でステートマシンを作る スクリプトでアニメーションの遷移を制御する 実際には、アニメーションの数が多いとアニメーションツリーパネル内でノードとそれらを繋ぐ線がごちゃごちゃしてきて、見た目上わかりにくくなるかもしれない。そのような場合は、頭の中を整理する意味で、先に紙にペンで書き出してみると良い。\nもちろん「AnimationTree」ノードに頼らず、スクリプトでステートマシンを作ることもできるので、もしアニメーションツリーパネルの編集が苦手な場合は、そちらを試してみるのも良いだろう。\n\u0026lt;\u0026gt;\n参考 Godot Docs - Introduction to the animation features Godot Docs - Using AnimationTree Godot Docs - AnimationNodeStateMachinePlayback [KidsCanCode - CONTROLLING ANIMATION STATES](http://kidscancode.org/godot_recipes/3.x/ YouTube - Godot Recipes: Animation States YouTube - Make an Action RPG in Godot 3.2 (P9 | Attacking Animation \u0026#43; State Machines) YouTube - Name Files Logically itch.io - mystic woods ","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0019_2d_animation_state_machine/","summary":"今回のテーマは 2D ゲームのアニメーションステートマシンの実装だ。ステートとは「状態」のことで、ステートマシンというのは、キャラクターのある状態からある状態への遷移を制御する仕組みのことだ。 ある状態からは","title":"Godot3 で作るアニメーションステートマシン"},{"content":"この記事では、2Dゲームにおけるシンプルな近接攻撃の当たり判定を実装する方法を紹介する。\n一般的によく使われる手法で、攻撃するオブジェクト（プレイヤーキャラクターなど）に攻撃時のみ有効になる衝突形状（Hit Box という）を用意し、攻撃を受けるオブジェクト（敵キャラクターや破壊できる樽や木箱、草など）には攻撃を受ける範囲となる衝突形状（Hurt Box という）を用意し、攻撃時のアニメーションに合わせて、Hit Box と Hurt Box の有効/無効の切り替えやサイズ、位置の変更をすることで攻撃の当たり判定を実装することができる。\n比較的簡単に実装できるのでさっそくやっていこう。\nEnvironment Godot のバージョン: 3.5.1\nコンピュータのOS: macOS 11.6.5\nBasic Articles 以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 インプットマップの追加 まずは「プロジェクト」＞「プロジェクト設定」＞「インプットマップ」タブで、以下のアクションを追加する。\nright: D キー left: A キー down: S キー up: W キー attack: Space バー Player シーンを作る プレイヤーキャラクターのシーンを作成する。ルートノードを「KinematicBody2D」にして、必要なノードを追加し、以下のようなシーンツリーを作成する。 Player (KinematicBody2D) Sprite BodyCollisionShape (CollisionShape2D) HitBox (Area2D) HitBoxCollisionShape (CollisionShape2D) AnimationPlayer このシーンを「Player.tscn」というファイル名で保存する。 Player シーンのノードを編集する Sprite ノード プレイヤーキャラクターの近接攻撃のアニメーションを含むスプライトシートとして、今回は itch.io から Pixel Art Dwarf Sprites というアセットをダウンロードして利用させていただいた。特に近接攻撃用のアニメーションとして、3 ~ 5 行目を利用することになる。\nダウンロードしたスプライトシートをファイルシステムドックにドラッグしてインポートする。そのままだと少しぼやけた感じで表示されるため、ファイルを選択して、インポートドックから、2D Pixel のプリセットを適用して再インポートする。 インスペクタードックにて「Texture」プロパティにインポートしたスプライトシートを適用する。\n縦横それぞれ 8 フレームずつのスプライトシートなので、「Animation」＞「Hframes」/「Vframes」の値をそれぞれ 8 とする。\n2D ワークスペース上に 1 フレーム分のテクスチャが表示されればOKだ。\nBodyCollisionShape (CollisionShape2D) ノード 親の「Player」ルートノードは KinematicBody2D クラスなので、必ず衝突形状の設定が必要だ。あとで作成する Hit Box の衝突形状と区別するため、「BodyCollisionShape」と名前を変更している。\n「Shape」プロパティには「RectangleShape」リソースを適用する。\n2D ワークスペースにて、衝突形状をスプライトのテクスチャの体部分に合わせる。\nコリジョン形状が視覚的に邪魔な場合は、必要に応じて、シーンドックでノードを非表示に設定すると良い。\nHitBox (Area2D) ノード Hit Box とは、キャラクターが近接攻撃する時の当たり判定を行うための衝突形状である。Hit Box というだけあって、一般的に四角い衝突形状が使われることが多い。Godot で作る 2D ゲームの場合、「Area2D」とその子ノードの「CollisionShape2D」を使用する。\n親の「HitBox」ノードの編集は不要だが、あとでスクリプトを作成する際に、このノードのシグナルを利用することになる。\nHitBoxCollisionShape (CollisonShape2D) ノード 「BodyCollisionShape」ノードと区別するため、名前を「HitBoxCollisionShape」としている。\n「Shape」プロパティに新規「RectangleShape」リソースを適用して四角い衝突形状を設定する。サイズや位置は後ほど攻撃時のアニメーションの中で変更させるので、今の時点で「RectangleShape」の「Extents」プロパティはデフォルトのままで良い。\nプレイヤーキャラクターの攻撃時のみ衝突判定を有効にしたいので、「Disabled」プロパティは オン にして、衝突を無効化しておく。\nAnimationPlayer ノード（アニメーションの作成） 「AnimationPlayer」ノードで近接攻撃のアニメーションを作成する。\nシーンドックで「AnimationPlayer」ノードを選択する。 アニメーションパネルを開く アニメーションを新規作成し、名前を「right_attack1」とする。\n*左右それぞれの向きに対して attack1, 2, 3 まで作る想定である。 まずは以下の通りに設定する。 読み込み時の自動再生： Off アニメーションの長さ(秒): 0.6 アニメーションのループ： Off 「Sprite」ノードの「Frame Coords」プロパティのトラックを追加する。0.1 秒間隔で、スプライトシートの 3 行目のテクスチャを左端から順番に 6 列目まで追加する。具体的には、 (0, 2)、(1, 2)、(2, 2)、(3, 2)、(4, 2)、(5, 2) と、y の値（スプライトシートの行）はそのままで x の値（スプライトシートの列）のみ 0 から 5 へ変化させていく。\nこのトラックの「Interpolation」の種類を「Nearest」に変更する。\n「BodyCollisionShape」の「Disabled」プロパティのトラックを追加する。プレイヤーキャラクターは、自分の攻撃時は敵からダメージを受けないようするため、タイムラインの0.3秒の位置で「BodyCollisionShape」の「Disabled」プロパティをオンにし、0.5秒の位置でオフに戻すようにする。\n「HitBoxCollisionShape」の「Disabled」プロパティのトラックを追加する。さっきと逆で、タイムラインの0.3秒の位置で「Disabled」プロパティをオフにし、0.5秒の位置でオンに戻す。これにより、プレイヤーキャラクターの攻撃アニメーションのうち、まさに斧を振り下ろしているアニメーションフレームの時だけ Hit Box の当たり判定が有効になる。 続けて「HitBoxCollisionShape」の「Position」プロパティと「Shape」＞「Extents」プロパティのトラックを追加する。タイムラインの0.3秒の斧を振り下ろすアニメーションに合わせて、HitBox の衝突形状のサイズと位置を調整する。「Position」の値は(7.5, -2.25)、「Extents」の値は(9.5, 12.25)とした（若干テクスチャ上の斧の軌跡より大きめにしている）。\n最終的に「right_attack1」は以下のようになった。\nSprite frame_coords Time: 0 / Value: (0, 2) / Easing: 1.00 Time: 0.1 / Value: (1, 2) / Easing: 1.00 Time: 0.2 / Value: (2, 2) / Easing: 1.00 Time: 0.3 / Value: (3, 2) / Easing: 1.00 Time: 0.4 / Value: (4, 2) / Easing: 1.00 Time: 0.5 / Value: (5, 2) / Easing: 1.00 BodyCollisionShape disabled Time: 0.1 / Value: On / Easing: 1.00 HitBoxCollisionShape disabled Time: 0.3 / Value; Off / Easing: 1.00 Time: 0.5 / Value; On / Easing: 1.00 position Time: 0.3 / Value: (7.5, -2.25) / Easing: 1.00 Time: 0.4 / Value: (4, 4) / Easing: 1.00 shape:extents Time: 0.3 / Value: (9.5, 12.25) / Easing: 1.00 Time: 0.4 / Value: (6, 6) / Easing: 1.00 以下のGIF画像は、今作成した「right_attack1」のアニメーションを 0.5 倍速で再生している。斧を振り下ろすタイミングだけ HitBox の衝突形状が有効（緑色）になっているのがおわかりいただけるだろう。\n同様の手順で、「right_attack2」のアニメーションを作成した。スプライトシートの 4 行目のテクスチャを使用した。タイムラインの 0.1 ~ 0.4 秒の間、「HitBoxCollisionShape」の「Position」と「Extents」を 0.1 秒おきに少しずつ変化させている。\n「right_attack2」を 0.5 倍速で再生するとこのようになる。\nさらに、「right_attack3」のアニメーションを作成した。こちらはスプライトシートの 5 行目のテクスチャを使用した。テクスチャは 2 フレームのみだが、その 2 つを 4 回繰り返している。「Sprite」ノードの「Position」プロパティのトラックを追加して、少し前に移動してから戻ってくるようなアニメーションにしている。\n「right_attack3」を 0.5 倍速で再生すると以下のようになる。\n左向きのアニメーションの作成時は、「Sprite」ノードの「Offset」＞「Flip H」プロパティをオンにしてから作業するとやりやすい。先に作った右向きの近接攻撃アニメーションを複製して、左向き用に調整すると簡単だ。\nPlayer ノードにスクリプトをアタッチする プレイヤーキャラクターの移動と近接攻撃を制御するために、「Player」ルートノードにスクリプトをアタッチしてコーディングしていく。\n###Player.gd### extends KinematicBody2D # 移動スピード var speed = 80.0 # 移動速度 var velocity: Vector2 # 攻撃アニメーションの番号（1 ~ 3） var attack_num = 1 # Sprite ノードの参照 onready var sprite = $Sprite # AnimationPlayer ノードの参照 onready var anim_player = $AnimationPlayer # キャラクターの移動に関する入力を制御するメソッド func move(): velocity = Vector2() if Input.is_action_pressed(\u0026#34;right\u0026#34;): velocity.x += 1 sprite.flip_h = false if Input.is_action_pressed(\u0026#34;left\u0026#34;): velocity.x -= 1 sprite.flip_h = true if Input.is_action_pressed(\u0026#34;down\u0026#34;): velocity.y += 1 if Input.is_action_pressed(\u0026#34;up\u0026#34;): velocity.y -= 1 velocity = velocity.normalized() * speed # 速度が 0 なら idle アニメーションを再生 if velocity.length() == 0: anim_player.play(\u0026#34;idle\u0026#34;) # 速度が 0 より大きければ run アニメーションを再生 if velocity.length() \u0026gt; 0: anim_player.play(\u0026#34;run\u0026#34;) # 物理プロセスの組み込み関数 func _physics_process(_delta): move() # 移動に関する入力をキャラクターの動きとして反映させる velocity = move_and_slide(velocity) # 入力の組み込みコールバック関数 func _unhandled_input(event): # スペースバーが押されたら if event.is_action_pressed(\u0026#34;attack\u0026#34;): # 移動できないように物理プロセスを停止 set_physics_process(false) # スプライトが左右反転していたら（左向きだったら） if sprite.flip_h: # 左向きの攻撃アニメーションを再生 anim_player.play(\u0026#34;left_attack\u0026#34; + str(attack_num)) # スプライトが左右反転していなかったら（右向きだったら） else: # 右向きの攻撃アニメーションを再生 anim_player.play(\u0026#34;right_attack\u0026#34; + str(attack_num)) # 現在の攻撃アニメーションの番号が 3 未満の場合は番号に + 1 if attack_num \u0026lt; 3: attack_num += 1 # 現在の攻撃アニメーションの番号が 3 以上の場合は番号を 1 に戻す else: attack_num = 1 「AnimationPlayer」ノードの「animation_finished」シグナルをスクリプトに接続し、自動生成されたメソッドを以下のように編集する。\nfunc _on_AnimationPlayer_animation_finished(anim_name): # アニメーションの名前に「attack」が含まれていたら物理プロセスを再開する if \u0026#34;attack\u0026#34; in anim_name: set_physics_process(true) 「Player」シーンを実行してみよう。事前に「デバッグ」メニューから衝突形状を表示する設定を有効にしておくとアニメーション中の衝突形状の変化がわかりやすいだろう。\nプレイヤーキャラクターの動きは以下のGIF画像のようなになる。\nEnemy シーンを作る プレイヤーキャラクターの近接攻撃の当たり判定を確認するために「Enemy」シーンを用意する。「Player」シーンと似たような作業内容のため、詳細は割愛させていただく。\nまずシーンツリーは以下の通りだ。\nEnemy (KinematicBody2D) Sprite BodyCollisionShape (CollisionShape2D) AnimationPlayer ReviveTimer (Timer) Enemy シーンのノードを編集する Sprite ノード 「Sprite」ノードの「Texture」プロパティには itch.io - mystic woods からダウンロードさせていただいたアセットのうち、「slime.png」のスプライトシートを適用する。\nBodyCollisionShape ノード 「Shape」プロパティには「CircleShape2D」を適用し、スプライトよりやや小さめの衝突形状にする。今回のチュートリアルでは、これがいわゆる Hurt Box となる。この衝突形状に、プレイヤーキャラクターの Hit Box が重なった時に当たり判定が有効となるようにすれば良いというわけだ。その制御は後ほどスクリプトで行う。\nAnimationPlayer ノード アニメーションパネルにて、以下の4つのアニメーションを用意する。全て 0.1 秒おきにスプライトシート上の次のフレームのテクスチャに変更する設定だ。\njump: 待機時の飛び跳ねるアニメーション（読み込み時に自動再生） hurt: ダメージを受けた時のアニメーション die: ライフが 0 になって死ぬときのアニメーション 「BodyCollisionShape」の「Disabled」をオンにする revive: 死んだあと一定時間後に生き返るアニメーション 「BodyCollisionShape」の「Disabled」をオフにする RevieTimer ノード 「One Shot」プロパティを有効にしておく。\nEnemy ノードにスクリプトをアタッチする 「Enemy」ルートノードにスクリプトをアタッチして以下のようにコーディングした。\n###Enemy.gd### extends KinematicBody2D # ライフの最大値 export (int) var max_life = 3 # 現在のライフ var life: int = max_life # Playerインスタンスを参照するための変数 var player: KinematicBody2D # Sprite ノードの参照 onready var sprite = $Sprite # AnimationPlayer ノードの参照 onready var anim_player = $AnimationPlayer # ReviveTimer ノードの参照 onready var revive_timer = $ReviveTimer func _process(_delta): # プレイヤーの位置により Sprite の向きを反転したりしなかったり sprite.flip_h = global_position.x \u0026gt; player.global_position.x # ダメージを受けるメソッド func hurt(): # ライフを 1 減らす life -= 1 # アニメーション hurt を再生する anim_player.play(\u0026#34;hurt\u0026#34;) さらに「AnimetionPlayer」の「animation_finished」シグナルと、「ReviveTimer」の「timeout」シグナルをスクリプトに接続し、それぞれの生成されたメソッドを以下のように編集する。\n###Enemy.gd### # AnimationPlayer のアニメーション終了時のシグナルにより呼ばれるメソッド func _on_AnimationPlayer_animation_finished(anim_name): # 終了したアニメーションが hurt の場合 if anim_name == \u0026#34;hurt\u0026#34;: # ライフが 0 より大きければ jump アニメーションに戻る if life \u0026gt; 0: anim_player.play(\u0026#34;jump\u0026#34;) # ライフが 0 以下の場合は die アニメーションを再生する if life \u0026lt;= 0: anim_player.play(\u0026#34;die\u0026#34;) # 終了したアニメーションが die の場合は ReviveTimer をスタートさせる if anim_name == \u0026#34;die\u0026#34;: revive_timer.start() # 終了したアニメーションが revive の場合は if anim_name == \u0026#34;revive\u0026#34;: anim_player.play(\u0026#34;jump\u0026#34;) # ReviveTimer のタイムアウト時のシグナルで呼ばれるメソッド func _on_ReviveTimer_timeout(): # revive アニメーションを再生する anim_player.play(\u0026#34;revive\u0026#34;) # ライフを最大値に戻す life = max_life Player のスクリプトに HitBox のシグナルを追加する 「Player.gd」スクリプトの方に、近接攻撃が当たったら、「HitBox」のシグナルにより「Enemy.gd」のhurtメソッドを呼び出すようにする。\n「Player.tscn」シーンに戻り、「HitBox」ノードの「body_entered(body: Node)」シグナルを「Player.gd」スクリプトに接続する。\n###Player.gd### # 省略 # HitBox に物理ボディが当たった時のシグナルで呼ばれるメソッド func _on_HitBox_body_entered(body): # 物理ボディノードの名前が Enemy だったらその hurt メソッドを呼ぶ if body.name == \u0026#34;Enemy\u0026#34;: body.hurt() World シーンを作る 最後に「World」シーンを作って、そこに「Player」シーンのインスタンスと「Enemy」のインスタンスを追加する。\nシーンツリーはシンプルに以下の通りだ。\nWorld (Node2D) Enemy (Enemy.tscn のインスタンス) Player (Player.tscn のインスタンス) 2D ワークスペース上で、それぞれのインスタンスを適当に配置する。\nWorld シーンにスクリプトをアタッチする World シーンにスクリプトをアタッチして、以下のようにコーディングする。目的は、「World」ルートノードから、「Enemy.gd」で宣言した「Enemy」ノードの変数playerに「Player」インスタンスの参照を渡すことだ。\n###World.gd### extends Node2D onready var player = $Player onready var enemy = $Enemy func _ready(): enemy.player = self.player プロジェクトを実行する 最後にプロジェクトを実行して近接攻撃の当たり判定の挙動を確認する。\n「Player」の「HitBox」ノードの衝突形状が「Enemy」の「BodyCollisionShape」(Hurt Box)と重なった時に当たり判定が有効になり、「Enemy」の「hurt」アニメーションが再生されているのがおわかりいただけるだろうか。\nおわりに 今回は2Dゲームにおけるシンプルな近接攻撃の当たり判定についてご紹介した。Hit Box と Hurt Box を使った攻撃の当たり判定の実装は比較的理解しやすく、様々なゲームで応用できるだろう。\nちなみに、実際のゲームでは、体の部位ごとに別々の Hit Box や Hurt Box を設定し、その組み合わせによってより複雑な仕組みを作ることもあるようだ。\n例えば、格闘ゲームでは手、足、頭など攻撃する側にいくつかの Hit Box を用意し、攻撃を受ける側にも上段、中段、下段の位置にそれぞれの Hurt Box を設定すれば、それぞれの組み合わせによって、ダメージなどを複雑に変化させることができる。\n他にも、ゾンビものの FPS ゲームであれば、ゾンビの頭と体で異なる Hurt Box を用意しておけば、頭を射撃すれば 1 発で倒せるが、他の部位だとそうはいかない、というお決まりのルールを実装することもできるだろう。\nこの記事が少しでもお役に立てたなら幸いだ。\n参考 この記事の作成にあたり、以下のリンク先の資料が大変参考になったのでご紹介させていただきたい。これらも併せてご覧いただくとより理解が深まるはずだ。\nIntroduction to the animation features KidsCanCode - MELEE ATTACKS YouTube - How to Make Melee Combat in Godot YouTube - Make an Action RPG in Godot 3.2 (P11 | Melee attacks with Hurtboxes and Hitboxes) itch.io - Pixel Art Dwarf Sprites *素材\nitch.io - mystic woods *素材\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0018_melee_attacks/","summary":"この記事では、2Dゲームにおけるシンプルな近接攻撃の当たり判定を実装する方法を紹介する。 一般的によく使われる手法で、攻撃するオブジェクト（プレイヤーキャラクターなど）に攻撃時のみ有効になる衝突形状（H","title":"Godot3 で作る 2D ゲームの近接攻撃の当たり判定"},{"content":"この記事では、AStar というアルゴリズムを利用して、2D ゲームにおけるグリッドベースの経路探索の実装方法について紹介する。なお、グリッドベースではない 2D 経路探索については、「Godot で作る 2D 経路探索 」の記事で紹介しているので、作りたいゲームに併せて記事を選んでいただければ幸いだ。\nこのチュートリアルで最後にできあがるプロジェクトのファイルは GitHubリポジトリ に置いている。.zipファイルをダウンロードして展開したあと、「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment Godot のバージョン: 3.5\nコンピュータのOS: macOS 11.6.5\nBasic Articles 以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 AStar について AStar という探索アルゴリズムを使って、グリッドベースの経路探索を実装する。現在地から目的地まで自動的にオブジェクトをグリッドに沿って移動させたい時に便利だ。例えば、盤面上でピースを移動させるようなパズルゲームや、盤面上で敵、味方それぞれのキャラクターを移動させて戦わせるような戦略シミュレーションゲームなどに最適な手法である。\nAStar とは エースターと読み、A* とも表記する。スタート地点からゴール地点まで障害物を回避しつつ最短の経路を探索するアルゴリズムである。ゲーム開発で多く採用されている。Godot エンジンの場合、一からアルゴリズムをコーディングしなくても済むように、AStar のクラスが初めから用意されている。今回のチュートリアルでもそれを利用する。\nWikipedia - A* Godot Docs - AStar2D プロジェクト作成 まずはプロジェクトを新規作成する。今回、プロジェクトの名前は「2D Grid Based Path Finding」としておく。\nプロジェクト設定 「プロジェクト」メニュー＞「プロジェクト設定」にて以下の設定を行う。\n「一般」タブ 「Display」＞「Window」 「Size」セクション Width: 1024 Height: 576 「Stretch」セクション Mode: 2d Aspect: keep 「インプットマップ」タブ アクションに「move_to」を追加 「move_to」の操作に「マウス左ボタン」を割り当てる。\nアセットのインポート 今回はKENNEYのサイトから Board Game Icons というアセットパックを利用させていただいた。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「/kenney_boardgameicons/PNG/Default (64px)」フォルダ内の以下のファイルを Godot エディタのファイルシステムドックへドラッグ\u0026amp;ドロップしてプロジェクトにインポートする。\ncharacter.png d3.png structure_wall.png Game シーンを作る まずはプロジェクトのメインとなる「Game」シーンを作る。ルートノードに「Node2D」を選択し、それに必要なノードを追加、名前を変更して、以下のようなシーンツリーを作成する。\nGame (Node2D) Board (TileMap) Obstacles (Node2D) *あとでこのノードに子ノードを追加する予定 Line (Line2D) Player (Sprite) AStarVisualizer (Control) ノードを編集する Board (TileMap) ノード ゲームのプレイヤーの駒が移動する盤面として、「Board」ノードを編集する。\n「Board」ノードを選択し、インスペクターにて「Tile Set」プロパティに「新規 TileSet」リソースを適用する。\nインスペクターで適用した「TileSet」をクリックし、タイルセットパネルを開く。 先にインポートしておいた「d3.png」をファイルシステムドックからタイルセットパネルのサイドバーにドラッグ\u0026amp;ドロップして、タイルセットのテクスチャとして追加する。 追加したテクスチャを選択し、「New Single Tile」として、その「領域」を指定して追加する。\nそのままインスペクターにて、「Modulate」プロパティでタイルを好みの色に変更する。\nシーンドックで「Board」ノードを選択し、以下のポイントに注意しながら、2D ワークスペース上でタイルマップを作成する。 ゲームのウインドウサイズに収まる範囲内でタイルマップを作成する。 配置するタイルはプレイヤーノードが移動可能な領域として使用する。 あとでプレイヤーノードを一番左上のグリッド座標 (0, 0）に配置するため、必ずその位置にタイルを配置し、そこからプレイヤーノードが移動できるようにタイルを適当につなげて配置する。\nObstacles (Node2D) ノード 「Obstacles」ノードは、タイルマップ上に配置する複数の障害物ノードをまとめるための入れ物（親ノード）として使用する。したがって、このノード自体は編集不要だ。\nObstacle シーンを作成する タイルマップ上に配置する障害物のシーンを作成する。\nルートノードに「Sprite」を選択し、名前を「Obstacle」に変更する。 インスペクターにて「Texture」プロパティに、ファイルシステムドックから「structure_wall.png」をドラッグ\u0026amp;ドロップしてリソースを適用する。\n「Offset」＞「Centered」プロパティをオフにする。\n「Modulate」プロパティで、先に用意した「Board」ノードのタイルの上に重ねた時に視認しやすい色に変更する。\nObstacles ノードに Obstacle シーンのインスタンスを追加する 「Game」シーンに戻り、「Obstacles」ノードに作成した「Obstacle」シーンのインスタンスノードを10個追加し、タイルマップ上の適当な位置に配置する。ただし、グリッド座標 (0, 0) にはプレイヤーの駒を配置するのでそこには配置しないように注意する。\nPlayer (Sprite) ノード 盤面上を AStar による経路探索で移動させる駒としてこのノードを使用する。\nインスペクターにて、「Texture」プロパティにファイルシステムドックから「character.png」をドラッグ\u0026amp;ドロップしてリソースを適用する。\n「Offset」＞「Centered」プロパティをオフにする。\n2D ワークスペースにて、プレイヤーの初期位置である座標 (0, 0) に配置されていることを確認する。\nスクリプトで制御する Board ノードにスクリプトをアタッチする AStar アルゴリズムによる経路探索は、大まかには以下のような流れになる。\nタイルマップに配置したタイルの位置を取得する タイルの位置を AStar の点として追加する AStar のそれぞれの点に対して、上下左右で隣接している点に接続する 障害物の位置を取得する 障害物の位置に相当する AStar の点を無効化する。 AStar の有効な点をつなぐ線の中から経路探索する。 「Board」ノードにスクリプトをアタッチして、コードを以下のように編集する。\nextends TileMap # Player の移動するパスの点を格納する配列 var path: Array = [] # Board(TileMap)でタイルが配置されているセルの配列 var cells = get_used_cells() # Obstacles ノードの参照 onready var obstacles = $Obstacles # AStar2D クラスのインスタンス onready var astar = AStar2D.new() # Board(TileMap) のセルの半分のサイズ onready var half_cell_size = cell_size / 2 func _ready(): # AStar の点を追加するメソッドを呼び出す add_points() # AStar の点をつなぐメソッドを呼び出す connect_points() # AStar の点を無効化するメソッドを呼び出す # 引数は Obstaclesノードの子ノードの位置を配列で返すメソッド disable_points(get_obstacles()) # AStar の点を追加するメソッド func add_points(): # タイルマップ上のタイルが配置されたセルでループ処理 for cell in cells: # セルのIDを生成して AStar の点として追加する astar.add_point(id(cell), cell) # AStar の点をつなぐメソッド func connect_points(): # タイルマップ上のタイルが配置されたセルでループ処理 for cell in cells: # そのセルが AStar の点に含まれていたら if astar.has_point(id(cell)): # 隣り合う四方向の方向ベクトルを配列にする var neighbors = [ Vector2.RIGHT, Vector2.LEFT, Vector2.DOWN, Vector2.UP ] # それぞれの方向ベクトルに対してループ処理 for neighbor in neighbors: # 隣接するセルを定義 var next_cell = cell + neighbor # 隣接するセルにタイルが配置されている場合 if cells.has(next_cell): # AStar のもとのセル上の点と隣接するセル上の点をつなぐ astar.connect_points(id(cell), id(next_cell), false) # Obstaclesノードの子ノードの位置を配列で返すメソッド func get_obstacles() -\u0026gt; Array: # 障害物が配置されているセルのグリッド座標を入れる配列 var obstacle_cells = [] # Obstacles の全ての子ノード（Obstacle インスタンス）でループ処理 for child in obstacles.get_children(): # 用意した配列に障害物のグリッド座標を追加する obstacle_cells.append(world_to_map(child.global_position)) # 戻り値として配列を返す return obstacle_cells # AStar の点を無効化するメソッド # 引数にはセルのグリッド座標を要素にもつ配列を渡す func disable_points(target_cells): # 引数の配列の要素（セルのグリッド座標）でループ処理 for cell in target_cells: # 該当のセルに相当する AStar の点を無効化する astar.set_point_disabled(id(cell)) # Player が移動する最短経路（通過する点の配列）を更新するメソッド func update_path(start, end): # AStar で引数の出発地点から目的地点までの最短経路を探索する path = astar.get_point_path(id(start), id(end)) # グリッド座標からIDを生成するメソッド func id(point): var a = point.x var b = point.y return (a + b) * (a + b + 1) / 2 + b これで「Board (TileMap)」ノードでタイルが配置されているセルの座標に AStar の点が追加され、それぞれの点が線で繋がる。さらにその点のうち「Obstacle」インスタンスが配置されている座標と一致する点は無効化され、そこに繋がる線も無効化される。こうして最終的に形成された AStar のネットワークが経路として利用される。\nupdate_path()メソッドは「Game」ノードのスクリプトの方で呼び出す予定だ。このメソッドを呼び出す際に、引数startとendに「Player」ノードの現在の位置と移動先の位置をそれぞれ渡すと、形成された AStar のネットワーク上最も短い経路を割り出して、その上を Player ノードが移動する。\nもちろん「Obstacle」インスタンスの位置は AStar の点が無効化されているので、線が繋がっておらず移動できないようになっている。\nこの AStar の点と線がイメージしにくいかもしれないので、「AStarVisualizer」にスクリプトをアタッチして可視化していく。\nAStarVisualizer (Control) ノードにスクリプトをアタッチする AStar の点と線を可視化するために、「AStarVisualizer」にスクリプトをアタッチし、コードを以下のように編集する。\nextends Control onready var board: TileMap = get_parent().get_node(\u0026#34;Board\u0026#34;) onready var astar: AStar2D = board.astar onready var offset: Vector2 = board.half_cell_size # シーンツリーにノードが読み込まれたら _draw() 関数を呼び出す func _ready(): _draw() # スクリーンにAStar の点と線を描画するよう組み込み関数 _draw()を上書き func _draw(): # AStar の全ての点（ID）でループ処理 for point in astar.get_points(): # 点が無効化されていたらこの後の処理をスキップ if astar.is_point_disabled(point): print(\u0026#34;astar point is disabled\u0026#34;) continue # AStar の点（ID）からグリッド座標に変換 var cell = astar.get_point_position(point) # グリッド座標からワールド座標に変換 var pos = board.map_to_world(cell) # AStar の点のワールド座標をセルの左上角から中央にズラして描画する draw_circle(pos + offset, 4, Color.white) # 取得した AStar の点につながっている上下左右の点(ID)を全て取得 var point_connections = astar.get_point_connections(point) # つながっている全ての点をワールド座標として格納するための配列 var connected_positions = [] # つながっている点でループ処理 for connected_point in point_connections: # もしつながっている点が無効化されている場合はこの後の処理をスキップ if astar.is_point_disabled(connected_point): print(\u0026#34;connected point is disabled\u0026#34;) continue # つながっている点のIDをグリッド座標に変換 var connected_cell = astar.get_point_position(connected_point) # グリッド座標からワールド座標に変換 var connected_pos = board.map_to_world(connected_cell) # ワールド座標を配列に追加 connected_positions.append(connected_pos) # つながっている点のワールド座標の配列の要素でループ処理 for connected_pos in connected_positions: # 元の点とそれに接続している点をつなぐ線を描画する draw_line(pos + offset, connected_pos + offset, Color.white, 2) このスクリプトにより、AStar の点と線が画面に描画され、AStar のネットワークが可視化できるようになった。プロジェクトを実行すると以下のように表示されるはずだ。\nGame ノードにスクリプトをアタッチする 最後にマウスの入力操作で「Player」ノードが移動するようにコーディングしていく。\n「Game」ルートノードにスクリプトをアタッチしたら、以下のようにコードを編集する。\nextends Node2D # Board ノードの参照 onready var board = $Board # Line ノードの参照 onready var line = $Line # Player ノードの参照 onready var player = $Player func _input(event): # マウスの左ボタンがクリックされたら if event.is_action_pressed(\u0026#34;move_to\u0026#34;): # マウスカーソルのグローバルな x, y 座標からタイルマップ上のセルの座標を目的地として取得 var target_cell = board.world_to_map(get_global_mouse_position()) # 目的地のセルの座標から AStar 用の ID を生成 var target_cell_id = board.id(target_cell) # ID が AStar の有効な点に含まれている場合 if board.astar.has_point(target_cell_id): # Player のゲーム画面上の x, y 座標からタイルマップ上のセルの座標を取得 var player_cell = board.world_to_map(player.global_position) # Player のセルから目的地のセルの経路を更新する board.update_path(player_cell, target_cell) # Player ノードを移動させるメソッドを呼び出す move() # プレイヤーの駒を移動させるメソッド func move(): # 移動中はクリック操作ができないようにインプットプロセスを無効にする set_process_input(false) # 経路を構成する点のセル座標でループ処理して Line ノードのパスを描画 for point in board.path: # 点のゲーム画面上の x, y 座標を Line ノードのパスに追加 line.add_point(board.map_to_world(point) + board.half_cell_size) # 経路を構成する点のセル座標でループ処理して Player ノードを移動 for point in board.path: # 点のゲーム画面上の x, y 座標を Player ノードの位置として上書きする player.global_position = board.map_to_world(point) # 0.1秒待機 yield(get_tree().create_timer(0.1), \u0026#34;timeout\u0026#34;) # 移動が完了したら Line ノードのパスの点を消去 line.clear_points() # インプットプロセスを有効にする set_process_input(true) このスクリプトにより、マウスの左クリックで「Player」ノードの移動が可能になった。「Player」ノードがあるグリッド座標から左クリック時のマウスカーソルが重なっているグリッド座標までの最短経路を AStar アルゴリズムによって割り出し、その経路に沿って「Player」ノードを移動させている。\nプロジェクトを実行すると以下のGIF画像のような動作を確認できるはずだ。\nおわりに 今回は AStar アルゴリズムを利用したグリッドベースの 2D 経路探索を紹介した。今回作成したプロジェクトは、タイルや障害物の配置を変えても同様に動作するはずだ。ポイントをまとめておこう。\nGodot では AStar クラスが最初から用意されているのでそれを利用する。 ワールド座標 ⇄ グリッド座標 ⇄ ID の変換をそれぞれ適宜行う。 経路探索の順序は次の通り。 AStar の点を追加 AStar の隣接する点と点を接続 障害物と重なっている AStar の点を無効化\n*もちろん手順 1 の時点で障害物を除いた点のみを追加する方法でも良い。 現在地と目的地の最短経路を AStar アルゴリズムで導く また、以下のようなアレンジを加えると、よし面白いゲームができるかもしれない。\nタイルや障害物をランダム生成させる。 敵、味方それぞれ複数キャラクターを盤面上に配置し移動させる。 上下左右の四方向に加えて、斜め方向への移動も可能にする。 参考 今回の記事を作成するにあたって、以下のリソースが非常に参考になったのでご紹介させていただく。\nYouTube - A* TileMap for Grid-Based PATHFINDING in Godot / HeartBeast YouTube - A* Path-Finding for Grid-Based Tilemap in Godot / AndOne YouTube - 2D Grid-Based Pathfinding (AStar) - Godot Tutorial / GamemakerPixel 2dgames.jp - 【Godot】AStar2Dを使用した経路探索の実装方法 / しゅん Godot Docs - AStar2D KENNEY - Board Game Icons Wikipedia - A* ","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0017_2d_grid_based_path_finding/","summary":"この記事では、AStar というアルゴリズムを利用して、2D ゲームにおけるグリッドベースの経路探索の実装方法について紹介する。なお、グリッドベースではない 2D 経路探索については、「Godot で作る 2D 経路探","title":"Godot3 で作る 2D グリッドベース経路探索"},{"content":"先日開催された「KENNEY Game Jam」に参加した。私にとって初めてのゲームジャムであった。今回はゲームジャムに参加してみてわかったこと、感じたことを交えつつ、itch.io のサイトで催されているインディーゲームデベロッパー向けのゲームジャムについて記事にした。\nゲームジャムとは ゲームジャムとは、参加者が短い期間でゲームを開発、公開して評価し合うイベントのことである。ゲーム開発のハッカソン とも言われる。\nitch.io のサイトはゲーム、アセットの販売のほか、ワールドワイドで一般の個人または小規模チーム（つまりインディーゲームデベロッパー）に向けて開催されているゲームジャムが数多く開催されている。毎月開催されているものや、年に一回のイベントとして開催されているものなど、小規模、大規模さまざまなゲームジャムが存在し、一年を通して何らかのゲームジャムが常に開催されているのが現状だ。私が参加したKENNEY Jam 2022 もitch.io にて開催された。\nゲームジャムに参加するのは主に個人開発者や小規模チームだ。初心者からベテランまでスキルレベルもさまざまだ。ベテランの方が有利だと思われるそうだが、作品の提出期間が短いゲームジャムが多く、その場合、大作ゲームを作り込むことはほぼ不可能なので、圧倒的な差はつけにくいだろう。一つの目標として、初心者でも挑戦する人が割と多い印象だ。\nもちろん itch.io で開催されているゲームジャムに参加するには、アカウントを作成してログインする必要があるので、参加したいゲームジャムがある場合は、早めにアカウントを作成しておくようにしよう。\nゲームジャムに参加する意義 ゲームジャムに馴染みのない人間（私のことだ）からすると、一見、一般に広く呼びかけたコンクールのようなもののように見えるかもしれない。コンクールといえば、優れた作品に優勝、準優勝と順位をつけ、賞金や賞品がもらえたりする。ゲームジャムの中にはそういったものもあるが、ほとんどの場合そうではない。ゲームジャムはどちらかというとお祭りである。参加者がお互いのゲームをプレイし合って、「あなたのゲームのアイデアはこういうところが素晴らしい」とか「きみのゲームシステムがこういうところが斬新で驚いた」などとフィードバックを送ったり、新たなインスピレーションを得たりしながら、開発者としてレベルアップできる、それがゲームジャムの醍醐味なのだ。\nしかも、お祭りと言いながら、全力で作り上げた作品をアピールし、作品と自分の技術やアイデアを世に知らしめるための絶好の機会でもあるのだ。優れた作品は当然、最終的な評価結果で上位にランクインするだろう。これは非常に名誉なことだが、それだけではない。有名なゲームジャムで上位に食い込めば、多くの人の目に触れやすくなり、大手パブリッシャーの目に止まる可能性すらある。また、開発者に多くのファンがつくこともある。このように、ゲーム開発者としての成功のとっかかりにもなりうるイベント、という側面もある。\nただし、それらの恩恵は、圧倒的に優れたゲームを公開できた場合の話だ。しかし、落胆する必要はない。万人が驚くようなゲームが作れなかったとしても、ゲームジャムに参加する真の価値は他にある。\nまずひとつは、他の参加者のゲームをたくさんプレイできることだ。他の参加者のゲームをプレイし、真剣に評価することで、自分にはなかった別のアプローチが見えてくる。これが非常に勉強になるのだ。\nもう一つは、自分のゲームを他の参加者から評価してもらえることだ。評価項目に対するレーティングも反省材料になるのだが、より具体的なフィードバックとして、自分のゲームに対して具体的なコメントをもらえることが一番の収穫になる。褒められることばかりではないので、少し傷ついてしまうこともあるかもしれないが、私は改善点のフィードバックこそが最良の成長材料だと考えている。自分では気づかなかった改善点を指摘してもらえる絶好の機会なのである。\n例えば、私が今回参加した KENNEY Jam 2022 のテーマは Growth(成長) であったが、私は Hungry Cyclops という、魔法使いがペットのサイクロプスという 一つ目 のモンスターに餌をあげて育てるカジュアルゲームを提出した。サイクロプスが大きくなればなるほど、サイクロプスが歩く時の画面揺れが激しくなる仕様だった。テーマに沿っているという部分はかなり高評価を頂けたが、画面揺れについて、激しすぎるという指摘が複数あった。これは私自身ではあまり意識できていなかったポイントだった。ユーザー体験を意識する必要性を大いに痛感した。\nちなみに、ブラウザ上でプレイできるので、もし良ければ Hungry Cyclops をやってみてほしい。下のバナーからアクセス可能だ。\nHungry Cyclops by gobo ゲームジャムに参加する際の英語の必要性 itch.io のゲームジャムの場合、Web上でワールドワイドで開催されるため、参加するには要所要所で英語が必要だ。これが英語が苦手な人が多い日本人にとっては意外と大きな障壁になるかもしれない。\nしかし、英語があまりできない場合は参加できないかというと、そうでもない。\nまず、ゲームジャムの参加ルールは英語で表記されているが、DeepL など機械翻訳や、ブラウザの翻訳機能で対処可能だ。\n次に、ゲーム内の英語の使用については、会話のダイアログや文字でのUI表現を極力避けるようにすれば、そこまで英語ができなくても問題ないだろう。しかも、ゲームジャムのテーマが発表されてから提出期限までの短い期間で作成するゲームとなるため、むしろ文字での表現は自然と少なくなるはずだ。\nゲームの提出時についても、DeepL など機械翻訳を駆使すればよい。DeepL の翻訳精度は非常に高い。下手に自分で英語を書くより自然な表現の文章を作ってくれる。説明文にゲームの操作方法とルールを記載しておけばOKだ。もし既知のバグやイシューがあれば補足説明を入れるとより丁寧だ。\nゲームジャムの流れ ゲームジャムの流れは大まかに以下の通りである。\n参加資格、テーマ発表日、参加ルールなど事前に公開される テーマが発表される 自分のゲームを提出する（期間は2~3日程度のものが多い） 他の人のゲーム評価する（期間は5日~1週間程度のものが多い） 評価結果発表 ルール、FAQなどは事前に公開されることがほとんどなので、それらを確認して自分が参加できそうなゲームジャムかどうか判断すると良いだろう。特にルールについてはよく確認しておこう。下のスクリーンショットは KENNEY Jam 2022 のルールとFAQだ。\nテーマ発表後の提出期間は数日程度と短いことが多く、その間にゲームを1本完成させるというのはなかなか過酷である。他の作品に負けないようにと考えると寝食惜しんで作業してしまいそうだが、健康第一で十分な食事と睡眠を取るように心がけたいところだ。\nテーマをどう捉えるべきか ゲームジャムにはテーマがつきものだ。テーマに合わせて開発することで、ゲームをコンパクトにまとめることができる。また、制約のある中で開発したゲームの方が、アイデアが光るものが生まれやすい。\n「テーマに合わせるのが面倒だったらテーマは無視すれば良い」という意見もたまに目にするが、私はそうは思わない。テーマ性という評価軸を失うと、アイデアではなく、グラフィックやゲームシステムなどの技術面での評価に偏ってしまうため、ベテランの開発者ばかりが有利になってしまうだろう。\n私が参加した KENNEY Jam 2022 のテーマは Growth だった。私はモンスターに餌を与えて体を大きく成長させるというゲームを作って、テーマ性を表現した。一方、同じテーマでも他の開発者によるさまざまな表現が見られた。例えば、植物を繁殖させる、武器を伸ばす、軍隊の規模を大きくする、建物を高くする、街を発展させる、生物の成長を絵本のように見せる、など解釈は千差万別だ。\nさらにそれらの解釈にゲーム性を与えることで、さらに表現の多様性が増す。例えば、2Dピクセルアートでキノコを増やすゲームにしたり、3Dシミュレーションとして、グリッドに沿って建物を建てて街を発展させるゲームにしたりだ。\n最終的に他の開発者から評価されることを考慮すると、プレイヤーがテーマを感じられることが提出するゲームの大前提になるだろう。独自の解釈をしすぎて、テーマ性がわかりにくくなると、テーマ性に対する評価を落としてしまうので注意が必要だ。「テーマ性はわかりやすく、ゲーム性はおもしろく」という考え方が評価されやすいゲームになるだろう。\n個人的に KENNEY Jam 2022 でアイデアが印象的だったのは、アイテムに当たるとプレイヤーキャラクターのサイズが大きくなっていくプラットフォーマーゲームだ。実際の画面上では、プレイヤーキャラクターのサイズは変わらず、背景のサイズが小さくなっていった。なるほど、と唸ってしまった。このように、テーマ性がはっきりしていて、かつ「そっちか」と意表を突く表現ができると最高だ。\nゲームを短期間で完成させるためのコツ 作品の提出期間が1週間以上ある場合は、ある程度余裕とスケジュール感を持ってゲームを作り上げることができるだだろう。しかし、テーマが発表されてから提出期間が2、3日しかないとなると、そこからゲームを一本作り上げるのはかなり大変な作業だ。\nまず、テーマが発表されたら、それに沿ってどのようなゲームを作るかアイデアを出して方向性を固めるまでに半日から一日はかかる可能性がある。さらに実際にコーディングしたり画像を用意したりしてゲームを開発する作業にも一日以上かかるだろう。そうなると納期内にゲームを完成させるのは至難の業のように思えてくる。\nしかし、納期内に作品を仕上げるためのコツは、いくつかある。\nまずひとつ目は、全体を通してシンプルに保つことだ。細かい部分は徹底的に排除しなければならない。UIのデザインやキャラクターのテクスチャ画像とそのアニメーション、バックグラウンドミュージック、サウンドなど、どれも凝りはじめるとキリがない。絶対に意識すべきなのは、徹底してゲームの構成要素を減らすことだ。提出するゲームができるだけシンプルでコンパクトにまとまった形になるよう努めるのが肝である。\nそして、ふたつ目。プログラミングする際、既存のコードで流用できるものはできるだけコピー＆ペーストして、手打ちで一からプログラムを書かないようにすることだ。思いついたゲームに対して、今までに自分が作ってきたゲームからそのまま使えそうなコードがないか検討することから始めるというわけだ。\n例えば、私が KENNEY Jam 2022 で提出したゲーム「Hungry Cyclops」の場合、このサイトに掲載している画面揺れのチュートリアル で作成していた画面揺れのコードを流用してサイクロプスが歩くたびに生じる画面揺れを実装し、2D経路探索のチュートリアル で作成した経路探索用コードを流用して、サイクロプスがプレイヤーキャラクターについてくる仕組みを実装した。その結果、手打ちのコーディング時間を削減し、意図しないエラーの発生とその対処時間を回避できたはずだ。\n最後に、画像や音、フォントなどのアセットファイルの準備について。これらを一つずつ作っている暇はおそらくほとんどないだろう。アセットストアでの購入（フリーのものもたくさんある）や、過去に自分が作成したものの流用を検討するように心がけよう。\nちなみに KENNEY Jam 2022 の場合は、ルール上、音やフォント以外の2Dのスプライトテクスチャや3DのモデルはKENNEY のサイトで公開されているアセットを利用することが求められていたので、アセットの準備は非常に簡単だった。\n自分のゲームを評価してもらうためのコツ 納期内に提出できたら、次は他の参加者からできるだけたくさん評価されることを目標にしたい。ここで強調しておきたいのは、無理に高い評価を得ることを目標にするのではなく、あくまで評価回数を増やすことを目標にする、ということだ。評価回数が少ないと、評価の平均が偏ってしまうことがある。人それぞれゲームの好みは異なるので、例えば、たまたまあなたのゲームが気に入らない人にしか評価してもらえなければ、実際のゲームの完成度から乖離した評価結果になる可能性がある。要するに、評価してもらう回数を増やして、適正な評価結果になるように努めるべき、という話である。そうすれば、評価された後の改善活動も的を射たものになるはずだ。\nところで、特に参加者の多いゲームジャムの場合、他の人の評価をする作業もかなり骨の折れる作業である。他の人の評価をしたところで自分の評価が変わるわけではないので、この作業にあまりモチベーションの上がらない人は多いかもしれない。ではどうすればよりたくさん評価してもらえるようになるのだろうか。\nカバーイメージをしっかり作ろう ゲームジャムのWebサイト上に参加者のゲームがリスト表示された時、評価者はまずサムネイルを見てそのゲームが面白そうか、そうでないかを瞬時に判断するだろう。サムネイルになるカバーイメージが第一印象として非常に重要なのである。\n色調は彩度が高く、コントラストの強い画像にすれば、真っ先に目に飛び込んでくるサムネイルになるだろう。また、そのゲームの内容が伝わるようなキャラクターや他のオブジェクトにフォーカスした画像にするのも効果的だ。実際のゲーム画面のスクリーンショットを使用するならば、それをそのままカバーイメージにするのではなく、重要な部分だけを拡大したり、タイトルなどをつけてバランスの良い画像にする方がよりアピールできるだろう。\n次に、プラットフォームの選定が重要だ。一般的には Windows用、macOS用、Linux用、ブラウザ用の4種類の内いずれか（または全て）の形式で提出するというルールが多いようだ。しかし、たまにブラウザ用だけを指定するゲームジャムもある。そして、最もプレイを開始しやすいのもブラウザ用だ。\nゲームジャムが Web 上で開催される限り、そのサイト内ですぐにプレイできるブラウザ用のゲームは、面倒なダウンロードや圧縮ファイルの解凍などの手間が不要なため、比較的評価してもらいやすくなる。反対に、Windows用やmacOS用にゲームを出力した場合、ゲームジャムの Web サイトからファイルをダウンロードする必要があるので評価回数は低くなりがちだ。ちょっとした手間すら避けたくなる人間の性を考えると当然かもしれない。最終的に、ブラウザ用に加えて他のプラットフォーム用にダウンロード版も用意できれば、それがベストではある。\n他の人の作品を評価してコメントしよう 自分のゲームを見てもらうには、先に他の人のゲームをプレイしてコメントするのも有効な手段になるだろう。itch.io のゲームジャムでは、コメントした人のゲームへのリンクがコメントのすぐ下に自動的に表示される。\n人情としては大抵「プレイして良いコメントをくれたのだから、この人のゲームもプレイしてあげよう」という気になるものなのだ。無理なお世辞のコメントを残す必要はないが、できるだけ建設的でポジティブなコメントを残しておくようにすると良いだろう。それだけで、そのゲームの開発者が自分のゲームを評価してくれる確率は上がるはずだ。\n他の人のゲームを評価するときに気をつけること 評価前にゲームを必ずプレイすることはもちろん大前提である。1プレイに30秒から1分程度の時間を要するゲームであれば、繰り返し3〜5回くらいプレイすると、大体ゲームの操作方法、仕組み、面白さがわかってくるはずだ。後半はできるだけ評価項目を意識しながらプレイすると、そのあと、各評価項目についての評価を素早く判断できるだろう。\nコメントはとにかくポジティブな表現を心がけよう。事実と異なることを述べるのとは違うのでご注意いただきたい。\n例えば、プレイしたゲームが操作手順の分かりにくいゲームだったとしよう。この時「操作手順は比較的分かりやすく、初回からプレイを楽しめました」というコメントは事実と異なるのでNGだ。また「操作手順が分かりにくすぎて続けるのが嫌になった」という表現はネガティブなので避けるべきだ。一方、「次にクリックすべき箇所をハイライトするような機能があればさらに快適に楽しめそうです！」という表現はポジティブであり事実を伝えているのでOKだ。\n「否定より提案をする」という意識があれば、適切なコメントを残すことができるだろう。おべんちゃらは開発者のためにならないので完全に不要である。\nゲームジャムが終わったら ゲームジャムの評価期間が終わると、事実上、ゲームジャムも終了となる。そこであっさりゲームジャムから離れてしまうのはなんとももったいない話である。まずは評価結果をしっかり確認し、自分の作品の順位を確かめよう。総合点はもちろん、それぞれの評価項目ごとの数値と、他の参加者からいただいたコメントをしっかり確認しよう。そこから、次の開発に活かすべき改善点が見えてくるはずだ。\nもし、提出した作品にバグが見つかっている場合や、いただいた評価やコメントからすぐに改善できる箇所がある場合は、それらを修正してアップロードしておこう。ゲームジャム終了後もそのゲームを遊んでくれる人たちへの配慮だ。ただし、評価期間中にこれをやると、先に提出したゲームのファイルだけ削除され、修正版がアップロードされないので、十分にご注意いただきたい。説明文に、修正箇所を追記しておくとより丁寧で良い。\nあとは、評価結果で上位にランクインしている作品を順番にプレイしていこう。必ずそこに高い評価を得るべくして得た理由があるはずなのだ。そして、良いと思ったアイデアやゲームシステムは自分の今後の作品に活かせるよう、しっかりメモを取っておくようにしよう。\nおわりに ということで、今回はゲームジャムについて記事を書いた。あなたがもしゲーム開発初心者でも、ゲームジャムに参加する意義は十分にあるということが伝わっただろうか。多くの場合、己の開発能力を成長させる機会になるので、都合の合うゲームジャムには積極的に参加したいものだ。\n参加のハードルを下げるためのいくつかのヒントもお伝えしたので振り返っておこう。英語のハードルはDeepLを使って対応すればOK。提出期間中に完成させるために、コードやアセットの流用も検討しつつ、とにかくシンプルかつコンパクトなゲームになるよう心がけることが重要だ。提出後、自分のゲームを評価してもらうために、まずは最適なカバーイメージを用意する。そして、積極的に他の人の作品をプレイしたら、事実に基づいてポジティブなコメントを残すようにするのも大事なポイントだ。\n私もまたチャンスがあれば他のゲームジャムにも参加したいと考えている。もしあなたが参加したゲームジャムで私の作品を見かける機会があれば、ぜひフィードバックをいただけると幸いだ。\n参考 ハッカソン itch.io KENNEY Jam 2022 KENNEY DeepL ","permalink":"https://www.peanuts-code.com/ja/posts/post0004_my_first_game_jam/","summary":"先日開催された「KENNEY Game Jam」に参加した。私にとって初めてのゲームジャムであった。今回はゲームジャムに参加してみてわかったこと、感じたことを交えつつ、itch.io のサイトで催されているインデ","title":"ゲームジャムで成長しよう"},{"content":"このチュートリアルでは 2D ゲームにおける経路探索 (Path Finding) について紹介する。経路探索というのは、例えばあるオブジェクトをある目的地へ移動させる際に、オブジェクトから目的地までの移動可能な最短経路を割り出す機能だ。なお、AStar というアルゴリズムを利用したグリッドベースの経路探索については「Godot で作る 2D グリッドベース経路探索 」の記事で紹介している。\nGodot 3.4 までは経路探索の実装に Navigation ノードを利用していた。特に不便ということもなかったが、これを使ったゲーム開発の方法論が限定的で、応用が効かない部分があったようだ。今回紹介するのは Godot 3.5 から追加された Navigation Server を使用した実装方法だ。これは現在開発が盛んに進められている Godot 4 からのバックポート（新しいバージョンから古いバージョンへの移植）だ。本記事は 3.5 以降を使用されている方を対象としている。もし Godot のバージョンが 3.4 以前の環境では非対応の内容を含むためご注意いただきたい。\nこのチュートリアルで最後にできあがるプロジェクトのファイルはGitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment Godot のバージョン: 3.5\nコンピュータのOS: macOS 11.6.5\nBasic Articles 以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 準備 新規プロジェクトを作成する それでは Godot Engine を立ち上げて、新規プロジェクトを作成しよう。プロジェクトの名前はあなたのお好みで決めていただいてOKだ。もし思いつかなければ「2D Path Finding Start」としておこう。\nプロジェクト設定を更新する エディタが表示されたら、プロジェクト全体に関わる設定を更新しておく。\nまずはゲームのディスプレイサイズを設定する。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 「一般」タブのサイドバーから「Display」＞「Window」を選択する。 「Size」セクションで以下の項目の値を変更する。 Width: 512 Height: 320 Test Width: 768 Test Height: 480 「Stretch」セクションで以下の項目の値を変更する。 Mode: 2d Aspect: keep 「インプットマップ」タブに切り替え、アクションに「move_to」を追加する。 「move_to」の操作に「マウス左ボタン」を割り当てる。\nアセットをダウンロードしてインポートする 次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは 1-Bit Pack というアセットパックだ。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「Tilesheet」フォルダ内の「colored-transparent_packed.png」ファイルをエディタのファイルシステムドックへドラッグ\u0026amp;ドロップしてプロジェクトにインポートする。\nファイルをインポートした直後は画像がぼやけた感じになっているので、これを以下の手順で修正しておく。\nファイルシステムドックでインポートしたアセットファイルを選択した状態にする。 インポートドックで「プリセット」＞「2D Pixel」を選択する。\n一番下にある「再インポート」ボタンをクリックする。\nこれでピクセルアート特有のエッジの効いた画像になったはずだ。インポートしたタイルセットは、後ほどタイルマップやプレイヤーキャラクターのテクスチャに利用する。\nWorld シーンを作る World シーンを新規作成する まず最初にゲームの世界を用意するために「World」シーンを作成する。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Node2D」クラスのルートノードが生成されたら、その名前を「World」に変更する。 シーンを保存する。フォルダを作成して、ファイルパスを「res://Scene/World.tscn」としてシーンを保存する。 World シーンに TileMap ノードを追加して編集する 「World」ルートノードに「TileMap」ノードを追加する。\nインスペクターにて、「TileMap」ノードの「TileSet」プロパティに「新規 TileSet」リソースを適用する。\n適用した「TileSet」リソースをクリックして、エディタ下部のタイルセットパネルを開く。\nタイルセットパネルの左サイドバーに、先にインポートしておいた KENNEYの「res://colored-transparent_packed.png」リソースファイルをドラッグして追加する。\n追加したテクスチャシートを選択し、以下の３つのシングルタイルを用意する。\nキャラクターが通る通路用のタイル\n*このナビゲーション領域が設定されているタイルが経路探索の対象となる。 砂利のタイルを使用 コリジョンポリゴン: 不要 ナビゲーションポリゴン: 必要 キャラクターは通らないが衝突もしないタイル\n*経路探索してキャラクターが移動する際、コリジョン形状を持つ木のタイルに引っかからないようにマージンとして使用する。 草のテクスチャを使用 コリジョンポリゴン: 不要 ナビゲーションポリゴン: 不要 キャラクターは通らないし衝突判定ありのタイル\n*経路探索時に通過不可の障害物として使用する。 木のテクスチャを使用 コリジョンポリゴン: 必要 ナビゲーションポリゴン: 不要 シーンドックで「TileMap」を選択し、2D ワークスペース上でタイルマップを作成する。以下はサンプルだ。砂利のタイルで通り道（ナビゲーション領域）がある程度確保できていればOKだ。\nただし、ここで注意すべきなのは、障害物用の木のタイルを置いたら、その周りに必ずマージン用の草のタイルを配置することだ。そうしないと、キャラクターが経路探索して移動するときに木のタイルギリギリをを通ろうとしてしまい、引っかかって移動できなくなってしまうのだ。これは今後改善してほしいポイントでもある。まだキャラクターの実装をしていないが、先にどういう挙動になるかをお見せしておく。\nWorld シーンに Line2D ノードを追加して編集する 「Line2D」ノードは探索して確定した経路を視覚的にわかりやすくするために使用する。\n「World」ルートノードに「Line2D」ノードを追加する。\nインスペクターで「Line2D」ノードの「Width」プロパティを 1 にする。\nPlayer シーンを作る ここからは探索した経路上を移動させるプレイヤーキャラクターのシーンを作成する。\nPlayer シーンを新規作成する 「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「KinematicBody2D」クラスのルートノードが生成されたら、その名前を「Player」に変更する。 シーンを保存する。フォルダを作成して、ファイルパスを「res://Scenes/Player.tscn」としてシーンを保存する。 Player シーンにノードを追加して編集する 「Player」ルートノードにノードを追加して、シーンツリーを以下のようにする。\nPlayer(KinematicBody2D) Sprite CollisionShape2D NavigationAgent2D 続いて各ノードを編集していく。\nSprite ノード このノードで「Player」シーンにテクスチャ（見た目）を施す。\nインスペクターにて「Texture」プロパティに KENNEY のサイトからダウンロードした「res://colored-transparent_packed.png」リソースを適用する。\n「Region」＞「Enabled」プロパティにチェックを入れて有効にする。\nエディタ下部のテクスチャ領域パネルを開き、好みのプレイヤーキャラクターのテクスチャの領域を選択する。このチュートリアルでは保安官っぽいテクスチャを採用した。\nCollisionShape2D ノード このノードで KinematicBody2D クラスである「Player」ルートノードのコリジョン形状を設定する。\nインスペクターにて「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。 さらに適用した「RectanbleShape2D」リソースの「Extents」プロパティの値を (x: 6, y: 6) にする。\n2Dワークスペース上では以下のようになる。\nNavigationAgent2D ノード このノードは Godot 4 からバックポートされる形で Godot 3.5 で導入されたノードだ。このノードを子に追加している親ノード（今回の場合は「Player」ノード）は、自動的に障害物との衝突を回避し、経路探索による移動が可能になる。デフォルトの World2D の navigation map に登録されて制御される仕組みのようだ。\nGodot Docs: NavigationAgent2D 「Avoidance」＞「Avoidance Enabled」プロパティにチェックを入れて有効にする。これにより、障害物との衝突回避が制御され、経路探索が可能になる。 「Avoidance」＞「Radius」プロパティを 8 にする。このプロパティはこのエージェントのサイズだ。「Sprite」ノードのテクスチャのサイズに合わせて、半径 8 px とした。 「Avoidance」＞「Neighbor Dist」プロパティも 8　にする。このプロパティは、他のエージェントを検知する距離を設定する。あとでこの「Player」を自動的に追跡する他のオブジェクトシーンを作成し、それらにも NavigationAgent2D ノードを追加することになるが、それらのエージェントが「Player」のすぐ隣に来るまでは検知する必要はないので、エージェントのサイズと同様に 8 とした。 「Avoidance」＞「Max Speed」プロパティを 40 にする。これはエージェントの最大移動速度だ。 World シーンに Player シーンのインスタンスを追加する ここで作成した「Player.tscn」シーンのインスタンスノードを「World」シーンに追加する。「World」シーンのシーンドックが以下のようになればOKだ。\nPlayer ノードにスクリプトをアタッチして編集する 「Player」シーンに戻ったら、「Player」ルートノードにスクリプトをアタッチしてコードを記述していく。ファイルパスを「res://Scripts/Player.gd」としてスクリプトを作成しよう。スクリプトエディタが開いたら以下のコードを記述する。\n###Player.gd### extends KinematicBody2D # Player のスピード export (float) var speed = 40 # WorldシーンのLine2Dノードを参照 onready var line: Line2D = get_node(\u0026#34;../Line2D\u0026#34;) # NavigationAgent2Dノードを参照 onready var nav_agent = $NavigationAgent2D # ノードがシーンツリーに読み込まれたら呼ばれる組み込み関数 func _ready(): # NavigationAgent2Dにより現在の位置を暫定の目的地としてセット nav_agent.set_target_location(global_position) # 毎フレーム呼ばれる組み込みの物理プロセス関数 func _physics_process(delta): # もし探索した経路の最後の位置に到達していなければ if not nav_agent.is_navigation_finished(): # 次の障害物のない移動可能な位置を取得 var next_loc = nav_agent.get_next_location() # 現在のPlayerの位置を取得 var current_pos = global_position # 次の移動可能な位置に対する方向とスピードから速度を計算 var velocity = current_pos.direction_to(next_loc) * speed # NavigationAgent2Dの衝突回避アルゴリズムに速度を渡す # 速度調整が完了次第velocity_computedシグナルを発信する nav_agent.set_velocity(velocity) # インプットマップアクションmove_to（マウス左ボタン）を押したら if Input.is_action_pressed(\u0026#34;move_to\u0026#34;): # 経路探索を開始するメソッドを呼ぶ find_path() # このあと定義 # 経路探索を開始するメソッド func find_path(): # NavigationAgent2Dにより現在のマウスの位置を次の目的地としてセット nav_agent.set_target_location(get_global_mouse_position()) # 次の障害物のない移動可能な位置を取得 nav_agent.get_next_location() # WorldシーンのLine2DのパスにNavigationAgent2Dが生成した経路の情報を渡す # どちらもデータ型がPoolVector2Arrayなのでそのまま渡すことができる line.points = nav_agent.get_nav_path() ここで「NavigationAgent2D」ノードのシグナルを3種類、このスクリプトに接続する。\n上のスクリーンショットだと順番が下からになるが、まず一つ目は「velocity_computed」シグナルだ。このシグナルは「NavigationAgent2D」が周りのオブジェクトとの衝突回避のための速度調整を完了したタイミングで発信される。\n二つ目は「target_reached」シグナルだ。このシグナルは最終目的地への経路上で次に移動可能な位置へ到達できたタイミングで発信される。\n三つ目のシグナルは「navigation_finished」だ。これは経路上の最終目的地に到達したタイミングで発信される。\nそれぞれのシグナルをスクリプトに接続したら、生成されたメソッド内に必要なコードを記述していく。コードは以下のようになる。\n###Player.gd### # NavigationAgent2Dが速度調整を終えたら発信するシグナルで呼ばれる func _on_NavigationAgent2D_velocity_computed(safe_velocity): # 調整された速度をPlayerの移動に適用する move_and_slide(safe_velocity) # NavigationAgent2Dが次の移動可能な位置に到達した時に発信するシグナルで呼ばれる func _on_NavigationAgent2D_target_reached(): # WorldシーンのLine2Dノードのパスに... # NavigationAgent2Dの更新された経路を反映する line.points = nav_agent.get_nav_path() # NavigationAgent2Dが経路の最後の目的地に到達した時に発信するシグナルで呼ばれる func _on_NavigationAgent2D_navigation_finished(): # WorldシーンのLine2Dノードのパスのポイントを0にリセットする line.points.resize(0) 以上で「Player.gd」スクリプトの編集は完了だ。このタイミングで一度プロジェクトを実行してみる。初めてプロジェクトを実行する場合は、メインシーンに「res://Scenes/World.tscn」を選択する。\nタイルマップ上を適当にクリックして、「Player」が問題なく経路探索して移動するかどうか確認してみよう。\nAnimal シーンを作る 「Player」シーンではマウスの位置を目的地とした経路探索を実装したが、ここからは、その移動する「Player」を目的地として移動する別オブジェクトの経路探索を実装する。とはいえ、ほとんどやることは同じなので心配は無用だ。\nさきほど作成した「Player」のインスタンスオブジェクトに複数の動物のオブジェクトが集まってくるようにしてみよう。その動物のオブジェクトのために「Animal」シーンをこれから作成していく。\nAnimal シーンを新規作成する 「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「KinematicBody2D」クラスのルートノードが生成されたら、その名前を「Animal」に変更する。 シーンを保存する。フォルダを作成して、ファイルパスを「res://Scenes/Animal.tscn」としてシーンを保存する。 Animal シーンにノードを追加して編集する 「Animal」ルートノードにノードを追加して、シーンツリーを以下のようにする。\nAnimal(KinematicBody2D) Sprite CollisionShape2D NavigationAgent2D PathTimer(Timer)\n続いて各ノードを編集していく。\nSprite ノード このノードで「Animal」シーンにテクスチャ（見た目）を施す。\nインスペクターにて「Texture」プロパティに KENNEY のサイトからダウンロードした「res://colored-transparent_packed.png」リソースを適用する。\n「Region」＞「Enabled」プロパティにチェックを入れて有効にする。\nエディタ下部のテクスチャ領域パネルを開き、動物のテクスチャ6つ分の領域を選択する。\n「Animation」＞「Hframes」プロパティの値を 6 にする。先に選択したテクスチャ領域が動物 6 種類分を含むので、1種類につき 1frameとなるように設定している。「Frame」プロパティでデフォルトのフレームを 0（1番目）としている。\nCollisionShape2D ノード このノードで KinematicBody2D クラスである「Animal」ルートノードのコリジョン形状を設定する。\nインスペクターにて「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。 さらに適用した「RectanbleShape2D」リソースの「Extents」プロパティの値を (x: 8, y: 8) にする。\n2Dワークスペース上では以下のようになる。\nNavigationAgent2D ノード 「Animal」シーンでも「Player」シーンと同様に、このノードを使って、障害物との衝突を回避し、経路探索による移動を可能にする。\n「Avoidance」＞「Avoidance Enabled」プロパティにチェックを入れて有効にする。 「Avoidance」＞「Radius」プロパティをはデフォルトの 10 のままとする。「Sprite」ノードのテクスチャのサイズより少し大きめにして、動物たちの間隔を少しだけ取るようにした。 「Avoidance」＞「Neighbor Dist」プロパティもデフォルトの 500　のままとする。ディスプレイサイズの横幅を 512 px にしているので、500 にしておけば、だいたいディスプレイの端から端まで他のエージェントを検知して衝突を回避できる。「Animal」シーンの複数のインスタンスが「Player」インスタンスの周りに群がることになるので、身動きが取れなくなるのを少しでも緩和するのが狙いだ。\nPathTimer(Timer) ノード このノードは移動する目的地（「Player」のインスタンスノード）の位置を定期的に更新するために使用する。\n「Wait Time」プロパティはデフォルトの 1 のままにしておく。 「One Shot」プロパティもデフォルトのまま無効にしておく。これで 1 秒おきに繰り返しタイムアウトする。 「Autostart」プロパティのチェックを入れて有効にする。これでこのノードがシーンツリーに読み込まれた時点で自動的にタイマーがスタートする。\nAnimal ノードにスクリプトをアタッチして編集する ここからは「Animal」ルートノードにスクリプトをアタッチして、コードを記述して「Animal」シーンを制御していく。ファイルパスを「res://Scripts/Animal.gd」としてスクリプトを作成する。スクリプトエディタが開いたら以下のようにコーディングする。\n###Animal.gd### extends KinematicBody2D # Animalのスピード var speed = 30 # 経路の目的地となるオブジェクトを代入するための変数 var target # Spriteノードの参照 onready var sprite = $Sprite # NavigationAgent2Dの参照 onready var nav_agent = $NavigationAgent2D # 以下、Player.gdとほぼ同様 func _ready(): nav_agent.set_target_location(global_position) func _physics_process(_delta): if not nav_agent.is_navigation_finished(): var current_pos = global_position var next_loc = nav_agent.get_next_location() var velocity = current_pos.direction_to(next_loc) * speed nav_agent.set_velocity(velocity) # 目的地のオブジェクトのx座標の方がanimalノードのx座標より小さい場合は # SpriteノードのTextureイメージを反転 sprite.flip_h = target.global_position.x \u0026lt; global_position.x 続いてシグナルを2つスクリプトに接続する必要がある。 まず一つ目は「Player」シーンの時と同様に、「NavigationAgent2D」ノードの「velocity_computed」シグナルを接続する。\n接続したら、生成された_on_NavigationAgent2D_velocity_computedメソッド内にmove_and_slideメソッドを記述して「Animal」ノードの移動を制御する。\n###Animal.gd### # NavigationAgent2Dが速度調整を終えたら発信するシグナルで呼ばれる func _on_NavigationAgent2D_velocity_computed(safe_velocity): # 調整された速度をPlayerの移動に適用する move_and_slide(safe_velocity) 次は「PathTimer」ノードの「timeout」シグナルをスクリプトに接続する。\n接続したら、生成されたメソッド_on_PathTimer_timeout内で、目的地となるオブジェクト（ここでは「Player」）の位置を経路探索時の目的地にセットするよう「NavigationAgent2D」ノードのset_target_locationメソッドを記述する。これで、1秒ごとのタイムアウト時に、最新の「Player」インスタンスノードの位置を取得して、そこを目的地とした経路探索が行われる。\n###Animal.gd### func _on_PathTimer_timeout(): nav_agent.set_target_location(target.global_position) 以上で「Animal.gd」スクリプトは完成だ。\nWorld シーンに Animals ノードを追加する 「World」シーンに「Animal」シーンのインスタンスを複数格納するための入れ物として Node2D クラスのノードを追加し、名前を「Animals」に変更する。「Animal」のインスタンスの追加はこのあとスクリプトで行うようにしていく。\nWorld ノードにスクリプトをアタッチして編集する 「World」ルートノードにスクリプトをアタッチし、それを編集して、「Animal」のインスタンスを複数追加する。ファイルパスを「res://Scripts/World.gd」としてスクリプトを保存し、スクリプトエディタが開いたら、以下のようにコードを記述する。\n###World.gd### extends Node2D # プリロードしたAnimalシーンファイルの参照 const animal_scn = preload(\u0026#34;res://Scenes/Animal.tscn\u0026#34;) # Animalインスタンスの数 export (int) var head_count = 12 # TileMapノードの参照 onready var tile_map = $TileMap # Playerノードの参照 onready var player = $Player # Animals(Node2D)ノードの参照 onready var animals = $Animals func _ready(): # 乱数生成関数のためにランダマイズ randomize() # TileMap上のID9のタイルを配列で取得 var cells = tile_map.get_used_cells_by_id(9) # Animalのインスタンスの数だけループ for i in head_count : # ID9のタイルの数の範囲内でランダム値を生成 var random_index = randi() % cells.size() # ID9のタイルからランダム値に当てはまるタイルを取得 var spawn_tile = cells.pop_at(random_index) # もしそのタイルが配列からすでに取り出し済みかつまだ配列が空でなければ while spawn_tile == null and not cells.empty(): # 再度ID9のライルの数の範囲内でランダム値を生成 random_index = randi() % cells.size() # 再度ID9のタイルからランダム値に当てはまるタイルを取得 spawn_tile = cells.pop_at(random_index) # Animalインスタンスを生成するメソッドを呼び出し... # 取得したタイル上にAnimalインスタンスを置く spawn_animal(spawn_tile) # Animalインスタンスを生成するメソッド func spawn_animal(spawn_tile): # 引数で渡されたタイルのx,y座標に(8, 8)ずらした位置を取得 var spawn_pos = tile_map.map_to_world(spawn_tile, true) + Vector2(8, 8) # Animalシーンのインスタンスを生成 var animal = animal_scn.instance() # Animalインスタンスの位置を引数で渡されたタイル上に配置 animal.position = spawn_pos # Animalインスタンスの目的地用プロパティにPlayerノードを代入して参照 animal.target = player.global_position # AnimalインスタンスのSpriteノードのテクスチャをランダムに決定 animal.get_node(\u0026#34;Sprite\u0026#34;).frame = randi() % animal.get_node(\u0026#34;Sprite\u0026#34;).hframes # AnimalインスタンスをAnimalsノードの子にする animals.add_child(animal) これで「World.gd」スクリプトは完成だ。プロジェクトを実行して、複数の「Animal」インスタンスが「Player」に近寄ってくる様を見てみよう。\nスクリプト内で定義したhead_countプロパティの数は、exportキーワード付きなのでインスペクターで簡単に編集できる。試しに「Animal」を100匹に増やしてみたが、最後は身動きが取れなくなった。「Animal」がゾンビだったらまさに地獄だ。\nサンプルゲーム 今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。\nYour browser does not support the video tag. サンプルゲームのプロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。\nゲームのルール マウス左クリックで、マウスカーソルの位置に移動 スペースキーでマウスカーソルの方向へ銃を撃つ 弾丸は最大12発。尽きるとリロードモーションの後また12発充填される。 敵（虫）に一定距離まで近づくと攻撃してくる 敵に当たるとハートが一つ減る ハートがなくなるとゲームオーバー 敵は色が濃いほどライフが多くスピードは遅い、色が薄いほどライフが少なくスピードが早い 敵を倒すと落ちるジュエルを拾った数がプレイヤーのスコア おわりに 今回のチュートリアルでは Godot 3.5 で追加された新しい Navigation Server　による経路探索を実装した。2Dの場合、痒いところに手が届かない印象は若干あるが、まだまだこれから改善されていくことを期待したい。今回のプロジェクトにおけるポイントを最後にまとめておこう。\nTileMap を使用する場合は移動可能なタイルに必ずナビゲーションを設定する。 TileMap を使用する場合は、角に引っかからないように領域のみ設定したタイルでマージンを作る。 今回は使用しなかったが NavigationPolygonInstance ノードを使ってナビゲーション領域を定義しても良い。 移動したいオブジェクトの子に「NavigationAgent2D」ノードを追加する スクリプトで経路探索を制御する際、最終目的地のセット、次に移動可能な位置の取得、衝突回避のために速度を調整、調整した速度で移動、の順番を意識してコードを記述する。 参考 Official Article - Navigation Server for Godot 4.0 Official Article - Godot 3.5: Can\u0026#39;t stop won\u0026#39;t stop Godot Doc - NavigationAgent2D YouTube - Godot 3.5 | NavigationAgent2D YouTube - Godot 3.5 is Out, and it\u0026#39;s SICK! Real-time pathfinding, new tween animations, and more GitHub - godotengine/godot - issue #60546 UPDATE\n2022/09/19 2D グリッドベース経路探索の記事へのリンクを追加\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0016_2d_path_finding/","summary":"このチュートリアルでは 2D ゲームにおける経路探索 (Path Finding) について紹介する。経路探索というのは、例えばあるオブジェクトをある目的地へ移動させる際に、オブジェクトから目的地までの移動可能な最短経路を割り出す機能","title":"Godot3 で作る 2D 経路探索"},{"content":"今回は、円形のプログレスバーの作り方を紹介する。プログレスバーを、一般的な縦向きや横向きではなく、円形にすることによって、画面上のちょっとしたアクセントにもなるので使い所があれば是非参考にしていただきたい。また、チュートリアルの最後のほうで、円形以外の形状（例えばハート型）のプログレスバーもサンプルとしていくつか紹介するのでそちらも興味があればぜひご覧いただきたい。\nこのチュートリアルで最後にできあがるプロジェクトのファイルはGitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment Godot のバージョン: 3.4.4\nコンピュータのOS: macOS 11.6.5\nBasic Articles 以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 準備 円形プログレスバーの画像を用意する お使いのコンピュータに Photoshop や GIMP などの描画アプリがあれば、そちらをお使いいただければOKだ。描画アプリの使い方の詳細はここでは割愛させていただく。難しい場合はググってみてほしい。\n真ん中をくり抜いた円の図形を作成する。この時、円の色は白にする。理由は Godot エディタ上で色の設定が簡単にできるだからだ。白以外の部分は透過させた状態にしておく。画像サイズを縦横 300 px にして png ファイルとして保存する。\nちなみに私の場合は、Mac の「Keynote」アプリ（Windows PC の PowerPointのようなスライドショー作成アプリ）で作成した図形オブジェクトをクリップボードにコピーして、「プレビュー」アプリを起動して、「クリップボードから新規作成」して、png として保存した。\nこの手順を省略したい場合は、下の画像をブラウザから直接ダウンロードしていただければと思う（背景が白いと画像が同化して何もないように見えるかもしれない\u0026hellip;）。\n新規プロジェクトを作成する それでは Godot Engine を立ち上げて、新規プロジェクトを作成しよう。プロジェクトの名前はあなたのお好みで決めていただいてOKだ。もし思いつかなければ「Circular Progress Bar」としておこう。\n用意した画像をインポートする ファイルシステムドックで先にリソースフォルダ直下（res://）に「Textures」フォルダを作成する。そこにさきほど用意した円形の画像をドラッグ\u0026amp;ドロップしてインポートする。ファイル名は「CircularProgressBar.png」としておく（ファイルパスは res://Textures/CircularProgressBar.png ）。\nシーンを作る まずは CircularProgressBar シーンを作ろう。\n「シーン」メニュー＞「新規シーン」を選択する。\n「Control」クラスのノードをルートノードとして選択したら、名前を「CircularProgressBar」に変更する。\n一旦ここでシーンを保存する。ファイルパスを「res://CircularProgressBar.tscn」としてシーンを保存する。\n続けて「CircularProgressBar」ルートノードに「TextureProgress」ノードを追加する。\nさらに「CircularProgressBar」ルートノードに「Label」ノードを追加する。\nシーンツリーは以下のようになったはずだ。\nノードを編集する CircularProgressBar (Control) ルートノード 2D ワークスペースで、ツールバー＞「レイアウト」から「全画面」を選択する。\nTextureProgress ノード インスペクターにて、「Fill Mode」プロパティの値を「Clockwise」にする。これは時計回りにぐるりとプログレスバーが進行するスタイルだ。このプロパティはプログレスバーの形状に合わせて適切に選択することを心がけたい。例えば、もしハート型のプログレスバーなら下から上にバーが進行する「Bottom to Top」が相応しいだろう。\n「Texture」＞「Under」プロパティに先にインポートしておいた画像リソース「res://Textures/CircularProgressBar.png」をドラッグして適用しよう。 「Texture」＞「Progress」プロパティも同様にする。\n「Tint」＞「Under」プロパティの色を #000000 (黒) にする。 「Tint」＞「Progress」プロパティは、味気ないが、ひとまずデフォルトの #ffffff (白) のままにしておく\n2D ワークスペースで、ツールバー＞「レイアウト」から「中央」を選択する。\nLabel ノード インスペクターにて「Text」プロパティには初期値として適当に「100%」などと入力しておく。 「Align」プロパティを「Center」にする。 「Valign」プロパティも「Center」にする。\nOpen Font Package をダウンロードする 「Label」ノードにフォントを設定したいので、エディタ上部のタブで「Asset Library」に切り替えて「Open Font Package」をダウンロードしよう。\n上部の「AssetLib」タブをクリックして「Asset Library」に切り替える。 「font」で検索するなどして「Open Font Package」を見つけたら、それをクリックする。\n「Download」をクリックする。\n必要なフォントファイルだけチェックして「Install」をクリックする。今回は「Xolonium-Bold.ttf」を選択。\nファイルシステムドックに表示されれば完了だ。\nLabel ノード（続き） インスペクターに戻って、「Theme Overrides」＞「Fonts」＞「Font」プロパティに「新規 DynamicFont」を適用する。 適用した「DynamicFont」リソースを展開し、「Font」＞「Font Data」プロパティにインストールしたばかりのフォントリソース「res://fonts/xolonium/xolonium-fonts-4.1/ttf/Xolonium-Bold.ttf」を適用する。 同じく「DynamicFont」リソースの「Settings」＞「Size」プロパティを 40 にする。 同じく「DynamicFont」リソースの「Settings」＞「Outline Size」プロパティを 4 にする。 少し戻って、「Theme Overrides」＞「Colors」＞「Font Color」を有効にして、色は #000000 (黒) のままにしておく。\n2D ワークスペースにて、ツールバーの「レイアウト」から「中央」を選択する。\nスクリプトをアタッチしてコーディングする 上下矢印キーでプログレスバーを更新させる ではキーボードの上下矢印キーでプログレスバーの値が変化するようにスクリプトをコーディングしていこう。「TextureProgress」ノードの「Value」プロパティの値を変化させることで、「Texture」＞「Progress」プロパティの表示範囲も連動してくれる。\n「CircularProgressBar」ルートノードにスクリプトをアタッチする。ファイル名を「Progress.gd」としてファイルパスは「res://Progress.gd」とする。 エディタが開いたら、以下のように編集する。 ###Progress.gd### extends Control # TextureProgressノードの参照 onready var progress_bar = $TextureProgress # Labelノードの参照 onready var label = $Label func _ready(): # TextureProgressノードのvalueプロパティを0にリセットする progress_bar.value = 0 func _process(delta): # 入力操作を処理するメソッドを呼び出す get_input() # LabelノードのTextプロパティを更新するメソッドを呼び出す update_label() # 入力操作を処理するメソッド func get_input(): # もし上矢印キーを押したら if Input.is_action_pressed(\u0026#34;ui_up\u0026#34;): # TextureProgressノードのValueプロパティの値に1をプラス progress_bar.value += 1 # もし下矢印キーを押したら if Input.is_action_pressed(\u0026#34;ui_down\u0026#34;): # TextureProgressノードのValueプロパティの値から1をマイナス progress_bar.value -= 1 # Labelノードのtextプロパティを更新するメソッド func update_label(): # TextureProgressノードのValueプロパティの値に%をつけて表示する label.text = str(progress_bar.value) + \u0026#34;%\u0026#34; ではプロジェクトを実行して、上下矢印キーでプログレスバーの値を変化させてみよう。初めてプロジェクトを実行する場合は、メインシーンの選択を促すダイアログにて、現在のシーンをメインシーンとして設定すればOKだ。\nプログレスバーの値に連動して色を変化させる モノクロだと味気ないので、プログレスバーの色も変化させてみよう。今度は、プログレスバーの値の変化に合わせて、徐々にプログレスバーの色も変化させたい。「TextureProgress」ノードの「Value」プロパティの値の更新をより細かくするために「Step」プロパティの値を小さくしておこう。今回は 0.1 に設定する。\nスクリプトを以下のように編集する。\n###Progress.gd### extends Control # TextureProgressノードのtint_progressプロパティ(Colorクラス)の... # h, s, vプロパティの始まりと終わりの値を指定するプロパティ(HSVで色を指定する) export (float) var h_start = 0.0 export (float) var h_end = 0.45 export (float) var s_start = 0.3 export (float) var s_end = 1.0 export (float) var v_start = 0.3 export (float) var v_end = 1.0 onready var progress_bar = $TextureProgress onready var label = $Label func _ready(): progress_bar.value = 0 func _process(delta): get_input() update_label() # 追加：色相を更新するメソッドを呼び出す update_color() func get_input(): if Input.is_action_pressed(\u0026#34;ui_up\u0026#34;): progress_bar.value += 1 if Input.is_action_pressed(\u0026#34;ui_down\u0026#34;): progress_bar.value -= 1 func update_label(): label.text = str(progress_bar.value) + \u0026#34;%\u0026#34; # 追加：色相を更新するメソッド func update_color(): # Valueプロパティの値がminからmaxへ変化するのに合わせてプログレスバーの色相を変化させる progress_bar.tint_progress.h = range_lerp(progress_bar.value, progress_bar.min_value, progress_bar.max_value, h_start, h_end) # Valueプロパティの値がminからmaxへ変化するのに合わせてプログレスバーの彩度を変化させる progress_bar.tint_progress.s = range_lerp(progress_bar.value, progress_bar.min_value, progress_bar.max_value, s_start, s_end) # Valueプロパティの値がminからmaxへ変化するのに合わせてプログレスバーの明度を変化させる progress_bar.tint_progress.v = range_lerp(progress_bar.value, progress_bar.min_value, progress_bar.max_value, v_start, v_end) それでは改めてプロジェクトを実行してみよう。\n色の変化があると美しいような気はするが、あくまでゲームに合わせたデザインを心掛けたい。\nさまざまな形状のプログレスバー ここまで実装してみてお気づきかもしれないが、プログレスバーはその形状となる画像リソースさえあれば、割と応用が効くのだ。\nここまでに作成した「CircularProgressBar.tscn」を複製して、少しプロパティを変更するだけで、色々なパターンのプログレスバーを比較的簡単に作ることができる。いくつかのサンプルを用意したのでご覧いただきたい。\nハート型のプログレスバー ルートノードの「Script Variables」の各プロパティ。色相は紫から赤へ。彩度と明度は最初から高め。\n「TextureProgress」ノードの「Fill Mode」プロパティ。下から上に進行。\n「TextureProgress」ノードの「Textures」＞「Under」/「Progress」プロパティ。ハートのテクスチャを適用。\nシーンを実行。\nドクロ型のプログレスバー ルートノードの「Script Variables」の各プロパティ。色相は緑から青へ。彩度は低めに抑える。\n「TextureProgress」ノードの「Fill Mode」プロパティ。中央から上下両方向へ。\n「TextureProgress」ノードの「Textures」＞「Under」/「Progress」プロパティ。ドクロ型のテクスチャを適用。\nシーンを実行。\nフラスコのプログレスバー このサンプルでは「Progress.gd」スクリプトを少し編集する。\n###Progress.gd### # 追加: バーの限界値（初期値はmax_valueに合わせて100） export (float) var value_limit = 100 # 入力操作処理のメソッド func get_input(): if Input.is_action_pressed(\u0026#34;ui_up\u0026#34;): progress_bar.value += 1 # 追加：バーの限界値までしかバーを進行させない progress_bar.value = min(progress_bar.value, value_limit) if Input.is_action_pressed(\u0026#34;ui_down\u0026#34;): progress_bar.value -= 1 # Labelノードのtextプロパティを更新するメソッド func update_label(): # 追加：Labelの%をバーの限界値を1として計算 var actual_value = floor(progress_bar.value / value_limit * 100) label.text = str(actual_value) + \u0026#34;%\u0026#34; ルートノードの「Script Variables」の各プロパティ。ここで新たに追加したプロパティ「Value Limit」の値を 72.5 に変更している。これがちょうどこのあと適用するフラスコのテクスチャ画像に描かれている一番上の目盛りに合う値だ。\n「TextureProgress」ノードの「Fill Mode」プロパティ。下から上へ。\n「TextureProgress」ノードの「Textures」＞「Under」/「Progress」プロパティ。フラスコのテクスチャを適用。\nシーンを実行。上記の調整で、フラスコのテクスチャの一番上の目盛りでバーの進行が止まる。\n脳みそのプログレスバー ルートノードの「Script Variables」の各プロパティ。\n「TextureProgress」ノードの「Fill Mode」プロパティ。\n「TextureProgress」ノードの「Textures」＞「Under」/「Progress」プロパティ。\n「TextureProgress」ノードの「Radial Fill」＞「Fill Degrees」を180にして、進行バーの展開できる角度を最大 180° とした。進行バーの回転の中心を脳みそのテクスチャのすぐ下までずらすために「Center Offset」の y の値を 130 とした。\nシーンを実行。\nここまでに作ったものを１つのシーンにまとめてみる。\nメインシーンの設定を変更してプロジェクトを実行するとこんな感じだ。\nおわりに 今回は円形プログレスバーやその他の形状のプログレスバーの作成方法について紹介した。ポイントは以下の通りだ。\nプログレスバーの形状を決めるのはテクスチャ用の画像リソース。 形状に合わせて「TextureProgress」ノードの「Fill Mode」プロパティでバーの進行方向を設定する。 スクリプトで「TextureProgress」ノードの「Value」プロパティの値を変化させることで、進行バーも連動させられる。 スクリプトで「TextureProgress」ノードの「Tint」＞「Progress」プロパティの色を変化させることで、バーの進行状況に合わせて色を変化させられる。 参考 YouTube: Godot Circle Progress Bar Chart YouTube: Creating a circular meter using a single Godot Control Node UPDATE\n2022/08/06 Header の構成とサイズを若干修正 ","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0015_circular_progress_bar/","summary":"今回は、円形のプログレスバーの作り方を紹介する。プログレスバーを、一般的な縦向きや横向きではなく、円形にすることによって、画面上のちょっとしたアクセントにもなるので使い所があれば是非参考にしていただき","title":"Godot3 で作る円形プログレスバー"},{"content":"今回の記事では、2Dゲームでの画面揺れの実装方法を紹介する。ゲームに絶対に必要な要素ではないが、うまく使えばプレイヤーのゲーム体験をよりインタラクティブにでき、ユーザエクスペリエンスに直接影響を与えることができる。例えば、銃を撃った時や敵からダメージを受けた時、高いところから落ちた時など、使えそうな場面は山ほどある。ちなみに、このような必要ではないものの追加することでゲームをより面白くする要素を、英語圏ではゲーム・ジュース[Game Juice]といい、またそうすることをジューシング[Juicing]というようだ。\n画面揺れの実装方法について解説したリソースは Web 上にたくさん存在し、今回紹介する以外の方法ももちろん存在する。今回はその中でも特に以下の動画と記事を参考にしているので、併せて確認いただくとより理解が深まるだろう。\nReference YouTube: GDC - Math for Game Programmers: Juicing Your Cameras With Math KidsCanCode: SCREEN SHAKE このチュートリアルで最後にできあがるプロジェクトのファイルはGitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment Godot のバージョン: 3.4.4\nコンピュータのOS: macOS 11.6.5\n準備 新規プロジェクトを作成する それでは Godot Engine を立ち上げて、新規プロジェクトを作成しよう。プロジェクトの名前はあなたのお好みで決めていただいてOKだ。もし思いつかなければ「Screen Shake」としておこう。\nプロジェクト設定を更新する エディタが表示されたら、プロジェクト全体に関わる設定を更新しておく。\nまずはゲームのディスプレイサイズを設定する。今回は 16 px を基準値として縦横 9:16 の比率とする。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。\n「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。\n「Size」セクションで以下の項目の値を変更する。\nWidth: 256 Height: 144 Test Width: 512 Test Height: 288\n「Stretch」セクションで以下の項目の値を変更する。\nMode: 2d Aspect: keep\n「インプットマップ」タブに切り替え、アクションに「shake」を追加する。\n「shake」の操作に「space」キーを割り当てる。\nアセットをダウンロードしてインポートする 次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは「Tiny Dungeon 」というアセットパックだ。このアセットに含まれるタイルセットを使用する。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「/kenney_tinydungeon/Tilemap/tilemap_packed.png」をファイルシステムドックへドラッグしてプロジェクトにインポートする。\nファイルをインポートした直後は画像がぼやけた感じになっているので、これを以下の手順で修正しておく。\nファイルシステムドックでインポートしたアセットファイルを選択した状態にする インポートドックで「プリセット」＞「2D Pixel」を選択する\n一番下にある「再インポート」ボタンをクリックする。\nこれでピクセルアート特有のエッジの効いた画像になったはずだ。インポートしたタイルセットは、後ほどタイルマップ作成時に利用する。\nCamera シーンを作る Camera シーンを新規作成する まずは Camera シーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「Camera2D」クラスのノードをルートノードとして選択したら、名前を「Camera」に変更する。 一旦ここでシーンを保存する。フォルダを作成して、ファイルパスを「res://Camera/Camera.tscn」としてシーンを保存する。 シーンツリーは子ノードがないため、シーンドックは以下のように「Camera」ノードのみになっているはずだ。\nCamera ノードのプロパティを編集する 続けてインスペクターで以下の編集をする。\n「Current」プロパティを On にする。\n「Limit」プロパティをディスプレイサイズに合わせる。\nCamera ノードにスクリプトをアタッチして編集する Camera ノードに新規でスクリプトをアタッチする。ファイルパスを「res://Camera/Camera.tscn」としてスクリプトファイルを作成する。\n今回、「荒い画面揺れ』と「滑らかな画面揺れ」の2種類の揺れを実装していく。まず先にコードの内容が比較的シンプルな「荒い画面揺れ」から。\nスクリプトには以下のコードを記述する。\n###Camera.gd### extends Camera2D # 揺れの強さ（0.0から1.0まで） var trauma = 0.0 # 揺れの強さを累乗する際の指数 var trauma_power = 2 # 揺れの強さ trauma を指数 trauma_power で累乗した値を入れる var amount = 0.0 # 1秒で減衰する揺れの強さ（0.0以下だと永遠に揺れるので注意） var decay = 0.8 # 最大の揺れ幅（x軸方向、y軸方向それぞれの値をVector2型で一つのデータとして保持） var max_offset = Vector2(36, 64) # display ratio is 16 : 9 # 最大の回転角度（ラジアン) var max_roll = 0.1 # ノードが読み込まれたら最初に呼ばれる組み込み関数 func _ready(): # ランダム値を返す関数のためにシード値をランダム化する # シード値が同じだと得られる数も同じになるため必須 randomize() # 毎フレーム呼ばれる組み込みのプロセス関数 func _process(delta): # もし trauma の数値が0より大きければ if trauma: # 揺れの強さを減衰させる trauma = max(trauma - decay * delta, 0) # 荒い画面揺れの揺れ幅と回転角度を設定するメソッドを呼ぶ # これを毎フレーム呼ぶことで画面揺れを表現する rough_shake() # このあと定義 # 荒い画面揺れの揺れ幅と回転角度を設定するメソッド func rough_shake(): # amount は揺れの強さを累乗した値 # pow() 関数は第一引数を第二引数を指数として累乗する # 揺れの強さが 0 に近づくほど、累乗するとその値はより小さくなる # 例: 1.0 * 1.0 = 1.0, 0.5 * 0.5 = 0.25, 0.1 * 0.1 = 0.01 amount = pow(trauma, trauma_power) # 回転角度 = 最大回転角度 * 揺れの強さを累乗した値 * -1 ~ 1 のランダム値 rotation = max_roll * amount * rand_range(-1, 1) # x軸方向の揺れ幅 = x軸方向の最大揺れ幅 * 揺れの強さを累乗した値 * -1 ~ 1 のランダム値 offset.x = max_offset.x * amount * rand_range(-1, 1) # y軸方向の揺れ幅 = y軸方向の最大揺れ幅 * 揺れの強さを累乗した値 * -1 ~ 1 のランダム値 offset.y = max_offset.y * amount * rand_range(-1, 1) # 揺れの強さをセットするメソッド func set_shake(add_trauma = 0.5): # 引数 add_trauma の値を現在の trauma の値に加算する # 1.0 以上になる場合は trauma を 1.0 とする trauma = min(trauma + add_trauma, 1.0) # 入力を処理する組み込みの関数 func _unhandled_input(event): # もしインプットマップのアクション「shake」のキーを押したら if event.is_action_pressed(\u0026#34;shake\u0026#34;): # 揺れの強さをセットするメソッドを呼ぶ set_shake() これで「荒い画面揺れ」のスクリプトは完成だ。\nWorld シーンを作る World シーンを新規作成して必要なノードを追加する Camera シーンだけでは画像がないので揺れがわからない。揺れを確認するために、World シーンを作成し、そこに Camera シーンのインスタンスと、背景となるノードを用意していく。\n「シーン」メニュー＞「新規シーン」を選択する。 ルートノードとして「Node2D」を選択し、名前を「World」に変更する。 ファイルパスを「res://World/World.tscn」としてシーンを保存する。\n続いて、World シーンが以下のシーンツリーになるようにノードを追加する。\nWorld (Node2D) Camera (Camera2D、Cameraシーンのインスタンス) TileMap TileMap ノードを編集する 背景用に手早くタイルマップを作成しよう。\n「TileMap」ノードの「Tile Set」プロパティに新規タイルセットリソースを適用する。\nタイルセットパネルを開き、左側に KENNEY からダウンロードした「res://Assets/tilemap_packed.png」リソースファイルをドラッグし、シングルタイルかアトラスでタイルを適当に設定する。\nシーンドックで「TileMap」を選択してタイルマップを作成する。範囲はディスプレイサイズを少しはみ出す程度に。\n「荒い画面揺れ」をテストする ようやくプロジェクトを実行して「荒い画面揺れ」をテストだ。初めて実行する場合はプロジェクトのメインシーンに「World.tscn」を選択する。\nスペースキーを押して画面を揺らしてみよう。少し待ってから押してみたり、間を空けずに連続的に押したりして、挙動を確認してみる。\nYour browser does not support the video tag. 違和感は特になく、それなりに良い感じだ。しかし、この後実装する滑らかな画面揺れと比較すると、やや荒い印象を受けるはずだ。\nCamera ノードのスクリプトに「滑らかな画面揺れ」のコードを追加する ここからは「滑らかな画面揺れ」を実装していく。Camera シーンに戻り、アタッチしている「Camera.gd」スクリプトにコードを追加する。\n滑らかな画面揺れは、ノイズと呼ばれる以下のような画像を利用する。\nノイズ画像には白、グレー、黒がランダムに分布している。黒を -1 白を 1 、中間のグレーを 0 として、ノイズの値は -1 ~ 1 まで変化する。ノイズ上の座標を指定して、そのピクセルのノイズの値を取得し、それを画面揺れに応用しようというわけだ。\nGodot では OpenSimplexNoiseというクラス（リソース）が用意されている。これをスクリプト上で新規生成し、このリソースのクラスに組み込まれているget_noise_2dメソッドで、引数にx座標、y座標を渡してあげると、指定した座標のノイズ値が取得できる。今回は引数に渡す x座標をランダムで指定し、y座標を 1 pixel ずつずらしながらノイズ値を取得し、それを揺れ幅の計算に乗ずることで、滑らかな画面揺れを再現する。\nちなみに、ノイズを構成するいくつかのパラメータを変化させると、ノイズがどのように変わるのかは、Godot の OpenSimplexNoise を利用した以下のデモページで色々と試してみると直感的に理解できるかもしれない。\nReference OpenSimplexNoise Viewer ノイズについてはちょっとややこしく感じられたかもしれないが、ひとまずスクリプトを記述してみよう。ついでに「荒い画面揺れ」と「滑らかな画面揺れ」を切り替えられるようにしていく。\n###Camera.gd### extends Camera2D # 画面揺れの種類をenumで定義 enum { ROUGH, # 荒い揺れの場合 SMOOTH # 滑らかな揺れの場合 } ## 共通のプロパティ var type = ROUGH # 画面揺れの種類（デフォルトは荒い揺れ） var trauma = 0.0 var trauma_power = 2 var amount = 0.0 ## 荒い画面揺れのプロパティ var decay = 0.8 var max_offset = Vector2(36, 64) var max_roll = 0.1 ## 滑らかな画面揺れのプロパティ var noise_y = 0 # ノイズの y 座標 onready var noise = OpenSimplexNoise.new() # ノイズのインスタンス func _ready(): randomize() ## 滑らかな画面揺れの場合に使用 # シード：ノイズ特有のランダムな見た目を決める値（ランダムな整数を割り当てる） # シード値が変わればノイズの白から黒のドットの配置も変わる noise.seed = randi() # オクターブ：ノイズを作るレイヤー数（ここでは 2 とする） # 値が大きいほど白と黒の間のグレーの階層が増えて詳細なノイズになる noise.octaves = 2 # ピリオド：ノイズの周期（ここでは 4 とする） # 値が小さいほど高周波ノイズになる noise.period = 4 func _process(delta): if trauma: trauma = max(trauma - decay * delta, 0) # もし画面揺れの種類が ROUGH の場合 if type == ROUGH: # 荒い画面揺れの揺れ幅と回転角度を設定するメソッドを呼ぶ rough_shake() # もし画面揺れの種類が SMOOTH の場合 elif type == SMOOTH: # 滑らかな画面揺れの揺れ幅と角度を設定するメソッドを呼ぶ smooth_shake() func rough_shake(): amount = pow(trauma, trauma_power) rotation = max_roll * amount * rand_range(-1, 1) offset.x = max_offset.x * amount * rand_range(-1, 1) offset.y = max_offset.y * amount * rand_range(-1, 1) # 滑らかな画面揺れの揺れ幅と回転角度を設定するメソッド func smooth_shake(): # amount は揺れの強さを累乗した値 amount = pow(trauma, trauma_power) # ノイズの y 座標を 1 ピクセル増やす noise_y += 1 # 回転角度 = 最大回転角度 * 揺れの強さを累乗した値 * 指定した座標のノイズ値(-1 ~ 1) rotation = max_roll * amount * noise.get_noise_2d(noise.seed, noise_y) # x軸方向の揺れ幅 = x軸方向の最大揺れ幅 * 揺れの強さを累乗した値 * 指定した座標のノイズ値(-1 ~ 1) # noise.seed に乗じている 2 は回転角度とy軸方向の揺れ幅とは異なるノイズ値を取得するための適当な数値 offset.x = max_offset.x * amount * noise.get_noise_2d(noise.seed * 2, noise_y) # y軸方向の揺れ幅 = y軸方向の最大揺れ幅 * 揺れの強さを累乗した値 * 指定した座標のノイズ値(-1 ~ 1) # noise.seed に乗じている 3 は回転角度とx軸方向の揺れ幅とは異なるノイズ値を取得するための適当な数値 offset.y = max_offset.y * amount * noise.get_noise_2d(noise.seed * 3, noise_y) func set_shake(add_trauma = 0.5): trauma = min(trauma + add_trauma, 1.0) func _unhandled_input(event): if event.is_action_pressed(\u0026#34;shake\u0026#34;): set_shake() # 右矢印キーまたは左矢印キーを押したら画面揺れの種類を切り替え if event.is_action_pressed(\u0026#34;ui_right\u0026#34;)\\ or event.is_action_pressed(\u0026#34;ui_left\u0026#34;): # 現在荒い画面揺れの設定になっていたら if type == ROUGH: # 滑らかな画面揺れの設定にする type = SMOOTH # 滑らかな画面揺れの設定になっていたら else: # 荒い画面揺れの設定にする type = ROUGH World シーンにノードを追加する 画面上どちらの種類の画面揺れになっているか分かりやすくするためシーンツリーに「CanvasLayer」ノードとその子として「Label」ノードを追加する。ノードの名前は「TypeLabel」としておく。\nインスペクターで「Text」プロパティに「ROUGH」と初期値を入力しておく。\n「Theme Overrides」＞「Color」＞「Font Color」プロパティで、フォントの色を #000000（黒）とする。\n2D ワークスペースのツールバーの「Layout」から「中央」を選択し、「TypeLabel」ノードの位置を中央に配置する。\n「World」ルートノードにスクリプトをアタッチして、ファイルパスを「res://World/World.gd」として保存する。スクリプトには、画面揺れの種類を切り替える操作のために以下のコードを記述する。\n###World.gd### onready var type_label = $CanvasLayer/TypeLabel func _unhandled_input(event): if event.is_action_pressed(\u0026#34;ui_right\u0026#34;)\\ or event.is_action_pressed(\u0026#34;ui_left\u0026#34;): if type_label.text == \u0026#34;ROUGH\u0026#34;: type_label.text = \u0026#34;SMOOTH\u0026#34; else: type_label.text = \u0026#34;ROUGH\u0026#34; これで左右矢印キーで画面揺れの種類を ROUGH（荒い画面揺れ）と SMOOTH（滑らかな画面揺れ）とで切り替えられるようになった。\n「滑らかな画面揺れ」をテストし「荒い画面揺れ」と比較する それでは最後に再度プロジェクトを実行し、揺れの種類を切り替えつつ、「滑らかな画面揺れ」の挙動を確認し、「荒い画面揺れ」と比較してみよう。\nYour browser does not support the video tag. 以上で、画面揺れの実装は完了だ。違いを感じていただけただろうか。僅かな違いな気もするが、ゲームの演出にこだわるならその場面にふさわしい揺れを採用したいものだ。\nサンプルプロジェクト さらに視覚的に画面揺れの状態を分かりやすくしたプロジェクトを別で用意した。よければ触ってみてほしい。\nYour browser does not support the video tag. サンプルゲームのプロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。\nサンプルプロジェクトの仕様はおおよそ以下の通りだ。\namountプロパティとtraumaプロパティをゲージで表示 キーボード操作で上下左右に移動できるキャラクターを追加 D キー: 右 A キー: 左 W キー: 上 S キー: 下 キャラクターが踏んだら画面揺れが発生する複数のスパイクを地面に追加 traumaに追加する値を上矢印キーで 0.1 増加、下矢印キーで 0.1 減少（最大 1.0、最小 0.0） 「ROUGH」と「SMOOTH」の揺れの種類を左上に表示 左右矢印キーで「ROUGH」と「SMOOTH」の揺れの種類を切り替え スペースキーでも画面揺れを発生 おわりに 今回は2Dでの画面揺れの実装について紹介した。ゲームのジャンルや場面は選ぶが、画面揺れを適用できる機会はきっと多いだろう。また、画面揺れを構成するパラメータをどう変化させれば揺れがどう変わるのかを理解すれば、利用目的に最適な画面揺れを表現することができるはずだ。\n参考 KENNEY - Assets Godot demo projects - OpenSimplexNoise KidsCanCode: SCREEN SHAKE YouTube: Math for Game Programmers: Juicing Your Cameras With Math YouTube: Godot Game Juice Tutorial 1: Camera Shake and Frame Freeze Coding Kaiju - Screen Shake in Godot: The Best Way UPDATE:\n2022/08/01 タイポ修正\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0014_screen_shake/","summary":"今回の記事では、2Dゲームでの画面揺れの実装方法を紹介する。ゲームに絶対に必要な要素ではないが、うまく使えばプレイヤーのゲーム体験をよりインタラクティブにでき、ユーザエクスペリエンスに直接影響を与える","title":"Godot3 で作る画面揺れ"},{"content":"今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。\nこれはモバイルゲームで人気を博した「パズル\u0026amp;ドラゴンズ（Puzzle \u0026amp; Dragons）/ 通称パズドラ」のようなパズルをイメージしていただくとわかりやすいだろう。\nただし、チュートリアルに味方のデッキやガチャ、敵キャラクターとのバトルなど全てのゲーム要素を盛り込むとボリュームが大きすぎるので、今回はパズル部分にフォーカスして手順を説明させていただく。\nなお「キャンディークラッシュ」のようなオーソドックスなマッチ3（スリー）パズルゲームや「LINEツムツム」のような指でピースをなぞって繋げて消すタイプのパズルゲームの作り方については、以下のチュートリアルを参照いただきたい。\nOther Tutorials 「キャンディークラッシュ」のようなゲームを作ってみたい場合：\nGodot で作るマッチ 3 パズルゲーム 「LINE：ディズニーツムツム」のようなゲームを作って見たい場合：\nGodot で作る同じ色をつなげて消すパズルゲーム このチュートリアルで最後にできあがるプロジェクトのファイルはGitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.4\n・コンピュータのOS: macOS 11.6.5\nMemo: ゲームを作り始めるのに以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 新規プロジェクトを作成する それでは Godot Engine を立ち上げて、新規プロジェクトを作成しよう。プロジェクトの名前はあなたのお好みで決めていただいてOKだ。もし思いつかなければ「Advanced Match3 Start」としておこう。\nプロジェクト設定を更新する エディタが表示されたら、先にプロジェクト全体に関わる設定を更新しておこう。\nまずはゲームのディスプレイサイズを設定する。今回はスマホの縦向きの画面を想定して、縦横の比率を 16 : 9 とする。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。 「Size」セクションで以下の項目の値を変更する。 Width: 630 Height: 1120 Test Width: 315 Test Height: 560\n「Stretch」セクションで以下の項目の値を変更する。 Mode: 2d Aspect: keep\nそのまま「プロジェクト設定」ウインドウを開いた状態で、デバッグパネルでスマホのタッチ操作をマウスで代用するための設定をする。\n「一般」タブで「mouse」と検索し、サイドバーの「Input Devices」＞「Pointing」を選択する。 「Emulate Touch From Mouse」の On のチェックを入れる。\nさらに「プロジェクト設定」ウインドウを開いた状態で、インプットマップにスマホのタッチ操作の相当するアクションを追加しよう。\n「インプットマップ」タブに切り替え、アクションに「touch」を追加する。 「touch」の操作にマウスの左クリックを追加する。\nアセットをダウンロードしてインポートする 次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは「Physics Assets 」というアセットパックだ。このアセットに含まれるなんともかわいいエイリアンの顔の画像を、ゲームの盤面に並べるピースのテクスチャとして使用する。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「/physicspack/PNG/Aliens」フォルダの中のファイル名が「~_round.png」の画像だけを残して他は削除し、「Aliens」フォルダごとエディタのファイルシステムドックへドラッグしてプロジェクトにインポートしよう。\nGrid シーンを作る まずはマッチ3パズルゲームでピースが配置される盤面として、「Grid」シーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Area2D」クラスのルートノードが生成されたら、その名前を「Grid」に変更する。 シーンを保存する。フォルダを作成して、ファイルパスを「res://Grid/Grid.tscn」としてシーンを保存する。\nGrid シーンにノードを追加する 「Grid」ルートノードに、さらにノードを追加していこう。\n「Grid」ルートノードに「CollisionShape2D」ノードを追加する。 「Grid」ルートノードに「Node2D」ノードを追加し、名前を「PiecesContainer」に変更する。 「Grid」ルートノードに「Timer」ノードを２つ追加し、それぞれ名前を「TouchTimer」、「WaitTimer」に変更する。 ひとまず現時点でのシーンツリーは以下のようになったはずだ。\n続けて追加したノードを編集していこう。\nGrid シーンのノードを編集する Grid (Area2D) ルートノード このパズドラ風のパズルでは、盤面上でピースを自由に動かせるわけだが、盤面から動かしているピースがはみ出してはいけない。そうしないと、盤面の外側を移動させて離れたピースと入れ替えることができてしまう。このパズルゲームは、あくまで動かしているピースと隣り合ったドロップが次々に交換されていく仕様なのだ。\nルートノードを Area2D クラスにしたのは、そのシグナルを使って盤面から指（動かしているピース）がはみ出したことを検知させるためだ。検知さえできれば、あとはスクリプトで制限できる。このシーンへのスクリプトのアタッチは最後に行うので、その時にあらためてシグナルの接続を行うことにしよう。\nこのノードそのもののプロパティ編集は不要だ。\nCollisionShape2D ノード このノードは、盤面の外に指（動かしているピース）がはみ出した時にそれを検知するために利用する。インスペクターで以下の通りに各プロパティを編集しよう。\nShape: 新規 RectangleShape2D リソースを適用する。 RectangleShape2D \u0026gt; Extents: (x: 225, y: 190)\nTransform \u0026gt; Position: (x: 315, y: 840)\n2D ワークスペース上では以下のようになったはずだ。\nPiecesContainer (Node2D) ノード このノードは盤面に配置されるピースをまとめるためのノードだ。ゲーム中、スクリプトでピースのインスタンスが生成されたら全てこの「PiecesContainer」ノードの子として追加することになる。そうすることで、ピースのインスタンスがどれだけ生成されても、シーンツリー上のノードの順序を維持することができる。\n特に編集が必要なプロパティはないので次へ行こう。\nTouchTimer ノード この Timer クラスのノードは、指でピースを動かし始めてからカウントダウンを始め、タイムアウトしたら、動かしていたピースが指から自動的に離れるようにするためのものだ。これにより、制限時間内でピースを並べなければならないというある種の緊張感をプレイヤーに与えることができる。今回は 5 秒間ピースを移動できる設定にする。\nインスペクターで以下のように編集しよう。\nWait Time: 5 One Shot: オン\nWaitTimer ノード こちらの Timer クラスのノードは、指からピースが離れた後の、ピースのマッチング処理、マッチしたピースの削除、削除されて空いたグリッドへピースを詰めて、不足している分を追加する、という一連の流れを自動処理する際に、それぞれの処理の間に一瞬だけ間をあけるためのノードだ。\nインスペクターで以下のように編集しよう。\nWait Time: 0.3 One Shot: オン\n以上で、「Grid」シーンの編集は完了だ。\nPiece シーンを作る 次に、盤面に並べるピースとして「Piece」シーンを作成する。ただし、この「Piece」シーンはあくまで雛形で、実際にゲーム中で利用する各色のピースは、この「Piece」シーンを継承する形でのちほど用意する。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のシーン」を選択する。 「Area2D」クラスのルートノードが生成されたら、その名前を「Piece」に変更する。 シーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Pieces/Piece.tscn」としてシーンを保存する。\nPiece シーンにノードを追加する 続けて、「Piece」シーンに必要なノードを追加していこう。\n「Piece」ルートノードに「Sprite」ノードを追加する。 「Piece」ルートノードに「CollisionShape2D」ノードを追加する。 「Piece」ルートノードに「Tween」ノードを追加する。\nPiece シーンのシーンツリーは以下のようになったはずだ。\nPiece シーンのノードを編集する Piece (Area2D) ルートノード ルートノードを Area2D クラスにしたのは、動かしたいピースに指が当たった時や離れた時、ピース同士が衝突した時に、それを検知できるようにするためだ。\nこのノードのプロパティは編集不要だが、１つだけグループへの追加が必要だ。シーンドックで「Piece」ルートノードを選択したら、ノードドック＞グループタブを選択して、「Pieces」という名前のグループを作成して追加しよう。\n「Grid」シーンの方で「Grid」ルートノードには盤面からのはみ出し検知用のコリジョン形状が設定されており、これは常に全ピースと接触しているので、ピース同士との衝突を区別するために必要なグループなのだ。\nSprite ノード 先述の通り、「Piece」はあくまで継承元（雛形）なので、このシーンでは「Sprite」ノードの「Texture」プロパティにはリソースを敢えて適用せずそのままにしておく。継承先のシーンでそれぞれのピースの色にあった画像を適用する予定だ。\nこのシーンを継承する各色のピースのシーンでは「Texture」プロパティに先にインポートした KENNEY の画像を適用するが、その画像の縦横のサイズが 70 px なので、その画像の中心を右上にずらして画像の左下の角が(x: 0, y: 0)に合うように「Offset」プロパティを設定しよう。\nOffset:\nOffset: (x: 35, y: -35)\nピースを配置する盤面のグリッドは x 軸は左から右へ、y 軸は下から上へカウントする仕様で、かつ盤面の 1 グリッドのサイズもテクスチャのサイズに合わせて 70 px とする。ピースのテクスチャ画像の左下の角を (x: 0, y: 0) に合わせれば、「Piece」ルートノードの位置 (x: 0, y: 0) をグリッドに合わせて配置したときに、ちょうど「Sprite」の画像がグリッドに沿って配置されるというわけだ。\nCollisionShape2D ノード このノードはルートノードにコリジョン形状を付与する役目だ。ピースに指を触れたり、指を離したり、隣のピースと衝突したりするのを検知させるのに必要なノードである。コリジョン形状を縦横 70 px の Sprite の Texture にピッタリ合わせてしまうと、少しピースを動かしただけで、隣のピースとの衝突を検知してしまう。かといって、コリジョン形状が小さすぎると、指でピースに触れているつもりなのに検知されなかったり、ピースを移動させるときに、ピース同士の衝突をうまく検知できずにピースとピースの間を通り抜けてしまったりする。そこでコリジョン形状は Sprite の Texture の半分のサイズにするとちょうど良い。位置も Sprite の Texture にきれいに重なるように調整しよう。\nShape: 新規 CircleShape2D リソースを適用する CircleShape2D: Radius: 17.5\nTransform: Position: x: 35, y: -35\n2D ワークスペース上では以下のようになったはずだ。\nTween ノード このノードは、指定したノードの単一のプロパティのみをアニメーションさせることができる。今回このノードを使用するのは、ピースの位置が交換される時や、マッチして消えたピースの位置にピースを詰める時のピースの移動をアニメーションさせるためだ。\nただし、アニメーションはスクリプトで実装するので、このタイミングでのプロパティの編集は不要だ。\nPiece ノードにスクリプトをアタッチして編集する 「Piece」ルートノードに新規スクリプトをアタッチしよう。ファイルパスを「res://Pieces/Piece.gd」としてスクリプトファイルを作成する。\nひとまずスクリプトを以下のように編集してほしい。\n###Piece.gd### extends Area2D # プレイヤーが動かしているピースに衝突したら発信するシグナル（引数にピース自身を渡す） signal collided(self_piece) # ピースの色を設定するプロパティ export (String) var color # マッチした場合のフラグとなるプロパティ var matched = false # マッチしたピースのグループに割り振られるインデックス var matched_index = 0 # プレイヤーが動かしている場合のフラグとなるプロパティ var held = false # ピースのテクスチャと同じオフセット var offset = Vector2(35, -35) # Spriteノードへの参照 onready var sprite = $Sprite # Tweenノードへの参照 onready var tween = $Tween # メインループで毎フレーム呼ばれる組み込みメソッド func _process(_delta): # もしプレイヤーがピースを移動中だったら if held: # ピースの位置を(35, -35)ずらしてマウスに追随させる position = get_global_mouse_position() - offset # ピースを移動させるメソッド func move(destination): # Tweenノードのアニメーションを設定する # ピースを0.1秒かけて現在の位置から引数destinationの位置まで移動させる tween.interpolate_property(self, \u0026#34;position\u0026#34;, position, destination, .1, Tween.TRANS_QUINT, Tween.EASE_IN) # Tweenノードのアニメーションを開始する tween.start() # ピースがマッチした時に呼ばれるメソッド func make_matched(index): # マッチのフラグを立てる matched = true # マッチしたグループごとのインデックス（引数index）を割り当てる matched_index = index # ピースの色を半透明にする modulate = Color(1,1,1,.5) # プレイヤーの指がピースに触れたら呼ばれるメソッド func enable_held(): # プレイヤーが動かしているフラグを立てる held = true # ピースの色を20％透明にする modulate = Color(1, 1, 1, 0.8) # プレイヤーが指をピースから離したら呼ばれるメソッド func disable_held(): # プレイヤーが動かしているフラグを解除する held = false # ピースの色をデフォルトに戻す modulate = Color(1, 1, 1, 1) 続けて、ピースに別のピースが当たった時に発信されるシグナルを利用する。シーンドックで「Piece」ルートノードを選択したらノードドック＞シグナルタブでarea_entered(area: Area2D)を、現在編集中の「Piece.gd」スクリプトに接続しよう。\nプレイヤーが動かしているピースが当たったらシグナルcollided(self_piece)を発信させたいので、自動生成されたメソッド_on_Piece_area_entered(area)内にそのためのコードを記述しよう。\n###Piece.gd### # Area2Dが当たったらシグナルが発信されて呼ばれるメソッド func _on_Piece_area_entered(area): # もし当たったArea2Dが「Pieces」グループ（つまりPieceのインスタンス）で... # かつ、プレイヤーが動かしているピースだったら if area.is_in_group(\u0026#34;Pieces\u0026#34;) and area.held: # 引数に自分自身のピースを渡してシグナル collided を発信する emit_signal(\u0026#34;collided\u0026#34;, self) これで「Piece.gd」スクリプトの編集は完了だ。\nPiece シーンを継承した各色のシーンを作る 雛形となる「Piece」シーンは完成したので、それを継承したシーンをピースの色の数だけ作成していこう。ピースの色は、ベージュ、青、緑、ピンク、黄の 5 色だ。まずは「ベージュ」のドロップを例に手順を進めてみよう。\n「シーン」メニュー＞「新しい継承シーン」を選択する。 継承元のシーンとして「Piece.tscn」を選択する。 継承シーンが生成されたら、ルートノードの名前を「PieceBeige」に変更する。\n*このルートノードの名前はそれぞれのドロップの色に合わせること。 シーンを一旦保存しておく。ファイルパスを「res://Pieces/PieceBeige.tscn」として保存する。 シーンドックでルートノード「PieceBeige」を選択した状態で、インスペクターで「Script Variables」の「Color」プロパティの値を「beige」とする。\nシーンドックで「Sprite」ノードを選択し、「Texture」プロパティに先にインポートしておいたリソース「res://Aliens/alienBeige_round.png」を適用する（ファイルシステムドックからドラッグすればOK）。\n2D ワークスペース上では以下のスクリーンショットのようになったはずだ。\n以上で、「PieceBeige」シーンは完成だ。残りの 4 色のピースについても、同様の手順でシーンを作成してほしい。なお、シーンごとに異なる部分については、以下を参考にしてほしい。 青のピース ルートノード名: PieceBlue Color プロパティ: blue Sprite \u0026gt; Texture プロパティ: res://Aliens/alienBlue_round.png シーン保存時のファイルパス: res://Pieces/PieceBlue.tscn 緑のピース ルートノード名: PieceGreen Color プロパティ: green Sprite \u0026gt; Texture プロパティ: res://Aliens/alienGreen_round.png シーン保存時のファイルパス: res://Pieces/PieceGreen.tscn ピンクのピース ルートノード名: PiecePink Color プロパティ: green Sprite \u0026gt; Texture プロパティ: res://Aliens/alienPink_round.png シーン保存時のファイルパス: res://Pieces/PiecePink.tscn 黄のピース ルートノード名: PieceYellow Color プロパティ: yellow Sprite \u0026gt; Texture プロパティ: res://Aliens/alienYellow_round.png シーン保存時のファイルパス: res://Pieces/PieceYellow.tscn 全部で 5 色のピースの継承シーンができたら作業完了だ。\nGrid シーンをスクリプトで制御する ここからはスクリプトをコーディングしてゲームを制御していく。コード量がやや多めなので頑張ろう。\nGodot エディタで「Grid.tscn」シーンに切り替えたら、「Grid」ルートノードに新規スクリプトをアタッチしよう。ファイルパスは「res://Grid/Grid.gd」として作成する。\nなお、スクリプト内のコメントには「指が触れた」または「指が離れた」と記載しているが、Godot デバッグパネル上では「マウス左ボタンを押した」または「マウス左ボタンを離した」と置き換えてほしい。\nまた、同じ色が３つ以上揃った状態のことを「マッチ」と表現しているので、こちらもご留意いただきたい。\nでは、スクリプトエディタが開いたら、まずは必要なプロパティを定義しておこう。\n###Grid.gd### extends Area2D # ピースを動かして指を離した後の自動処理開始時に発信するシグナル signal waiting_started # 各色のピースのシーンファイルを要素とした配列 const pieces_scn = [ preload(\u0026#34;res://Pieces/PieceBeige.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceBlue.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceGreen.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PiecePink.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceYellow.tscn\u0026#34;) ] # x軸方向のグリッド数 var width: = 7 # y軸方向のグリッド数 var height: = 6 # x軸方向のグリッド開始位置（pixel） var x_start: = 70 # y軸方向のグリッド開始位置（pixel） var y_start: = 1050 # 1グリッドのサイズ（PieceのSpriteのTextureと同じにする） var grid_size: = 70 # ピースが生成される時に何グリッドy軸方向にズラして落とすか var y_offset: = 3 # 盤面のピースの配置を表す配列（二次元配列） var board = [] # プレイヤーが動かしているピースの参照 var moving_piece # プレイヤーが動かしているピースの最後の位置（グリッド） var last_pos = Vector2() # ゲーム開始時の準備中のフラグ var is_initializing = true # プレイヤーがピースを動かしている場合のフラグ var is_touching = false # ピース入れ替え中のフラグ var is_swapping = false # プレイヤーがピースを動かした後の自動処理中のフラグ var is_waiting = false # マッチしたピースのグループの数（カウントアップする） var matched_groups = 0 # PiecesContainerノードの参照 onready var pieces_container = $PiecesContainer # TouchTimerノードの参照 onready var touch_timer = $TouchTimer # WaitTimerノードの参照 onready var wait_timer = $WaitTimer 続いてここからはメソッドを追加していく。なお、以下のコード内に出てくる 二次元配列 とは、要素として配列を格納する配列、つまり配列の配列のことだ。\n今回のスクリプトで利用している二次元配列の場合、一階層目の配列では、盤面の x 軸方向のグリッドの数だけ空の配列を要素とし、二階層目としてそれぞれの配列内に縦方向のグリッド数だけ要素を格納する。その要素として、ピースオブジェクトを格納することで、それぞれのピースが盤面のどこに位置しているか（x 軸方向に何番目のグリッドで、y 軸方向に何番目のグリッドか）を管理することができるのだ。\n###Grid.gd### # シーンが読み込まれたら呼ばれる関数 func _ready(): # ランダムな数を生成する関数の出力結果を毎回ランダムにするための組み込み関数を呼ぶ randomize() # board（配列）を盤面のグリッドを構成する二次元配列にする board = make_2d_array() # このあと定義 # ピースを生成して盤面に配置して盤面情報を board に反映する spawn_pieces() # このあと定義 is_initializing = false # 盤面のグリッドを構成する二次元配列を生成するメソッド func make_2d_array() -\u0026gt; Array: # array という名前の配列を用意 var array = [] # array に x 軸方向のグリッド数だけ空の配列を入れる for i in width: array.append([]) # さらにそれぞれの配列に y 軸方向のグリッド数だけ暫定的に null を入れる for j in height: array[i].append(null) # できあがった二次元配列を返す return array # ピースを生成して盤面に配置して盤面情報を board に反映するメソッド func spawn_pieces(): # x軸方向のグリッド数だけループ for i in width: # y軸方向のグリッド数だけループ for j in height: # 全ピースの二次元配列上で該当グリッドにピースが存在しない場合 #（ゲーム開始時は全部 null） if board[i][j] == null: # 各色のピースのシーンからランダムで１つ選択してインスタンス化 var index = floor(rand_range(0, pieces_scn.size())) var piece = pieces_scn[index].instance() # もしゲーム開始時の準備中だったら if is_initializing: # マッチしてしまった場合は、ピースのインスタンスを削除してやり直し while match_at(i, j, piece.color): # このあと定義 piece.queue_free() index = floor(rand_range(0, pieces_scn.size())) piece = pieces_scn[index].instance() # ピースのインスタンスをPiecesContainerノードの子にする pieces_container.add_child(piece) # ピースのインスタンスの collided シグナルを... # _on_Piece_collided メソッド（あとで定義）に接続する piece.connect(\u0026#34;collided\u0026#34;, self, \u0026#34;_on_Piece_collided\u0026#34;) # ピースのインスタンスを配置位置より y_offset 分ずらして置き... # そこから配置位置へ移動させる（落とす） piece.position = grid_to_pixel(i, j + y_offset) # このあと定義 piece.move(grid_to_pixel(i, j)) # このあと定義 # 盤面情報として board の適切なインデックスの要素に生成したピースを追加 board[i][j] = piece 上記コードの中で未定義のmatch_atメソッドとgrid_to_pixelメソッドを定義しておこう。\n###Grid.gd### # 指定したグリッド位置で同じ色ピースが３つ以上並んでいるか確認するメソッド # 引数columnはx軸のグリッド位置、rowはy軸のグリッド位置、colorはピースの色 func match_at(column, row, color): # 指定したグリッドの x 軸方向の位置が3以上の場合 if column \u0026gt;= 2: # 指定したグリッド位置の左隣ともう一つ左隣にピースがある場合 if board[column-1][row] != null \\ and board[column-2][row] != null: # 左隣ともう一つ左隣のピースの色が指定したピースの色と同じ場合 if board[column-1][row].color == color \\ and board[column-2][row].color == color: # true を返す return true # 指定したグリッドの y 軸方向の位置が3以上の場合 if row \u0026gt;= 2: # 指定したグリッド位置の下ともう一つ下にピースがある場合 if board[column][row-1] != null \\ and board[column][row-2] != null: # 下ともう一つ下のピースの色が指定したピースの色と同じ場合 if board[column][row-1].color == color \\ and board[column][row-2].color == color: # true を返す return true # グリッドの位置をピクセルの位置に変換するメソッド func grid_to_pixel(column, row) -\u0026gt; Vector2: # 先にピクセル位置出力用に Vector2 型の変数 pixel_pos を定義 var pixel_pos = Vector2() # ピクセル x 座標 = x 軸方向のグリッド開始位置 + グリッドサイズ x グリッド x 座標 pixel_pos.x = x_start + grid_size * column # ピクセル y 座標 = y 軸方向のグリッド開始位置 - グリッドサイズ x グリッド y 座標 pixel_pos.y = y_start - grid_size * row # ピクセル座標を返す return pixel_pos これで、ゲーム開始時に各色のピースが盤面にランダムで並べられるはずだ。一度プロジェクトを実行して確認してみよう。なお、初めてプロジェクトを実行する場合は、メインシーン選択のダイアログが表示されるので、「Grid.tscn」をメインシーンとして選択しよう。\nちょうどgrid_to_pixelメソッドを定義したので、ついでにこのあと使用するpixel_to_gridメソッドも定義しておこう。名前の通り、先に定義したgrid_to_pixelとは逆で、ピクセルの位置をグリッドの位置に変換するメソッドだ。\n###Grid.gd### # ピクセルの位置をグリッドの位置に変換するメソッド func pixel_to_grid(pixel_x, pixel_y) -\u0026gt; Vector2: var grid_pos = Vector2() grid_pos.x = floor((pixel_x - x_start) / grid_size) grid_pos.y = floor((pixel_y - y_start) / -grid_size) return grid_pos さらに、もう一つこのあと使用するis_in_gridメソッドを定義しておく。これは引数に渡した位置が盤面グリッドの範囲内かどうかを判定してその結果を返すメソッドだ。\n###Grid.gd### # 指定した位置が盤面グリッドの範囲内かどうかを返すメソッド func is_in_grid(grid_position: Vector2) -\u0026gt; bool: if grid_position.x \u0026gt;= 0 and grid_position.x \u0026lt; width \\ and grid_position.y \u0026gt;= 0 and grid_position.y \u0026lt; height: # 盤面グリッドの範囲内だったら true を返す return true else: # 盤面グリッドの範囲外だったら false を返す return false ここで、ゲームのプレイヤーの入力（画面のタッチ操作）を処理するプログラムを記述していく。\n###Grid.gd### # ゲームのメインループで毎フレーム呼ばれる関数 func _process(_delta): # もしマッチングの処理中でなければ if not is_waiting: # プレイヤーの入力を処理する touch_input() # このあと定義 # プレイヤーの入力を処理するメソッド func touch_input(): # もし画面に指が触れたら if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # ピースに触れた時の処理を実行するメソッドを呼ぶ touch_piece() # このあと定義 # もし画面から指が離れたら if Input.is_action_just_released(\u0026#34;touch\u0026#34;) and is_touching: # ピースから指が離れた時の処理を実行するメソッドを呼ぶ release_piece() # このあと定義 # ピースに触れた時の処理を実行するメソッド func touch_piece(): # 指が触れた時のピクセル座標を取得する var pos = get_global_mouse_position() # ピクセル座標からグリッド座標に変換する var grid_pos = pixel_to_grid(pos.x, pos.y) # もしグリッド座標が盤面の範囲内だったら if is_in_grid(grid_pos): # 動かしているピースの最後の位置としてグリッド座標を登録 last_pos = grid_pos # 動かしているピースとしてグリッド座標に位置するピースを登録 moving_piece = board[last_pos.x][last_pos.y] # ピースを動かしているフラグを立てる is_touching = true # 動かしているピースインスタンス自体の動かしているフラグも立てる moving_piece.enable_held() # ピースを動かせる制限時間のタイマースタート touch_timer.start() # ピースから指が離れた時の処理を実行するメソッド func release_piece(): # 二次元配列 board の要素から動かしていたピースを見つけたら... # 動かしていたピースを盤面グリッドにきっちり収める for i in width: for j in height: if board[i][j] == moving_piece: moving_piece.move(grid_to_pixel(i, j)) break # 動かしていたピースインスタンス自体の動かしているフラグを解除する moving_piece.disable_held() # ピースを動かしているフラグを解除する is_touching = false # ピースを動かせる制限時間のタイマーストップ touch_timer.stop() # このあとのマッチング自動処理開始のシグナルを発信 emit_signal(\u0026#34;waiting_started\u0026#34;) まだピースの交換は実装していないが、ここまでのコーディングで、指で触ったピースを移動させ、指を離したら移動しているピースが最後にいた場所にきっちり収まる動きが実装できたはずだ。一度プロジェクトを実行して確認してみよう。\n次に定義する_on_Piece_collidedメソッドには、すでに Piece インスタンス生成時にcollidedシグナルを接続するようコーディング済みだ。このシグナルはピースにプレイヤーが動かしているピースが当たった時に発信されるように「Piece.gd」スクリプトの方でコーディングしたことを思い出してほしい。\n動かしているピースとそれに当たったピースの場所を入れ替えるメソッドを定義して、_on_Piece_collidedの中で呼び出してみよう。\n###Grid.gd### # Piece インスタンスの collided シグナルで呼ばれるメソッド func _on_Piece_collided(self_piece): # ピースを動かしていて、かつピース交換中でなければ if is_touching and not is_swapping: # ピース交換中のフラグを立てる is_swapping = true # ピースを交換するメソッドを呼ぶ swap_pieces(self_piece) # あとで定義 # ピース交換中のフラグを解除 is_swapping = false # 動かしているピースとそれに当たったピースの場所を入れ替えるメソッド # 引数 collided_piece には動かしているピースに当たったピースが渡される func swap_pieces(collided_piece): # 当たったピースのグリッド座標を取得する。 var collided_pos = pixel_to_grid(collided_piece.position.x, collided_piece.position.y) # 二次元配列 board 上の動かしているピースと動かしているピースが一致していれば if board[last_pos.x][last_pos.y] == moving_piece: # board の動かしているピースの位置に当たったピースを入れる board[last_pos.x][last_pos.y] = collided_piece # 当たったピースを動かしているピースの最後のグリッド座標へ移動させる collided_piece.move(grid_to_pixel(last_pos.x, last_pos.y)) # board の当たったピースの位置に動かしているピースを入れる board[collided_pos.x][collided_pos.y] = moving_piece # 動かしているピースの最後の位置として当たったピースのグリッド座標を登録する last_pos = collided_pos これでピースの交換も実装できたはずだ。では実際にプロジェクトを実行してピースを動かしてみよう。通ったルートのピースが次々と交換される動作を確認しよう。\nさて、この時点で問題になるのは以下の2点だ。\n盤面の外側を自由に移動できてしまうこと いつまでもピースをつかんでいられること これらの問題はシグナルを使って解決することができる。\nArea2D クラスである「Grid」ルートノードのシグナルをスクリプトに接続しよう。コリジョン形状を盤面のサイズに調整したことを覚えているだろうか。その範囲から指（動かしているピース）が外にはみ出た場合に発信するシグナルによってrelease_pieceメソッドを呼び出して、動かしていたピースが指からも離れて盤面上の最後の位置に戻るようにする。\nシーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブを選択し、erea_exitedシグナルをこのスクリプトに接続する。\nもう一つ、「TouchTimer」ノードのピースを動かせる制限時間がタイムアウトした時に発信されるシグナルもスクリプトに接続する。この場合も同様に、シグナルによってにrelease_pieceメソッドを呼び出すようにする。timeoutシグナルを接続しよう。\n続けて、それぞれのシグナルの接続によって生成されたメソッドを以下のように編集してほしい。\n###Grid.gd### # 盤面から Area2D がはみ出たときにシグナルで呼ばれるメソッド func _on_Grid_area_exited(area): # はみ出た Area2D が動かしているピースの場合 if area.is_in_group(\u0026#34;Pieces\u0026#34;) and area.held: # ピースから指が離れた時の処理を実行するメソッドを呼ぶ release_piece() # ピースを動かせる制限時間が切れたときにシグナルで呼ばれるメソッド func _on_TouchTimer_timeout(): # 移動中の場合 if is_touching: # ピースから指が離れた時の処理を実行するメソッドを呼ぶ release_piece() これで盤面からはみ出したら、ピースが指から離れて盤面上の最後の位置に戻るようになったはずだ。また、5秒以上ピースをつかんでいた場合も、タイマーにより、指からピースが離れて盤面上の最後のグリッド座標に収まるようになったはずだ。\nそれでは実際にプロジェクトを実行して動作を確認してみよう。\nここからはマッチしたピースを自動的に処理するプログラムを作っていく。release_pieceメソッドの最後にemit_signal(\u0026quot;waiting_started\u0026quot;)というコードでwaiting_startedシグナルを発信するようにしていたのだが、このシグナルをスクリプトに接続するところから始める。\nシーンドックで「Grid」ルートノードを選択し、ノードドック＞シグナルタブでwaiting_startedシグナルをスクリプトに接続しよう。_on_Grid_waiting_startedメソッドがスクリプトに追加されたら、そのメソッド内にマッチしたピースの自動処理を記述していく。大まかに自動処理は以下の流れになる。\n自動処理中のフラグを立てる マッチしたピースが1組でもあるかチェックする。1組でもある場合は以下の処理をループする。 全てのピースをチェックしてマッチしたピースにフラグを立てる。 フラグの立っているピースを削除する。 削除して空になったスペースへ同じ列の上のグリッドからピースを移動させて詰める。 ピースを下へ詰めたら、最後に空のスペースに新しいピースを生成する。 マッチしたピースが1組もなくなったら自動処理中のフラグを解除する。\n上記の流れを段階的に実装していこう。まずは「全てのピースをチェックしてマッチしたピースにフラグを立てる」ところまで進めてみよう。\n###Grid.gd### # releaseメソッドの最後に発信されるシグナルで呼ばれるメソッド func _on_Grid_waiting_started(): # 自動処理中のフラグを立てる is_waiting = true # 人組でマッチしているピースが1組でもあればループし続ける while check_matches(): # このあと定義 # マッチしているピースにフラグを立てるメソッドを呼ぶ find_matches() # このあと定義 # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \u0026#34;timeout\u0026#34;) # 自動処理中のフラグを解除する is_waiting = false # マッチしているピースが1組でもあるかチェックするメソッド func check_matches() -\u0026gt; bool: # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # そのグリッド座標にピースが存在していれば if board[i][j] != null: # そのピースがマッチしていたら if match_at(i, j, board[i][j].color): # true を返す return true # 1組もマッチしているピースがなければ false を返す return false # マッチしているピースにフラグを立てるメソッド func find_matches(): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # そのグリッド座標にピースが存在していれば if board[i][j] != null: # 現在の色をそのグリッド座標のピースの色と定義する var current_color = board[i][j].color # もしその x 軸座標が x 軸方向のグリッド数 - 2 より小さければ if i \u0026lt; width - 2: # そのピースの右隣とさらにその右隣にピースが存在する場合 if board[i+1][j] != null \\ and board[i+2][j] != null: # それらのピースの色が現在の色と同じ場合 if board[i+1][j].color == current_color \\ and board[i+2][j].color == current_color: # マッチした組に割り振る番号の変数を定義 var matched_index: int # そのピースにすでにマッチしているフラグが立っていれば if board[i][j].matched: # マッチした組の番号はそのピースの組の番号とする matched_index = board[i][j].matched_index # そのピースにマッチしているフラグが立ってなければ else: # マッチした組のグループ数を1増やす matched_groups += 1 # マッチした組の番号をマッチした組のグループ数とする matched_index = matched_groups # その座標のピースにマッチしたフラグを立て、組の番号を割り当て、半透明にする board[i][j].make_matched(matched_index) # その座標の右隣のピースも同様にする board[i+1][j].make_matched(matched_index) # さらにもう一つ右隣のピースも同様にする board[i+2][j].make_matched(matched_index) # y軸方向に対しても同様にする if j \u0026lt; height - 2: if board[i][j+1] != null \\ and board[i][j+2] != null: if board[i][j+1].color == current_color \\ and board[i][j+2].color == current_color: var matched_index: int if board[i][j].matched: matched_index = board[i][j].matched_index else: matched_groups += 1 matched_index = matched_groups board[i][j].make_matched(matched_index) board[i][j+1].make_matched(matched_index) board[i][j+2].make_matched(matched_index) マッチしたピースの処理のうち、マッチしているピースにフラグを立てるところまで実装した。プロジェクトを実行して、マッチしたピースが半透明になるか確認してみよう。 次はマッチ状態のフラグが立っているピースを削除するメソッドを定義する。\n###Grid.gd### # マッチのフラグが立っているピースを削除するメソッド # 引数 index には削除対象のマッチの組番号を渡す func delete_matches(index): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # もしそのグリッド座標にピースが存在していれば if board[i][j] != null: # もしそのグリッド座標のピースにマッチのフラグが立っていたら if board[i][j].matched: # もしそのグリッド座標のピースの組番号は削除対象の組番号と一致したら if board[i][j].matched_index == index: # そのグリッド座標のピースを解放する board[i][j].queue_free() # 二次元配列 board の該当の要素を null にする board[i][j] = null delete_matchesメソッドが定義できたので、これを_on_Grid_waiting_startedメソッドのループの中に入れよう。\n###Grid.gd### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) # ここを追加 # マッチしたグループの数が0より大きければ if matched_groups \u0026gt; 0: # マッチしたグループの数だけループさせる # 全て同時に削除せず、マッチした組ごとに削除する for index in range(1, matched_groups + 1): # マッチしたピースを削除するメソッドを呼ぶ delete_matches(index) # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \u0026#34;timeout\u0026#34;) # マッチしたピースをすべて削除したらマッチしたグループの数を 0 に戻す matched_groups = 0 is_waiting = false これで、マッチしたピースが半透明になったあと、削除されるところまで実装できたはずだ。プロジェクトを実行して確認してみよう。 続いて、ピースが削除されて空いたグリッドスペースに上のピースを詰める（落とす）処理を実装する。まずはメソッドから定義しよう。\n###Grid.gd### # 空いたグリッドスペースに上のピースを詰める（落とす）メソッド func collapse_columns(): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # もしそのグリッド座標にピースがなければ if board[i][j] == null: # その y座標より1つ上のグリッドから残りの y軸方向のグリッド数だけループ for k in range(j + 1, height): # もしそのグリッド座標にピースが存在していれば if board[i][k] != null: # そのグリッド座標のピースを空いたスペースへ移動する board[i][k].move(grid_to_pixel(i, j)) # 二次元配列 board の要素を入れ替える board[i][j] = board[i][k] board[i][k] = null # ループ終了 break collapse_columnsメソッドが定義できたので、これを_on_Grid_waiting_startedメソッドのループの中に追加しよう。\n###Grid.gd### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) if matched_groups \u0026gt; 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) matched_groups = 0 # ここを追加 # 空いたグリッドスペースに上のピースを詰める（落とす）メソッドを呼ぶ collapse_columns() # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \u0026#34;timeout\u0026#34;) is_waiting = false これで、マッチして半透明になったピースが削除されたあと、その空いたスペースには上のピースが詰められる（落とされる）ようになったはずだ。プロジェクトを実行して確認してみよう。\n最後に、ピースを下に詰めた後の上の空いたスペースには新しいピースを補充する必要がある。そのためのメソッドは、_ready関数の中でも実行している、すでに定義済みのspawn_piecesメソッドだ。ゲームのプレイが開始した時点ではis_initializingプロパティはfalseになっているので、このメソッドを実行してピースが生成された時点ですでに新たなマッチが発生するかもしれない。これが期待以上のコンボを発生させ、ゲーム体験をより気持ち良く、楽しいものにしてくれるはずだ。\nspawn_piecesメソッドを_on_Grid_waiting_startedメソッドのループの中に追加しよう。\n###Grid.gd### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) if matched_groups \u0026gt; 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) matched_groups = 0 collapse_columns() wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) # ここを追加 # 空いたスペースにピースを生成するメソッドを呼ぶ spawn_pieces() # WaitTimerのタイマースタート(0.3秒) wait_timer.start() # WaitTimerがタイムアウトするまで待機 yield(wait_timer, \u0026#34;timeout\u0026#34;) is_waiting = false これでマッチ処理のコーディングが完了だ。このチュートリアルとしても作業はここまでとなる。最後にプロジェクトを実行して、このパズルゲームの最終動作確認をして終わりにしよう。\nサンプルゲーム 今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。\nYour browser does not support the video tag. サンプルゲームのプロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。\nゲームのルール:\nプレイヤーがピースを動かせるのは1回につき5秒まで。5秒経過すると指から離れる。 プレイヤーが動かしているピースが盤面からはみ出すと、ピースが指から離れて、移動もそこまでとなる。 マッチしたピースの組の数だけコンボ数が上がる。プレイヤーはコンボの数だけエイリアン（敵キャラクター）を攻撃でき、パワーも上がる。 エイリアンを攻撃するとパワーの分だけHPを減らすことができ、エイリアンのHPを0にすると倒すことができる。 エイリアンは一定の間隔でプレイヤーを攻撃してくる。 プレイヤーのライフは最大10。エイリアンに攻撃されると１つ減り、10回攻撃されるとゲームオーバー。 敵を倒すごとにレベルが1上がる。レベルが上がるとプレイヤーのパワーが少しアップする一方、敵キャラクターもHPが上がり、攻撃してくる間隔も少し短くなる。 マッチしたピースの自動処理中（コンボカウント中と敵への攻撃中）は敵のタイムゲージは一時停止する。 最終的に、倒したエイリアンの数がこのゲームのスコアとなる。 おわりに 今回のチュートリアルでは進化系マッチ3パズルゲームと銘打って、パズドラ風のパズルゲームを作った。オーソドックスなマッチ3とは違い、盤面上で一定時間ピースを自由に動かせるようにしたり、マッチしたピースが消える時も、パズドラのようにマッチした組ごとに順番に消えるようにしたりと、スクリプトのコードはやや複雑になったかもしれないが、最後まで作り切ることができただろうか。\n今回のような進化系マッチ3パズルゲームを作るときのポイントをまとめておこう。\n最低限必要なシーンは盤面とピースの２つだけ。 雛形のピースシーンを作ってから、それを継承して各色のピースシーンを作る。 二次元配列を利用して盤面グリッドに配置するピースを管理する。 Area2Dのシグナルを利用して、以下について検知させる。 指がピースに触れた時 指がピースから離れた時 動かしているピースと静止しているピースが当たった時 動かしているピースが盤面からはみ出した時 フラグ用のプロパティを用意して、状態管理をする。例えば以下。 ピースを動かしているかどうか ピースが入れ替え中かどうか ピースがマッチしているかどうか マッチの自動処理中かどうか ピースを入れ替えるときは、画面上のピースの位置と二次元配列の要素をそれぞれ更新する必要がある。 参照 KidsCanCode: OBJECT HEALTHBARS KidsCanCode: HEART CONTAINERS: 3 WAYS Puzzle＆Dragons（パズル＆ドラゴンズ） ","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/","summary":"今回のチュートリアルでは、進化形マッチ3パズルゲームと銘打って、盤面上で１つのピースを一定時間（数秒間）自由に動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームをを作っていく。 これはモバイ","title":"Godot3 で作る進化形マッチ 3 パズルゲーム"},{"content":"せっかく始めたゲームの個人開発、できれば長く楽しく続けたいものだ。しかし、一般的にゲーム開発は挫折しがちである。まずはその理由について考えてみよう。\n挫折する理由 まず、ゲーム開発は大変だ。総合芸術などと呼ばれることもある。つまり、ゲームというのは、音楽も映像もキャラクターもシナリオもシステムもレベルデザインも、全部合わせて１つの作品として表現するものなのだ。簡単なわけがない。大変なので、まずそれだけで挫折しがちというわけだ。\nしかし実はもう一つ、特に個人開発でゲームを作っている大人たちにはより大きな問題がある。それは、ゲームの個人開発では稼げない、という事実だ。お金にならないならこんな大変な作業はもう辞める、というパターンだ。ゲーム開発は大変でも、売れれば報われるのだ。\n稼げない、というのは少々大雑把な表現かもしれない。なぜなら、世の中には稼いでいる人間が必ず存在するからだ。稼いでいる人がほんのひと握りで、あとは稼げない人が大半という図式なのだ。\nエンターテインメントや芸術の分野は、だいたいそうだ。例えば、音楽、イラスト、小説なんかは、どれも稼ぐのは難しい。長くやっていれば稼げるようになる、というものでもない。それなりの時間をかけることは大前提で、それに加えて、計算高く、大衆が欲しているもの理解し、そこを狙いつつ新鮮さを感じられるものを生み出さなければならない。さらに多くの人に知ってもらうための宣伝も必要不可欠だ。\nゲームも音楽もイラストも小説も、もともとそれらのエンターテインメントを享受することが大好きな人たちが、いつか自分も素晴らしい作品を生み出して人々を感動させたいという思いで、作品を作りを始めることがほとんどではないだろうか。素晴らしい作品の数々に触れ、面白いゲームとは何かを十分に理解したつもりになり、自分にもそのような作品を生み出す力が備わっているような錯覚をするのだ。だから、自分が傑作と思ってリリースしたゲームがさっぱり売れなかったり、そもそもこれは傑作と思えるようなゲームが作れなかったりすると、「こんなはずではなかった」と挫折してしまうのだ。\nこのように人々をゲーム開発に駆り立てるのは、自己顕示欲や承認欲求の類であり、それはまさに衝動なのではないだろうか。\n新しいゲームを作っても作ってもなかなかヒットしないという状況は、自分の作品の良さに世間はなぜ気づかないのか、というやや身勝手な不満と、自分には良い作品を作る才能がないのではないか、という漠然とした不安を増幅させるに違いない。自己顕示欲や承認欲求は満たされないまま、それらの負の感情に耐えきれずに挫折してしまうのではないだろうか。\nきっかけは衝動だって構わないはずで、何かを始めるときはむしろそのような強いインパクトが必要だ。しかし一方で、何かを長く続けるためには、そのような情熱的な感情とは別に、冷静かつ論理的に物事を理解する頭が必要なのだ。\n挫折しないために理解したい３つのこと では上述の負の感情を回避するにはどうすれば良いのか。それには、次の3つのことを理解するだけで良い。\n世間は自分の作品など知らない。 自分には才能がない。 失敗は成功のもとである。\n1. 世間は自分の作品など知らない、という理解 まず「世間は自分の作品など知らない」という当たり前の事実を受け入れることはとても重要だ。例えば、SteamやApp Store、Google Playなどの主要な販売プラットフォームには数えきれない大量のゲームが溢れており、日々、多くの新作ゲームが追加され続けている。その中にはもちろん、大人気ゲームのシリーズものや派生物があったり、人気ゲームメーカーの新作ゲームが並んでいる。そんなレッドオーシャンで何の情報も無しに自分の作品にたどり着いてくれる人などほとんどいない、というのは容易に想像がつくはずだ。\nだから、販売プラットフォーム上に表示するタイトルや説明、スクリーンショットはかなり重要だし、知ってもらうための宣伝活動はもっと重要だ。このあたりの作業は面白くないかもしれないが、しっかり研究して実践すれば、何もしないのに比べて確実に結果に反映される。\nとにかく「世間は自分の作品など知らない」という事実を認めた上で、じゃあどうすれば良いか、を考えて具体的に行動することが成功の鍵なのだ。売れるための行動を何もしていないのに「世間は自分の作品の素晴らしさに気づいてくれない」などと考えてしまうのは、まったくもってナンセンスである。\n2. 自分には才能がない、という理解 次に「自分には才能がない」という理解もまた重要だ。そもそも問題は、本当にあるかどうかわからない「才能」という神様からの授かり物のようなものを信じていることだ。自分に才能があるかないかを他人や他人の作品と比較してジャッジし、その結果に基づいて、続けるのか辞めるのかを決めてしまうのである。才能など誰にも最初から備わっていないのだ。脳や身体の優位性は生まれ持ったものが多少あるかもしれないが、人生の中でその優位性に気づける人がどれだけいるだろうか。遺伝子解析が一般化される時代が来るまでは、そんなものより、自分が好きか嫌いか、やりたいかやりたくないか、の方がよっぽど確かである。\n例えば「才能のあるプロスポーツ選手やプロの音楽家を思い浮かべてください」と言われると、何人か顔が思い浮かぶだろう。では、その人たちが何の努力もせずに結果を出して有名になれたかというと、それは違うはずだ。才能というのは、実は結果論ではないか。飛び抜けた結果を出した人間には才能があると誰しも思ってしまいがちだ。しかしそのような人たちは、結果を出すまでの過程で、技術の向上や知識の習得に誰よりも時間を投下しているはずなのだ。その時間の使い方も、インプットとアウトプットのバランスが取れているはずだ。そして、他者との比較よりも、過去の自分との比較をしてモチベーションを高く保ち、常に向上心を持って工夫してスキルアップに励んでいるはずだ。\n実は、他者ではなく過去の自分との比較をし続けることはとても良いサイクルを生む。特にゲーム開発を始めた最初の頃は、できるようになることも多いので、確実に昨日の自分より今日の自分はスキルアップしている。すると「自分はゲーム開発に向いているんじゃないか」と思えてくる。気分はどんどん楽しくなってくるし、ゲーム開発が好きだと思えてくる。そうなると、もっとできるようになりたいと思う。そしてまた時間を投下して昨日よりできるようになる。このサイクルにより、どんどん時間を投下できるようになる。そうして、半年、一年と経過した時に、いつの間にかゲーム開発スキルがかなり習熟した状態になっているというわけだ。もしかしたら「才能がありますね」と言われる日が来るかもしれない。\nスキルアップすれば必ずゲームが売れるわけではないが、確実に面白いゲームは作れるようになるはずだ。売れるかどうかは運がつきもので、例えば、たまたま知名度のある人が自分のゲームを買ってくれて、それが面白かった時に、ソーシャルメディアで拡散してくれるかもしれない。しかし、ゲームが面白くなければその可能性すらない。\n3. 失敗は成功のもとである、という理解 「失敗は成功のもと」とは使い古された言葉だが、この理解が非常に重要だ。失敗したら、その事実に落ち込みそうになるかもしれない。一生懸命作ったゲームがさっぱり売れなければ、確かにショックだろう。しかし、ここで冷静に事実を見つめてみることが次の成功につながることを忘れてはいけない。\nゲームが売れずに落ち込んでしまうのは、そのゲームが完璧だと思い込んでいたからだ。完璧などあり得ないし、売れなかった理由は絶対にある。その理由を明確にして、次回の作品でクリアすれば良いのだ。例えば、単純に販売開始後、宣伝が不十分だったのであれば、次回はもっと宣伝すれば良い。グラフィックの質が低かったのであれば、グラフィックの質をあげればいい。自分のスキルを上げてもいいし、お金をかけて他の人に作ってもらってもいいだろう。\n何が良くなかったのかは、販売プラットフォームでのレビューを参考にしたり、ソーシャルメディアで作品のエゴサーチをしてみるのが手っ取り早い。意見を真摯に受け止め、次回に活かすのだ。そもそもレビューが全く無いのであれば、それは宣伝が足りなかったという認識で間違いないだろう。\nまとめ 過去の自分とだけ比較し、高いモチベーションを維持していれば、大変な開発作業も楽しみながらゲームを完成までもっていくことができるだろう。完成すれば販売できる。販売してしっかり宣伝すれば、稼げる可能性を上げることができる。一本目のゲームが売れなくても、売れなかった理由をリサーチして次回作に活かそう。このサイクルを続けていれば確実に良いゲームになり、より売れるようになるはずだ。売れれば売れるほど大変な開発作業が報われるので、挫折する可能性は反比例して下がっていくだろう。\nただ、最後に一つ申し添えておきたい。たとえ開発の作業が大変だとしても、たとえゲームが売れなくて稼げなかったとしても、それが楽しくて、しかも他にやりたいことがないのなら、やろう。こんなにクリエイティブで楽しい活動はなかなかないのだから。\n","permalink":"https://www.peanuts-code.com/ja/posts/post0003_how_to_avoid_frustration/","summary":"せっかく始めたゲームの個人開発、できれば長く楽しく続けたいものだ。しかし、一般的にゲーム開発は挫折しがちである。まずはその理由について考えてみよう。 挫折する理由 まず、ゲーム開発は大変だ。総合芸術などと","title":"ゲームの個人開発で挫折しないための方法"},{"content":"今回のチュートリアルではマッチ3パズルゲームを作っていく。マッチ3（スリー）パズルゲームとは、盤面のグリッドに沿って均一に並べられた複数のカラフルなピースのうちの１つを、1マス動かして同じ色のピースを３つ以上並べて消すタイプのパズルゲームの総称だ。うまく動かすと、一回の操作で連続的に複数のピースを消すことができ、なんとも気持ちの良いプレイ感覚を味わうことができる。簡単な操作で気軽に楽しめるため、モバイルゲームで特に人気のあるジャンルだ。\n人気どころをいくつか例に挙げると、キャンディークラッシュ、トゥーンブラスト、ロイヤルマッチなどがそれにあたる。少し操作感は異なるが、他にも「パズル\u0026amp;ドラゴンズ」や「LINEツムツム」もベースはマッチ3だ。今回はキャンディークラッシュのような、一回の操作でピースを1マスだけ動かして色を揃えるタイプのパズルを作っていく。\nOther Tutorials 「パズル＆ドラゴンズ」のようなゲームを作ってみたい場合：\nGodot で作る進化形マッチ 3 パズルゲーム 「LINE：ディズニーツムツム」のようなゲームを作って見たい場合：\nGodot で作る同じ色をつなげて消すパズルゲーム このチュートリアルで最後にできあがるプロジェクトのファイルは GitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.4\n・コンピュータのOS: macOS 11.6.5\nMemo: ゲームを作り始めるのに以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 新規プロジェクトを作成する それでは Godot Engine を立ち上げて、新規プロジェクトを作成しよう。プロジェクトの名前はあなたのお好みで決めていただいてOKだ。もし思いつかなければ「Match3 Start」としておこう。\nプロジェクト設定を更新する エディタが表示されたら、先にプロジェクト全体に関わる設定を更新しておこう。\nまずはゲームのディスプレイサイズを設定する。今回はスマホの縦向きの画面を想定して、縦横の比率を 16 : 9 とする。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。 「Size」セクションで以下の項目の値を変更する。 Width: 630 Height: 1120 Test Width: 315 Test Height: 560\n「Stretch」セクションで以下の項目の値を変更する。 Mode: 2d Aspect: keep\nそのまま「プロジェクト設定」ウインドウを開いた状態で、デバッグパネルでスマホのタッチ操作をマウスで代用するための設定をする。\n「一般」タブで「mouse」と検索し、サイドバーの「Input Devices」＞「Pointing」を選択する。 「Emulate Touch From Mouse」の On のチェックを入れる。\nさらに「プロジェクト設定」ウインドウを開いた状態で、インプットマップにスマホのタッチ操作の相当するアクションを追加しよう。\n「インプットマップ」タブに切り替え、アクションに「touch」を追加する。 「touch」の操作にマウスの左クリックを追加する。\nアセットをダウンロードしてインポートする 次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは「Physics Assets 」 というアセットパックだ。このアセットに含まれるなんともかわいいエイリアンの顔の画像を、ゲームの盤面に並べるピースのテクスチャとして使用する。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「/physicspack/PNG/Aliens」フォルダの中のファイル名が「~_round.png」の画像だけを残して他は削除し、「Aliens」フォルダごとエディタのファイルシステムドックへドラッグしてプロジェクトにインポートしよう。\nGrid シーンを作る まずはマッチ3パズルゲームでピースが配置される盤面として、「Grid」シーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「2D シーン」を選択する。\n1.「Node2D」クラスのルートノードが生成されたら、その名前を「Grid」に変更する。 シーンを保存する。フォルダを作成して、ファイルパスを「res://Grid/Grid.tscn」としてシーンを保存する。\nGrid シーンにノードを追加する 「Grid」ルートノードに、さらに「Node2D」クラスの子ノードを追加し、名前を「PiecesContainer」に変更しよう。このノードは盤面に配置されるピースをまとめるためのノードだ。ゲーム中は、スクリプトでピースのインスタンスが生成されたら全てこの「PiecesContainer」ノードの子として追加することになる。\nシーンツリードックの表示は以下のようになったはずだ。\nなお、「Grid」シーンのノードのプロパティ編集は特に必要ない。\nPiece シーンを作る 次に、盤面に並べるピースとして「Piece」シーンを作成する。ただし、この「Piece」シーンはあくまで雛形で、実際にゲーム中で利用する各色のピースは、この「Piece」シーンを継承する形でのちほど用意する。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「2D シーン」を選択する。 「Node2D」クラスのルートノードが生成されたら、その名前を「Piece」に変更する。 シーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Pieces/Piece.tscn」としてシーンを保存する。\nPiece ノードに子ノードを追加する 「Piece」ルートノードに「Sprite」クラスの子ノードを追加しよう。シーンツリードックの表示は以下のようになったはずだ。\nSprite ノードのプロパティを編集する 「Sprite」ノードのプロパティを少し編集しておこう。先述の通り、「Piece」はあくまで継承元（雛形）なので、このシーンでは「Sprite」ノードの「Texture」プロパティにはリソースを敢えて適用せずそのままにしておく。継承先のシーンでそれぞれのピースの色にあった画像を適用する予定だ。\n「Offset」\u0026gt;「Offset」プロパティの値を「(x: 35, y: -35)」に変更しておこう。このシーンを継承する各色のピースのシーンでは「Texture」プロパティに先にインポートした KENNEY の画像を適用するが、その画像の縦横のサイズが 70 px なので、その画像の中心を右上にずらして画像の左下の角を(x: 0, y: 0)に合わせた。\nピースを配置する盤面のグリッドは x 軸は左から右へ、y 軸は下から上へカウントする仕様で、かつ盤面の 1 グリッドのサイズもテクスチャのサイズに合わせて 70 px とする。ピースのテクスチャ画像の左下の角を (x: 0, y: 0) に合わせれば、「Piece」ルートノードの位置 (x: 0, y: 0) をグリッドに合わせて配置したときに、ちょうど「Sprite」の画像がグリッドに沿って配置されるというわけだ。\nPiece ノードにスクリプトをアタッチして編集する 「Piece」ルートノードに新規スクリプトをアタッチしよう。ファイルパスを「res://Pieces/Piece.gd」としてスクリプトファイルを作成する。\nひとまずスクリプトを以下のように編集してほしい。\n###Piece.gd### extends Node2D # ピースの色を文字列データとして設定するためのプロパティ export (String) var color # マッチした（3つ以上同じ色が並んだ）状態を示すプロパティ var matched = false # Sprite ノードの参照 onready var sprite = $Sprite # ピースを移動させるメソッド # 引数 target に渡した位置に Piece インスタンスを移動する func move(target): position = target # マッチした（3つ以上同じ色が並んだ）ときに呼ばれるメソッド # matched プロパティを true にし、色を半透明にする func make_matched(): matched = true sprite.modulate = Color(1,1,1,.5) これで「Piece.gd」スクリプトの編集は完了だ。\nPiece シーンを継承した各色のシーンを作る 雛形となる「Piece」シーンは完成したので、それを継承したシーンをピースの色の数だけ作成していこう。ピースの色は、ベージュ、青、緑、ピンク、黄の 5 色だ。まずは「ベージュ」のドロップを例に手順を進めてみよう。\n「シーン」メニュー＞「新しい継承シーン」を選択する。 継承元のシーンとして「Piece.tscn」を選択する。 継承シーンが生成されたら、ルートノードの名前を「PieceBeige」に変更する。\n*このルートノードの名前はそれぞれのドロップの色に合わせること。 シーンを一旦保存しておく。ファイルパスを「res://Pieces/PieceBeige.tscn」として保存する。 シーンツリードックでルートノード「PieceBeige」を選択した状態で、インスペクターで「Script Variables」の「Color」プロパティの値を「beige」とする。\nシーンツリードックで「Sprite」ノードを選択し、「Texture」プロパティに先にインポートしておいたリソース「res://Aliens/alienBeige_round.png」を適用する（ファイルシステムドックからドラッグすればOK）。\n2D ワークスペース上では以下のスクリーンショットのようになったはずだ。\n以上で、「PieceBeige」シーンは完成だ。残りの 4 色のピースについても、同様の手順でシーンを作成してほしい。なお、シーンごとに異なる部分については、以下を参考にしてほしい。 青のピース ルートノード名: PieceBlue Color プロパティ: blue Sprite \u0026gt; Texture プロパティ: res://Aliens/alienBlue_round.png シーン保存時のファイルパス: res://Pieces/PieceBlue.tscn 緑のピース ルートノード名: PieceGreen Color プロパティ: green Sprite \u0026gt; Texture プロパティ: res://Aliens/alienGreen_round.png シーン保存時のファイルパス: res://Pieces/PieceGreen.tscn ピンクのピース ルートノード名: PiecePink Color プロパティ: green Sprite \u0026gt; Texture プロパティ: res://Aliens/alienPink_round.png シーン保存時のファイルパス: res://Pieces/PiecePink.tscn 黄のピース ルートノード名: PieceYellow Color プロパティ: yellow Sprite \u0026gt; Texture プロパティ: res://Aliens/alienYellow_round.png シーン保存時のファイルパス: res://Pieces/PieceYellow.tscn 全部で 5 色のピースの継承シーンができたら作業完了だ。\nGrid シーンをスクリプトで制御する 各色のピースのシーンができあがったので、ここからはプログラミングしてゲームを制御していく。今回はコード量がやや多めなので頑張ろう。\nGodot エディタで「Grid.tscn」シーンに切り替えたら、「Grid」ルートノードに新規スクリプトをアタッチしよう。ファイルパスは「res://Grid/Grid.gd」として作成する。\nなお、スクリプト内のコメントには「指が触れた」または「指が離れた」と記載しているが、Godot デバッグパネル上では「マウス左ボタンを押した」または「マウス左ボタンを離した」と置き換えてほしい。\nまた、同じ色が３つ以上揃った状態のことを「マッチ」と表現しているので、こちらもご留意いただきたい。\nでは、スクリプトエディタが開いたら、まずは必要なプロパティを定義しておこう。\n###Grid.gd### extends Node2D # 各色のピースのシーンファイルを要素とした配列 const pieces_scn = [ preload(\u0026#34;res://Pieces/PieceBeige.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceBlue.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceGreen.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PiecePink.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceYellow.tscn\u0026#34;) ] # x軸方向のグリッド数 var width: = 7 # y軸方向のグリッド数 var height: = 10 # x軸方向のグリッド開始位置（pixel） var x_start: = 70 # y軸方向のグリッド開始位置（pixel） var y_start: = 910 # 1グリッドのサイズ（PieceのSpriteのTextureと同じにする） var grid_size: = 70 # 盤面のピースの配置を表す配列（二次元配列） var all_pieces = [] # 画面に指を触れた位置 var touched_pos = Vector2() # 画面から指を離れた位置 var released_pos = Vector2() # 画面に指が触れているステート、触れている: true / 離れている: false var is_touching = false # マッチしたピースの自動処理ステート、処理中: true / 停止中: false var is_waiting = false # PiecesContainer ノードの参照 onready var pieces_container = $PiecesContainer 続いて以下のメソッドを追加しよう。なお、以下のコード内に出てくる 二次元配列 とは、要素として配列を格納する配列、つまり配列の配列のことだ。\n今回のスクリプトで利用している二次元配列の場合、一階層目の配列では、盤面の x 軸方向のグリッドの数だけ空の配列を要素とし、二階層目としてそれぞれの配列内に縦方向のグリッド数だけ要素を格納する。その要素として、ピースオブジェクトを格納することで、それぞれのピースが盤面のどこに位置しているか（x 軸方向に何番目のグリッドで、y 軸方向に何番目のグリッドか）を管理することができるというわけだ。\n###Grid.gd### # シーンが読み込まれたら呼ばれる関数 func _ready(): # ランダムな数を生成する関数の出力結果を毎回ランダムにするための組み込み関数を呼ぶ randomize() # all_pieces を盤面のグリッドを構成する二次元配列にする all_pieces = make_2d_array() # このあと定義 # ピースを生成して盤面に配置して盤面情報を all_pieces に反映するメソッドを呼ぶ spawn_pieces() # このあと定義 # 盤面のグリッドを構成する二次元配列を生成するメソッド func make_2d_array(): # array という名前の配列を用意 var array = [] # array に x 軸方向のグリッド数だけ空の配列を入れる for i in width: array.append([]) # さらにそれぞれの配列に y 軸方向のグリッド数だけ暫定的に null を入れる for j in height: array[i].append(null) # できあがった二次元配列を返す return array # ピースを生成して盤面に配置して盤面情報を board に反映するメソッド func spawn_pieces(): # x軸方向のグリッド数だけループ for i in width: # y軸方向のグリッド数だけループ for j in height: # 全ピースの二次元配列上で該当グリッドにピースが存在しない場合 #（ゲーム開始時は全部 null） if all_pieces[i][j] == null: # 各色のピースのシーンからランダムで１つ選択してインスタンス化 var index = floor(rand_range(0, pieces_scn.size())) var piece = pieces_scn[index].instance() # マッチしてしまった場合は、ピースのインスタンスを削除してやり直し while match_at(i, j, piece.color): # このあと定義 piece.queue_free() index = floor(rand_range(0, pieces_scn.size())) piece = pieces_scn[index].instance() # ピースのインスタンスをPiecesContainerノードの子にする pieces_container.add_child(piece) # グリッドからピクセルに変換した位置にピースのインスタンスを配置 piece.position = grid_to_pixel(i, j) # このあと定義 # 全ピースの二次元配列を更新 all_pieces[i][j] = piece 上記コードの中で未定義のmatch_atメソッドとgrid_to_pixelメソッドを定義しておこう。\n###Grid.gd### # 指定したグリッド位置で同じ色ピースが３つ以上並んでいるか確認するメソッド # 引数columnはx軸のグリッド位置、rowはy軸のグリッド位置、colorはピースの色 func match_at(column, row, color): # 指定したグリッドの x 軸方向の位置が3以上の場合 if column \u0026gt;= 2: # 指定したグリッド位置の左隣ともう一つ左隣にピースがある場合 if all_pieces[column-1][row] != null \\ and all_pieces[column-2][row] != null: # 左隣ともう一つ左隣のピースの色が指定したピースの色と同じ場合 if all_pieces[column-1][row].color == color \\ and all_pieces[column-2][row].color == color: # true を返す return true # 指定したグリッドの y 軸方向の位置が3以上の場合 if row \u0026gt;= 2: # 指定したグリッド位置の下ともう一つ下にピースがある場合 if all_pieces[column][row-1] != null \\ and all_pieces[column][row-2] != null: # 下ともう一つ下のピースの色が指定したピースの色と同じ場合 if all_pieces[column][row-1].color == color \\ and all_pieces[column][row-2].color == color: # true を返す return true # グリッドの位置をピクセルの位置に変換するメソッド func grid_to_pixel(column, row): # 先にピクセル位置出力用に Vector2 型の変数 pixel_pos を定義 var pixel_pos = Vector2() # ピクセル x 座標 = x 軸方向のグリッド開始位置 + グリッドサイズ x グリッド x 座標 pixel_pos.x = x_start + grid_size * column # ピクセル y 座標 = y 軸方向のグリッド開始位置 - グリッドサイズ x グリッド y 座標 pixel_pos.y = y_start - grid_size * row # ピクセル座標を返す return pixel_pos これで、ゲーム開始時に各色のピースが盤面にランダムで並べられるはずだ。一度プロジェクトを実行して確認してみよう。なお、初めてプロジェクトを実行する場合は、メインシーン選択のダイアログが表示されるので、「Grid.tscn」をメインシーンとして選択しよう。\nちょうどgrid_to_pixelメソッドを定義したので、ついでにこのあと使用するpixel_to_gridメソッドも定義しておこう。名前の通り、先に定義したgrid_to_pixelとは逆で、ピクセルの位置をグリッドの位置に変換するメソッドだ。\n###Grid.gd### # ピクセルの位置をグリッドの位置に変換するメソッド func pixel_to_grid(pixel_x, pixel_y) -\u0026gt; Vector2: var grid_pos = Vector2() grid_pos.x = floor((pixel_x - x_start) / grid_size) grid_pos.y = floor((pixel_y - y_start) / -grid_size) return grid_pos さらに、もう一つこのあと使用するis_in_gridメソッドを定義しておく。これは引数に渡した位置が盤面グリッドの範囲内かどうかを判定してその結果を返すメソッドだ。\n###Grid.gd### # 指定した位置が盤面グリッドの範囲内かどうかを返すメソッド func is_in_grid(grid_position: Vector2): if grid_position.x \u0026gt;= 0 and grid_position.x \u0026lt; width \\ and grid_position.y \u0026gt;= 0 and grid_position.y \u0026lt; height: # 盤面グリッドの範囲内だったら true を返す return true else: # 盤面グリッドの範囲外だったら false を返す return false ここで、ゲームのプレイヤーの入力（画面のタッチ操作）を処理するプログラムを記述していく。\n###Grid.gd### # ゲームのメインループで毎フレーム呼ばれる関数 func _process(_delta): # もしマッチングの処理中でなければ if not is_waiting: # プレイヤーの入力を処理する touch_input() # このあと定義 # プレイヤーの入力を処理するメソッド func touch_input(): # もし画面に指が触れたら if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # 指の位置をピクセルからグリッドに変換 var start_pos = get_global_mouse_position() var start_grid = pixel_to_grid(start_pos.x, start_pos.y) # 指の位置が盤面グリッドの範囲内だったら if is_in_grid(start_grid): # 画面に指を触れた位置を保存 touched_pos = start_grid # ステートを画面に指が触れている状態にする is_touching = true # もし画面から指が離れたら if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # 指の位置をピクセルからグリッドに変換 var end_pos = get_global_mouse_position() var end_grid = pixel_to_grid(end_pos.x, end_pos.y) # もし指の位置が盤面グリッドの範囲内... # かつステートが画面に指が触れている状態だったら if is_in_grid(end_grid) and is_touching: # 指を離した位置情報として保存 released_pos = end_grid # 指が触れた位置と指を離した位置でピースの移動を処理するメソッドを呼ぶ touch_and_release() # このあと定義 # ステートを画面から指が離れている状態にする is_touching = false 上記コードで、盤面グリッド内で画面に指を触れた位置と画面から指を離した位置を取得し、それらの情報を利用してピースの移動を処理するtouch_and_releaseメソッドを呼び出している。このメソッドとその中でさらに呼び出すswap_piecesというヘルパーメソッドを定義していこう。ヘルパーメソッドというのは簡単に言うと、メソッドの中で呼び出されるメソッドで、親のメソッドをシンプルに保つ役割をする。\n###Grid.gd### # 指が触れた位置と指を離した位置を利用してピースの移動を処理するメソッド func touch_and_release(): # 指が触れた位置と指が離れた位置との差を計算 var difference = released_pos - touched_pos # x 軸方向の差の絶対値が y 軸方向の差の絶対値より大きい場合 if abs(difference.x) \u0026gt; abs(difference.y): # x 軸方向の差が 0 より大きい場合 if difference.x \u0026gt; 0: # ヘルパーメソッドを呼び、触れた位置のピースと右に隣接するピースを入れ替える swap_pieces(touched_pos, Vector2.RIGHT) # このあと定義 # x 軸方向の差が 0 より小さい場合 elif difference.x \u0026lt; 0: # ヘルパーメソッドを呼び、触れた位置のピースと左に隣接するピースを入れ替える swap_pieces(touched_pos, Vector2.LEFT) # このあと定義 # x 軸方向の差の絶対値が y 軸方向の差の絶対値より小さい場合 elif abs(difference.x) \u0026lt; abs(difference.y): # y 軸方向の差が 0 より大きい場合 if difference.y \u0026gt; 0: # ヘルパーメソッドを呼び、触れた位置のピースと下に隣接するピースを入れ替える swap_pieces(touched_pos, Vector2.DOWN) # このあと定義 # y 軸方向の差が 0 より小さい場合 elif difference.y \u0026lt; 0: # ヘルパーメソッドを呼び、触れた位置のピースと上に隣接するピースを入れ替える swap_pieces(touched_pos, Vector2.UP) # このあと定義 # ピースを入れ替えるヘルパーメソッド func swap_pieces(pos, dir): # 指を触れた位置のピースを全ピースの二次元配列から取得 var touched_piece = all_pieces[pos.x][pos.y] # 指を離した方向に隣接するピースを全ピースの二次元配列から取得 var target_piece = all_pieces[pos.x + dir.x][pos.y + dir.y] # 全ピースの二次元配列上、どちらのピースも存在している場合 if touched_piece != null and target_piece != null: # 全ピースの二次元配列の中から指を触れた位置のピースを指を離した方に隣接するピースで上書きする all_pieces[pos.x][pos.y] = target_piece # 全ピースの二次元配列上、指を離した方に隣接するピースを指を触れた位置のピースで上書きする all_pieces[pos.x + dir.x][pos.y + dir.y] = touched_piece # 盤面上、指を触れた位置のピースインスタンスを指を離した方にに1グリッド移動する touched_piece.move(grid_to_pixel(pos.x + dir.x, pos.y + dir.y)) # 盤面上、指を離した方に隣接するピースインスタンスを指を触れた位置へ移動する target_piece.move(grid_to_pixel(pos.x, pos.y)) # ここからマッチしたピースの処理が始まるので、自動処理ステートを処理中にする is_waiting = true 上記コードで、プレイヤーがドラッグしたピースが隣接するピースと入れ替わる処理が実装できた。入力操作が正しく機能するか、プロジェクトを実行して確認しておこう。\nここからはピースを入れ替えたあとに自動的に実行されるべき処理を実装していく。大まかには以下の流れだ。\n自動処理ステートを処理中に変更する。 マッチしたピースが1組でもあるかチェックする。1組でもある場合は以下の処理をループする。 全てのピースをチェックしてマッチしたピースにフラグを立てる。 フラグの立っているピースを削除する。 削除して空になったスペースへ同じ列の上のグリッドからピースを移動させて詰める。 ピースを下へ詰めたら、最後に空のスペースに新しいピースを生成する。 マッチしたピースが1組もなくなったら自動処理ステートを停止中にする。 上記の大まかな流れをコーディングしよう。\nまず先に定義したピースを入れ替えるswap_piecesメソッドの最後にis_waiting = trueの1行を追加しよう。つまりこれは、自動処理ステートを処理中に変更している。\n###Grid.gd### func swap_pieces(pos, dir): var touched_piece = all_pieces[pos.x][pos.y] var target_piece = all_pieces[pos.x + dir.x][pos.y + dir.y] if touched_piece != null and target_piece != null: all_pieces[pos.x][pos.y] = target_piece all_pieces[pos.x + dir.x][pos.y + dir.y] = touched_piece touched_piece.move(grid_to_pixel(pos.x + dir.x, pos.y + dir.y)) target_piece.move(grid_to_pixel(pos.x, pos.y)) # 以下を追加 # ここからマッチしたピースの自動処理が開始するので自動処理ステートを処理中にする is_waiting = true touch_inputメソッドに「もし自動処理実行中のステートだったら」というif構文を記述し、そのブロックの中に自動的に実行させたい処理を追加していこう。追加する位置はちょうど指での操作が終わったあとだ。処理が完了した後にはis_waiting = falseの1行追加して、自動処理ステートを停止中にしておこう。\n###Grid.gd### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # 省略 if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # 省略 # ここから追加 # もし処理中だったら if is_waiting: # マッチしたピースが1組でもあるかチェック \u0026gt; ある限りループ while check_matches(): # このあと定義 pass # マッチしたピースが1組もなく処理が完了したら、自動処理ステートを停止中にする is_waiting = false whileループで、マッチしたピースが1組でもあれば必要な処理を繰り返すようにしている。\nまずはwhileループのループ条件ともなっているcheck_matches()を以下の通りに定義する。\n###Grid.gd### # マッチしたピースが1組でもあるかチェックして結果を返すメソッド func check_matches() -\u0026gt; bool: # 盤面の x軸方向のグリッドでループ for i in width: # 盤面の y軸方向のグリッドでループ for j in height: # その グリッドの座標にピースが存在する場合 if all_pieces[i][j] != null: # そのグリッド座標のピースがマッチしていれば true を返してメソッドも終了 if match_at(i, j, all_pieces[i][j].color): return true # 全ピースをチェックしてマッチしているピースが一つもなければ false を返す return false 続いて、whileループ内の最初の処理」全てのピースをチェックしてマッチしたピースにはフラグを立てる」を行うためのfind_matchesメソッドを以下のように定義しよう。ここでいう「フラグを立てる」と言うのは、つまり、ピースのインスタンスのmatchedプロパティをtrueに変更する、ということだ。\n###Grid.gd### # マッチしているピースを見つけてフラグを立てるメソッド func find_matches(): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # そのグリッドの座標にピースが存在する場合 if all_pieces[i][j] != null: # 現在の色をそのグリッド座標のピースの色と定義する var current_color = all_pieces[i][j].color # もしその x 軸座標が x 軸方向のグリッド数 - 2 より小さければ if i \u0026lt; width - 2: # そのピースの右隣とさらにその右隣にピースが存在する場合 if all_pieces[i+1][j] != null \\ and all_pieces[i+2][j] != null: # それらのピースの色が現在の色と同じ場合 if all_pieces[i+1][j].color == current_color \\ and all_pieces[i+2][j].color == current_color: # そのピースにフラグが立ってなければ if not all_pieces[i][j].matched: # そのピースの matched プロパティを true にしてフラグを立てる # 同時にそのピースのテクスチャの色を半透明にする all_pieces[i][j].make_matched() # そのピースの右隣のピースにフラグが立ってなければ if not all_pieces[i+1][j].matched: # そのピースの matched プロパティを true にしてフラグを立てる # 同時にそのピースのテクスチャの色を半透明にする all_pieces[i+1][j].make_matched() # そのピースの２つ右隣のピースにフラグが立ってなければ if not all_pieces[i+2][j].matched: # そのピースの matched プロパティを true にしてフラグを立てる # 同時にそのピースのテクスチャの色を半透明にする all_pieces[i+2][j].make_matched() # もしそのピースの y 座標が y 軸方向のグリッド数 - 2 より小さければ if j \u0026lt; height - 2: # そのピースの上とさらにその上にピースが存在する場合 if all_pieces[i][j+1] != null \\ and all_pieces[i][j+2] != null: # それらのピースの色が現在の色と同じ場合 if all_pieces[i][j+1].color == current_color \\ and all_pieces[i][j+2].color == current_color: # そのピースにフラグが立ってなければ if not all_pieces[i][j].matched: # そのピースの matched プロパティを true にしてフラグを立てる # 同時にそのピースのテクスチャの色を半透明にする all_pieces[i][j].make_matched() # そのピースの上のピースにフラグが立ってなければ if not all_pieces[i][j+1].matched: # そのピースの matched プロパティを true にしてフラグを立てる # 同時にそのピースのテクスチャの色を半透明にする all_pieces[i][j+1].make_matched() # そのピースの２つ上のピースにフラグが立ってなければ if not all_pieces[i][j+2].matched: # そのピースの matched プロパティを true にしてフラグを立てる # 同時にそのピースのテクスチャの色を半透明にする all_pieces[i][j+2].make_matched() このfind_matchesメソッドをtouch_inputメソッド内のwhileループの中で呼び出す必要があるので、以下のように更新しよう。\n###Grid.gd### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # 省略 if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # 省略 if is_waiting: # マッチしたピースが1組でもあるかチェック \u0026gt; ある限りループ while check_matches(): # マッチしたピースを見つけてフラグを立てる find_matches() # 処理を視覚的にわかりやすくするため0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) is_waiting = false これで、マッチした各ピースのインスタンスのmatchedプロパティはtrueになり、ピースの色も半透明になるはずだ。プロジェクトを実行して確認してみよう。\n続いて、whileループ内の2番目の処理「フラグの立っているピースを削除する」を実行するdelete_matchesメソッドを以下のように定義してほしい。\n###Grid.gd### # マッチしているピースを削除するメソッド func delete_matches(): # 盤面の x 軸方向のグリッド数だけループ for i in width: # 盤面の y 軸方向のグリッド数だけループ for j in height: # そのグリッド座標にピースが存在する場合 if all_pieces[i][j] != null: # そのグリッド座標のピースにフラグが立っていたら if all_pieces[i][j].matched: # そのグリッド座標のピースを削除する all_pieces[i][j].queue_free() # 全ピースの二次元配列からそのグリッド座標の要素を空にする all_pieces[i][j] = null このdelete_matchesメソッドをtouch_inputメソッドのwhileループ内に追加しよう。\n###Grid.gd### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # 省略 if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # 省略 if is_waiting: # マッチしたピースが1組でもあるかチェック \u0026gt; ある限りループ while check_matches(): # マッチしたピースを見つけてフラグを立てる find_matches() # 0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # フラグを立てたピースを削除する delete_matches() # 0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # マッチしたピースが1組もなく処理が完了したら、処理中状態を無効にする is_waiting = false これでマッチしたピースが半透明になった後、削除されるはずだ。プロジェクトを実行して確認してみよう。\n次は、whileループ内の3番目の処理「削除して空になったスペースへ同じ列の上のグリッドからピースを移動させて詰める」を実行するcollapse_columnsメソッドを以下のように更新してほしい。\n###Grid.gd### # 列ごとにピースが存在しないスペースには上にあるピースを移動して詰めるメソッド func collapse_columns(): # 盤面の x　軸方向のグリッド数だけループ for i in width: # 盤面の y　軸方向のグリッド数だけループ for j in height: # そのグリッド座標にピースが存在しない（null）場合 if all_pieces[i][j] == null: # そのグリッドの y 座標より１つ上の行から一番上の行までのループ for k in range(j + 1, height): # 1つ上のグリッドにピースが存在している場合 if all_pieces[i][k] != null: # １つ上のグリッドのピースを下の空いているグリッドに移動する all_pieces[i][k].move(grid_to_pixel(i, j)) # 全ピースの二次元配列の現在のグリッド座標に１つ上のピースを入れる all_pieces[i][j] = all_pieces[i][k] # 全ピースの二次元配列の１つ上のグリッド座標を空にする all_pieces[i][k] = null # ループを抜ける break このcollapse_columnsメソッドをtouch_inputメソッドのwhileループ内で呼び出そう。\n###Grid.gd### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # 省略 if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # 省略 if is_waiting: # マッチしたピースが1組でもあるかチェック \u0026gt; ある限りループ while check_matches(): # マッチしたピースを見つけてフラグを立てる find_matches() # 0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # フラグを立てたピースを削除する delete_matches() # 0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # 空のスペースに同じ列の上にあるピースを移動して詰める collapse_columns() # 0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # マッチしたピースが1組もなく処理が完了したら、処理中状態を無効にする is_waiting = false これでピースが削除されて空いたスペースに上にあるピースを詰める仕組みができた。さらにwhileループにより、空いたスペースにピースを詰めた あとに マッチしたピースも連続的に削除されるはずだ。プロジェクトを実行して確認してみよう。\n最後に、すでに定義済みのspawn_piecesメソッドをピースを下に詰めたあとに呼び出すようにすれば、空いた空間に新しいピースが配置され盤面が埋まるはずだ。touch_inputメソッドを以下のように更新しよう。\n###Grid.gd### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # 省略 if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # 省略 if is_waiting: # マッチしたピースが1組でもあるかチェック \u0026gt; ある限りループ while check_matches(): # マッチしたピースを見つけてフラグを立てる find_matches() # 0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # フラグを立てたピースを削除する delete_matches() # 0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # 空のスペースに同じ列の上にあるピースを移動して詰める collapse_columns() # 0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # 空のスペースに新しいピースを生成して配置する spawn_pieces() # 0.3秒待機 yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # マッチしたピースが1組もなく処理が完了したら、処理中状態を無効にする is_waiting = false 以上で自動処理部分のコーディングは完了だ。このチュートリアルの手順もここまでとなる。最後にプロジェクトを実行して動作を確認しておこう。\nサンプルゲーム 今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。ちなみに以下のGIF画像は3倍速で再生しているので実際はもう少し穏やかだ。\nサンプルゲームのプロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。\nおわりに 今回はマッチ3パズルゲームを作った。シンプルな操作で何回でも楽しめるモバイルゲームにはうってつけのゲームジャンルだ。\n今回のようなシンプルなマッチ3パズルゲームを作るときのポイントをまとめておこう。\n最低限必要なシーンは盤面とピースの２つだけ。 雛形のピースシーンを作ってから、それを継承して各色のピースシーンを作る。 二次元配列を利用して盤面グリッドに配置するピースを管理する。 ピースを入れ替えるときは、画面上のピースの位置の入れ替えと二次元配列の要素の入れ替えの両方が必要。 スクリプトは以下がポイント。 プレイヤーがピースを動かす処理 画面に指が触れた位置と画面から指が離れた位置を取得する。 ２つの位置がグリッド内か（有効な操作か）判定する。 ２つの位置の差からピースを入れ替える方向を判定する。 マッチした時の自動処理（ループ）。 マッチしているピースが1組でもあるかチェック（ループの条件）。 マッチしているピースにフラグを立てる。 フラグの立っているピースを削除する。 削除されて空いたスペースに上のピースを詰める。 詰めて空いたスペースに新しいピースを生成する。 参照 「Candy Crush（キャンディークラッシュ）」 「Royal Match（ロイヤルマッチ）」 「Toon Blast（トゥーンブラスト）」 「Puzzle＆Dragons（パズル＆ドラゴンズ（通称パズドラ））」 YouTube: Part 0: Why Godot? - Make a Match 3 game like Candy Crush Using Godot. ","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0012_match3/","summary":"今回のチュートリアルではマッチ3パズルゲームを作っていく。マッチ3（スリー）パズルゲームとは、盤面のグリッドに沿って均一に並べられた複数のカラフルなピースのうちの１つを、1マス動かして同じ色のピースを","title":"Godot3 で作るマッチ 3 パズルゲーム"},{"content":"このチュートリアルでは、スマホゲームで大人気の ディズニーツムツムのような同じ色のドロップをなぞってつなげて消すタイプのゲームの作り方を説明する。ちなみにディズニーツムツムを知らない方は以下のリンク先を一度ご覧いただきたい。\nLINE：ディズニー ツムツム Other Tutorials 「パズル＆ドラゴンズ」のようなゲームを作ってみたい場合：\nGodot で作る進化形マッチ 3 パズルゲーム 「キャンディークラッシュ」のようなゲームを作ってみたい場合：\nGodot で作るマッチ 3 パズルゲーム なお、このチュートリアルで最後にできあがるプロジェクトのファイルは GitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.4\n・コンピュータのOS: macOS 11.6.5\nMemo: ゲームを作り始めるのに以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 新規プロジェクトを作成する まずは Godot Engine を立ち上げて、新規プロジェクトを作成してほしい。プロジェクトの名前は「Connect Colors Start」としておこう。\nプロジェクト設定を更新する エディタが表示されたら、先にプロジェクト全体に関わる設定を更新しておこう。\nまずはゲームのディスプレイサイズを設定する。今回はスマホの縦向きの画面を想定して、縦横の比率を16:9とした。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 「一般」タブで「window」で検索して、サイドバーの「Display」＞「Window」を選択する。 「Size」セクションで以下の項目の値を変更する。 Width: 144 Height: 256 Test Width: 288 Test Height: 512\n「Stretch」セクションで以下の項目の値を変更する。 Mode: 2d Aspect: keep\nそのまま「プロジェクト設定」ウインドウを開いた状態で、デバッグパネルでスマホのタッチ操作をマウスで代用するための設定をする。\n「一般」タブで「mouse」で検索し、サイドバーの「Input Devices」＞「Pointing」を選択する。 「Emulate Touch From Mouse」の On のチェックを入れる。\nさらに「プロジェクト設定」ウインドウを開いた状態で、インプットマップにスマホのタッチ操作の相当するアクションを追加しよう。\n「インプットマップ」タブに切り替え、アクションに「tap」を追加する。 「tap」の操作にマウスの左クリックを追加する。\nアセットをダウンロードしてインポートする 次に、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは Pixel Platformer というアセットパックだ。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「Tilemap」フォルダ内の「characters_packed.png」ファイルをエディタのファイルシステムドックへドラッグ\u0026amp;ドロップしてプロジェクトにインポートしよう。\nファイルをインポートした直後は画像がぼやけた感じになっているので、これを以下の手順で修正しておく。\nファイルシステムドックでインポートしたアセットファイルを選択した状態にする\nインポートドックで「プリセット」＞「2D Pixel」を選択する\n一番下にある「再インポート」ボタンをクリックする。\nこれでピクセルアート特有のエッジの効いた画像になる。\nWorld シーンを作る まず最初のシーンとして、ゲームの舞台を用意する。「World」という名前のシーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Node2D」クラスのノードをルートノードとして選択。 ルートノードの名前を「World」に変更する。 一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://World/World.tscn」としてシーンを保存する。\nWorld シーンにノードを追加する World シーンが以下のシーンツリーになるようにノードを追加しよう。なお、それぞれのプロパティ編集は後で順番にやっていくので一旦そのままで良い。\nWorld (Node2D) Bin (StaticBody2D) CollisionPolygon2D SpawnPath (Path2D) Spawner (PathFollow2D) AnimationPlayer Drops (Node2D) DropsLine (Line2D) Pointer (Area2D) CollisionShape2D シーンツリードックの表示は以下のようになったはずだ。\nWorld シーンのノードを編集する Bin (StaticBody2D) ノード このノードの編集は不要だ。「StaticBody2D」は 2D ゲームにおいて、移動しない障害物や壁などに利用される。今回は落ちてくるドロップ（なぞって消すオブジェクト）を画面内にとどめるための入れ物（ビン）として利用する。\nCollisionPolygon2D ノード このノードは親ノードの「Bin」にコリジョン形状を付与するための利用する。コリジョン形状は 2D ワークスペース上で点を打って作る。\n2D ワークスペースのツールバーでグリッドスナップを有効にする。\n基本的に、ウインドウ枠の外側を囲むように点を打ってコリジョン形状を成形する。ただし、上部は、ディスプレイサイズの y 座標 0 より -64px ずらして成形する。理由は、ウインドウ枠上部外側でドロップを生成して落下させるためだ。また、コリジョンポリゴン下部はディスプレイサイズよりやや内側まで配置し、ドロップが転がるように少し斜めにしている。\nSpawnPath (Path2D) ノード このノードはドロップの生成位置を x 軸方向に常に移動させるために使う。これは、ドロップが毎回画面上部の同じ位置から落ちてくるのを防ぐ役割だ。これをウインドウ枠の上部外側に配置する。\n2D ワークスペース上で (16, -32) と (128, -32) の２つの点を打って x 軸に並行な直線のパスを作る。\nSpawner (PathFollow2D) ノード このノードは先に編集した「SpawnPath」ノードのパス上を移動するノードだ。このノードを常にパスに沿って往復させ、このノードの位置からドロップを生成するようにする。これによりドロップの落下位置が「SpawnPath」ノードのパスの範囲で常に変化する\nプロパティ「Rotate」をオフにする。\nAnimationPlayer ノード このノードは「Spawner」を「SpawnPath」のパスに沿って常に往復移動させるために利用する。「Spawner」のプロパティ「Unit Offset」は、親ノード「SpawnPath」のパスの開始位置を 0、終点を 1 で表す。つまりこのプロパティを常に 0 ⇄ 1 で変化させれば、パス上を往復させることができる。\n以下の通りにアニメーションを一つ作成する。 アニメーション名: move_spawn_pos 読み込み後、自動再生: 有効 アニメーションの長さ(秒): 0.4\n*0.4 秒でパスを往復する アニメーションループ: 有効 トラック: Spawner ノード - unit_offset プロパティ Time: 0 / Value: 0 / Easing: 1.00 Time: 0.2 / Value: 1 / Easing: 1.00\n*0.2秒時点でパスの終点から折り返す\nDrops (Node2D) ノード このノードのプロパティ編集は不要だ。役割は、ドロップシーン（後ほど作成）から複数生成するインスタンスをまとめるただの入れ物だ。\nDropLine (Line2D) ノード このノードは同じ色のドロップをなぞった時に、そのドロップとドロップをつなぐ線を描画するために利用する。これにより、どのドロップをなぞってきたのか、いくつつながっているのか、が視覚的に確認しやすくなる。\nプロパティ「Width」を 2 に変更する。これは線の太さだ。\nプロパティ「Capping」＞「Joint Mode」、「Begin Cap Mode」、「End Cap Mode」をそれぞれ「Round」に変更する。これにより、線の繋ぎ目、先端、終端の形状を丸くすることができる。\nPointer (Area2D) ノード このノードの編集は不要だ。目的としては、スマホなら指、PCならマウスカーソルにこのノードを追随させて、ドロップに触っていることを検知するために利用する。のちほど、このノードの位置を常に指またはマウスカーソルの位置と同じにするためのコードをスクリプトに記述する。\nCollisionShape2D ノード このノードは、親ノード「Pointer」にコリジョン形状を付与する。指やマウスカーソルでのドロップをタッチする操作を考慮して、コリジョンはできるだけ小さい形状にする。\nプロパティ「Shape」にリソース「新規 CircleShape2D」を適用する。 適用したリソース「CircleShape2D」のプロパティ「Radius」の値を 1 にする。\n以上で各ノードの編集は完了だ。\nDrop シーンを作る ここからは同じ色をなぞって消す対象となる「Drop」シーンを作っていく。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「RigidBody2D」クラスのノードをルートノードとして選択。 ルートノードの名前を「Drop」に変更する。 一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Drops/Drop.tscn」としてシーンを保存する。\nDrop シーンにノードを追加する Drop シーンが以下のシーンツリーになるようにノードを追加しよう。なお、それぞれのプロパティ編集は後で順番にやっていくので一旦そのままで良い。\nDrop (RigidBody2D) Sprite CollisionShape2D PointableArea (Area2D) CollisionShape2D AnimationPlayer StickableArea (Area2D) CollisionShape2D シーンツリードックの表示は以下のようになったはずだ。\nDrop シーンのノードを編集する Drop (RigidBody2D) ルートノード 「Drop」シーンには、そのインスタンスを「World」シーンに追加した時、自動的に重力に従って落下したり、バウンドしたりしてもらいたい。そのような物理演算による動きをノードのプロパティに合わせて自動的に再現してくれるのが RigidBody2D クラスだ。\nインスペクタードックにて、プロパティ「Physics Material Override」に新規「PhysicsMaterial」リソースを適用する。\nプロパティ「Gravity Scale」の値を 2 にする。ドロップの落下速度を少し速くするのが目的だ。\nノードドック＞グループタブを開き、「Drops」という名前のグループを作って追加する。これはスクリプトでの条件分岐処理で重要だ。\nSprite ノード このノードで「Drop」にテクスチャ（見た目）を付与する。冒頭でインポートしたたくさんのテクスチャをまとめた1枚のスプライトシートから使いたいテクスチャの範囲を指定してスプライトのテクスチャを設定する方法を採用する。\nインスペクターにて、プロパティ「Texture」にファイルシステムからリソース「res://characters_packed.png」をドラッグして適用する。\n「Region」＞「Enabled」をオンにする。\nエディタ下部のテクスチャ領域パネルを開く。ここで行うのはスプライトシートの中の利用したいテクスチャの領域を指定する作業だ。\n作業しやすいように、展開アイコンをクリックしてパネルを広げる。\nパネル上部の「snapモード」で「グリッドスナップ」を選択する。\nパネル上部の「ステップ」を 24px 24px にする。これでグリッドのサイズがスプライトシートのテクスチャ 1 つ分と同じサイズになる。\nスプライトシート上でドラッグ操作により緑色のドロップ（見た目はエイリアンだが）の2種類のテクスチャを範囲選択する。\nインスペクターに戻り、「Animation」＞「Hframes」プロパティの値を 2 に変更する。\nCollisionShape2D ノード (ルートノード Drop の子) このノードはルートノード「Drop」にコリジョン形状を提供する。ルートノードは「RigidBody2D」クラスで、物理ボディの１つだ。物理ボディ同士の衝突判定にはコリジョン設定が必須だ。このコリジョン形状により、複数の「Drop」シーンのインスタンスが画面上でお互いにぶつかり合って、積み上がっていくことを想定している。\nプロパティ「Shape」に新規「CircleShape2D」リソースを適用する。 さらにそのリソースのプロパティ「Radius」の値を 12 に変更する。これで半径 12 px の円形のコリジョン形状ができた。2D ワークスペースで直感的にサイズ調整しても構わない。\nPointableArea (Area2D) ノード このノードは、指またはマウスカーソルがそのドロップに触れたことや離れたことを検知するために利用する。プロパティの編集は不要だが、グループの追加が必要だ。\nノードドック＞グループタブを開き、「Pointable」という名前のグループを作って追加する。これは指またはマウスカーソルがドロップに触れているかどうかを判定する際に利用する。\nCollisionShape2D (PointableArea の子)ノード このノードは、親の「PointableArea」にコリジョン形状を提供する。指やマウスカーソルがドロップの端に触っただけでは反応しないように、ルートノード「Drop」のコリジョン形状よりやや内側に収まるようにする。\nプロパティ「Shape」に新規「CircleShape2D」リソースを適用する。 さらにそのリソースのプロパティ「Radius」の値を 10 に変更する。ルートノード「Drop」のコリジョン形状よりひと回り小さくした。隣接するドロップ同士でこのコリジョン形状と重なってしまうと、ドロップから指が離れたことを検出される前に隣のドロップとの接触が検出されるため、スクリプトでの制御が難しくなってしまうのだ。2D ワークスペースで直感的にサイズ調整しても構わない。\n*このノードのコリジョン形状は内側の円 AnimationPlayer ノード ここではまず先に、指やマウスカーソルが触れていない時のドロップの待機中のアニメーションと、触れた後にそれがわかるように点滅するアニメーションを作成する。このノードは、作成したそれらのアニメーションリソースを再生するのに利用する。\n以下の通りに、ドロップの待機中のアニメーションを作成する。 アニメーション名: idle 読み込み後、自動再生: 有効 アニメーションの長さ(秒): 1 アニメーションループ: 有効 トラック: Sprite ノード - frame プロパティ Time: 0 / Value: 0 / Easing: 1.00 Time: 0.5 / Value: 1 / Easing: 1.00 Sprite ノード - modulate プロパティ Time: 0 / Value: #ffffff / Easing: 1.00\n*「flash」アニメーションでmodulateが変更された後、「idle」アニメーション再生時に確実に初期値に戻すためのトラック\n以下の通りに、ドロップの待機中のアニメーションを作成する。 アニメーション名: flash 読み込み後、自動再生: 無効 アニメーションの長さ(秒): 0.2 アニメーションループ: 有効 トラック: Sprite ノード - frame プロパティ Time: 0 / Value: 0 / Easing: 1.00 Time: 0.1 / Value: 1 / Easing: 1.00 Sprite ノード - modulate プロパティ Time: 0 / Value: #ffffff / Easing: 1.00 Time: 0.1 / Value: #64ffffff / Easing: 1.00\nStickableArea (Area2D) ノード このノードは、ドロップが他のドロップと接触しているかどうかを検知するために利用する。プロパティの編集は不要だが、グループの追加が必要だ。\nノードドック＞グループタブを開き、「Stickable」という名前のグループを作って追加する。これはドロップを指でなぞった時に「隣接している」 = 「つなげるか」かどうかを判定するのに重要だ。\nCollisionShape2D ノード このノードは、親の「StickableArea」にコリジョン形状を提供する。隣接しているドロップを検知するのに利用する。隣り合っているドロップ同士の接触を検知させるために、ルートノード「Drop」のコリジョン形状よりやや大きめにする。\nプロパティ「Shape」に新規「CircleShape2D」リソースを適用する。 さらにそのリソースのプロパティ「Radius」の値を 18 に変更する。これで半径 18 px の円形のコリジョン形状ができた。2D ワークスペースで直感的にサイズ調整しても構わない。\n*このノードのコリジョン形状は一番外側の円 以上で各ノードの編集は完了だ。\nDrop シーンをスクリプトで制御する それではルートノード「Drop」に新規スクリプトをアタッチしよう。ファイルパスを「res://Drops/Drop.gd」としてスクリプトファイルを作成する。\nひとまずスクリプトを以下のように編集してほしい。\n###Drop.gd### extends RigidBody2D # Drop シーンを継承するシーンにそれぞれの色の名前を割り当てるプロパティ # 今はブランクの文字列 export var color = \u0026#34;\u0026#34; # 隣接するドロップを入れる配列を stuck_drop と定義 var stuck_drops = [] # AnimationPlayerノードへの参照 # Drop のインスタンスを World シーンに追加してから利用する onready var anim_player = $AnimationPlayer 次に、「StickableArea」ノードの Area2D ノードのシグナルを利用する。隣接するドロップと接触した時に発信されるシグナル「area_entered」と、接触していたドロップが離れた時に発信されるシグナル「area_exited」をスクリプトに接続しよう。\nそれぞれのシグナルを接続したときに生成されるメソッドを以下のように編集してほしい。\n###Drop.gd### # StickableArea に他の area (Area2D クラスのノード)が当たった時に呼ばれるメソッド func _on_StickableArea_area_entered(area): # もし当たった area が Stickable グループのノードだったら if area.is_in_group(\u0026#34;Stickable\u0026#34;): # その親ノードを drop と定義 var drop = area.get_parent() # 配列 stuck_drops に drop を追加 stuck_drops.append(drop) # StickableArea から他の area (Area2D クラスのノード) が離れた時に呼ばれるメソッド func _on_StickableArea_area_exited(area): # もし当たった area が Stickable グループのノードだったら if area.is_in_group(\u0026#34;Stickable\u0026#34;): # その親ノードを drop と定義 var drop = area.get_parent() # 配列 stuck_drops の中の drop の index を調べる var index = stuck_drops.find(drop) # 配列 stuck_drops から index に該当する要素（隣接していた Drop）を削除 stuck_drops.remove(index) これで「Drop.gd」の編集は完了だ。\nDrop シーンを継承したシーンを作る さっき作った「Drop」シーンはこれから作るシーンの雛形だ。これから「Drop」シーンを継承したシーンをドロップの色の数だけ作成する。ドロップの色は、青、緑、オレンジ、赤、黄の 5 色だ。まずは青のドロップを例に手順を進めてみよう。\n「シーン」メニュー＞「新しい継承シーン」を選択する。 継承元のシーンとして「Drops.tscn」を選択する。 シーンが生成されたら、ルートノードの名前を「Blue」に変更する。\n*このルートノードの名前はそれぞれのドロップの色に合わせること。 シーンを一旦保存しておこう。ファイルパスを「res://Drops/BlueDrop.tscn」として保存する。 シーンツリードックでルートノード「BlueDrop」を選択した状態で、インスペクターで Script Variables の「Color」の値を「Blue」とする。\nシーンツリードックで「Sprite」ノードを選択する。エディタ下部の「テクスチャ領域」パネルを開き、青いエイリアンのテクスチャ２つ分を選択しよう。\n以上で、「BlueDrop」シーンは完成だ。同じ手順で残りの 4 色のシーンも作成してほしい。なお、シーンのルートノードの名前とそのプロパティ「Color」の値は以下の通りだ。\nルートノード: GreenDrop / Color: Green ルートノード: OrangeDrop / Color: Orange ルートノード: RedDrop / Color: Red ルートノード: YellowDrop / Color: Yellow 全部で 5 色のドロップの継承シーンができたら作業完了だ。\nWorld シーンをスクリプトで制御する いよいよ今回のチュートリアルも終盤に差し掛かった。では「World」シーンのルートノードにスクリプトをアタッチしよう。ファイルパスは「res://World/World.tscn」として作成する。\nスクリプトエディタが開いたら、まずは以下の通りにプロパティを定義する。\n###World.gd### extends Node2D # preloadした5色のドロップシーンを要素にもつ配列を drop_scenes として定義 const drop_scenes = [ preload(\u0026#34;res://Drops/BlueDrop.tscn\u0026#34;), preload(\u0026#34;res://Drops/GreenDrop.tscn\u0026#34;), preload(\u0026#34;res://Drops/OrangeDrop.tscn\u0026#34;), preload(\u0026#34;res://Drops/RedDrop.tscn\u0026#34;), preload(\u0026#34;res://Drops/YellowDrop.tscn\u0026#34;) ] # つなげて消せる最小ドロップ数 export (int) var min_erasable = 3 # プレイ画面に表示される最大ドロップ数 export (int) var max_drops = 50 # 現在ゲームをプレイ中の場合は true になる var is_playing = false # 指を画面に当てたまま or マウス左クリックを押したままの場合 true になる var is_holding = false # 現在指またはマウスカーソルが当たっているドロップの参照用 var pointed_drop # 現在つなげているドロップの色 var active_color = \u0026#34;\u0026#34; # ホールド中の（なぞってつながっている）ドロップのリスト用の配列 var held_drops = [] # Spawnerノードへの参照 onready var spawner = $SpawnPath/Spawner # Dropsノードへの参照 onready var drops = $Drops # DropsLineノードへの参照 onready var drops_line = $DropsLine # Pointerノードへの参照 onready var pointer = $Pointer 次にゲーム開始直後に画面外上部からドロップが最大ドロップ数の 50 個落ちてくるようコーディングしていこう。\n###World.gd### # World シーンのノードが全て読み込まれたら呼ばれるメソッド func _ready(): # ランダム系のメソッドの出力結果を毎回ランダムにしてくれる組み込みメソッド randomize() # max_drops の数 (50) だけループする for _i in range(max_drops): # ドロップを生成するメソッド（このあと定義）を呼び出す spawn_drop() # 一つのドロップが生成されたら0.025秒待機して次のドロップ生成 yield(get_tree().create_timer(0.025), \u0026#34;timeout\u0026#34;) # ドロップを生成するメソッド func spawn_drop(): # 配列 drop_scenes からランダムで選ばれた色のドロップのシーンファイルの参照 var drop_scene = drop_scenes[randi() % drop_scenes.size()] # 選択された色のドロップシーンをインスタンス化する var drop = drop_scene.instance() # ドロップのインスタンスの位置を Spawner ノードの位置と同じにする drop.position = spawner.global_position # ドロップのインスタンスを World シーンに追加する drops.add_child(drop) それではプロジェクトを実行して、ゲーム開始時のランダムに決定された色のドロップが50個降ってくる挙動を見ておこう。なお、初めてプロジェクトを実行する際はメインシーンを「World.tscn」としておこう。\n「Pointer (Area2D)」ノードの位置は、指、またはマウスカーソルの位置に追随させるようにこのあとコーディングするのだが、その時、指やマウスカーソルが「Drop」インスタンスの「PointableArea (Area2D)」と重なった時とそのあと離れた時に「Pointer」ノードがそれを検知してシグナルを発信する。それを利用して、ドロップをなぞった時の処理をコーディングしていこう。\nシーンツリードックで「Pointer」を選択し、ノードドック＞シグナルタブにて、シグナル「area_entered(area: Area2D)」とシグナル「area_exited(area: Area2D)」をスクリプトに接続する。\n自動的に生成されたメソッドを以下のように編集しよう。\n###World.gd### # Pointer ノードが他の area(Area2D オブジェクト)に触れたら呼ばれるメソッド func _on_Pointer_area_entered(area): # area が「Pointable」グループのノードだったら if area.is_in_group(\u0026#34;Pointable\u0026#34;): # pointed_drop に area の親ノード（Drop ノード）の参照を渡す pointed_drop = area.get_parent() # ホールド中のドロップが 0 ではなく.. # かつホールド中の最後のドロップが pointed_drop と隣接していたら if not held_drops.empty() and held_drops[-1] in pointed_drop.stuck_drops: # ドロップのつながりを更新するメソッドを呼ぶ（あとで定義） update_drops_connection() # Pointer ノードが触れていた area(Area2D オブジェクト)が離れたら呼ばれるメソッド func _on_Pointer_area_exited(area): # area が「Pointable」グループのノードだったら if area.is_in_group(\u0026#34;Pointable\u0026#34;): # pointed_drop を null にする pointed_drop = null 次は組み込み関数_processを利用して、毎フレーム（60FPS）呼び出したいメソッドを実行する。\n###World.gd### # 組み込み関数: 60FPSで呼び出される func _process(_delta): # DropsLine　ノードの Points プロパティを更新する update_drops_line() # 指またはマウスカーソルの操作を受けつる get_input() # DropsLine ノードの Points プロパティを更新するメソッド # ドロップが転がったり落ちたりして位置が変わるため func update_drops_line(): # ホールド中のドロップが 1 つでもある場合 if not held_drops.empty(): # テンポラリのVector2配列を作成 var temp_array = PoolVector2Array() # ホールド中のドロップに対してループ for drop in held_drops: # テンポラリの配列にホールド中のドロップの位置を追加 temp_array.append(drop.position) # DropsLine ノードの points プロパティを現在ホールド中のドロップの位置に更新 drops_line.points = temp_array # 指またはマウスの入力があったら処理するメソッド func get_input(): # Pointer ノードの位置を常に指またはマウスカーソルの位置にする pointer.position = get_global_mouse_position() # もし指で画面を押したら、もしくはマウス左ボタンを押したら if Input.is_action_just_pressed(\u0026#34;tap\u0026#34;): # ドロップをホールドするメソッド（あとで定義）を呼び出す hold_drop() # ホールド中のドロップのつながりを更新するメソッド（あとで定義）を呼び出す update_drops_connection() # もし指が画面から離れたら、もしくはマウス左ボタンが上がったら if Input.is_action_just_released(\u0026#34;tap\u0026#34;): # ホールド中のドロップを消すメソッド（あとで定義）を呼び出す erase_drops() # ホールドを解除するメソッド（あとで定義）を呼び出す release_drops() 上のコードで定義したメソッドget_input内で呼び出している以下のメソッドはこの後順番に定義していく。\nhold_drop update_drops_connection erase_drops release_drops まずはドロップを押さえた時に呼び出されるメソッドhold_dropとupdate_drops_connectionを定義していこう。\n###World.gd### # ドロップをホールド中にするメソッド func hold_drop(): # もし指またはマウスカーソルがドロップに触れていたら if pointed_drop: # ホールド中とする is_holding = true # ドロップのつながりを更新するメソッド func update_drops_connection(): # もしドロップをホールド中かつ.. # 指またはマウスカーソルがドロップに重なっていたら if is_holding and pointed_drop: # もしホールド中のドロップが 0 だったら if held_drops.empty(): # これからつなぐドロップの色を現在指または.. # マウスカーソルが触れているドロップの色とする active_color = pointed_drop.color # ドロップをつなぐメソッド（あとで定義）を呼ぶ connect_drop() # もし現在指またはマウスカーソルが触れているドロップの色が.. # つないでいるドロップの色と同じだったら elif pointed_drop.color == active_color: # ホールド中のドロップの数が 2 以上かつ現在触れている.. # ドロップがホールド中のドロップの最後から2番目と同じだったら if held_drops.size() \u0026gt;= 2 and pointed_drop == held_drops[-2]: # つながりを解除するメソッド（あとで定義）を呼ぶ disconnect_drop() # ホールド中のドロップの中に現在指またはマウスカーソルが.. # 触れているドロップがなければ elif not pointed_drop in held_drops: # ドロップをつなぐメソッド（あとで定義）を呼ぶ connect_drop() ここで定義したメソッドupdate_drops_connection内を見ると、さらに未定義のconnect_dropメソッドとdisconnect_dropメソッドが呼ばれている。\n続けてこれらのメソッドを定義しよう。\n###World.gd### # ドロップをつなぐメソッド func connect_drop(): # 現在指またはマウスカーソルが触れているドロップのAnimationPlayerで.. # アニメーション\u0026#34;flash\u0026#34;を再生する pointed_drop.anim_player.play(\u0026#34;flash\u0026#34;) # ホールド中のドロップリストに現在触れているドロップを追加する held_drops.append(pointed_drop) # DropsLine ノードの Points プロパティに現在触れているドロップの位置を追加する drops_line.add_point(pointed_drop.position) # ドロップのつながりを解除するメソッド func disconnect_drop(): # ホールド中のドロップのリストの最後のドロップを canceled_drop とする var canceled_drop = held_drops.pop_back() # canceled_drop の AnimationPlayer でアニメーション（\u0026#34;flash\u0026#34;）を停止する canceled_drop.anim_player.stop() # canceled_drop の AnimationPlayer でアニメーション（\u0026#34;idle\u0026#34;）を再生する canceled_drop.anim_player.play(\u0026#34;idle\u0026#34;) # DropsLineノードの Points プロパティから最後の点を削除する drops_line.remove_point(drops_line.get_point_count() - 1) get_inputメソッド内で、指が画面から離れたら、またはマウス左ボタンが上がった時に呼び出される２つのメソッドerase_drops、release_dropsをこれから定義していく。\n###World.gd### # ドロップを消すメソッド func erase_drops(): # もしホールド中のドロップの数がつなげて消せる最小ドロップ数未満だったら if held_drops.size() \u0026lt; min_erasable: # メソッドを即時終了する return # ホールド中のドロップの配列を変数 erased の値として複製 var erased = held_drops.duplicate() # 配列 erased の要素に対してループ処理 for drop in erased: # 配列 erased に含まれるドロップを解放する drop.queue_free() # 消した分、新しいドロップを生成する spawn_drop() # 0.1 秒待機（それから次のループ） yield(get_tree().create_timer(0.1), \u0026#34;timeout\u0026#34;)\t# ドロップからホールドを解放するメソッド func release_drops(): # ホールド中ステータスを解除 is_holding = false # ホールド中のドロップの配列の要素対してループ for drop in held_drops: # 配列から取り出したドロップの AnimationPlayer で.. # アニメーションを停止する drop.anim_player.stop() # 配列から取り出したドロップの AnimationPlayer で.. # アニメーション\u0026#34;idle\u0026#34;を再生する drop.anim_player.play(\u0026#34;idle\u0026#34;) # ホールド中のドロップの配列を空っぽにする held_drops.clear() # DropsLine ノードの Points プロパティを空っぽにする drops_line.clear_points() 以上で「World.gd」スクリプトの編集は完了だ。\nシーンを実行して動作確認する 最後にシーンを実行して思った通りの動きが再現できるか確認してみよう。\n以下について想定通りであることが確認できただろうか。\nマウスカーソルがドロップの中央付近にある状態でマウス左ボタンを押すとドロップがホールド状態になり「flash」アニメーションが再生される マウス左ボタンを押したまま、隣接するドロップをなぞっていくと「DropsLine」の線がつながっていく なぞってきたドロップを戻ってなぞり直すとホールドが解除され「idle」アニメーションの再生に戻る なぞったドロップが3つ以上だとマウス左ボタンを離したときにホールド中のドロップが全て消える なぞったドロップが3つ未満だとマウス左ボタンを離してもドロップは消えずホールド解除のみされる サンプルゲーム 今回のチュートリアルで作成したプロジェクトをさらにブラッシュアップしたサンプルゲームを用意した。\nYour browser does not support the video tag. プロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートすれば確認していただけるはずだ。\nおわりに 今回のチュートリアルでは同じ色をなぞって消すパズルゲームを作った。ゲームの中毒性を感じずにはいられない種類のゲームだ。最後に作成におけるポイントをまとめておこう。\nドロップは RigidBody2D にして、エンジンに物理演算を任せる。 ドロップに、指やカーソルを検知するための Area2D クラスのノードと、隣接するドロップを検知するための Area2D クラスのノードを追加して、それらのシグナルを利用する。 指やマウスカーソルには Area2D クラスのノードを常に追随させ、ドロップとの接触にはこのノードのシグナルを利用する。 参照 KENNEY Godot Docs: 物理の紹介 Godot Docs: RigidBody2D Godot Docs: Area2Dの使用 Godot Docs: Area2D Godot Docs: CollisionShape2D Godot Docs: CollisionPolygon2D Godot Docs: Path2D Godot Docs: PathFollow2D Zenn:【Godot Engine】Path2D/PathFollow2Dを使って決まった経路で動かす方法 | syun77 Godot Docs: Line2D Qiita:【Godot】Line2Dを使ったトレイルの実装方法 | @2dgames_jp Godot Docs: Introduction to the animation features Godot Docs: AnimationPlayer UPDATE\n2022/06/20 変数holded_dropsのスペルをheld_dropsに修正（GitHubリポジトリ上のコードも修正）\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/","summary":"このチュートリアルでは、スマホゲームで大人気の ディズニーツムツムのような同じ色のドロップをなぞってつなげて消すタイプのゲームの作り方を説明する。ちなみにディズニーツムツムを知らない方は以下のリンク先を","title":"Godot3 で作る同じ色をつなげて消すパズルゲーム"},{"content":"このチュートリアルでは、2Dゲームにおける「グリッドベース移動」をどのように実装するのかを説明する。グリッドベース移動というのは、等間隔にグリッド（格子状の線）で区分されたゲームの画面上をキャラクターなどのオブジェクトが 1 グリッド（ 1 マス）ずつ移動する動きのことだ。\n人気スマホゲーム「パズル＆ドラゴンズ」や元祖落ちゲー「テトリス」などのパズルゲームはもちろん、「ファイヤーエムブレムシリーズ」「タクティクスオウガ」などのタクティカルシミュレーションゲームで、この動きを採用しているものは多いだろう。一方、「ファイナルファンタジー」シリーズや「ドラゴンクエスト」シリーズなどの RPG も、ファミコン用やスーパーファミコン用のソフトとして登場した 2D グラフィックの時代は、キャラクターの移動をよく見ると、このグリッドベース移動を行っている。このように、グリッドベース移動はさまざまなジャンルのゲームで使用されており、その汎用性はかなり高いと言える。\nこの記事では、できるだけグリッドベース移動の実装に絞って解説していく。また、最後にグリッドベース移動を使ったサンプルゲームも紹介するので、こちらもよかったら参考にしてほしい。\nなお、このチュートリアルで最後にできあがるプロジェクトのファイルは、GitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「End」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ、直接プロジェクトを確認していただくことも可能だ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.4\n・コンピュータのOS: macOS 11.6.5\nMemo: ゲームを作り始めるのに以下の記事もお役立てください。\nGodot をダウンロードする Godot のプロジェクトマネージャー Godot の言語設定 新規プロジェクトの作成 まずは Godot Engine を立ち上げて、新規プロジェクトを作成してほしい。プロジェクトの名前は「Grid Based Movement Tutorial」とでもしておこう。\nエディタが表示されたら、先にゲームのディスプレイサイズを設定しておこう。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 「window」で検索して、サイドバーの「Display」＞「Window」を選択する。 「Size」セクションで以下の項目の値を変更する。 Width: 256 Height: 160 Test Width: 1024 Test Height: 640\n「Stretch」セクションで以下の項目の値を変更する。 Mode: 2d Aspect: keep\n続いて、KENNEYのサイトからアセットをダウンロードして利用させてもらおう。今回利用するのは 1-Bit Pack というアセットパックだ。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nダウンロードしたら「Tilesheet」フォルダ内の「colored-transparent_packed.png」ファイルをエディタのファイルシステムドックへドラッグ\u0026amp;ドロップしてプロジェクトにインポートしよう。\nファイルをインポートした直後は画像がぼやけた感じになっているので、これを修正する。\nファイルシステムドックでインポートしたアセットファイルを選択した状態にする\nインポートドックで「プリセット」＞「2D Pixel」を選択する\n一番下にある「再インポート」ボタンをクリックする。\nこれでピクセルアート特有のエッジの効いた画像になる。\nWorld シーンを作る まず最初のシーンとして、ゲームの世界を用意する。「World」という名前のシーンを作成しよう。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Node2D」クラスのノードをルートノードとして選択。 ルートノードの名前を「World」に変更する。 一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://World/World.tscn」としてシーンを保存する。 ルートノードに「TileMap」ノードを追加する。 これでシーンツリーは以下のようになったはずだ。\nTileMap ノードを編集する TileMap ノードのプロパティを編集する シーンツリードックで「TileMap」ノードを選択し、インスペクターでプロパティを編集しよう。\n「TileSet」プロパティに「新規 TileSet」リソースを割り当てる。\n「Cell」＞「Size」プロパティの値を(x: 16, y: 16)にする。これから利用するスプライトシートのテクスチャのサイズ（縦横 16px）に合わせて設定した。\nTileSet リソースを編集する 続けて、「TileSet」プロパティに割り当てたリソース「TileSet」を編集していく。\nインスペクターでリソースをクリックする。\nGodot エディタ下部の「TileSet」パネルが開いたら、ファイルシステムドックからスプライトシートのリソース「res://colored-transparent_packed.png」をパネル内の左サイドバーにドラッグして追加する。追加したリソースをクリックして編集モードにしよう。\n「New Single Tile」を選択する。\n「領域(Region)」タブを選択したまま、グリッドスナップを有効にする。\nインスペクターで「Snap Options」＞「Step」を (x: 16, y: 16)にして、スプライトシートのテクスチャ一つ分と同じサイズにする。\n順番に「草」と「木」のテクスチャの領域を選択して、Single Tile として登録する。\n「木」のタイルは、「コリジョン(Collision)」タブを選択して、コリジョン形状も設定する。\n以上で TileSet リソースの編集は完了だ。\nTileMap を作成する ここからは先に作成した「TileSet」リソースのタイルを配置して TileMap を作成していく。\nシーンツリードックで「TileMap」を選択した状態にする。 2D ワークスペースのツールバーからグリッドスナップを有効にする。\n同じくツールバーの「Snapping Options」をクリックし、「Configure Snap」を選択する。\n「Configure Snap」の設定パネルが開いたら、「Grid Step」を (x: 16, y: 16) にして「OK」をクリックする。\nこれで 2D ワークスペース上に、縦横 16px ごとに区切られたグリッドが表示されていることだろう。「Grid Snap」を有効にしているので、「TileMap」の編集時は、簡単にグリッドに沿ってタイルを配置できるようになっているはずだ。\nでは 2D ワークスペースにタイルを配置していく。ここではシンプルに、あとで配置するプレイヤーキャラクターが外に出ないように画面の枠を「木」のタイルで囲って、その中に「草」のタイルを敷き詰めよう。\nこれで「TileMap」の編集は完了だ。\nPlayer シーンを作る ここからはプレイヤーキャラクターのシーンを作成する。このチュートリアルで実際にグリッドベース移動させるためのオブジェクトだ。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「KinematicBody2D」クラスのノードをルートノードとして選択。 ルートノードの名前を「Player」に変更する。 一旦ここでシーンを保存しておこう。フォルダを作成して、ファイルパスを「res://Player/Player.tscn」としてシーンを保存する。 ルートノードに「Sprite」ノードを追加する。 ルートノードに「CollisionShape2D」ノードを追加する。 ルートノードに「RayCast2D」ノードを追加する。 これで「Player」シーンツリーは以下のようになったはずだ。\nPlayer シーンの各ノードを編集する Sprite ノード たくさんのテクスチャをまとめた1枚のスプライトシートから使いたいテクスチャの範囲を指定してスプライトのテクスチャを設定する方法を採用する。\nインスペクターにて、「Texture」プロパティにリソースファイル「res://colored-transparent_packed.png」を適用する。\n「Offset」＞「Centered」プロパティをオフにする。これにより、このノードの位置（「Position」プロパティ）がテクスチャの中央ではなく左上角になり、ちょうどグリッドのマス目に収まるようになる。\n「Region」＞「Enabled」をオンにする。\nエディタ下部の「テクスチャ領域」パネルを開く。ここで行うのはスプライトシートの中の利用したいテクスチャの領域を指定する作業だ。\n作業しやすいように、展開アイコンをクリックしてパネルを広げる。\nパネル上部の「snapモード」で「グリッドスナップ」を選択する。\nパネル上部の「ステップ」を 16px 16px にする。これでグリッドのサイズがスプライトシートのテクスチャ 1 つ分と同じサイズになる。\nスプライトシート上でドラッグ操作により「王様」のテクスチャを範囲選択する。\nCollisionShape2D ノード このノードで「KinematicBody2D」クラスのルートノードに対してコリジョン形状を設定する。\nインスペクターにて、「Shape」プロパティに「新規 RectangleShape2D」リソースを適用する。\n「Sprite」ノードのテクスチャの位置に合わせるため、 「Transform」＞「Position」プロパティの値を (x: 8, y: 8) にする。\n2Dワークスペースにて、コリジョン形状を「Sprite」ノードのテクスチャのサイズに合わせる。\nインスペクターで直接入力する場合は、「RectangleShape2D」リソースのプロパティを以下のようにする。 Extents: (x: 8, y: 8) RayCast2D ノード このノードはグリッドベース移動での衝突判定にとても役に立つ。2D ワークスペース上は矢印型のコリジョン形状として表される。その矢印とオブジェクトが重なった場合に衝突を検知する。これを利用して、プレイヤーキャラクターの前方にあるオブジェクトとの衝突を検知させ、その先には進めないようにするなど制御することができる。\nインスペクターで、「Enabled」プロパティを On にしておく。これで衝突判定が可能になる。\n「Transform」＞「Position」プロパティを (x: 8, y: 8) にしておく。これは「Sprite」のテクスチャの中央に位置を合わせるためだ。\n「Cast To」プロパティの値を (x: 16, y: 0) にしておく。これは暫定的に初期値を設定しているだけで、実際にプロジェクトを実行したら、スクリプトでプレイヤーキャラクターを移動させるたびに値を変更することになる。\n2D ワークスペース上では以下のスクリーンショットのようになったはずだ。\n「Collide With」はデフォルトのまま「Areas」は Off、「Bodies」は On にしておく。さきほど作成したタイルセットの「木」のパネルは物理ボディなので「Bodies」にチェックが入っていれば、衝突が検知される。\nPlayer ノードにグリッドベース移動を実装する インプットマップを設定する 先にキーボードのキー入力でプレイヤーキャラクターを動かせるように、プロジェクト設定のインプットマップにアクションを追加する。\n「プロジェクト」メニュー＞「プロジェクト設定」を選択したら「Input Map」タブに切り替える。 以下の４つの「Action」を追加する。 move_right: D キー move_left: A キー move_down: S キー move_up: W キー *上下左右の矢印キーを割り当ててもOK\nスクリプトをアタッチして編集する まずはルートノード「Player」にスクリプトをアタッチする。ファイルパスを「res://Player/Player.gd」としてスクリプトファイルを作成しよう。\n作成後、スクリプトエディタが開いたら、スクリプトのコードを以下のように編集してほしい。\nextends KinematicBody2D #1 const inputs = { \u0026#34;move_right\u0026#34;: Vector2.RIGHT, \u0026#34;move_left\u0026#34;: Vector2.LEFT, \u0026#34;move_down\u0026#34;: Vector2.DOWN, \u0026#34;move_up\u0026#34;: Vector2.UP } #2 var grid_size = 16 #3 onready var raycast = $RayCast2D #4 func _unhandled_input(event): for action in inputs.keys(): if event.is_action_pressed(action): move(action) #5 func move(action): var destination = inputs[action] * grid_size raycast.cast_to = destination raycast.force_raycast_update() if not raycast.is_colliding(): position += destination スクリプトには、コメントで #1 ~ #5 まで番号を振っておいた。この順番に解説していく。\n#1: 辞書型の定数inputsを定義した。先に設定しておいたインプットマップのアクションと同じ名前の Key に対して、その値にはそれぞれのアクションで移動させたい Vector2 型の方向ベクトル（長さが 1 のベクトル）を指定した形だ。ちなみにVector2クラスの組み込み定数（RIGHTやDOWNなど）の値は以下の通りだ。\nVector2.RIGHT: Vector2(1, 0) Vector2.LEFT: Vector2(-1, 0) Vector2.DOWN: Vector2(0, 1) Vector2.UP: Vector2(0, -1) #2: プロパティgrid_sizeを定義した。値は「TileMap」のタイルのサイズと同じ16としている。\n#3: プロパティraycastを定義した。これは「RayCast2D」ノードを参照するプロパティだ。\n#4: 組み込み関数_unhandled_inputをオーバーライドした。これはキーボードやマウス、ジョイスティックなどからの入力があるとすぐに呼ばれるコールバック関数だ。別の関数_inputと似ているが、ここでは細かい違いは気にしなくて大丈夫だ。\n_unhandled_inputの中で、先に定義した辞書型定数inputsに対してループ処理を行っている。もし入力されたのがinputsのキー（move_leftやmove_upなど）と同じ名前のインプットマップアクションだった場合に、そのキーに対する値（例えばキーがmove_rightならVector2.RIGHT）を引数に渡してmoveというメソッドを呼んでいる。このmoveというメソッドはこのあと定義する。\n#5: メソッドmoveを定義している。このメソッドを呼ぶときは引数actionに値を渡す必要がある。\nまず変数destinationを定義している。値には、辞書型定数inputsから引数actionとマッチするキーに対する値（例えば、actionにmove_leftが渡されている場合はVector2.LEFT）にプロパティgrid_sizeを乗算した値が入る。つまり、プレイヤーが「D」キーを入力した場合、その値は Vector2(1, 0) x 16 = Vector2(16, 0) になる。これは右方向の 1 グリッド分の長さを持つベクトルだ。\n次に「RayCast2D」ノードのプロパティcast_toに先に定義した変数destinationの値を渡している。これでプレイヤーが入力したキーに合わせて「RayCast2D」の矢印の向きと長さが置き換わる。この置き換えをただちにアップデートするのが次の行で呼んでいるforce_raycast_updateというメソッドだ。これは「RayCast2D」ノードの組み込みだ。\n次の行ではif構文が記述されている。「RayCast2D」ノードの組み込みメソッドis_collidingは、現在このノード（矢印）がオブジェクトと衝突しているかどうかを Bool 型（trueかfalse）で返してくれる。ifの後にnotがあるので、このif構文の意味としては「もし『RayCast2D』ノードがオブジェクトと衝突していなければ』となる。\n上述のif構文で「RayCast2D」が他のオブジェクトと衝突していなかった場合、「Player」ノードのプロパティpositionの値にdestinationの値が加算される。つまりdestinationの値の分だけプレイヤーキャラクターが移動する、ということになる。例えば、現在の「Player」ノードの位置がVector2(64, 32)だとして、この時プレイヤーが「S」キーを一度押すと、現在の位置からVector2(0, 16)だけ移動するので、移動先の位置はVector2(64, 48)となる。つまり、現在の位置から下方向に 1 グリッド分移動したということだ。\n以上でグリッドベース移動の制御が実装できたはずだ。\nWorld シーンに Player シーンのインスタンスを追加する 「Player」シーンが完成したので、そのインスタンスを「World」シーンに追加して、タイルマップ上を移動させてみよう。\n「World.tscn」シーンを開く ルートノード「World」に「Player.tscn」シーンのインスタンスを追加する。\n2D ワークスペースで、画面の中央あたりの適当な位置に「Player」ノードを移動する。\n以上で作業は完了だ。\nグリッドベース移動の動作確認をする 作業が完了したので、実際にグリッドベース移動が問題なくできるかどうか確認してみよう。\n特に「Player」の子ノード「RayCast2D」の矢印型コリジョン形状も確認しやすくするため、先に「デバッグ(Debug)」メニューから「Visible Collision Shapes」のチェックを入れて有効にしておこう。\n初めてプロジェクトを実行する場合は Main Scene に「res://World/World.tscn」を選択してほしい。\nそれでは、プロジェクトを実行して、大草原の中を王様がグリッドベース移動で駆け回ることができるのか見てみよう。\n一回のキー入力で、タイル 1 つ分だけ移動しているのがよくわかる。また、わざと「木」のタイルの方向に移動しようとしても移動できないことも確認できた。\n以上で、グリッドベース移動のチュートリアルは完了だ。\nサンプルゲーム 今回のグリッドベース移動を利用したサンプルゲームを用意した。プロジェクトファイルは、GitHubリポジトリ に置いているので、そこから .zip ファイルをダウンロードしていただき、「Sample」フォルダ内の「project.godot」ファイルを Godot Engine でインポートしていただければ OK だ。\nYour browser does not support the video tag. このサンプルは、いわゆるモグラ叩きゲームだ。ゲームの設定として、プレイヤーは王様を操り、墓から出てくる王国の兵士たちの亡霊に向かって、聖なる指輪をかざして呪われた魂を解放する、というものだ。\n操作は以下の通りだ。\nD: 右に移動 A: 左に移動 S: 下に移動 W: 上に移動 スペース: 亡霊と向かい合わせの場合のみ指輪を掲げて亡霊の魂を解放する 亡霊は 1 秒以内に指輪で成仏させないと王様に呪いをかけてくる。呪われると Life が一つ減る。Life は最初 10 用意されているが、全てなくなったら王様は呪い殺されゲームオーバーになる。\n次の亡霊が出現するまでのインターバルは、ゲーム開始時の 2 秒から徐々に短くなり、最短 1 秒まで短くなる。\nちなみに私の最高スコアは 150 だ。これがすごいのか、大したことないのかはわからない。\n補足説明 最後にこのサンプルゲームのプロジェクトについて補足しておきたい。\nゲーム中、墓石から亡霊が出現するとき、「KinematicBody2D」クラスでコリジョン形状を設定済みの「Ghost」インスタンスと「TileMap」のコリジョンを設定した墓石のタイルが重なっている状態だ。このとき「Player」インスタンスの「RayCast2D」が墓石より亡霊との衝突判定を優先させるために少し工夫している。\n「TileSet」の編集で墓石のタイルを作るときに、タイルの 1/2 のサイズのコリジョンを設定しているのだ。先にインスペクターで「Snap Options」＞「Step」を (x: 4, y: 4)にしてからコリジョン形状を設定するとスムーズだ。もちろん「Ghost」のコリジョン形状は (x: 16, y: 16) になっている。\nおわりに 今回のチュートリアルでは2Dゲームにおけるグリッドベース移動の実装について解説した。パズルゲームやシミュレーションゲームなど、これからあなたが取り組むプロジェクトに応用いただける機会があれば幸いだ。\nグリッドベース移動のポイントをまとめておこう。\n以下を正確に設定する。 リソース「TileSet」で用意したタイルの縦横のサイズ 移動させるオブジェクト（今回は「Player」）のスプライトのサイズと位置 移動させるオブジェクトのコリジョン形状のサイズと位置 2D ワークスペースの Grid Step オブジェクトのノードにアタッチしたスクリプトでの移動距離を表すプロパティの値（今回はgrid_size） 移動させるオブジェクトと他のオブジェクトとの衝突判定には「RayCast2D」を利用する。「RayCast2D」の向きとサイズはスクリプトで制御する。 プレイヤーの操作でオブジェクトを移動させるには、インプットマップのアクションを登録しておき、スクリプトでそれぞれの入力に対して移動する方向を制御する。 参照 KENNEY Godot Docs: RayCast2D Godot Docs: Using TileMaps Godot Docs: TileSet KidsCanCode: Grid-based movement YouTube: Grid-based movement Godot 3 demo overview YouTube: Make your first 2D grid-based game from scratch in Godot ","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0010_2d_grid_based_movement/","summary":"このチュートリアルでは、2Dゲームにおける「グリッドベース移動」をどのように実装するのかを説明する。グリッドベース移動というのは、等間隔にグリッド（格子状の線）で区分されたゲームの画面上をキャラクター","title":"Godot3 で作る 2D グリッドベース移動"},{"content":"このチュートリアルでは、2Dトップダウンシューティングにおける「ホーミングミサイル」を作っていく。ホーミングミサイルというのは、ターゲットを追跡するミサイルのことだ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.2\n・コンピュータのOS: macOS 11.6.5\nこのチュートリアルでは、ホーミングミサイルの作成にフォーカスするため、それ以外の部分は事前に下準備として作成済みだ。\nこのチュートリアルのプロジェクトファイルは GitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「Start」フォルダの中の「project.godot」ファイルを Godot Engine にインポートしていただければ、下準備だけ完了したプロジェクトを開始できる。また、取り急ぎ完成形を確認されたい場合は「End」フォルダの方の「project.godot」ファイルをインポートしていただければOKだ。\nなお、今回プロジェクトにインポートしてあるアセットは全て KENNEY（ケニー） のサイトからダウンロードさせていただいた。今回利用したのは Tower Defense (top-down) というアセットパックだ。このような素晴らしいアセットパックを公開いただいていることに、ただただ感謝である。\n下準備 以下のゲームの仕様のうち、（予定）と記載しているホーミングミサイルの部分以外は、すでに下準備として作成済みだ。\nプレイヤーキャラクター（飛行機）: 以下のキーで操作可能。 move_up: W キー・・・プレイヤーキャラクターが上に移動する move_down: S キー・・・プレイヤーキャラクターが下に移動する move_right: D キー・・・プレイヤーキャラクターが右に移動する move_left: A キー・・・プレイヤーキャラクターが左に移動する magic: スペースキー、またはマウス左ボタン・・・マシンガンを撃つ マシンガンの弾は敵キャラクターの戦車とそれが発射するホーミングミサイルに当たると消える。 マシンガンの弾は画面外に出たら消える。 敵キャラクター（戦車）: ゲーム画面上に最大5機現れる。残りが 0 機になると新たに 5 機生成される。 常にプレイヤーキャラクターの方に向かって移動してくる。 プレイヤーが一定距離まで近づくと、ホーミングミサイル を発射する（予定）。 ホーミングミサイルは、プレイヤーキャラクターかマシンガンの弾が当たると消える（予定）。 HUD: 左上に表示されている Life と Score のみのシンプルな HUD（ヘッズアップディスプレイ）。 Life: プレイヤーキャラクターの残機数（最大 5）。プレイヤーの飛行機に戦車のホーミングミサイルが命中すると 1 減り、0になるとゲームオーバー（デバッグパネルが閉じる）。 Score: 戦車にマシンガンの弾が命中すると敵キャラクターのライフ（最大 3）が 1 減り、0 になって戦車を破壊すると 1 ポイント加算される。\nそれでは、Godot Engine で「Start」フォルダの方のプロジェクトを開いて、ホーミングミサイルを実装していこう。\nホーミングミサイルを作る シーンを作る まずは以下の手順でホーミングミサイルのシーンを作成する。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Area2D」クラスのノードをルートノードとして選択。 ルートノード「Area2D」の名前を「Missile」に変更する。 一旦ここでシーンを保存しておく。ファイルパスを「res://Enemy/Missile.tscn」とする。 次にルートノード「Missile」に子ノードを追加していく。\nルートノード「Missile」に「Sprite」クラスのノードを追加する。これはミサイルの見た目だ。 ルートノード「Missile」に「CollisionShape2D」クラスのノードを追加する。これはミサイルがプレイヤーの飛行機やそれが放ったマシンガンの弾との衝突を検知するために利用する。 ルートノード「Missile」に「Timer」クラスのノードを追加する。これはミサイルのインスタンスを一定時間経過後に解放するためだ。 シーンツリーは以下のようになったはずだ。\nノードのプロパティを編集する インスペクターで、シーンツリーの各ノードのプロパティを編集していこう。\nMissile (Area2D) ルートノード 「CollisionObject2D」クラスの「Collision」＞「Layer」プロパティと「Collision」＞「Mask」プロパティを編集する。\n「Layer」プロパティは、そのオブジェクト（ここでは「Missile」ノード）をどのコリジョンレイヤーに割り当てるかを設定できる。\n「Mask」プロパティは、そのオブジェクトがどのコリジョンレイヤーのオブジェクトとの衝突を有効にするかを設定できる。つまり、「Mask」プロパティで選択しなかったレイヤーのオブジェクトとは位置が重なっても衝突せずに互いに通り抜ける。例えば、ホーミングミサイルは敵キャラクターの戦車との衝突は無視されて通過するが、プレイヤーキャラクターやマシンガンの弾との衝突は検出される必要がある。プレイヤーキャラクターの飛行機は戦車の上を飛んでいるため、戦車との衝突は無視され、ホーミングミサイルとの衝突は検出される必要がある。\nどのコリジョンレイヤーにどのオブジェクトを割り当てるのかわかりやすくするため、以下の手順で、すでに使用するコリジョンレイヤーに名前をつけておいた。\n「プロジェクト」メニュー＞「プロジェクト設定」を開く。 サイドバー「Layer Names」＞「2d Physics」を選択する。 Layer 1 ~ 4 まで、以下の通りに名前を設定する。 Layer 1: Player Layer 2: Enemies Layer 3: PlayerBullets Layer 4: EnemyMissiles\n上記のコリジョンレイヤーの名前に合わせて、プレイヤーキャラクター、マシンガンの弾、敵キャラクターの「Layer」プロパティと「Mask」プロパティは以下の通りに設定済みである。\nプレイヤーキャラクター: Player.tscn シーン \u0026gt; Player（KinematicBody2D）ルートノード Layer プロパティ: Layer 1 Mask プロパティ: Layer 4（ミサイルとの衝突を検知）\n敵キャラクター: Enemy.tscn シーン \u0026gt; Enemy（KinematicBody2D）ルートノード Layer プロパティ: Layer 2 Mask プロパティ: Layer 2, 3（他の戦車とマシンガンの弾との衝突を検知）\nマシンガンの弾: Bullet.tscn シーン \u0026gt; Bullet（Area2D）ルートノード Layer プロパティ: Layer 3 Mask プロパティ: Layer 2, 4（戦車とホーミングミサイルとの衝突を検知）\nそして、今編集中のホーミングミサイルも同様に以下のように設定してほしい。\nホーミングミサイル: Missile.tscn \u0026gt; Missile（Area2D）ルートノード Layer プロパティ: Layer 4 Mask プロパティ: Layer 1, 3（飛行機とマシンガンの弾との衝突を検知）\nルートノード「Missile」のプロパティの編集ができたら、ついでにこのノードを「Missiles」というグループを作って追加しておこう。これはマシンガンの弾がミサイルにヒットした時に、ミサイルかどうかを判別するのに用いている。\nシーンツリードックで「Missile」を選択する ノードドック＞グループタブを開いて「Missiles」のグループを追加する。\nSprite ノード たくさんのテクスチャをまとめた1枚のスプライトシートから使いたいテクスチャの範囲を指定してスプライトのテクスチャを設定する方法を採用する。\nインスペクターにて、「Texture」プロパティにリソースファイル「res://towerDefense_tilesheet.png」を適用する。\n「Region」＞「Enabled」をオンにする。\nエディタ下部の「テクスチャ領域」パネルを開き、スプライトシートの中の利用したいテクスチャの領域を指定する。\n作業しやすいように、展開アイコンをクリックしてパネルを広げる。\n「テクスチャ領域」パネル上部の「snapモード」で「グリッドスナップ」を選択する。\n同じくパネル上部の「ステップ」を 64px 64px にする。これでグリッドのサイズがスプライトシートのスプライトと同じサイズになる。\nスプライトシート上で大きい方のミサイルのテクスチャを選択する。\nインスペクターに戻り、「Transform」＞「Rotation」プロパティを 90 にする。\nこれで 90° テクスチャが回転した状態になる。通常オブジェクトの向きは正のx軸方向が 0° であり、ミサイルの進行方向もこれを基準にするため、それに合わせてスプライトの向きも調整した。\nCollisionShape2D ノード このノードでホーミングミサイルのコリジョン形状を設定する。ミサイルとプレイヤーキャラクターとの衝突判定のために必須であり、システム上「Area2D」クラスのノードにコリジョン形状を設定する子ノードが追加されていないとアラートが表示されるようになっている。\nインスペクターにて、「Shape」プロパティに「新規 CapsuleShape2D」リソースを適用する。\n2Dワークスペースにて、コリジョン形状を「Sprite」ノードのテクスチャのサイズに合わせる。\nインスペクターで直接入力する場合は、「CapsuleShape2D」リソースのプロパティを以下のようにする。 「Radius」プロパティを 8 にする。 「Height」プロパティを 24 にする。\nTimer ノード このノードは、ホーミングミサイルが一定時間経過後に自爆するためのタイマーだ。いつまでもゲームの中にミサイルが存在し続けると、ミサイルの数が膨れ上がって、コンピュータのメモリが不足して処理しきれなくなる。それを回避するため、時間切れによりインスタンスを解放する仕様にする。直線的に飛んでいくミサイルなら画面外に出た時に「VisibilityNotifier2D」ノードのシグナルを使ってインスタンスを解放することも可能だが、プレイヤーキャラクターを追尾するホーミングミサイルではタイマーの方が適切だ。\nインスペクターにて、「Wait Time」プロパティを 3 にする。これはミサイルの有効時間だ。お好みで微調整いただいて良いのだが、長すぎるとミサイルが同時に複数存在しすぎてメモリ消費が多くなるので注意してほしい。 「One Shot」プロパティをオンにする。 「Auto Start」プロパティをオンにする。\n以上で、インスペクターでの各ノードのプロパティ編集は完了だ。\nスクリプトで制御する 次はスクリプトを作成して、ミサイルを制御していく。ルートノード「Missile」に新しいスクリプトをアタッチしてほしい。ファイルパスは「res://Enemy/Missile.gd」として作成する。\nまずは以下のように「Missile.gd」スクリプトを編集しよう。\n###Missile.gd### extends Node2D # ミサイルのスピード export var speed = 400 # ミサイルのベロシティ（方向の要素を持った速度） var velocity = Vector2() # 物理プロセス（60FPS: 60回/秒呼ばれる組み込みメソッド） func _physics_process(delta): # ベロシティ（方向性をもつ速度） = 現在の向き x スピード velocity = transform.x * speed # 位置を更新： 現在の位置 + ベロシティ x delta（1フレームの秒数） position += velocity * delta # 向きを更新：現在のベロシティに合わせる rotation = velocity.angle() さて、これでひとまずミサイルが真っ直ぐ飛んでいくようにはなったはずだ。シーンを実行して確認してみよう。\nGIF画像の上端部分をミサイルが左から右に飛んでいくのがわかるだろうか。\n続いて、プレイヤーキャラクターを追尾する動きをスクリプトに追加していく。まずは必要なプロパティをいくつか定義しておこう。以下のコードの「# 追加」とコメントしている箇所を追加してほしい。\n###Missile.gd### extends Node2D export var speed = 400 # 追加：プレイヤーのいる方向へ舵を切る力 # 値が大きいほど素早く方向を修正できる export var steering_force = 20.0 var velocity = Vector2() # 追加：加速度 var acceleration = Vector2() # ターゲットである Player オブジェクトの参照（検出され次第） var target = null 次にミサイルがプレイヤーキャラクターの方へ舵を切る（軌道修正する）メソッドを定義する。\n###Missile.gd### # ミサイルがプレイヤーキャラクターの方へ舵を切るメソッド func steer(): # 舵を切るベロシティとして定義 var steering = Vector2() # 理想のベロシティ（現在の位置から見たプレイヤーキャラクターへの方向 x スピード）を定義 var ideal_velocity = (target.position - position).normalized() * speed # 舵を切る速度 = （理想のベロシティ - 現在のベロシティ）で得た方向ベクトル x 舵を切る力 steering = (ideal_velocity - velocity).normalized() * steering_force # 舵を切るベロシティを出力 return steering コード上のコメントだけではイメージしにくいと思われるため、図で補足しておく。\nホーミングミサイルはプレイヤーキャラクターの飛行機を検知したら、それをtargetとして追尾する。このとき、ミサイルがtargetの方向へ直線で移動できたと仮定した場合の理想のベロシティが変数ideal_velocityだ。しかし実際には、ミサイルはプロパティvelocityの持つ方向で飛んでいるため、ideal_velocityの方へ舵を切って軌道修正したい。そこでベクトルの計算になる。ideal_velocityからvelocityを引いたベクトルをメソッドnormalizedで方向ベクトル（長さが 1 のベクトル）にして、それに舵を切る力であるプロパティsteering_forceの値を乗算すれば、舵を切るベロシティである変数steeringの値が定まる。\nではこのメソッドsteerで出力される変数steeringの値を利用して、ミサイルが軌道修正しながら飛行するように修正しよう。「# 追加」とコメントした箇所をメソッド_physics_processに追加してほしい。\n###Missile.gd### func _physics_process(delta): velocity = transform.x * speed # 追加：加速度に舵を切るベロシティを加算していく acceleration += steer() # 追加：ベロシティに 加速度 x delta の値を加算していく velocity += acceleration * delta # 追加：ベロシティのベクトルの長さがスピードを超えないように制限する velocity = velocity.clamped(speed) position += velocity * delta rotation = velocity.angle() これでホーミングミサイルがプレイヤーキャラクターを追尾する動きが実装できたはずだ。\n続けて、プレイヤーキャラクターやマシンガンの弾に衝突した時のプログラムを追加しよう。これにはルートノード「Missile」の Area2D クラスのシグナルを利用する。\nではシーンツリードックで「Missile」を選択したら、ノードドック＞シグナルタブでシグナル「body_entered(body: Node)」をこの「Missile.gd」スクリプトに接続しよう。\n接続後、自動的に生成されたメソッド_on_Missile_body_enteredは以下のように編集する。\n###Missile.gd### # ミサイルに物理ボディが衝突したら発信するシグナルで呼ばれるメソッド func _on_Missile_body_entered(body): # 物理ボディがプレイヤーキャラクターだったら if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Missile hit \u0026#34;, body.name) # Player シーンの AnimationPlayer のアニメーション hit を再生する body.anim_player.play(\u0026#34;hit\u0026#34;) # Player ノードのシグナル player_hit を発信する body.emit_signal(\u0026#34;player_hit\u0026#34;) # Player の Life が 1 より大きかったら -1 する if body.life \u0026gt; 1: body.life -= 1 # 1 以下の場合 else: # アニメーション hit の再生終了を待つ yield(body.anim_player, \u0026#34;animation_finished\u0026#34;) # Player オブジェクトを解放する body.queue_free() print(\u0026#34;Game Over!\u0026#34;) # デバッグパネルを閉じて終了 get_tree().quit() # ミサイル自身も解放する queue_free() これでミサイルがプレイヤーキャラクターの飛行機に当たったらアニメーション（赤く点滅）して Life が一つ減り、5 機なくなったらゲームオーバーになる仕組みが実装できた。\n続いて「Timer」ノードのタイマーを利用して時間切れになったらミサイルを解放する仕組みを作る。これも「Timer」ノードのシグナルを利用する。ではシーンツリードックで「Timer」を選択したら、シグナル「timeout()」をスクリプトに接続しよう。\n接続して生成されたメソッド_on_Timer_timeoutはシンプルにメソッドqueue_freeを実行するだけでOKだ。\n###Missile.gd### func _on_Timer_timeout(): queue_free() ひとまずここまででミサイルの基本は完成だ。\n敵キャラクターにホーミングミサイルを発射させる 次は「Enemy.tscn」シーンの方で、作成したばかりの「Missile.tscn」シーンのインスタンスを生成して、敵キャラクターの戦車がホーミングミサイルを発射するようにしていく。\nスクリプトを編集して制御する それでは「Enemy.tscn」シーンのルートノード「Enemy」にアタッチしている「Enemy.gd」スクリプトを開いて編集していこう。\nまず先にミサイルのシーンファイルをプリロードしておこう。スクリプトの冒頭で参照用の定数を定義しておく。「# 追加」のコメントが目印だ。\n###Enemy.gd### extends KinematicBody2D signal enemy_killed # 追加：プリロードした Missile.tscn シーンファイルの参照 const missile_scn = preload(\u0026#34;res://Enemy/Missile.tscn\u0026#34;) 次に、メソッド_on_Timer_timeoutのブロックにはpassしか記述されていない状態なので、これを以下のように更新してほしい。ちなみに、このメソッドは「LaunchTimer」ノード（Timer クラス）のシグナル「timeout()」を接続して生成されたものだ。つまり、タイマーがタイムアウトするたびにこのメソッドが呼ばれる。\n###Enemy.gd### # LaunchTimer ノードがタイムアウトしたら発信されるシグナルで呼ばれるメソッド func _on_LaunchTimer_timeout(): # 親ノード（World）に Player という名前のノードがある場合 if get_parent().has_node(\u0026#34;Player\u0026#34;): # ミサイル発射のメソッドを呼ぶ launch_missile() 最後のメソッドlaunch_missileはこれから定義するところだ。\nそれではメソッドlaunch_missileを定義した以下のコードを、上記_on_LaunchTimer_timeoutの後に挿入してほしい。\n###Enemy.gd### # ミサイルを発射するメソッド func launch_missile(): # Missile.tscn シーンをインスタンス化 var missile = missile_scn.instance() # Missile の target プロパティに Player オブジェクトを代入 missile.target = get_parent().get_node(\u0026#34;Player\u0026#34;) # 親ノード（World）にミサイルのインスタンスを追加 get_parent().add_child(missile) # ミサイルの位置を戦車の大砲の先端に合わせる missile.position = muzzle.global_position # ミサイルの向きを戦車の大砲の先端の向きに合わせる missile.rotation = muzzle.global_rotation これでミサイルが発射されるはずだ。ここまでの作業がうまくいったか、プロジェクトを実行して確認してみよう。\nおまけ：演出を追加する 演出用に、下準備の段階でミサイルが当たった時の爆発のパーティクルと、ミサイルの後ろから出る煙のパーティクルを用意している。これらを「Missile.gd」スクリプトにコードを追加して利用し、見た目上の演出を咥えよう。\n「Missile.gd」スクリプトを開いたら、「# 追加」の行をコードに追加してほしい。\n###Missile.gd### # 追加：Smoke.tscn（煙のパーティクルだけのシーン）のプリロード参照 const smoke_scn = preload(\u0026#34;res://Effect/Smoke.tscn\u0026#34;) # 追加：Explosion.tscn（爆発のパーティクルだけのシーン）のプリロード参照 const explosion_scn = preload(\u0026#34;res://Effect/Explosion.tscn\u0026#34;) export var speed = 400 export var steering_force = 20.0 var velocity = Vector2() var acceleration = Vector2() var target = null # 追加：煙が出る間隔を空けるためのカウント var smoke_count = 0 次は_physics_processメソッド内で煙を出すメソッドを呼ぶ。\n###Missile.gd### func _physics_process(delta): velocity = transform.x * speed acceleration += steer() velocity += acceleration * delta velocity = velocity.clamped(speed) position += velocity * delta rotation = velocity.angle() # smoke_count に delta の値を加算する smoke_count += delta # smoke_count が 0.05 より大きければ if smoke_count \u0026gt; 0.05: # smoke_count を 0 に戻して smoke_count = 0 # 煙を出すメソッドを呼ぶ spawn_smoke() そして、最後の煙を出すメソッドspawn_smokeは以下のように定義しよう。このコードはsteerメソッドの下あたりに挿入しておけば良いだろう。\n###Missile.gd### # 煙を出すメソッド func spawn_smoke(): # 煙のパーティクルのシーンをインスタンス化 var smoke = smoke_scn.instance() # 親ノード（World）にインスタンスノードを追加 get_parent().add_child(smoke) # 煙を現在のミサイルの位置に置く smoke.position = global_position # 煙の向きを現在のミサイルの向きに合わせる（あまり意味はないが） smoke.rotation = global_rotation 続いて、今度は爆発のパーティクルを発生させるメソッドを定義する。これは上記メソッドspawn_smokeの下に追加すればOKだ。\n###Missile.gd### # 爆発させるメソッド func explode(): # 爆発のパーティクルのシーンをインスタンス化 var explosion = explosion_scn.instance() # 親ノード（World）にインスタンスノードを追加 get_parent().add_child(explosion) # 爆発パーティクルを現在のミサイルの位置に置く explosion.position = global_position # 爆発パーティクルの向きを現在のミサイルの向きに合わせる（あまり意味はないが） explosion.rotation = global_rotation 以下の「# 追加」コメントがある3箇所でメソッドexplodeを呼び出すようにコードを更新しよう。\n###Missile.gd### func _on_Missile_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Missile hit \u0026#34;, body.name) body.anim_player.play(\u0026#34;hit\u0026#34;) body.emit_signal(\u0026#34;player_hit\u0026#34;) if body.life \u0026gt; 1: body.life -= 1 else: explode() # 追加 yield(body.anim_player, \u0026#34;animation_finished\u0026#34;) body.queue_free() print(\u0026#34;Game Over!\u0026#34;) get_tree().quit() explode() # 追加 queue_free() func _on_Timer_timeout(): explode() # 追加 queue_free() 更新は以上だ。最後にもう一度プロジェクトを実行して、追加した演出を確認してみよう。\nところで、煙と爆発いずれのパーティクルも「Particles2D」クラスのノードを使用している。macOS ではこのノードを使うとパフォーマンスが低下する問題があるようだ。私は macOS 利用者だが、確かに動作遅延が生じた。上のGIF画像でもわかるレベルだ。\nもし macOS を利用されている場合は、シーンツリードックでルートノード（Particles2D クラス）を選択した状態で、ツールバーの「Paricles」から「Convert to CPUParticles2D」を利用して「CPUParticles2D」クラスに変換できるようだ。\nおわりに 今回のチュートリアルでは、トップダウンシューティングにおけるホーミングミサイルを作った。作成する際のポイントをまとめておこう。\nミサイルシーンはインスタンスが追加されたらすぐに自分で飛んでいくようにプログラムしておく。 ミサイルの追尾の動きを再現するには、物理プロセスで毎フレーム以下を順次実行する。 ターゲット（このチュートリアルの「Player」）に対する方向ベクトルにスピードを乗算して理想のベロシティを求める 理想のベロシティと実際のベロシティの差のベクトルをノーマライズして舵を切るべき方向を求める 舵を切るべき方向に予めプロパティで定義済みの舵を切る力を乗算して舵を切る速度を求める。 現在の加速度に舵を切る速度を加算する。 現在のベロシティに更新した加速度を加算する。 ミサイルのシーンのインスタンスを作成する時は、回転したり移動したりするオブジェクト（このチュートリアルの「Enemy」）の子ではなく、例えば、そのオブジェクトの親ノード（このチュートリアルの「World」）などで動かないオブジェクトの子にすると正しく飛んでいく。 メモリ消費を抑制するため、Timerのシグナルを利用し、タイムアウトでミサイルのインスタンスが解放されるようにする。 リンク このチュートリアルの作成にあたって、KidsCanCodeのYouTube動画や記事が非常に参考になった。この場を借りて感謝申し上げたい。より理解していただくのに、それらのコンテンツも併せてご覧いただくことをお勧めする。\nGodot Docs: RayCast2D YouTube: Make your first 2D grid-based game from scratch in Godot YouTube: Grid-based movement Godot 3 demo overview KidsCanCode: Grid-based movement UPDATE\n2022/05/28 「リンク」のリンク修正、「リンク」にコメント追加。\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0008_homing_missiles/","summary":"このチュートリアルでは、2Dトップダウンシューティングにおける「ホーミングミサイル」を作っていく。ホーミングミサイルというのは、ターゲットを追跡するミサイルのことだ。 Environment このチュートリアルは以下の環境で","title":"Godot3 で作るホーミングミサイル"},{"content":"このチュートリアルでは、2Dトップダウンシューティングゲームの「弾幕」を作っていく。弾幕というのは、敵キャラクターから放たれる大量の弾（またはそれに類似する遠距離攻撃）のことで、弾が幕のように隙間なく飛んでくるので「弾幕」という。プレイヤーはその隙間を縫うようにうまくかわしながら、敵キャラクターを射撃して倒していくゲームを弾幕シューティングゲームという。単に弾幕をかわすことに特化したゲームもある。イメージに合う宇宙船や戦闘機をモチーフにしたゲームが多いのも特徴だ（今回は魔法使いとモンスターの地上戦だが）。\nこのチュートリアルでは、弾幕の作成のみにフォーカスする。また、弾幕も様々な形状があるが、今回取り扱うのは回転式の弾幕だ。\nEnvironment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.2\n・コンピュータのOS: macOS 11.6.5\nこのチュートリアルのプロジェクトファイルは GitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「Start」フォルダの中の「project.godot」ファイルを Godot Engine にインポートしていただければ、下準備だけ完了したプロジェクトから開始できる。また、取り急ぎ完成形を確認されたい場合は「End」フォルダの方の「project.godot」ファイルをインポートしていただければOKだ。\nなお、今回プロジェクトにインポートしてあるアセットは全て KENNEY（ケニー） のサイトからダウンロードさせていただいた。今回利用したのは 1-Bit Pack というアセットパックだ。この素晴らしすぎる無料の素材に感謝せずにはいられない。\nさて、Godot Engine で「Start」フォルダの方のプロジェクトを開くと、あらかじめ以下は作成済みの状態になっている。\nプレイヤーキャラクター（魔法使い） プレイヤーキャラクターの遠距離攻撃（魔法） 敵キャラクター（モンスター、今回はこれに弾幕を放たせる） ゲームワールド（上記のオブジェクトが存在するゲームの世界） まずは一度、下準備だけ完了している「Start」フォルダの方のプロジェクトを実行してどのような状態か確認してみてほしい。\nゲームの設定は以下のようになっている。\nプレイヤーキャラクターは以下のキーで移動操作と魔法の遠距離攻撃が可能。 move_up: W キー・・・プレイヤーキャラクターが上に移動する move_down: S キー・・・プレイヤーキャラクターが下に移動する move_right: D キー・・・プレイヤーキャラクターが右に移動する move_left: A キー・・・プレイヤーキャラクターが左に移動する magic: スペースキー、またはマウス左ボタン・・・魔法を放つ プレイヤーキャラクターは敵キャラクターの弾が10回ヒットしたら死ぬ。 プレイヤーキャラクターが死んだらゲームオーバー（自動的にデバッグパネルが閉じる）。 敵キャラクターは現時点では移動のみ可能。 敵キャラクターは2秒おきにプレイヤーキャラクターの方へ向かってくる。 敵キャラクターは魔法が5回ヒットすると死ぬ。 敵キャラクターに魔法がヒットして赤白点滅している間は魔法が効かない。 敵キャラクターが死ぬと、次の敵キャラクターがプレイヤーキャラクターから半径50px以内に出現する。 敵キャラクターの見た目は毎回ランダムで変わる プレイヤーキャラクターの魔法は放たれてから1秒後に消える。 ゲームの世界は無制限に移動できる。 弾を作る 弾幕を作るにはそれを構成する一つひとつの弾が必要だ。ということで、まずは弾のシーンから作成していく。\nシーンを作成する 以下の手順で弾のシーンを新規で作成する。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」にて「その他のノード」を選択する。 「Area2D」クラスのノードをルートノードとして選択。 ルートノード「Area2D」の名前を「Bullet」に変更する。 一旦ここでシーンを保存しておく。ファイルパスを「res://Enemy/Bullet.tscn」とする。 シーンにノードを追加する 次にルートノード「Bullet」に子ノードを追加していく。\nルートノード「Bullet」に「Sprite」クラスのノードを追加する。これは弾の見た目だ。 ルートノード「Bullet」に「CollisionShape2D」クラスのノードを追加する。これは弾が物理ボディと衝突したことを検知するために利用する。 ルートノード「Bullet」に「VisibilityNotifier2D」クラスのノードを追加する。これは弾が画面外に出たことを検知するために利用する。 公式オンラインドキュメント: VisibilityNotifier2D シーンツリーは以下のようになったはずだ。\nノードのプロパティを編集する 続けてそれぞれのノードのプロパティを編集していく。\nBullet（Area2D）ノード このルートノードのプロパティの編集は不要。\nSprite ノード 今回は、たくさんのテクスチャをまとめた1枚のスプライトシートから使いたいテクスチャの範囲を指定してスプライトのテクスチャを設定する方法を採用する。\nインスペクターにて、「Sprite」ノードの「Texture」プロパティにリソースファイル「res://colored-transparent_packed.png」を適用する。\n「Region」＞「Enabled」をオンにする。\nエディタ下部の「テクスチャ領域」パネルを開き、スプライトシートの中の利用したいテクスチャの領域を指定する。\nまず、見やすいようにパネルをエディタ最上部まで広げたら、スプライトシートを見やすい大きさまで拡大する。 「テクスチャ領域」パネル上部の「snapモード」で「グリッドスナップ」を選択する。\n同じくパネル上部の「ステップ」を 16px 16px にする。これでグリッドのサイズがスプライトシートのスプライトと同じサイズになる。\nスプライトシート上で弾に適用したいテクスチャを選択する。このチュートリアルではドクロのテクスチャを選択した。モンスターがドクロの弾幕を放ってくるというのが、なんとも恐怖である。\nインスペクターに戻り、「Visibility」＞「Modulate」プロパティで色をお好みの弾の色に変更する。ここではサンプルとしてやや不気味な紫系の色 #9da4d8 にした。\nCollisionShape2D ノード このノードで弾のコリジョン形状を設定する。弾とプレイヤーキャラクターとの衝突判定のために必須であり、システム上「Area2D」クラスのノードにコリジョン形状を設定する子ノードが追加されていないとアラートが表示される。\nインスペクターにて、「Shape」プロパティに「新規CircleShape2D」リソースを適用する。\n2Dワークスペースにて、コリジョン形状を「Sprite」ノードのテクスチャのサイズに合わせる。\nインスペクターで直接入力する場合は、「CircleShape2D」リソースの「Radius」プロパティを 8 にする。\nVisibilityNotifier2D ノード このノードのプロパティの編集は不要。\nスクリプトで弾を制御する 次はスクリプトをプログラミングして、弾を制御する。ルートノード「Bullet」に新しいスクリプトをアタッチしよう。ファイルパスを「res://Enemy/Bullet.gd」として作成する。\nまずは以下のようにスクリプトを編集しよう。\n###Bullet.gd### extends Node2D # 弾の秒速 export var speed = 150 # 物理プロセス（60回/秒呼ばれるメソッド） func _physics_process(delta): # 現在の弾の位置に現在の弾の方向×秒速×1フレームの時間.. # を加算して毎フレーム弾を移動させる position += transform.x * speed * delta 次に、ルートノード「Bullet」は Area2D クラスなので、このシグナルを利用して、物理ボディに衝突したら弾が消えるようにする。さっそくインスペクターで「Bullet」を選択し、ノードドック＞シグナルタブでシグナル「body_entered(body)」をこの「Bullet.gd」スクリプトに接続しよう。\nシグナルを接続して生成されたメソッド_on_Bullet_body_entered内でメソッドqueue_freeを実行する。\n###Bullet.gd### # 物理ボディが衝突したら発信されるシグナルで呼ばれるメソッド func _on_Bullet_body_entered(body): # Bullet を解放する queue_free() 同様に、「VisibilityNotifier2D」ノードのシグナルを利用して、画面外に出たら弾が消えるようにする。「VisibilityNotifier2D」のシグナル「screen_exited()」をこの「Bullet.gd」スクリプトに接続しよう。\nシグナルを接続して生成されたメソッド_on_VisibilityNotifier2D_screen_exitedの中にメソッドqueue_freeを実行する。\n###Bullet.gd### # 画面外に出たら発信されるシグナルで呼ばれるメソッド func _on_VisibilityNotifier2D_screen_exited(): # Bullet を解放する queue_free() これで弾の完成だ。このあとは、作成した弾シーンのインスタンスを敵キャラクターのシーンツリーに追加する形で、敵キャラクターが弾を放てるようにしていく。\n弾幕を作る スクリプトで弾幕を制御する ここからは、敵キャラクターの「Enemy.tscn」シーンのルートノード「Enemy」にアタッチしているスクリプト「Enemy.gd」を編集して、弾幕を制御していく。スクリプトエディタで「Enemy.gd」を開いたら、まずは必要なプロパティを定義しよう。以下のコードの中の「# 追加」とコメントしている箇所のコードを追加してほしい。\n###Enemy.gd### extends KinematicBody2D signal died # 追加：プリロードしたBullet.tscnシーンファイルの参照 const bullet_scn = preload(\u0026#34;res://Enemy/Bullet.tscn\u0026#34;) var enemy_life = 5 var enemy_speed = 800 var delta_count = 0 # 追加：Enemyの中心から弾の発射位置までの距離 var radius = 20 # 追加：Enemyを中心とした弾の発射位置の回転速度 export var rotate_speed = 40 # 追加：弾を発射する間隔（秒） export var interval = 0.4 # 追加：一度に発射する弾の数 export var spawning_count = 4 コード内のコメントだけでは少しイメージしにくいかもしれないので、図をつけておく。\nご覧の通り、「Enemy」を中心とし、プロパティradiusの値を半径とした円をイメージするとわかりやすい。プロパティspawning_countで指定した一度に発射される弾のうち、1つ目の発射位置を必ず（x: radius, y: 0）として、２つ目以降の弾はそこからこの円の円周上に等間隔（角度差）で配置されるようにする。それらの弾の発射位置をプロパティintervalで指定した秒数ごとに、時計回りにプロパティrotate_speed分だけずらしては発射、ずらしては発射することで弾幕が生成される仕組みだ。\n続いて、シーンが読み込まれた時に最初に呼ばれる_readyメソッドを編集する。メソッド内に、弾幕生成に必要な初期化を行うためのコードを追加する。上の図をイメージしながら確認いただくとわかりやすいはずだ。\n###Enemy.gd### func _ready(): anim_player.play(\u0026#34;spawn\u0026#34;) randomize() sprite.frame = randi() % sprite.hframes # 以下全て追加: # 一度に発射する弾の間隔（角度差）を step として定義する # step は 180° x 2 = 360° を プロパティSpawning_countの値で割った値 var step = PI * 2 / spawning_count # spawning_count の値の数だけループ（spawning_count が 4 の場合は i に 0 ~ 3 が順に入る） for i in spawning_count: # 弾の発射位置の目印として使う Node2Dノードを新規作成し、それを spawn_point として定義する var spawn_point = Node2D.new() # 発射位置を pos として定義する # pos は基準位置(x: radius, y: 0)から(step x i)だけ回転した位置とする var pos = Vector2(radius, 0).rotated(step * i) # spawn_pointを弾の発射位置に配置する spawn_point.position = pos # spawn_pointの向きを正のx軸から発射位置までの角度に合わせる spawn_point.rotation = pos.angle() # spawn_point を回転するためのノードとして予め用意してある Rotater ノード（Node2D）の子にする rotater.add_child(spawn_point) # Timer ノードの wait_time プロパティを interval プロパティの値でセット timer.wait_time = interval # AnimationPlayerノードのアニメーションが終わるまで待機 yield(anim_player, \u0026#34;animation_finished\u0026#34;) # Timerノードのタイマーを開始する timer.start() あとは「Timer」ノードがタイムアウトするたびに、先に作った「Bullet.tscn」シーンのインスタンスを「Rotater」ノードの子ノード（上のコードのspawn_point）と同じ位置に配置してあげれば、自動的に弾が飛んでいくようになるはずだ。では「Timer」ノードの「timeout」シグナルで呼ばれる_on_Timer_timeoutメソッドを編集しよう。下準備にてシグナルはすでに接続済みなので、メソッド内のpassを以下の内容で置き換えてほしい。\n###Enemy.gd### # Timer ノードの timeout シグナルで呼ばれるメソッド func _on_Timer_timeout(): # Rotaterノードの子ノードに対してループ処理 for node2d in rotater.get_children(): # Bullet.tscn のインスタンス var bullet = bullet_scn.instance() # Bullet インスタンスノードを Enemy ノードではなく、その親ノード（Worldノード）の子にする get_parent().add_child(bullet) # Bullet インスタンスの位置を Rotater の子ノードの位置と同じにする bullet.position = node2d.global_position # Bullet インスタンスの方向を Rotater の子ノードの方向と同じにする bullet.rotation = node2d.global_rotation 発射位置は変わらないが、ひとまずこれで指定した弾の数だけ指定した時間差で発射されるはずだ。プロジェクトを実行してみよう。\n次は弾の発射位置を少しずつ回転させて、より弾幕らしくしていこう。今度は_physics_processメソッドに少しコードを更新する。以下のコードの「# 追加」とコメントしている箇所を追加してほしい。\n###Enemy.gd### func _physics_process(delta): delta_count += delta if delta_count \u0026gt; 2: delta_count = 0 if get_parent().has_node(\u0026#34;Player\u0026#34;): anim_player.stop() anim_player.play(\u0026#34;move\u0026#34;) var direction = global_position.direction_to(get_parent().get_node(\u0026#34;Player\u0026#34;).global_position) var velocity = direction * enemy_speed velocity = move_and_slide(velocity) # 追加：次の方向（角度）を new_rotation として定義 # new_rotation は Rotater ノードの現在の方向（角度）+ rotate_speed x 1フレームの時間とする var new_rotation = rotater.rotation + rotate_speed * delta # 追加：new_rotation を 360 で割った余り（角度）だけ Rotater ノードを回転する rotater.rotate(fmod(new_rotation, 360)) これで弾の発射位置がintervalプロパティに指定している0.4秒ごとに回転するはずだ。期待通りの挙動になるか、プロジェクトを再度実行して確認してみよう。\n弾幕をカスタマイズする スクリプト内で定義したプロパティも、最初にexportキーワードをつけていればインスペクターで手軽に値を編集可能だ。値を変更して、さっきのとは異なる弾幕を作成してみよう。\nサンプル1\nRotate Speed: 45 Interval: 0.5 Spawning Count: 10\nサンプル2\nRotate Speed: 10 Interval: 0.1 Spawning Count: 8\nサンプル2の方は、かなり鬼畜なゲームになってしまった。しかし、なんともスリリングで楽しい。\nランダム性を追加する 下準備時点で、敵キャラクターの見た目（スプライトのテクスチャ）は、6種類からランダムで決まるようにコーディングしている。弾幕のプロパティもランダムで決まるようにすれば、毎回どんな弾幕が放たれるのか予想できないので、面白いかもしれない。実はここまでに記述したスクリプトに少しコードを足すだけで、意外と簡単に実装できるのだ。\nではスクリプトエディタで「Enemy.gd」スクリプトを開いてほしい。まずは、すでに用意している弾幕を形成するための各プロパティの上限値と下限値を別のプロパティで定義する。以下のコードの「# 追加」および「# 変更」とコメントしている行を更新しよう。\n###Enemy.gd### var radius = 20 export var rotate_speed: float # 変更：型だけ定義して値を未定義にする export var max_rotate_speed = 80 # 追加 export var min_rotate_speed = 20 # 追加 export var interval: float # 変更：型だけ定義して値を未定義にする export var max_interval = 0.8 # 追加 export var min_interval = 0.2 # 追加 export var spawning_count: int # 変更：型だけ定義して値を未定義にする export var max_spawning_count = 10 # 追加 export var min_spawning_count = 2 # 追加 次に、シーンが読み込まれたタイミングで各プロパティにランダムな値を適用する必要があるので、_readyメソッドを編集する。「# 追加」のコメントがある箇所が更新箇所だ。\nfunc _ready(): anim_player.play(\u0026#34;spawn\u0026#34;) # ランダム値生成を有効にする randomize() sprite.frame = randi() % sprite.hframes # int, max: 5 # 追加：min_rotate_speed を下限、max_rotate_speed を上限にしたランダム小数を rotate_speed に代入 rotate_speed = rand_range(min_rotate_speed, max_rotate_speed) # 追加：min_interval を下限、max_interval を上限にしたランダム小数を interval に代入 interval = rand_range(min_interval, max_interval) # 追加：この後の計算で上限値が指定した値より -1 されるので先に +1 して調整 max_spawning_count += 1 # 追加：min_spawning_count を下限、max_spawning_count を上限にしたランダム整数を spawning_count に代入 spawning_count = randi() % max_spawning_count + min_spawning_count var step = PI * 2 / spawning_count for i in spawning_count: var spawn_point = Node2D.new() var pos = Vector2(radius, 0).rotated(step * i) spawn_point.position = pos spawn_point.rotation = pos.angle() rotater.add_child(spawn_point) timer.wait_time = interval yield(anim_player, \u0026#34;animation_finished\u0026#34;) timer.start() 少しランダム値の生成について補足しておく。\nまずrand_rangeはその第一引数を下限、第二引数を上限としたランダムな小数を返す。そのため、型を小数で定義しているプロパティrotate_speedとintervalで利用した。\n次にrandiはランダムな整数を返すメソッドだが、引数を取らないため、上限や下限を指定できない。そこで、返された値を上限値で割った時の余りが 0 以上かつ (上限値 -1) 以下 になることを利用する（最大値が指定した上限値 -1 なので、1行前のコードmax_spawning_count += 1で +1 している）。%（モジュロ） の記号を利用すれば a % b で a を b で割った時の余りが求められる。さらにその値に c を足して a % b + c とすれば、c より小さな値にはならない。つまり上限と下限のあるランダムな整数を求める場合は randi() % 上限値 + 下限値 で表すことができる。ただし返される値の最大値が上限値 -1 であることを覚えておこう。\nなお、今回は下準備にてrandomizeメソッドを先に記述しておいたが、これがないと毎回同じ結果になるので、ランダム値を返すメソッドを利用する場合は必ず_readyメソッドの冒頭に記述することも覚えておくと良いだろう。\nでは最後に、出現するモンスターごとに異なる弾幕になるか、プロジェクトを実行して確認してみよう。\nおわりに 今回のチュートリアルでは、2Dトップダウンシューティングゲームの弾幕を作った。今回のような回転式の弾幕の場合、以下がポイントになるだろう。\n円の半径、発射位置の回転速度、発射の時間差、同時発射弾数をプロパティでセット 回転用のノードを用意しておく 発射位置を円の半径と同時発射弾数から計算 回転用ノードに発射位置の目印用の子ノードを追加する タイマーの時間を発射の時間差にセット 物理プロセスにて常に回転用ノードを回転速度に合わせて回転させる タイマーがタイムアウトしたら弾のインスタンスを目印用ノードの位置に生成する 他にも実装方法はあるはずなので、いろいろ試して良いものを最終的に採用していただければと思う。\nまた、実際の弾幕シューティングゲームでは、今回のような回転式のものばかりではなく、波型、扇型など、多様だ。気になる場合はぜひ調べてみてほしい。\nリンク Godot Docs: 行列と変換 YouTube: How to Make a Bullet Hell Projectile Pattern Generator in Godot YouTube: How to Make a Bullet Hell Game in Godot [P1] - Basic Collisions UPDATE\n2022/05/25 キー操作を追加\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0007_bullethell/","summary":"このチュートリアルでは、2Dトップダウンシューティングゲームの「弾幕」を作っていく。弾幕というのは、敵キャラクターから放たれる大量の弾（またはそれに類似する遠距離攻撃）のことで、弾が幕のように隙間なく","title":"Godot3 で作る弾幕シューティングの弾幕"},{"content":"今回の記事は、もしあなたがゲーム開発を始めたばかりか、これから始めようと思っている初心者の場合は、特にご一読いただきたい内容になっている。最後までご覧いただけると幸いだ。\nさて、あなたにはどうしても作ってみたい「夢のゲーム」があるだろうか？おそらくゲーム開発を始めた人や始めようと考えている人の多くが、おそらくそういったゲームを夢想しているのではないだろうか。そして、そのゲームには、自分がこれまでの人生でプレイして影響を受けてきたゲームの要素がふんだんに盛り込まれているはずだ。\n察しがつくだろうが、今からこの記事では「夢のゲームは将来にとっておけ」という主張を展開する。しかし、この主張は真新しいものではなく、ゲーム開発初心者に対する助言として割とありふれたものでもある。なぜ、夢のゲームを寝かせておく必要があるのか、その理由を説明していこう。\n夢のゲームに含まれがちな要素 夢のゲームにはどのような要素が含まれがちだろうか。ちなみに、ここで言う要素とは、ゲームの仕様や機能のことだ。以下に例として思いつくものをリストアップしてみたのでご覧いただきたい。\nマルチプレイヤー対応 オンラインプレイ オープンワールド 高解像度ゴリゴリ3Dゲーム モーションキャプチャーによるキャラクターアニメーション AR / VR 機械学習を利用したAI ゲームの世界観、時代背景、キャラクター設定が超絶重厚なストーリー プレイヤーの選択で分岐するマルチエンディング キャラクター、モンスター、アイテムの数が膨大 キャラクターのセリフの量が膨大 キャラクター全員フルボイス 上記リストの中に、あなたの夢のゲームに当てはまる要素はあっただろうか。リストの要素を含むゲームの開発は、初心者にとって非常にハードな内容ばかりとなっている。もし、夢のゲームが上記リストに当てはまらない場合は、開発が比較的容易なゲームなのかもしれない。例えば、いわゆるカジュアルゲームと言われるようなジャンルのゲームが作りたいのであれば、それはこの記事の「夢のゲーム」の定義からは外れるので、初心者であっても開発を始めてしまって良いだろう。\n上記リストにあるような要素を含むゲームを開発するには、２つの大きな壁が立ちはだかる。一つは「スキルの壁」、もう一つは「作業量の壁」だ。\nスキルの壁 特にリストの 1 ~ 7 の要素を含んだゲームを作るには、高度な技術が必要になるので、開発を始めるためにはそのスキルの習得が必要だ。\nゲーム開発者に限らず、あらゆるエンジニアにとって、必要な技術を学習しながら開発することは割と一般的だが、基礎を習得せずして高度な技術を学習しようとすると、まずその難易度に圧倒されてしまうだろう。なかなかスキルが習得できないので、当然開発も思ったように進まない。高難易度の学習と開発の進捗の悪さによるストレスで、結果的にそのゲームプロジェクトを投げ出してしまうことになるだろう。これが、夢のゲームは将来にとっておくべき良い理由の一つだ。\n基礎からコツコツとスキルを身につければ、効率的に学習できる。自分の現在の能力をわきまえて（しかし過小評価する必要はないが）、手の届く範囲のゲームを作りながら少しずつできることを増やしていくことがモチベーション維持にはとても重要なのだ。ある程度経験を積んで、スキルアップするまで、夢のゲームは一旦寝かせておこう。\n一方、ある程度ゲーム開発の経験を積んでいるのに、まだ自分にはスキルが全く足りないと思い込み、夢のゲームに一向に着手しないでいる場合も、それはそれで問題だ。100% 必要なスキルが揃うことはまずない。基礎は理解した上で、わからないことを調査しながら開発を進めるのは、割と一般的なことだ。だから、十分にスキルを身につけている人は、もう夢のゲーム開発を始めてしまって良いはずだ。\n作業量の壁 続いて、上記リストの特に 8 ~ 12 の要素が含まれるようなゲームは技術より、むしろ作業量が問題になる。もちろん、上記リストに含まれないものであっても、多くの要素をあれもこれもゲームに入れ込もうとすると、全体として作業量は膨大になる。この場合、自分一人の力ではどうにもならないことがほとんどだ。個人開発者にとって、歯痒い事実でもある。\n昨今のAAA（トリプルエー）と呼ばれるような大作ゲームを想像してみて欲しい。例えば「ファイナルファンタジー」や「アンチャーテッド」、「モンスターハンター」などのシリーズの最新のナンバリングタイトルをイメージしてもらうとわかりやすいだろう。何百人という開発者たちがそれぞれの専門分野（ゲームデザイン、グラフィック、プログラム、ミュージックなど）に集中して作業し、それでも１〜2年、もしくはそれ以上開発し続けているのだ。単純計算で、100人で１年かけたゲームを一人で作る場合、100年かかる。つまり、自分の一生を捧げてもそのゲームを完成させることはできないのだ。自分の作りたいゲームがそのような大作ゲームなのであれば、ゲーム会社に就職するか、会社を立ち上げて仲間を集めることになるだろう。就職するにしても、技術力は問われるので、そういう意味でも自己研鑽を優先し、夢のゲームは就職したあとにとっておく、という流れになるだろう。\nただし、AAAタイトルの開発現場は、特に発売前の時期になると非常に過酷であることが多い、ということは付け足しておかなければならない。「ゲームは総合芸術であり、開発者は芸術家である」という考え方が歪曲して、「労働ではなく芸術に情熱を注いで没頭しているだけ」という価値観が浸透し、一般的な労働のあり方からかけ離れた状況になってしまうようだ。\n個人開発で夢のゲームを形にするためには、ゲームに本当に必要な要素とは何なのか、しっかりと吟味して、それ以外の要素は思い切って切り捨てることを常に検討しなければならない。いかに省エネで開発し、いかにシンプルで面白いゲームを作るか、ゲームデザインの腕が問われるところである。引き算の考え方を常に持っておきたいものだ。\n簡単なゲームから作る ところで、ゲーム開発初心者が、挫折しないでゲーム開発の技術を高めていくにはどうすれば良いのだろうか。それはまず簡単なゲームから作ることだ。\nこの理屈はなにもゲームに限った話ではない。例えば、絵を描くことや楽器を演奏することなど、どんなことでも簡単なところから学習していくはずだ。美しい絵を描くには、先にデッサン力をつけ、構図、遠近法などの理論を学ばなければ、説得力のある絵は描けないだろう。ギターなら、手のフォームや指板上の音の配置を覚え、和音やコード進行などの理論を理解した上で徐々に高度な演奏ができるようになるはずだ。誰も最初からゴッホのような絵は描けないし、クラプトンのようにはギターを弾けないのだ。\nでは、初心者にとって比較的簡単に作れるゲームとは何だろうか。それはずばり「ブロック崩し」だ。個人開発業界で著名な ひろはす 先生も YouTube 動画 で何度かおっしゃていた。また、ネットで検索するだけでも初心者向けのチュートリアルの題材としてよく採用されているのがわかるはずだ。\n本サイトでもゲームエンジン Godot でのブロック崩しのチュートリアルを掲載している。ゲーム作りの基礎がかなり詰まっているので、何から始めようか迷っている人には本当におすすめだ。私自身もブロック崩しから始めて、多くの基礎を学ぶことができた。具体的には、ブロック崩しには主にパドルとボールとブロックの3種類のオブジェクトが必要なのだが、プレイヤーが入力操作して動かすパドル、物理演算で動くボール、動かないブロック、という具合にそれぞれの制御の仕方がわかりやすく異なるところが、まず初心者にはうってつけなのである。そしてそれらを一つのゲームとして組み合わせるわけだが、そうすると、ゲーム全体は小さな部品の集合体であることも実感できるのだ。\nチュートリアル： Godot で作るブロック崩し 【超初心者向け】ブロック崩しを作りながらUnityの基本的な使い方を解説します ドット絵のブロック崩しをGameMaker Studio2で作ってみた【使い方講座】 他にも、初心者向けチュートリアルなんかでよく見かけるのは「ポンゲーム」だ。これはピンポン（卓球）のように左右両サイドのパドルでボールを跳ね返して遊ぶゲームだ。ブロック崩しととても似ているので、こちらも比較的始めやすいだろう。\nチュートリアル： Learn Godot by creating Pong 少し難易度は上がるが、こちらも比較的初心者向けのチュートリアルが多い「スペースアステロイド」系のゲームも初心者向きで良い。これは宇宙空間で戦闘機を操り、隕石を射撃して破壊し衝突を回避しつつ、敵機がきたらこちらが撃墜される前に撃ち落とす、というスタイルで、より高いハイスコアを狙うゲームだ。私も Godot Engine を使い始める前に少し GameMaker というゲームエンジンを使ってみた時期があったが、その時一番最初にやってみたのが、この「スペースアステロイド」系のチュートリアルだった。\nチュートリアル： Space Asteroid Arcade Shooter Godot Tutorial - CodingKaiju My First Game - Intro to GameMaker - Space Rocks (Part 1) 最後に、自分が使うゲームエンジンに Godot を選択した場合は、初心者向けチュートリアルが Godot 公式サイトに用意してある。いわゆる回避ゲームだ。画面の外側から四方八方敵キャラクターが出現してくるので、それをひたすらかわすゲームになっている。基礎が学べるように考えて作られているのがよくわかる。また、あまり時間もかからず手軽に始められるのでとてもおすすめだ。\nチュートリアル： Your first 2D game Your first 3D game ブロック崩しなどでゲーム開発の基本的なことがわかってきたら、次は自分の夢のゲームに近いサンプル的なチュートリアルをやってみるのが良いだろう。\n例えばメトロイドバニアというジャンルの横スクロールの探索型アクションゲームが作りたいのであれば、その基本となるプラットフォーマーのチュートリアルを一通りやってみるのが良いだろう。プラットフォーマーというのは、ファミコンやスーパーファミコン時代のスーパーマリオブラザーズシリーズのようなジャンプアクションがメインの横スクロールアクションゲームだ。\n本サイトにもチュートリアルを用意しているし、他にもわかりやすいチュートリアルはネット上でたくさん見つかるはずだ。\nチュートリアル： Godot で作るブロック崩し How to Make a Complete Game with Godot Godot 2D Platformer tutorial : Ultimate Guide To Make Games Godot Engine 3 - Platform Game Tutorial Make Your First 2D Game with Godot: Player and Enemy (beginner tutorial part 1) 夢のゲームを分解して個別のゲームとする 夢のゲーム開発に着手する段階まで来たとして、それだけに集中して長期間開発を続けるのは、実はかなり難しい。情熱というのはなぜか途中で消えそうになる時があるものだからだ。\nそこで、自分の作りたい夢のゲームに複数の要素が含まれる場合は、その要素をバラして、それぞれを単体のゲームとして構成してみると良い。規模を小さくすれば挫折する危険性も格段に下がる。\n例えば、パズルでモンスターとバトルして勝ったらそのモンスターをペットにして育成できるゲームが作りたいとする。その場合、まず先にパズルの要素だけで一つのゲームを作って、リリースしてみる。次に、育成の要素だけで別のゲームも作ってリリースしてみる。そしてそのあと、これら２つのゲームを組み合わせて新しいゲームとする。\nもちろん、「既存の２つのゲームを組み合わせただけ」と思われないように、UIやキャラクターのデザイン、サウンドなんかをアップデートする必要はあるだろうが、根幹のゲームシステムはできあがっているから比較的早く完成させられる。このようにして、短いスパンで新しいゲームをリリースしつつ、自分の「夢のゲーム」の完成に少しずつ近づいていくことができるというわけだ。\n短期間でゲームをリリースし続けるメリットは、開発のモチベーション維持にある。個人開発の場合、一つのゲームを年単位の時間をかけて開発していくとなると、様々な不安や飽きが生じてしまい、はっきり言って困難だ。途中で投げ出してしまったら、そこに費やした時間と労力は全て無駄になってしまう。しかし、小さなゲームでもコンスタントに完成させてリリースしていれば、良い頃合いで達成感を味わうことができ、モチベーションを維持しやすいのだ。また、個別のゲームに対するユーザのフィードバックを将来の夢のゲームに生かすこともできる。個人開発者にとって、これは非常に大きなメリットになるだろう。\nおわりに 今回は、夢のゲームを諦めないために大事な以下のことをお伝えした。\n難しい技術が必要なゲーム開発はスキルが伴っていないと挫折してしまいがち。 大作ゲームは個人では開発できないから会社に就職するか仲間を集めて会社を作る必要がある。 簡単なゲームから作っていけば、モチベーションを維持しながら徐々に必要なスキルを習得できる。 夢のゲームの要素を分解し、個別のゲームとして短期間でリリースしていけばモチベーション維持しつつ、夢のゲームを徐々に完成に近づけていくことができる。 すぐにやりたいことに飛びつきたい気持ち、面倒な基礎の学習はスキップしたい気持ち、すぐに成果を出したい気持ち、どれも当然だと思う。しかし、チュートリアルを見ながら、簡単なゲーム開発をやってみると、それはそれで新しい発見があったり、自己成長を感じられ、とても楽しいものなのだ。どうか基礎学習の食わず嫌いにはならないでほしい、と切に願う。また、「難しかったら簡単なところに戻る」つもりで、高度なゲーム開発にチャレンジするのは全く問題ない。気持ちが折れなければ何度でも立ち上がれるのだ。\n","permalink":"https://www.peanuts-code.com/ja/posts/post0002_development_starts_small/","summary":"今回の記事は、もしあなたがゲーム開発を始めたばかりか、これから始めようと思っている初心者の場合は、特にご一読いただきたい内容になっている。最後までご覧いただけると幸いだ。 さて、あなたにはどうしても作っ","title":"ゲーム開発は簡単なものから始めよう"},{"content":"このチュートリアルでは、2Dトップダウンシューティングゲーム（見下ろし型シューティングゲーム）で一般的によく登場する銃を4種類作っていく。具体的には以下の通りだ。\nハンドガン ショットガン マシンガン レーザーガン Environment このチュートリアルは以下の環境で作成しました。\n・Godot のバージョン: 3.4.2\n・コンピュータのOS: macOS 11.6.5\nこのチュートリアルでは、銃の作成にフォーカスするため、以下は予め用意しておいた。\nゲームの世界\n「World.tscn」というシーンを用意し、見た目は「TileMap」ノードを追加して簡単に作成している。「TileMap」以外に「Player」ノードと複数の「Obstacle」ノードを追加している。これらについては個別のシーンを作成して、インスタンスを追加した形だ。\nプレイヤーキャラクター\n「Player.tscn」シーンとして作成した。ルートノードは「KinematicBody2D」クラスで、子ノードに「Sprite」と「CollisionShape2D」を追加している。「Sprite」のテクスチャは銃をもったスキンヘッドのヒットマンにしている。ヒットマンが持っている銃の画像の先端の位置に「Position2D」クラスの「Muzzle」という名前のノードを配置している。これは後ほど銃を撃った時の弾丸インスタンスの生成される位置を指定するのに使用する。\nインプットマップには以下のアクションを追加済みだ。プレイヤーキャラクターの移動や射撃、銃の切り替えに使用する。\nup: W キー・・・プレイヤーキャラクターを前進させる時に使う down: S キー・・・プレイヤーキャラクターを後退させる時に使う fire: マウス左ボタン・・・銃を撃つ switch: マウス右ボタン・・・銃の種類を切り替える\nちなみに、チュートリアルの内容を簡潔にするため、プレイヤーキャラクターのスプライトは銃の種類が変わっても同じままだ。見た目はハンドガンっぽいが、マシンガンにもレーザーガンにもなる、なんでもありの銃、ということにしておこう。 障害物\n「Obstacle.tscn」というシーンを作成している。Obstacle は日本語で障害物という意味だ。画面上にたくさん置いている茶色い木箱のオブジェクトは全てこのシーンのインスタンスである。ルートノードは「StaticBody2D」クラスにして、その子ノードとして「Sprite」と「CollisionShape2D」を追加している。\n解放された（破壊された）時に同じ場所に爆発を表現するための「Smoke.tscn」というシーンのインスタンスを生成するようにしている。「Smoke」シーンは「Particle2D」ノードのみで構成され、こちらもパーティクルの実行が完了したら自動的に解放されるようにしている。\nこれらの下準備によりプロジェクトを実行すると、以下のように世界とヒットマンと障害物が描画され、現時点でヒットマンは移動操作のみ可能な状態だ。\nこのチュートリアルのプロジェクトファイルは GitHubリポジトリ に置いている。.zipファイルをダウンロードしていただき、「Start」フォルダの方を Godot Engine にインポートしていただければ、上述の下準備だけ完了したプロジェクトから開始できる。また、取り急ぎ完成形を確認されたい場合は「End」フォルダの方をインポートしていただければOKだ。\nまた今回プロジェクトにインポート済みのアセットは全て KENNEY（ケニー） のサイトからダウンロードして利用させていただいたものだ。CC0の非常に使いやすいアセットを豊富にご用意いただいていることに感謝申し上げたい。特に今回ご利用させていただいたのは下記のアセットパックだ。\nTopdown Shooter Particle Pack それでは銃の実装を進めていこう。\n弾丸のシーンを作る まずは弾丸のシーンを作ろう。ハンドガン、ショットガン、マシンガンの3種類の銃でこの弾丸のシーンを使いまわせるので、先に作ってしまおうというわけだ。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」で「その他のノード」を選択する。 ルートノードに「Area2D」クラスを選択し、名前を「Bullet」に変更する。 ルートノードに「Line2D」クラスの子ノードを追加する。このチュートリアルでのこのノードの用途は弾丸の見た目を作るのに使用するのみだ。もちろん「Line2D」ではなく弾丸用のテクスチャ画像を用意して「Sprite」にしても良い。 ルートノードに「CollisionShape2D」クラスの子ノードを追加する。 ルートノードに「VisibilityNotifier2D」クラスの子ノードを追加する。銃で撃った弾が画面外に出てしまったら、それをシグナルで通知し、弾丸のインスタンスを解放するために使用する。 一旦シーンを保存しておく。保存先のフォルダは用意しているのでファイルパスが「res://Bullet/Bullet.tscn」になるようにして保存しよう。 ここまででシーンツリーは以下のようになったはずだ。\n続いて、各ノードを編集をしていく。\n2D ワークスペースで「Line2D」ノードのパスを描く。まず１つ目の点を (-5, 0) に、次に2つ目の点を (5, 0) に打って直線のパスを描く。インスペクターで直接入力しても良い。\nインスペクターにて「Line2D」ノードの「Width」プロパティの値を 6 にする。\n「Default Color」プロパティで弾丸の色を指定する。もちろんあなたの好みの色にしてもらって構わない。このチュートリアルではサンプルとして #708293 の青っぽいグレーの色を指定した。\n「Capping」＞「End Cap Mode」プロパティを「Round」にする。これでパスの終端（2つ目の点）が丸くなったはずだ。角張っているより、この方がずっと弾丸らしい。\n2D ワークスペース上で「Line2D」は以下のようになったはずだ。\n「CollisionShape2D」ノードの「Shape」プロパティに「新規 RectangleShape2D」リソースを割り当てる。 2D ワークスペースで「Line2D」で作成した弾丸の形状に合わせてコリジョン形状を調整する。ピッタリでも良いし、弾丸のサイズよりやや内側に小さく作っても良い。このサンプルではリソース「RectangleShape2D」の「Extents」プロパティの値が (5, 2) となっている。\n2D ワークスペースで「VisibilityNotifier2D」ノードの形状を調整する。この形状が画面外に出た時に発信されるシグナルを利用することになる。「CollisionShape2D」より x 軸方向で狭くして、2D ワークスペースで「CollisionShape2D」のコリジョン形状が確認しやすいようにした。y 軸方向の長さは同じにした。サイズはだいたいで構わない。このサンプルでは「Scale」プロパティの値は (0.5, 0.1) になっている。\nノードの追加とそれぞれのノードのプロパティ編集はここまでだ。\n続いてルートノードにスクリプトをアタッチしてコーディングしていく。\nルートノードにスクリプトをアタッチする。ファイルパスを「res://Bullet/Bullet.gd」として作成しよう。 「Bullet.gd」スクリプトを以下のように編集する。 ###Bullet.gd### extends Area2D # 1秒あたりの弾丸のスピード var speed = 1500 # 弾丸が飛んでいく方向ベクトル：いったん(0, 0) var direction = Vector2.ZERO # 物理プロセス: 60回/秒呼ばれる組み込みメソッド func _physics_process(delta): # 弾丸の現在の回転角度からコサイン関数で弾丸が飛んでいく方向ベクトルの x の値を取得 direction.x = cos(global_rotation) # 弾丸の現在の回転角度からサイン関数で弾丸が飛んでいく方向ベクトルの y の値を取得 direction.y = sin(global_rotation) # 方向 × スピードで弾丸を毎フレーム移動させる translate(direction * speed * delta) 続いて、弾丸が物理ボディに当たったら発信されるシグナルをこのスクリプトに接続しよう。ルートノード「Bullet」が「Area2D」クラスなので、シーンツリードックでルートノード「Bullet」を選択し、そのままノードドック＞シグナルタブにて「body_entered(body)」シグナルを選択して「接続」をクリック（またはシグナルをダブルクリック）して接続する。\n接続できたら、自動的に追加されたメソッド_on_Bullet_body_enteredを以下のように編集しよう。\n###Bullet.gd### # 弾丸が物理ボディに当たったら発信されるシグナルによって呼ばれるメソッド func _on_Bullet_body_entered(body): # もし当たったボディが障害物だったら if body.is_in_group(\u0026#34;Obstacles\u0026#34;): # 障害物のオブジェクトを解放する body.queue_free() # 弾丸インスタンスを解放する queue_free() ちなみに、事前に「Obstacle」シーンのルートノードは「Obstacles」というグループに追加済みだ。\nこれで、外壁に当たれば弾丸だけ解放され、障害物に当たれば、障害物と弾丸が解放されるようになった。\nさらにもう一つシグナルを追加する。「VisibilityNotifier2D」ノードが画面上から消えた時に発信されるシグナル「screen_exited()」を「Bullet.gd」スクリプトに接続しよう。手順は先程のシグナル接続と同様で、シーンツリードックで「VisibilityNotifier2D」ノードを選択し、ノードドック＞シグナルタブで「screen_exited()」シグナルを接続すればOKだ。\n接続できたら、自動的に追加されたメソッド_on_VisibilityNotifier2D_screen_exitedを以下のように編集しよう。\n###Bullet.gd### # VisibilityNotifier2D ノードが画面外に出た時に発信されるシグナルで呼ばれるメソッド func _on_VisibilityNotifier2D_screen_exited(): # 弾丸インスタンスを解放する queue_free() これで画面外に出た時もその弾丸は解放されるようになった。\n以上で弾丸シーンは完成だ。\nハンドガンを実装する まずは一番簡単なハンドガン（拳銃）から撃てるようにしていこう。編集するスクリプトは「Player.gd」なのだが、すでに下準備の段階である程度のコードが出来上がっているので、そちらを先に確認しておこう。\nPlayer.gd のコードの下準備部分を見る ###Player.gd### extends KinematicBody2D # プリロードした弾丸シーンの参照 const bullet_scn = preload(\u0026#34;res://Bullet/Bullet.tscn\u0026#34;) # 現在使用中の銃（銃の種類ごとの数字の割り当ては以下のコメント） var gun = 0 # 0: hand # 1: shot # 2: machine # 3: lazer # プレイヤーキャラクターのスピード var speed = 200 # プレイヤーキャラクターの方向を伴うスピード var velocity = Vector2() # Muzzleノードの参照：銃口の位置 onready var muzzle = $Muzzle # シーンが読み込まれたら呼ばれるメソッド func _ready(): rotation_degrees = 270 # ゲーム開始時プレイヤーに上を向かせる # 物理プロセス：デフォルトで60回/秒呼ばれるメソッド func _physics_process(delta): move()　# プレイヤーキャラクターを移動させるメソッドを呼ぶ switch_gun() # 銃の種類を切り替えるメソッドを呼ぶ fire() # 銃を撃つメソッドを呼ぶ # プレイヤーキャラクターを移動させるメソッド func move(): look_at(get_global_mouse_position()) # キャラクターにマウスカーソルの方を向かせる velocity = Vector2() # ベロシティ（方向をもった速度）を(0, 0)に初期化 if Input.is_action_pressed(\u0026#34;down\u0026#34;): # Sキーを押したら... velocity = Vector2(-speed, 0).rotated(rotation) # ベロシティを後ろ向きにセット if Input.is_action_pressed(\u0026#34;up\u0026#34;): # Wキーを押したら... velocity = Vector2(speed, 0).rotated(rotation) # ベロシティを前向きにセット velocity = move_and_slide(velocity) # ベロシティに合わせて移動 # 銃の種類を切り替えるメソッド func switch_gun(): if Input.is_action_just_pressed(\u0026#34;switch\u0026#34;): # マウス右ボタンをクリックをした場合... if gun \u0026lt; 3: # 銃の割り当て番号が 3 未満の場合は... gun += 1 # 割り当て番号を 1 増やす else: # 銃の割り当て番号が 3（最後の数字）の場合は... gun = 0 # 銃の割り当て番号を 0 にする print(\u0026#34;Switched to \u0026#34;, gun) # デバッグ用に出力パネルに表示 # 銃を撃つメソッド func fire(): pass ということで、fireメソッドが今のところ中身が空っぽだ。これを次のように更新する。ちなみに fire は日本語で「（銃などを）撃つ」という意味だ。\n###Player.gd### # 銃を撃つメソッド func fire(): # 銃の種類がハンドガン（0）かつマウス左ボタンをクリックした場合 if gun == 0 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): # 弾丸インスタンスを生成して発射するメソッドを呼ぶ put_bullet() ここでput_bulletというメソッドが登場したが、これはこれから定義するメソッドだ。fireメソッドの下に以下のコードを追加して定義しよう。\n###Player.gd### # 弾丸インスタンスを生成して発射するメソッド func put_bullet(): # 弾丸シーンのインスタンスの参照 var bullet = bullet_scn.instance() # 弾丸インスタンスの位置を銃口の位置と同じにする bullet.global_position = muzzle.global_position # 弾丸インスタンスの向きを Player の向きと同じにする bullet.rotation_degrees = rotation_degrees # Playerではなくその親ノード(World)の子にする get_parent().add_child(bullet) # Worldの2番目の子にする（タイルマップより前面、プレイヤーキャラクターより背面） get_parent().move_child(bullet, 1) これでハンドガンの実装ができたはずだ。プロジェクトを実行して確認してみよう。\nショットガンを実装する 次はショットガン（散弾銃）を実装する。トップダウンシューティングでのショットガンは、複数の弾丸がそれぞれ少しずつ角度の差をつけて前方に飛んでいくような仕様が一般的だろう。一回で広範囲の複数オブジェクトを一掃できる強力な銃だ。\nまずはfireメソッドから更新しよう。\n###Player.gd### func fire(): # 銃の種類がハンドガン（0）かつマウス左ボタンをクリックした場合 if gun == 0 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): put_bullet() # 銃の種類がショットガン（1）かつマウス左ボタンをクリックした場合 if gun == 1 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): # 5回ループ for n in 5: # 弾丸インスタンスを生成して発射するメソッドの引数に値を渡して呼ぶ put_bullet(n) fireメソッドに２つ目のifブロックを追加した。プロパティgunの値が 1（ショットガンの割り当て番号）の場合にマウス左クリックでショットガンを撃てる。ifブロックの中身はforループで5回put_bulletを呼んでいるが、先程のハンドガンの時と違い、引数にループの周回数nを渡している。このメソッドが受け取った引数をどう処理するかは、このあとput_bulletメソッドを更新していくのでそこで確認しよう。\nfunc put_bullet(dir_offset = 2): # 引数dir_offsetを追加し、デフォルト値は2とした var bullet = bullet_scn.instance() bullet.global_position = muzzle.global_position bullet.rotation_degrees = rotation_degrees + (20 - 10 * dir_offset) # 更新 get_parent().add_child(bullet) get_parent().move_child(bullet, 1) 少しややこしいが、メソッドを呼ぶときに引数dir_offsetが未入力の場合、デフォルト値の2が自動的に引数に渡される。メソッドのブロック内3行目で弾丸の回転角度（向き）を指定しているのだが、例えばハンドガンの場合は、引数を指定せずにこのメソッドを呼んでいるので、引数にはデフォルト値の 2 が渡されて、20 - 10 * dir_offsetの部分が 0 になり、弾丸の角度はプレイヤーキャラクターの向いている角度と同じになる。\n一方、ショットガンの場合は、fireメソッド内のforループで5回このput_bulletメソッドが呼ばれており、ループの周回数 n（0からカウントして4まで）を引数dir_offsetに渡す形にしている。よって、ループが何周目かによって弾丸の角度は以下のように変化する。\nループ0周目：プレイヤーキャラクターの向いている角度 + 20° ループ1周目：プレイヤーキャラクターの向いている角度 + 10° ループ2周目：プレイヤーキャラクターの向いている角度 + 0° ループ3周目：プレイヤーキャラクターの向いている角度 + -10° ループ4周目：プレイヤーキャラクターの向いている角度 + -20° 上記のコードにより、5発の弾丸が「Player」が向いている方向に対して -20° から +20° の範囲で 10° ずつ異なる角度で同時に発射され、一度に広範囲を射撃できる銃の完成だ。なお、5 回程度のループであればコンピュータ上で一瞬で処理されるので、ほぼ同時にそれぞれの角度に弾丸が飛んでいくことになる。\nこれでショットガンの実装ができたはずだ。プロジェクトを実行して確認する際、マウス右ボタンを1回クリックしてショットガンに切り替えてから射撃してみよう。\nマシンガンを実装する 続いてマシンガン（機関銃）を実装していこう。マシンガンは一回いっかいトリガーを引いて射撃する銃とは違い、トリガーを引いている間、自動的に連続して射撃できる銃だ。ショットガンのようにワンショットで広範囲の射撃はできないが、高速で自動射撃するため、プレイヤーキャラクター自身が回転すればすぐに広範囲のオブジェクトを一掃できる。\nそれでは「Player.gd」スクリプトにマシンガン用のコードを追加していこう。\nまずはプロパティintervalを追加した。\n###Player.gd### var speed = 200 var velocity = Vector2() # マシンガンの次の弾丸が発射されるまでのカウント var interval: int = 0 # 追加 マシンガンの仕様として、マウス左ボタンを押したままにすれば自動的に弾丸が連続して発射されるようにするのだが、_physics_processメソッドでfireメソッドを毎フレーム呼ぶと、弾丸と弾丸の間隔が短すぎて弾丸が止まって見える（以下のGIF画像参照）。\n物理プロセスの 60 FPS（毎秒60フレーム）というフレームレートはかなり早いのだ。そこで今回は、毎フレーム、intervalプロパティに +1 してそのカウントが 5 を超えたら弾丸を発射するようにする。つまり、5 フレームに 1 回発射する計算だ。\nそこを踏まえてfireメソッドにマシンガン用のifブロックを追加していこう。\nfunc fire(): # 銃の種類がハンドガン（0）かつマウス左ボタンをクリックした場合 if gun == 0 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): put_bullet() # 銃の種類がショットガン（1）かつマウス左ボタンをクリックした場合 if gun == 1 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): for n in 5: put_bullet(n) # 銃の種類がマシンガン（2）かつマウス左ボタンを押している場合 if gun == 2 and Input.is_action_pressed(\u0026#34;fire\u0026#34;): # 次の弾丸までのカウントを +1 する interval += 1 # カウントが5以上だったら if interval \u0026gt;= 5: # カウントを0に戻して interval = 0 # 弾丸インスタンスを生成して発射するメソッドを引数なしで呼ぶ put_bullet() なお、ハンドガンとショットガンはInputクラスのis_action_just_pressedメソッドをifの条件に使っているが、こちらは左ボタンを押し続けても連続的には入力を検知されないようになっている。一方、マシンガンの場合はis_action_pressedメソッドを使っている。「just」がないだけで似たような名前のメソッドだが、こちらは押し続けていても毎フレーム入力が検知されるので、「押しっぱなし」の操作で利用するのに向いているのだ。\nこれでマシンガンの実装ができたはずだ。プロジェクトを実行して確認する際、マウス右ボタンを2回クリックしてマシンガンに切り替えてから射撃してみよう。\nレーザーのシーンを作る 最後はレーザーガン（光線銃）を実装するのだが、これは弾丸ではなくレーザーを発射するので、まず先にレーザーのシーンを作成していこう。パーティクルやアニメーションにより最低限のそれらしい演出も加える。\n「シーン」メニュー＞「新規シーン」を選択する。 「ルートノードを生成」で「その他のノード」を選択する。 ルートノードに「RayCast2D」クラスを選択し、名前を「Laser」に変更する。 ルートノードに「Line2D」クラスの子ノードを追加する。弾丸シーンと同様にレーザーの見た目を作るのに使用する。もちろん「Line2D」ではなくレーザー用のテクスチャ画像を用意して「Sprite」にする方法もあるが今回は不採用だ。 ルートノードに「Particle2D」クラスの子ノードを追加する。これはレーザーがオブジェクトに当たった箇所に粒子が泡立つような演出を追加するのに利用する。 ルートノードに「Tween」クラスの子ノードを追加する。これはレーザー発射時にレーザーの幅を 0 から一定の幅までゆっくり太くしていく演出と、レーザー終了時の逆の演出に利用する。 一旦シーンを保存しておく。保存先のフォルダは用意しているのでファイルパスが「res://Laser/Laser.tscn」になるようにして保存しよう。 ここまででシーンツリーは以下のようになったはずだ。\n続いて、各ノードを編集をしていく。\nインスペクターにて、ルートの「Laser」ノードの「Enabled」プロパティをオンにして、「Cast To」プロパティを (2000, 0) にする。\n2D ワークスペース上では以下のスクリーンショットのようになったはずだ。\n2D ワークスペースで「Line2D」ノードのパスを描く。まず１つ目の点を (0, 0) に、次に2つ目の点を (200, 0) に打って直線のパスを描く。インスペクターで直接入力しても良い。なお、２つ目の点はスクリプトで制御するので、y の値が 0 であれば、x の値は 2D ワークスペース上で確認しやすい適当な値で良い。\nインスペクターにて「Line2D」ノードの「Width」プロパティの値を 16 にする。\n「Default Color」プロパティでレーザーの色を指定する。もちろんあなたのイメージするレーザーの色にしてもらって構わない。このチュートリアルではサンプルとして #00b1ff の青色を指定した。\n2D ワークスペース上で「Line2D」はだいたい以下のようになったはずだ。\nここから「Particle2D」ノードのプロパティを以下のように編集する。プロパティが多いので大変だが頑張ろう。 まず先に「Textures」＞「Texture」プロパティにリソース「res://Assets/circle_05.png」を適用する。\n「Emitting」プロパティをオンにする。\n「Drawing」＞「Visibility Rect」プロパティの値を (x: -50, y: -50, w: 100, h: 100) にする。\n「Transform」＞「Position」プロパティを(x: 200, y: 0)にして、「Transform」＞「Scale」プロパティを (x: 0.1, y: 0.1) にする\n「Process Material」プロパティに 「新規 ParticleMaterial」を割り当てる。\nここからは今割り当てたリソース「ParticleMaterial」のプロパティを編集していく。\n「Emission Shape」＞\n「Shape」プロパティを「Box」に変更する。\n「Direction」＞\n「Direction」プロパティを (x: -1, y: 0, z: 0) にする。x軸の負の方向になる。 「Spread」プロパティを 60 にする。60°の幅でパーティクルが移動する。\n「Gravity」＞\n「Gravity」プロパティを (x: -300, y: 0, z: 0) にする。x軸の負の方向に重力を加える。\n「Initial Velocity」＞\n「Velocity」プロパティを 800 にする。速度を 800 とした。これはおそらく秒速だ。\n「Scale」＞\n「Scale Curve」プロパティに「新規 CurveTexture」を割り当てる。この次は割り当てたリソースのプロパティ編集だ。\n「CurveTexture」＞ 「Curve」プロパティに「新規 Curve」プロパティを割り当て、値の変化を以下のスクリーンショットのように２つの点を打ってカーブを作って設定する。\nこれで、時間経過とともにパーティクル１つひとつが次第に小さくなる。\n「Color」＞\n「Color Ramp」プロパティにリソース「新規 GradientTexture」を割り当てる。パーティクルが生成されて消失するまでに次第に色を変える演出のためだ。\n上で割り当てた「GradientTexture」リソースのプロパティにリソース「新規 Gradient」を割り当てる。\n「Gradient」リソースのプロパティを編集するが、ここはインスペクターで直感的にグラデーションの基準となる色を３つ指定する。\n一番左端：#001096（深い青色） 中央やや左寄りの位置：#2780ff（水色っぽい青色） 一番右端：#00ffffff（不透明度0の白色）\nすると、結果的に以下のようなリソースのプロパティになる。\n以上で、ノードの追加とそれぞれのノードのプロパティ編集は完了だ。\nここからはルートノード「Laser」にスクリプトをアタッチしてコーディングしていく。\nルートノード「Laser」にスクリプトをアタッチし、ファイルパスを「res://Laser/Laser.gd」として作成する。 「Laser.gd」スクリプトを以下のように編集する。 ###Laser.gd### extends RayCast2D # Line2Dノードの参照 onready var line = $Line2D # Particle2Dノードの参照 onready var particle = $Particles2D # Tweenノードの参照 onready var tween = $Tween # シーンが読み込まれたら呼ばれるメソッド func _ready(): # Particle2DノードのEmittingプロパティをオフにする（インスペクターでオンにしたままの時の対策） particle.emitting = false # Tweenノードのアニメーションの設定：Line2DのWidthプロパティを0から10に0.5秒かけて変化させる tween.interpolate_property(line, \u0026#34;width\u0026#34;, 0, 10.0, 0.5) # Tweenノードのアニメーション開始 tween.start() # 物理プロセス：60FPSで呼ばれるメソッド func _physics_process(delta): # もしRayCast2D（ルートノード）が物理ボディに当たっている場合は... if is_colliding(): # Line2Dノードの２つ目の点（終端）の位置をRayCast2Dが物理ボディに当たった位置に設定する line.set_point_position(1, to_local(get_collision_point())) # もし当たったのが障害物だったら... if get_collider().is_in_group(\u0026#34;Obstacles\u0026#34;): # 障害物インスタンスの参照 var obstacle = get_collider() # 障害物インスタンスのレーザー照射時間（irradiated_timeプロパティ）に delta の値を加算する obstacle.irradiated_time += delta # もしレーザー照射時間が最大照射時間（max_irradiationプロパティ）を超えたら... if obstacle.irradiated_time \u0026gt; obstacle.max_irradiation: # 障害物インスタンスを解放する obstacle.queue_free() # もしRayCast2D（ルートノード）が物理ボディに当たっていない場合は... else: # Line2Dノードの２つ目の点（終端）の位置をRayCast2D（ルートノード）の先端の位置と同じにする line.set_point_position(1, cast_to) # Particle2Dノードの位置をLine2Dノードのパスの終端の位置と同じにする particle.position = line.points[1] # Particle2DノードのEmittingプロパティをオンにする（パーティクルのアニメーション開始） particle.emitting = true # マウス左ボタンから指を離した場合... if Input.is_action_just_released(\u0026#34;fire\u0026#34;): # レーザーを止めるメソッドを呼ぶ stop_laser() # レーザーを止めるメソッドを定義 func stop_laser(): # Tweenノードのアニメーションを設定：Line2DノードのWidthプロパティを10から0に0.5秒かけて変化させる tween.interpolate_property(line, \u0026#34;width\u0026#34;, 10.0, 0, 0.5) # Tweenノードのアニメーション開始 tween.start() # Tweenノードのアニメーションが終わるまで待機 yield(tween, \u0026#34;tween_completed\u0026#34;) # Tweenノードを解放する queue_free() このコードについて、少し補足しておく。下準備として作成済みの障害物のシーン「Obstacle.tscn」のルートノードにアタッチしている「Obstacle.gd」スクリプトにて、irradiated_timeとmax_irradiationという２つのプロパティを定義している。前者はレーザーの照射時間、後者はレーザーの最大照射時間として用意したものだ。レーザーが当たってすぐに障害物が破壊されるより、一定時間（最大照射時間：0.2秒）照射されたら破壊される設定の方がレーザーっぽさが出るのではないか、という考えからこのような仕組みを作った次第だ。\nこれでレーザーシーンが用意できた。次は「Player」シーンを更新して、レーザーを発射できるようにしていく。\nレーザーガンを実装する レーザーシーンができたので、レーザーガンを実装していこう。レーザーガンの仕様として、まず発射時に、先に作成した「Laser.tscn」のインスタンスを「Player」シーンに追加するようにしていく。プレイヤーの操作はマシンガンと同様に、マウス左ボタンを押したままにしている間は発射し続けられるようにする。一方、ボタンから指を離すと、先にコーディングした「Laser.gd」スクリプトにより、レーザーが消えて、インスタンスも解放される。\nそれでは具体的に「Player.gd」スクリプトを編集していこう。まずはfireメソッドの 4 つ目のifブロックを以下のように追加してほしい。\n###Player.gd### func fire(): # 銃の種類がハンドガン（0）かつマウス左ボタンをクリックした場合 if gun == 0 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): put_bullet() # 銃の種類がショットガン（1）かつマウス左ボタンをクリックした場合 if gun == 1 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): for n in 5: put_bullet(n) # 銃の種類がマシンガン（2）かつマウス左ボタンを押している場合 if gun == 2 and Input.is_action_pressed(\u0026#34;fire\u0026#34;): # 次の弾丸までのカウントを +1 する interval += 1 # カウントが5以上だったら if interval \u0026gt;= 5: # カウントを0に戻して interval = 0 # 弾丸インスタンスを生成して発射するメソッドを引数なしで呼ぶ put_bullet() # 銃の種類がレーザーガン(3)かつマウスの左ボタンを押している場合 if gun == 3 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): # レーザーインスタンスを生成して発射するメソッドを呼ぶ load_laser() 追加した 4 つ目のifブロックで、銃がレーザーの時にマウスの左ボタンを押し続けている間はload_laserメソッドを呼ぶようにした。このメソッドはこれから定義するところだ。以下のコードをput_bulletメソッドの下に追加しよう。\n###Player.gd### # レーザーインスタンスを生成して発射するメソッド func load_laser(): # Laser.tscnのインスタンスの参照 var laser = laser_scn.instance() # Laserインスタンスの位置を銃口の位置と同じにする laser.position = muzzle.position # LaserインスタンスをPlayerルートノードに子ノードとして追加する add_child(laser) # LaserインスタンスノードをPlayerルートノードの子ノードのうち0番目（最背面）に移動する # Playerノードの子Spriteノードのテクスチャ画像（の銃口部分）より背面にするため move_child(laser, 0) マウス左ボタンを押して「Laser」インスタンスが生成された後は、「Laser.gd」スクリプトの方でレーザーの位置、向き、長さ、幅、先端のパーティクルの位置は全て制御される。指が離れた時の「Laser」インスタンスの解放も含めて、だ。\n以上で、レーザーガンの実装は完了だ。プロジェクトを実行して確認する際、マウス右ボタンを3回クリックしてレーザーガンに切り替えてから射撃してみよう。\n完成してから気がついたが、レーザーは他の色にした方がよかったかもしれない。まるで水鉄砲か高水圧洗浄機のようだ。\n最後にもう一度プロジェクトを実行し、４つの銃を切り替えながらプレイしてみよう。\nおわりに 今回、トップダウンシューティングゲームによく登場する銃 4 種類を実装した。もし、もっと細かく作り込むなら、例えば、以下のような要素を追加するとさらに面白くなるかもしれない。\n銃の種類によって弾丸の見た目や速度を変える。 銃を切り替えたらプレイヤーキャラクターのスプライトも変更する。 弾丸をリロードしたりレーザーのエネルギーを充填するアニメーションや間を設ける。 弾丸がオブジェクトに当たって解放される時に煙や破片のようなパーティクルを追加して演出する。 銃の種類ごとに当たったオブジェクトへのダメージを設定し、オブジェクト側にもいわゆるHPなどの一定のライフの値を設定し、ライフが 0 になったら破壊できるようにする。 リンク KENNEY Godot 公式オンラインドキュメント：2D移動の概要 Godot 公式オンラインドキュメント：Line2D Godot 公式オンラインドキュメント：RayCast2D Godot 公式オンラインドキュメント：パーティクル・システム(2D) Godot 公式オンラインドキュメント：Particles2D Godot 公式オンラインドキュメント：ParticlesMaterial note：[Godot]ゲームで使う数学の覚書 UPDATE\n2022/05/07 タイポ修正\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0006_guns_of_topdown_shooter/","summary":"このチュートリアルでは、2Dトップダウンシューティングゲーム（見下ろし型シューティングゲーム）で一般的によく登場する銃を4種類作っていく。具体的には以下の通りだ。 ハンドガン ショットガン マシンガン レーザ","title":"Godot3 で作るトップダウンシューティングの 4 種類の銃"},{"content":"Godot でゲームのプロジェクトを作っていると、そのうちゲームの規模がある程度大きくなった時に、ファイルシステムドックですぐに編集したいシーンが見つからなかったり、さっき修正しようと思っていたスクリプトがどこに行ったかわからなくなったりすることがあるかもしれない。\n今回は Godot エディタに備わっているキーボードショートカットでの便利な検索機能を紹介する。これらを知っているだけで「見つからない何かを探す」という、おそらく最も楽しくない時間を激減させることができるだろう。なんなら、ファイルシステムやスクリプトエディタで直接ファイルにカーソルを合わせてクリックして選択していた手順を、毎回検索する手順に切り替えてしまっても良いだろう。\nちなみにショートカット集は公式オンラインドキュメントにまとまっているのでショートカットに興味がある方はそちらもご参照いただきたい。ちなみに、macOS の Option キーを Alt と記載しているのを確認したので注意してほしい。\n公式オンラインドキュメント デフォルトのエディタ用ショートカット とにかく作業効率アップ間違いなしなので、この記事を見たあとからさっそく使ってみてほしい。では具体的に検索範囲が広い機能から順番に紹介していく。\nクイックオープン 「クイックオープン」を使用するには、Godot エディタ上で以下のキーボードショートカット操作を行う。ただし、スクリプトエディタ上では使用できないので 2D または 3D ワークスペースに切り替える必要がある。\nWindows: Shift \u0026#43; Alt \u0026#43; O macOS: Shift \u0026#43; Option \u0026#43; O 大量のアセットのファイルをインポートしている状況では綺麗にフォルダ分けしていたとしても、一つひとつファイル名まで覚えていられない。そこで便利なのが「クイックオープン」での検索だ。\nこの「クイックオープン」は全てのファイルが検索対象だ。だからインポートしたサウンドファイルもテクスチャファイルもフォントファイルもシーンファイルもスクリプトファイルも拡張子で検索したり、ファイル名の一部や保存されているフォルダで検索すれば、簡単に見つけることができるだろう。また、そもそもファイルシステムドックからディレクトリをたどっていくのが面倒な場合も検索すれば一発でファイルを開くことができる。\nシーンのクイックオープン 「シーンのクイックオープン」を使用するには、Godot エディタ上で以下のキーボードショートカット操作を行う。\nWindows: Ctrl \u0026#43; Shift \u0026#43; O macOS: Cmd \u0026#43; Shift \u0026#43; O 先に紹介した「クイックオープン」と似たようなこの「シーンのクイックオープン」は、検索対象がシーンファイルのみになる。特定のシーンを開きたい時に便利だ。操作画面もほとんど「クイックオープン」と同じだ。\nスクリプトのクイックオープン 「スクリプトのクイックオープン」を使用するには、Godot エディタ上で以下のキーボードショートカット操作を行う。\nWindows: Ctrl \u0026#43; Alt \u0026#43; O macOS: Cmd \u0026#43; Option \u0026#43; O こちらの「スクリプトのクイックオープン」も先に紹介した「クイックオープン」と似た機能だが、検索対象がスクリプトファイルに限定される。特定のスクリプトを開きたい時に便利だ。操作画面もほとんど「クイックオープン」と同じだ。\nスクリプトファイルが増えてくるとスクリプトエディタの左サイドバーからは見つけにくい。おまけに、公式ドキュメントをスクリプトエディタで開いたままにしていると余計にアイテム数が増えていく。アルファベット順で表示されるとはいえ、目視ではかなり辛い。この「スクリプトのクイックオープン」をぜひ使いこなしていきたいところだ。\n複数ファイル内を検索 「複数ファイル内を検索」するには、Godot エディタ上で「スクリプトエディタ」を開き、以下のキーボードショートカット操作を行う。\nWindows: Ctrl \u0026#43; Shift \u0026#43; F macOS: Cmd \u0026#43; Shift \u0026#43; F こちらはスクリプトエディタ上での検索機能だ。複数のスクリプトフォイルからキーワードを含むファイルを検索できる。エディタ下部の検索結果パネル上にキーワードにヒットした項目が表示され、それをクリックすれば、スクリプトエディタが該当の箇所を含むスクリプトを表示してくれる。\n特定のフォルダに保存されているファイルに限定して検索したい場合は、フォルダのパスを指定してあげれば、さらに絞り込むことができる。\nまた、すでに複数のスクリプトの中にたくさん記述してしまっている変数（プロパティ）や関数（メソッド）の名前を変えたい時には全部まとめて置換することができる。まずは検索キーワードを入れて、置換ボタンをクリックする。\nその後、検索結果パネル上で以下の手順を進める。\n置換する対象にチェックを入れる。 置換後の文字列を入力する。 全て置換ボタンをクリックする。 ファイル内を検索 「ファイル内を検索」するには、Godot エディタの「スクリプトエディタ」で特定のスクリプトファイルを開き、以下のキーボードショートカット操作を行う。\nWindows: Ctrl \u0026#43; F macOS: Cmd \u0026#43; F こちらはスクリプト単体を対象とした検索だ。こちらはシンプルに特定の変数や関数の名前、コメントの内容などを探すときに便利だ。コードが長くなってくると、スクロールしながら目視で該当の箇所を見つけるのが大変になってくる。場所は大体わかっていたとしても検索してしまった方が早いこともあるので、うまく利用したい。\nファイル内を検索して置換 「ファイル内を検索して置換」を行うには、Godot エディタの「スクリプトエディタ」で特定のスクリプトファイルを開き、以下のキーボードショートカット操作を行う。\nWindows: Ctrl \u0026#43; Alt \u0026#43; F macOS: Cmd \u0026#43; Option \u0026#43; F 先の「ファイル内を検索」のショートカットのキーコンビネーションを少し変えれば、スクリプトの中で文字の置換をすることができる。そのスクリプトでしか使用しないプロパティの名前を変えるときなど便利だ。\nおわりに 今回は Godot エディタの便利な検索機能について紹介した。ショートカットの操作はどれも最初は慣れが必要だが、一度手がキーコンビネーションを覚えてしまえば、高速で作業できるようになるだろう。ぜひ積極的に使っていこう。\nUPDATE\n2022/05/29 「ブログ」から「チュートリアル」に移行\n","permalink":"https://www.peanuts-code.com/ja/tutorials/gd0009_various_searches/","summary":"Godot でゲームのプロジェクトを作っていると、そのうちゲームの規模がある程度大きくなった時に、ファイルシステムドックですぐに編集したいシーンが見つからなかったり、さっき修正しようと思っていたスクリプトがどこ","title":"Godot3 エディタの便利な検索機能"},{"content":"ゲーム開発を始めてみたいけど、年齢を理由に諦める人がなんと多いことか。いや、これはゲーム開発に限らない。ピアノを始めてみたい、YouTuberを始めてみたい、など、あらゆることに当てはまるだろう。\n中年になると、なにかと体力や気力が衰える、という認識はなぜだか割と一般的だ。しかし、本当はそうじゃない。その社会通念が自分に当てはまる根拠はどこにもないのだ。むしろ、中年サラリーマンだろうが、小学1年生だろうが、御年90歳だろうが、年齢は関係ない。やりたいと思ったその瞬間こそ、やり始めるのに一番若いタイミングなのだ。\n人生は結局、やるか、やらないかだ。人生100年時代において、何かを始めるには遅い、というケースはほとんどない。ゲーム開発なんて、なんだか難しそうで自分には無理かもしれない、という漠然とした印象だけで決断するのはもったいない。やってみないと本当のことは何もわからないのだ。\nゲーム開発は、一般人にはハードルが高いものと思われがちなのは事実だろう。未経験者がゲーム開発と聞くと、プログラミングを覚えなきゃいけないとか、デザインセンスが無いとか、作曲なんてできないとか、自分にはできそうにないことを色々想像してしまうものだ。この「難しそう」という印象は、年齢とともに強くなっていく。\nしかし繰り返すが、年齢は関係ない。「難しそう」というのは、つまり「自分には必要なスキルを習得できなさそう」ということだろう。なぜそう思うのか。それは「自分の年齢では脳が衰えてしまったし、気力も体力もないから新しいことを覚えられない」と思い込んでいるのだ。そう思い込むのは、自分の若い頃や周りの若い人たちと比べているのだろうか。なんともナンセンス。完全に自分と同じ生活をしている人間との比較ができなければ、その差異は有意ではないだろう。\nところで、若宮正子さんをご存知だろうか。「hinadan」という雛人形を並べるシニア向けゲームで一躍時の人になったお方だ。当時「最高年齢のアプリ製作者」として Apple のCEO ティム・クックから会いたいと直接声がかかったほどだ。この方も「おもしろそう」と思って様々なことに挑戦されており、頭が下がる。年齢は関係ない、という事実をまさに証明してくれている。\n『ぼくらの履歴書 Powered by エン転職』より 「面白そう！」から始まった81歳のアプリ開発。好奇心が自分の世界を拡大する｜若宮正子の言葉 筆者はまもなく40歳だが、2年前の2020年からプログラミングを始め、ゲーム開発もやるようになった。今が人生で一番、心身の調子が良いと感じている。興味さえあれば、あらゆる新しいことを覚えられる感覚がある。\nここで、ゲーム開発を始めるには具体的に何が必要なのかを挙げてみた。ゲーム開発は以下の3つの条件が揃っていれば誰でも始められる。\nゲーム開発に興味がある（気持ち） 毎日 1 時間かそれ以上をゲーム開発に当てられる（時間） PCとインターネット環境がある（環境） たったこれだけだ。どうだろう、仮に「難しそう」と感じていても、始めるだけなら誰でも始められそうな気がしてこないだろうか。\nゲーム開発を始めてみたいけどまだ始めていない人へ。さあ今この瞬間に始めてしまおう。このあとの続きの文章はもはや読む必要はない。直ちにゲームエンジンをレッツ・ダウンロードだ。\n主要なゲームエンジンのサイト一覧： Godot のダウンロードページ Unity のダウンロードページ Unreal Engine のダウンロードページ GameMaker Studio 2 のページ Cocos2d-x のダウンロードページ ツクールストアのページ と、ここまで説明してもまだ躊躇している人はいるかもしれない。プログラミングやグラフィックデザイン、作曲などのスキル習得をするなんて到底無理だと思っている人がいるんじゃないだろうか。\n確かに、一昔前の個人ゲーム開発は本当にハードルが高かったかもしれない。それは開発環境を整えたり、必要なスキルを身につけるのが大変だったからだ。しかし、今はそうじゃない。インターネット上にはゲームを作るための無料のノウハウが溢れているから、学習するのにお金はほとんどかからない。さらに、今の時代は、ゲームエンジンと呼ばれるツールを利用してゲームを開発するのが一般的だ。ゲームエンジンが、グラフィックの描画、物理演算、カメラ調整、などあらゆる煩雑なことをやってくれる。つまり、開発者はゲームそのものの開発に集中できるのだ。\n開発に使うコンピュータだって、インターネットに接続できれば、市販されている基本的なスペックのもので十分だ。ほとんどのゲームエンジンがマルチプラットフォーム対応だから、持っているコンピュータが Windows だろうが、Mac だろうが関係ない。\n求められる個別のスキルをとってみても、最初から高度なプログラミングスキルは全く必要ないし、デザインセンスや作曲のスキルがなくても、Asset Store と呼ばれる類のサイトですぐに素材を購入できる時代だ。筆者も作曲のスキルはほぼゼロだ。\nさらに、ゲームエンジンによっては、プログラミングが不要なものもある。\n例えば「GameMaker Studio 2」という比較的人気の高いゲームエンジンは、ビジュアルスクリプトと呼ばれる機能を有している。これは視覚的に必要なコマンドを並べて繋げていくようなものだ。他にも、アスキー社が開発している「RPGツクール」などのツクールシリーズと呼ばれるツールもある。特定のジャンルに特化したツクール系アプリをいくつも展開している。これらは基本的にプログラミング知識がなくても使いこなせるはずだ。ゲームエンジンも様々な種類のものが世の中に登場してきているので、一度調べてみるのが良いだろう。\nまずは入り口としてプログラミング抜きで開発できるエンジンを使ってみる。そして、もっと複雑なゲームを作りたくなったらプログラミングにチャレンジしてみる、という流れでも良いではないか。そもそも最初から大規模なゲームを作ろうとすることが間違いなのだ。MMOでオープンワールドのオンラインゲームが作りたくても、その企画は大事にとっておくべきだ。野球を始めたばかりの少年がプロ野球の試合に出たらどうなるか想像してほしい。ほぼ間違いなく「ああ、自分はなんてできないんだろう」とか「自分にはあんなふうにはなれっこない」と落ち込んでやめてしまうのがオチだろう。\n実を言うと、筆者自身も2年前までは、プログラミングと聞くと、自分とは完全に別次元の話だと思っていた。しかし、実際にプログラミングを始めてみて、ググって解って、ググって解って、を繰り返すうちに、独学でもある程度プログラミングを使いこなせるようになった。毎日の進歩はほんの少しずつだ。しかしそれが1週間、1ヶ月、１年と続けていくうちに、いつの間にか十分なスキルが身についているのだから自分でも驚きだ。毎日、少しずつ積み上げることが何より大切なのだ。そして、個人開発というのは、良くも悪くもマイペースに進められる。だから必要以上のストレスやプレッシャーに苦しまずに済む。毎日の学習を積み上げていくにはとても大事なことだ。\nここまで説明で、以下のことがお分かりいただけたと思う。\nゲーム開発が難しそうなのはただの印象 ゲーム開発のハードルは高くない 興味と時間とネット接続できるPCがあればすぐにゲーム開発を始められる ではもう一度。ゲーム開発を始めたいと思っている人は、今この瞬間に始めてしまおう。直ちに、ゲームエンジンをレッツ・ダウンロードだ。\n主要なゲームエンジンのサイト一覧： Godot のダウンロードページ Unity のダウンロードページ Unreal Engine のダウンロードページ GameMaker Studio 2 のページ Cocos2d-x のダウンロードページ ツクールストアのページ Update\n2022/02/28 タイポ修正\n","permalink":"https://www.peanuts-code.com/ja/posts/post0001_no_matter_how_old/","summary":"ゲーム開発を始めてみたいけど、年齢を理由に諦める人がなんと多いことか。いや、これはゲーム開発に限らない。ピアノを始めてみたい、YouTuberを始めてみたい、など、あらゆることに当てはまるだろう。 中年","title":"ゲーム開発を始めるのに年齢は関係ない"}]