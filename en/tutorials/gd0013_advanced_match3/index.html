<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ü§ñ Advanced Match 3 Puzzle Game in Godot3 | Peanuts Code</title>
<meta name=keywords content="GameDev,GodotEngine,Godot3,2D,PuzzleGame,MobileGame,Match3,PuzzleAndDragonsCopy"><meta name=description content="In this tutorial, we will create an advanced match-3 puzzle game, a type of puzzle game in which one piece is moved freely on the board for a certain period of time to erase three or more pieces of the same color in a row.
This is easy to understand if you imagine a puzzle game like &ldquo;Puzzle & Dragons&rdquo; (a.k.a. &ldquo;Puzzle Dora&rdquo;), which has gained popularity as a mobile game.
However, the tutorial would be too large if it included all game elements such as decks, gacha, and battles with enemy characters, so we will focus on the puzzle part of the tutorial this time."><meta name=author content="Gobo"><link rel=canonical href=https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="ü§ñ Advanced Match 3 Puzzle Game in Godot3"><meta property="og:description" content="In this tutorial, we will create an advanced match-3 puzzle game, a type of puzzle game in which one piece is moved freely on the board for a certain period of time to erase three or more pieces of the same color in a row.
This is easy to understand if you imagine a puzzle game like &ldquo;Puzzle & Dragons&rdquo; (a.k.a. &ldquo;Puzzle Dora&rdquo;), which has gained popularity as a mobile game.
However, the tutorial would be too large if it included all game elements such as decks, gacha, and battles with enemy characters, so we will focus on the puzzle part of the tutorial this time."><meta property="og:type" content="article"><meta property="og:url" content="https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-07-15T18:40:00+09:00"><meta property="article:modified_time" content="2022-07-15T18:40:00+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif"><meta name=twitter:title content="ü§ñ Advanced Match 3 Puzzle Game in Godot3"><meta name=twitter:description content="In this tutorial, we will create an advanced match-3 puzzle game, a type of puzzle game in which one piece is moved freely on the board for a certain period of time to erase three or more pieces of the same color in a row.
This is easy to understand if you imagine a puzzle game like &ldquo;Puzzle & Dragons&rdquo; (a.k.a. &ldquo;Puzzle Dora&rdquo;), which has gained popularity as a mobile game.
However, the tutorial would be too large if it included all game elements such as decks, gacha, and battles with enemy characters, so we will focus on the puzzle part of the tutorial this time."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ü§ñ Tutorials","item":"https://www.peanuts-code.com/en/tutorials/"},{"@type":"ListItem","position":2,"name":"ü§ñ Advanced Match 3 Puzzle Game in Godot3","item":"https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ü§ñ Advanced Match 3 Puzzle Game in Godot3","name":"ü§ñ Advanced Match 3 Puzzle Game in Godot3","description":"In this tutorial, we will create an advanced match-3 puzzle game, a type of puzzle game in which one piece is moved freely on the board for a certain period of time to erase three or more pieces of the same color in a row.\nThis is easy to understand if you imagine a puzzle game like \u0026ldquo;Puzzle \u0026amp; Dragons\u0026rdquo; (a.k.a. \u0026ldquo;Puzzle Dora\u0026rdquo;), which has gained popularity as a mobile game.\nHowever, the tutorial would be too large if it included all game elements such as decks, gacha, and battles with enemy characters, so we will focus on the puzzle part of the tutorial this time.","keywords":["GameDev","GodotEngine","Godot3","2D","PuzzleGame","MobileGame","Match3","PuzzleAndDragonsCopy"],"articleBody":"In this tutorial, we will create an advanced match-3 puzzle game, a type of puzzle game in which one piece is moved freely on the board for a certain period of time to erase three or more pieces of the same color in a row.\nThis is easy to understand if you imagine a puzzle game like ‚ÄúPuzzle \u0026 Dragons‚Äù (a.k.a. ‚ÄúPuzzle Dora‚Äù), which has gained popularity as a mobile game.\nHowever, the tutorial would be too large if it included all game elements such as decks, gacha, and battles with enemy characters, so we will focus on the puzzle part of the tutorial this time.\nFor more information on how to create an standard match-3 puzzle game like ‚ÄúCandy Crush‚Äù or a puzzle game like ‚ÄúLINE Tsum Tsum‚Äù, please refer to the following tutorial.\nOther Tutorials If you want to make a game like ‚ÄúCandy Crush‚Äù:\nMatch 3 puzzle game in Godot If you want to make a game like ‚ÄúLINE: Disney Tsum Tsum‚Äù:\nConnecting matching colors puzzle game in Godot The project file that will be created at the end of this tutorial is located in the GitHub repository . You can also check the project directly by downloading the .zip file and importing the ‚Äúproject.godot‚Äù file in the ‚ÄúEnd‚Äù folder with the Godot Engine.\nEnvironment This tutorial was created in the following environment\n„ÉªGodot version: 3.4.4\n„ÉªComputer OS version: macOS 11.6.5\nMemo: Please also use the following articles to help you start creating your game.\nDownloading Godot Project Manager of Godot Creating a new project Start Godot Engine and create a new project. The name of the project is up to you. If you can‚Äôt think of one, let‚Äôs call it ‚ÄúAdvanced Match3 Start‚Äù.\n###Updating project settings\nOnce the editor appears, let‚Äôs go ahead and update project settings for the entire project.\nFirst, set the display size for the game. In this case, we will assume a smartphone screen in portrait orientation and set the aspect ratio to 16 : 9.\nOpen the ‚ÄúProject‚Äù menu \u003e ‚ÄúProject Settings‚Äù. In the ‚ÄúGeneral‚Äù tab, search for ‚Äúwindow‚Äù and select ‚ÄúDisplay‚Äù \u003e ‚ÄúWindow‚Äù in the sidebar. In the ‚ÄúSize‚Äù section, change the values of the following items Width: 630 Height: 1120 Test Width: 315 Test Height: 560\nIn the ‚ÄúStretch‚Äù section, change the values of the following items Mode: 2d Aspect: keep\nWith the ‚ÄúProject Settings‚Äù window open as it is, configure the settings to substitute the mouse for the phone‚Äôs touch operation in the debug panel.\nSearch for ‚Äúmouse‚Äù in the ‚ÄúGeneral‚Äù tab and select ‚ÄúInput Devices‚Äù \u003e ‚ÄúPointing‚Äù in the sidebar. Check the On checkbox for ‚ÄúEmulate Touch From Mouse‚Äù.\nIn addition, with the ‚ÄúProject Settings‚Äù window open, let‚Äôs add an action to the input map that corresponds to a smartphone touch operation.\nSwitch to the ‚ÄúInput Map‚Äù tab and add ‚Äútouch‚Äù to the action. Add a left mouse click to the ‚Äútouch‚Äù action.\n###Downloading and importing assets\nNext, let‚Äôs download assets from KENNEY‚Äôs site and use them. This time, we will use an asset pack called ‚ÄúPhysics Assets ‚Äù. I will use the cute alien face images in this asset pack as textures for the pieces I will place on the game board. I can‚Äôt help but be thankful for this wonderful free resource.\nOnce downloaded, delete the images in the ‚Äú/physicspack/PNG/Aliens‚Äù folder with the file name ‚Äú~_round.png‚Äù and drag the ‚ÄúAliens‚Äù folder to the file system dock of the editor to import them into your project.\nCreating a Grid scene First, let‚Äôs create a ‚ÄúGrid‚Äù scene as the board on which the pieces are placed in a match-3 puzzle game.\nSelect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Scene‚Äù. Select ‚ÄúOther Node‚Äù in ‚ÄúGenerate Root Node‚Äù. When the root node of the ‚ÄúArea2D‚Äù class is generated, rename it to ‚ÄúGrid‚Äù. Save the scene. Create a folder and save the scene with the file path ‚Äúres://Grid/Grid.tscn‚Äù.\nAdding a node to the Grid scene Let‚Äôs add more nodes to the ‚ÄúGrid‚Äù root node.\nAdd a ‚ÄúCollisionShape2D‚Äù node to the ‚ÄúGrid‚Äù root node. Add a ‚ÄúNode2D‚Äù node to the ‚ÄúGrid‚Äù root node and rename it to ‚ÄúPiecesContainer‚Äù. Add two ‚ÄúTimer‚Äù nodes to the ‚ÄúGrid‚Äù root node and rename them ‚ÄúTouchTimer‚Äù and ‚ÄúWaitTimer‚Äù respectively. The scene tree should now look like the following.\nLet‚Äôs continue editing the nodes we have added.\nEditing a node in a Grid scene Grid (Area2D) Root node In this puzzle, you can move the pieces freely on the board, but the pieces you are moving must not extend beyond the board. Otherwise, the pieces can be moved outside of the board and replaced with pieces that are far away from the board. In this puzzle game, the pieces you are moving and the adjacent drops are exchanged one after another.\nThe root node is an Area2D class node that uses a signal to detect when a finger (the piece being moved) moves off the board. As long as detection is possible, the movable area of the piece can be restricted by scripts. We will attach the script to this scene at the end, so we will connect the signals again at that time.\nThere is no need to edit the properties of this node itself.\nCollisionShape2D node This node is used to detect when a finger (the piece you are moving) protrudes outside of the board. Edit each property in the inspector as follows\nShape: Apply a new RectangleShape2D resource. RectangleShape2D \u003e Extents: (x: 225, y: 190)\nTransform \u003e Position: (x: 315, y: 840)\nOn a 2D workspace, it should have looked like this.\nPiecesContainer (Node2D) node This node is used to organize the pieces that will be placed on the board. During the game, every instance of a piece that is created by the script will be added as a child of this ‚ÄúPiecesContainer‚Äù node. This way, no matter how many instances of a piece are created, the order of the nodes in the scene tree will be maintained.\nThere are no particular properties that need to be edited, so let‚Äôs move on.\nTouchTimer node This node of the Timer class is used to start a countdown after the player starts moving the pieces with his/her finger, so that when the time runs out, the pieces he/she was moving will automatically leave his/her finger. This gives the player a certain sense of urgency to line up the pieces within the time limit. In this case, we will set the pieces to be able to move for 5 seconds.\nLet‚Äôs edit the inspector as follows.\nWait Time: 5 One Shot: On\nWaitTimer node This node of the Timer class is used to pause for a moment between each process in the automatic process of matching pieces, deleting the matched pieces, filling the empty grid, and adding the missing pieces after the pieces leave the fingers. The node is used to pause for a moment between each process.\nEdit as follows in the inspector.\nWait Time: 0.3 One Shot: On\nThis completes the editing of the ‚ÄúGrid‚Äù scene.\nCreating a Piece scene Next, create a ‚ÄúPiece‚Äù scene for the pieces to be placed on the board. However, this ‚ÄúPiece‚Äù scene is only a model, and the actual pieces of each color to be used in the game will be prepared later by inheriting this ‚ÄúPiece‚Äù scene.\nSelect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Scene‚Äù. Select ‚ÄúOther Scene‚Äù in ‚ÄúGenerate Root Node‚Äù. When the root node of ‚ÄúArea2D‚Äù class is generated, rename it to ‚ÄúPiece‚Äù. Save the scene. Create a folder and save the scene with the file path ‚Äúres://Pieces/Piece.tscn‚Äù.\nAdding nodes to the Piece scene Let‚Äôs continue adding the necessary nodes to the ‚ÄúPiece‚Äù scene.\nAdd a ‚ÄúSprite‚Äù node to the ‚ÄúPiece‚Äù root node. Add a ‚ÄúCollisionShape2D‚Äù node to the ‚ÄúPiece‚Äù root node. Add a ‚ÄúTween‚Äù node to the ‚ÄúPiece‚Äù root node.\nThe scene tree for the Piece scene should now look like this.\nEditing a node in a Piece scene Piece (Area2D) Root node The root node is an Area2D class so that we can detect when a finger hits the piece we want to move, moves away from the piece, or when the pieces collide with each other.\nThe properties of this node do not need to be edited, but one property needs to be added to the group. After selecting the ‚ÄúPiece‚Äù root node in the scene dock, select the Node Dock \u003e Groups tab and create and add a group named ‚ÄúPieces.‚Äù\nIn the ‚ÄúGrid‚Äù scene, the ‚ÄúGrid‚Äù root node has a collision shape set up to detect overhang from the board, and this is a necessary group to distinguish collisions between pieces, since it is always in contact with all pieces.\nSprite node As mentioned above, the ‚ÄúPiece‚Äù is only the inheritance source (template), so in this scene, no resource is applied to the ‚ÄúTexture‚Äù property of the ‚ÄúSprite‚Äù node and it is left as it is. The plan is to apply an image that matches the color of each piece in the inherited scene.\nIn the scene of each color piece inheriting this scene, we will apply the KENNEY image imported earlier to the ‚ÄúTexture‚Äù property, but since the size of the image is 70 px in height and width, let‚Äôs shift the center of the image to the upper right and set the ‚ÄúOffset‚Äù property so that the center of the image is shifted to the upper right and the lower left corner of the image fits (x: 0, y: 0).\nOffset:\nOffset: (x: 35, y: -35)\nThe grid of the board on which the piece is to be placed should count from left to right on the x-axis and from bottom to top on the y-axis, and the size of one grid on the board should be 70 px to match the size of the texture. If the lower left corner of the piece‚Äôs texture image is aligned with (x: 0, y: 0), then when the ‚ÄúPiece‚Äù root node is positioned (x: 0, y: 0) on the grid, the ‚ÄúSprite‚Äù image will be aligned exactly with the grid.\nCollisionShape2D node The role of this node is to give the root node a collision shape. This node is needed to detect when a piece is touched by a finger, taken off a finger, or collides with a neighboring piece.\nIf the collision shape is perfectly aligned with the 70 px Sprite texture, the collision with the neighboring piece will be detected even if the piece is moved slightly.\nOn the other hand, if the collision shape is too small, the collision will not be detected even though the user intends to touch the piece with a finger, or when moving the piece, the collision between pieces will not be detected properly and the piece will pass between pieces.\nTherefore, it is best to make the collision shape half the size of the Sprite‚Äôs Texture. The position of the collision should be adjusted so that it overlaps the Sprite texture nicely.\nShape: Apply a new CircleShape2D resource CircleShape2D: Radius: 17.5\nTransform: Position: x: 35, y: -35\nOn the 2D workspace, it should have looked like this.\nTween node This node can animate only a single property of a given node. The reason for using this node in this case is to animate the movement of the pieces when they are swapped positions or when a piece is packed in the position of a piece that has been matched and disappeared.\nHowever, since the animation is implemented in a script, there is no need to edit the properties here.\nAttaching and editing a script to the Piece node Let‚Äôs attach a new script to the ‚ÄúPiece‚Äù root node. Create a script file with the file path ‚Äúres://Pieces/Piece.gd‚Äù.\nEdit the script as follows.\n### Piece.gd ### extends Area2D # Signal to send out if the piece collides with a piece the player is moving # (pass the piece itself as an argument) signal collided(self_piece) # Property to set the color of the piece export (String) var color # Property that flags if a match occurs var matched = false # Index assigned to the group of matched pieces var matched_index = 0 # Property that will be a flag if the player is moving the piece var held = false # Offset equal to the texture of the piece var offset = Vector2(35, -35) # Reference to the Sprite node onready var sprite = $Sprite # Reference to a Tween node onready var tween = $Tween # Built-in method called every frame in the main loop func _process(_delta): # If the player is moving a piece if held: # Shift the position of the piece by (35, -35) to follow the mouse position = get_global_mouse_position() - offset # Method to move the piece func move(destination): # Set the animation of the tween node. # Move the piece from the current position to the argument destination in 0.1 seconds tween.interpolate_property(self, \"position\", position, destination, .1, Tween.TRANS_QUINT, Tween.EASE_IN) # Start the animation of the tween node tween.start() # Method called when a piece is matched func make_matched(index): # Flag a match matched = true # Assign an index (argument index) for each matched group matched_index = index # Make the piece color translucent modulate = Color(1,1,1,.5) # Method called when a player's finger touches a piece func enable_held(): # Set the flag that the player is moving the piece held = true # Make the color of the piece 20% transparent modulate = Color(1, 1, 1, 0.8) # Method called when the player removes his/her finger from the piece func disable_held(): # Disable the flag that the player is moving held = false # Restore the piece's color to default modulate = Color(1, 1, 1, 1) The next step is to use signals of the Area2D class. After selecting the ‚ÄúPiece‚Äù root node in the scene dock, go to the Node dock \u003e Signal tab and connect area_entered(area: Area2D) to the ‚ÄúPiece.gd‚Äù script that you are currently editing.\nWhen the piece the player is moving is hit, we want to send out a custom signal collided(self_piece), so let‚Äôs write the code for that in the auto-generated method _on_Piece_area_entered(area).\n### Piece.gd ### # Method called when Area2D is hit and a signal is sent out func _on_Piece_area_entered(area): # If the Area2D hit is a \"Pieces\" group (i.e. an instance of Piece)... # and if it is a Piece being moved by the player if area.is_in_group(\"Pieces\") and area.held: # Send a signal collided with the piece itself as argument emit_signal(\"collided\", self) This completes the editing of the ‚ÄúPiece.gd‚Äù script.\nCreating a scene for each color that inherits from the Piece scene Now that the ‚ÄúPiece‚Äù scene, which will serve as a template, is complete, let‚Äôs create a scene that inherits the ‚ÄúPiece‚Äù scene in the number of colors of the piece. There are five piece colors: beige, blue, green, pink, and yellow. First, let‚Äôs proceed with the procedure using the ‚Äúbeige‚Äù drop as an example.\nSelect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Inherited Scene Select ‚ÄúPiece.tscn‚Äù as the source scene After the inherited scene is generated, rename the root node to ‚ÄúPieceBeige.\n*The name of this root node should match the color of each drop. Save the scene once. Save the scene with the file path ‚Äúres://Pieces/PieceBeige.tscn‚Äù. With the root node ‚ÄúPieceBeige‚Äù selected in the scene dock, set the value of the ‚ÄúColor‚Äù property of ‚ÄúScript Variables‚Äù to ‚Äúbeige‚Äù in the inspector.\nSelect the ‚ÄúSprite‚Äù node in the scene dock and apply the previously imported resource ‚Äúres://Aliens/alienBeige_round.png‚Äù to the ‚ÄúTexture‚Äù property (you can drag it from the file system dock).\nOn the 2D workspace, it should now look like the following screenshot.\n! Sprite - Texture Region The ‚ÄúPieceBeige‚Äù scene is now complete. Follow the same procedure to create scenes for the remaining four colored pieces. Please refer to the following for details on the different parts of each scene. Blue piece. Root node name: PieceBlue Color property: blue Sprite \u003e Texture property: res://Aliens/alienBlue_round.png File path when saving the scene: res://Pieces/PieceBlue.tscn Green piece. Root node name: PieceGreen Color property: green Sprite \u003e Texture property: res://Aliens/alienGreen_round.png File path when saving the scene: res://Pieces/PieceGreen.tscn Pink piece. Root node name: PiecePink Color property: green Sprite \u003e Texture property: res://Aliens/alienPink_round.png File path when saving the scene: res://Pieces/PiecePink.tscn Yellow piece. Root node name: PieceYellow Color property: yellow Sprite \u003e Texture property: res://Aliens/alienYellow_round.png File path when saving the scene: res://Pieces/PieceYellow.tscn When the inherited scene of all 5 colored pieces has been created, the work is complete.\nControlling a Grid scene with scripts From here on, we will code scripts to control the game. The amount of code is rather large, so do your best.\nAfter switching to the ‚ÄúGrid.tscn‚Äù scene in the Godot editor, attach a new script to the ‚ÄúGrid‚Äù root node. The file path should be ‚Äúres://Grid/Grid.gd‚Äù.\nIn the comments in the script, ‚Äúfinger touched‚Äù or ‚Äúfinger released‚Äù should be replaced with ‚Äúleft mouse button pressed‚Äù or ‚Äúleft mouse button released‚Äù on the Godot debug panel.\nAlso, please note that ‚Äúmatch‚Äù is defined as three or more of the same color.\nNow, once the script editor is open, let‚Äôs define the necessary properties.\n### Grid.gd ### extends Area2D # Signal sent out at the start of automatic matching process signal waiting_started # Array with scene files for each color piece as elements const pieces_scn = [ preload(\"res://Pieces/PieceBeige.tscn\"), preload(\"res://Pieces/PieceBlue.tscn\"), preload(\"res://Pieces/PieceGreen.tscn\"), preload(\"res://Pieces/PiecePink.tscn\"), preload(\"res://Pieces/PieceYellow.tscn\") ] # Number of grids in x-axis var width: = 7 # Number of grids in y-axis var height: = 6 # Grid start position in x-axis direction (pixels) var x_start: = 70 # Grid start position in y-axis direction (pixel) var y_start: = 1050 # Size of one grid (should be the same as Texture of Sprite in Piece) var grid_size: = 70 # How many grid y-axis displacements to drop when the Piece is generated var y_offset: = 3 # Array representing the placement of the pieces on the board (two-dimensional array) var board = []. # Reference to the piece the player is moving var moving_piece # Last grid position of the piece the player is moving var last_pos = Vector2() # Flag for preparing at the start of the game var is_initializing = true # Flag if the player is moving the piece var is_touching = false # Flag if the player is swapping pieces var is_swapping = false # Flag during automatic match processing after the player moves the piece var is_waiting = false # Number of groups of matched pieces (to be counted up) var matched_groups = 0 # Reference to the PiecesContainer node onready var pieces_container = $PiecesContainer # Reference to the TouchTimer node onready var touch_timer = $TouchTimer # Reference the WaitTimer node onready var wait_timer = $WaitTimer Then from here on, we will be adding methods. Note that the two-dimensional array that appears in the following code is an array that stores arrays as elements, that is, an array of arrays.\nIn the case of the two-dimensional array used in this script, the first level of the array contains as many empty arrays as the number of grids in the x-axis direction of the board, and the second level of the array contains as many elements as the number of grids in the vertical direction within each array. By storing piece objects as its elements, we can manage where each piece is located on the board (how many grids in the x-axis direction and how many grids in the y-axis direction).\n### Grid.gd ### # Function called when scene is loaded func _ready(): # Call a built-in function to randomize the output result of a function that generates a random number each time randomize() # Make the board (array) into a 2d array that makes up the grid of the board board = make_2d_array() # define after this # Spawn the pieces and place them on the board and reflect the board information on the board spawn_pieces() # define after this is_initializing = false # Method to create a 2d array that makes up the grid of the board func make_2d_array() -\u003e Array: # Prepare an array named array var array = [] # Fill array with an empty array with the number of grids along the x-axis for i in width: array.append([]) # Append null to each array for the number of grids along the y-axis for j in height: array[i].append(null) # Return the resulting two-dimensional array return array # Method to spawn pieces, place them on the board, and reflect the board information to the board func spawn_pieces(): # Loop for the number of grids along the x-axis for i in width: # Loop over the number of grids along the y-axis for j in height: # If no piece exists in the corresponding grid on the 2D array of all pieces # (all are null at the start of the game) if board[i][j] == null: # Select one piece at random from the scene of pieces of each color and instantiate it var index = floor(rand_range(0, pieces_scn.size())) var piece = pieces_scn[index].instance() # If the game is being prepared at the start if is_initializing: # If a match has occurred, delete the piece instance and start over while match_at(i, j, piece.color): # define after this piece.queue_free() index = floor(rand_range(0, pieces_scn.size())) piece = pieces_scn[index].instance() # Make a piece instance a child of a PiecesContainer node pieces_container.add_child(piece) # Collided signal for a piece instance... # connect to the _on_Piece_collided method (defined later) piece.connect(\"collided\", self, \"_on_Piece_collided\") # Place the piece instance y_offset from the placement position... # move the piece instance to the placement position from there (drop it) piece.position = grid_to_pixel(i, j + y_offset) # define after this piece.move(grid_to_pixel(i, j)) # defined after this # Add the generated piece to the element at the appropriate index of the board as board information board[i][j] = piece Let‚Äôs define the undefined match_at and grid_to_pixel methods in the above code.\n### Grid.gd ### # Method to check if 3 or more pieces of the same color are lined up at the specified grid position # Arguments column is the x-axis grid position, the row is the y-axis grid position, and color is the color of the piece func match_at(column, row, color): # If the x-axis position of the given grid is greater than or equal to 3 if column \u003e= 2: # If there is a piece to the left of the specified grid position and one more to the left if board[column-1][row] ! = null \\ and board[column-2][row] ! = null: # If the left neighbor and another left neighbor have the same color as the specified piece if board[column-1][row].color == color \\ and board[column-2][row].color == color: # Return true return true # If y-axis position of the specified grid is 3 or more if row \u003e= 2: # If there are pieces below the specified grid position and one more below if board[column][row-1] ! = null \\ and board[column][row-2] ! = null: # If the color of the piece below and one more piece below is the same as the color of the specified piece if board[column][row-1].color == color \\ and board[column][row-2].color == color: # Return true return true # Method to convert grid position to pixel position func grid_to_pixel(column, row) -\u003e Vector2: # Define a variable of type Vector2 for pixel position output var pixel_pos = Vector2() # Pixel x-coordinate = grid start position along x-axis + grid size * grid x-coordinate pixel_pos.x = x_start + grid_size * column # Pixel y-coordinate = grid start position along y-axis - grid size x grid y-coordinate pixel_pos.y = y_start - grid_size * row # Return pixel coordinates return pixel_pos Now the pieces of each color should be randomly arranged on the board at the start of the game. Let‚Äôs run the project once to check it out. When you run the project for the first time, a dialog box for selecting the main scene will appear, so select ‚ÄúGrid.tscn‚Äù as the main scene.\nSince we just defined the grid_to_pixel method, let‚Äôs define the pixel_to_grid method for later use. As the name suggests, this method is the opposite of grid_to_pixel defined earlier and converts pixel positions to grid positions.\n### Grid.gd ### # Method to convert a pixel position to a grid position func pixel_to_grid(pixel_x, pixel_y) -\u003e Vector2: var grid_pos = Vector2() grid_pos.x = floor((pixel_x - x_start) / grid_size) grid_pos.y = floor((pixel_y - y_start) / -grid_size) return grid_pos In addition, we define one more method is_in_grid to be used later. This method determines whether the position passed as an argument is within the range of the board grid and returns the result.\n### Grid.gd ### # Method that returns whether the specified position is within the grid of the board func is_in_grid(grid_position: Vector2) -\u003e bool: if grid_position.x \u003e= 0 and grid_position.x \u003c width \\ and grid_position.y \u003e= 0 and grid_position.y \u003c height: # Return true if within the grid of the board return true else: # Return false if out of range of the board grid return false From this point on, we will write a program to process the game player‚Äôs input (screen touch operation).\n### Grid.gd ### # Function called every frame in the main loop of the game func _process(_delta): # if not in the process of matching if not is_waiting: # call a method to process the player's input touch_input() # defined after this # Method for handling player input func touch_input(): # If a finger touches the screen if Input.is_action_just_pressed(\"touch\"): # Call a method to perform processing when a piece is touched touch_piece() # defined after this # If the finger leaves the screen if Input.is_action_just_released(\"touch\") and is_touching: # Call the method that executes the action when the finger leaves the piece release_piece() # defined after this # Methods to execute when a piece is touched func touch_piece(): # Get the pixel coordinates of the piece when a finger touches it var pos = get_global_mouse_position() # Convert from pixel coordinates to grid coordinates var grid_pos = pixel_to_grid(pos.x, pos.y) # If grid coordinates are within the board if is_in_grid(grid_pos): # Register the grid coordinates as the last position of the piece being moved last_pos = grid_pos # register the piece at grid coordinates as the moving piece moving_piece = board[last_pos.x][last_pos.y] # Flag the piece as moving is_touching = true # Also flag the moving piece instance itself as moving moving_piece.enable_held() # Start a timer to limit the time the piece can be moved touch_timer.start() # Method to execute when the finger leaves the piece func release_piece(): # If we find a piece we were moving among the elements of the two-dimensional array board... # Fit the moved piece exactly on the board grid for i in width: for j in height: if board[i][j] == moving_piece: moving_piece.move(grid_to_pixel(i, j)) break # Disable the moving flag of the moving piece instance itself moving_piece.disable_held() # Disable the moving flag of the moving piece is_touching = false # Stop the timer for the time limit for moving the piece touch_timer.stop() # Signal the start of automatic matching process after this emit_signal(\"waiting_started\") Although we have not yet implemented the exchange of pieces, the coding up to this point should have implemented the movement of a piece that is touched by a finger, and when the finger is released, the piece that is being moved will settle exactly where it was last. Let‚Äôs run the project and check it out.\nThe next method we will define, _on_Piece_collided, has already been coded to connect a collided signal when the Piece instance is created. Recall that we coded this signal in the ‚ÄúPiece.gd‚Äù script to be sent out when a piece is hit by a piece being moved by the player.\nLet‚Äôs define a method to swap the location of the moving piece and the piece that hit it, and call it in _on_Piece_collided.\n### Grid.gd ### # Method called on collided signal of a Piece instance func _on_Piece_collided(self_piece): # If the piece is moving and not in the process of swapping pieces if is_touching and not is_swapping: # Flag the piece is being swapped is_swapping = true # Call a method to swap pieces swap_pieces(self_piece) # define later # Remove the flag that a piece is being swapped is_swapping = false # Method to swap the location of the piece being moved and the piece that hit it # The collided_piece argument is passed the piece that hit the piece being moved func swap_pieces(collided_piece): # Get the grid coordinates of the piece that hit it. var collided_pos = pixel_to_grid(collided_piece.position.x, collided_piece.position.y) # If the piece being moved on the two-dimensional array board matches the piece being moved if board[last_pos.x][last_pos.y] == moving_piece: # Put the piece that hit the position of the moving piece on the board board[last_pos.x][last_pos.y] = collided_piece # Move the hit piece to the last grid coordinate of the piece being moved collided_piece.move(grid_to_pixel(last_pos.x, last_pos.y)) # Put the piece being moved into the position of the hit piece on the board board[collided_pos.x][collided_pos.y] = moving_piece # Register the grid coordinates of the hit piece as the last position of the moving piece last_pos = collided_pos Now you should be able to implement the exchange of pieces. Let‚Äôs actually run the project and move the pieces. Let‚Äôs see how the pieces of the route are exchanged one after another.\nNow, at this point, there are two problems.\nBeing able to move freely outside of the board. Being able to grab the piece forever. These problems can be solved using signals.\nLet‚Äôs connect the signals of the ‚ÄúGrid‚Äù root node of the Area2D class to the script. Remember how we adjusted the collision shape to the size of the board? The signal that is sent out when the finger (the piece that is being moved) goes out of that area will cause the release_piece method to be called so that the piece that was being moved will also go away from the finger and return to its last position on the board.\nSelect the ‚ÄúGrid‚Äù root node in the Scene dock, select Node dock \u003e Signals tab, and connect the erea_exited signal to this script.\nAnother signal that is sent out when the time limit for moving the piece in the ‚ÄúTouchTimer‚Äù node times out is also connected to the script. In this case, the release_piece method should be called by the signal as well. Let‚Äôs connect the timeout signal.\nContinuing on, let‚Äôs edit the methods generated by the connection of each signal as follows.\n### Grid.gd ### # Method called with a signal when Area2D is out of the board func _on_Grid_area_exited(area): # If the area2D that has been moved out of the grid is a piece that is being moved if area.is_in_group(\"Pieces\") and area.held: # Call the method that handles when the finger leaves the piece release_piece() # Method called with a signal when the time limit for moving a piece expires func _on_TouchTimer_timeout(): # if the piece is moving if is_touching: # call a method that will do something when the finger leaves the piece release_piece() Now, if the piece is out of the board, the piece should now leave your finger and return to its last position on the board. Also, if you grabbed the piece for more than 5 seconds, the timer should now cause the piece to leave your finger and return to the last grid coordinate on the board.\nNow let‚Äôs actually run the project and see how it works.\nFrom here, we will create a program to automatically process the matched pieces. At the end of the release_piece method, we used the code emit_signal(\"waiting_started\") to send out a waiting_started signal, and we will start by connecting this signal to the script.\nSelect the ‚ÄúGrid‚Äù root node in Scene dock and connect the waiting_started signal to the script in the Node dock \u003e Signals tab. Once the _on_Grid_waiting_started method is added to the script, we will write the automatic processing of the matched piece in the method. Roughly speaking, the automatic process is as follows.\nSet the flag for automatic matching process in progress. Check if there is at least one matched piece; if there is at least one, loop through the following process. Check all pieces and flag matched pieces. Delete the flagged piece. Fill the empty space by moving a piece from the grid above in the same row or column. After the pieces are moved down, a new piece is created in the empty space at the end. When there are no more matched pieces, the automatic processing flag is cleared.\nLet‚Äôs implement the above process step by step. Let‚Äôs start with the ‚Äúcheck all the pieces and flag the matching pieces‚Äù part.\n### Grid.gd ### # Method called with a signal sent out at the end of the release method func _on_Grid_waiting_started(): # Set a flag that automatic Matching processing is in progress. is_waiting = true # Keep looping if there is at least one matched piece in a group of people while check_matches(): # define after this # Call method to flag matched pieces find_matches(): # define after this # Start WaitTimer timer (0.3 seconds) wait_timer.start() # Wait until WaitTimer times out yield(wait_timer, \"timeout\") # Clear the flag during automatic processing is_waiting = false # Method to check if there is at least one pair of matched pieces func check_matches() -\u003e bool: # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of grids in y-axis of the board for j in height: # If a piece exists at that grid coordinate if board[i][j] != null: # If the piece is matched if match_at(i, j, board[i][j].color): # Return true return true # Return false if none of the pieces match return false # Method to flag matched pieces func find_matches(): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of grids in y-axis of the board for j in height: # If a piece exists at that grid coordinate if board[i][j] != null: # Define current color as the color of the piece at that grid coordinate var current_color = board[i][j].color # If its x-axis coordinates are less than the number of grids along the x-axis - 2 if i \u003c width - 2: # If there are pieces to the right of that piece and further to its right if board[i+1][j] != null \\ and board[i+2][j] != null: # If the color of those pieces is the same as the current color if board[i+1][j].color == current_color \\ and board[i+2][j].color == current_color: # Define a variable for the index to assign to the matched pairs var matched_index: int # If the piece is already flagged as matched if board[i][j].matched: # Index should be the same as the index information the piece has matched_index = board[i][j].matched_index # If the piece is not flagged as matched else: # Increment the number of groups in the matched pair matched_groups += 1 # Set the index to the number of groups in the matched pairs matched_index = matched_groups # Flag the piece at those coordinates as matched, assign an index, and make it translucent board[i][j].make_matched(matched_index) # Do the same for the piece to the right of those coordinates board[i+1][j].make_matched(matched_index) # Do the same for the piece one more place to the right board[i+2][j].make_matched(matched_index) # Do the same for the y-axis direction if j \u003c height - 2: if board[i][j+1] != null \\f} and board[i][j+2] != null: if board[i][j+1].color == current_color \\ and board[i][j+2].color == current_color var matched_index: int if board[i][j].matched: matched_index = board[i][j].matched_index else: matched_groups += 1 matched_index = matched_groups board[i][j].make_matched(matched_index) board[i][j+1].make_matched(matched_index) board[i][j+2].make_matched(matched_index) Of the processing of the matched pieces, we have implemented the flagging of the matched pieces. Let‚Äôs run the project and see if the matched pieces become translucent.\nThe next step is to define a method to delete pieces that are flagged for match status.\n### Grid.gd ### # Method to delete a piece that is flagged as a match # The argument index is the index of the match pair to delete func delete_matches(index): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of grids in the y-axis of the board for j in height: # If a piece exists at that grid coordinate if board[i][j] != null: # If the piece at that grid coordinate is flagged as a match if board[i][j].matched: # If the pair number of the piece at that grid coordinate matches the pair number of the piece to be deleted if board[i][j].matched_index == index: # Release the piece at those grid coordinates board[i][j].queue_free() # Set the corresponding element of the two-dimensional array board to null board[i][j] = null Now that we have defined the delete_matches method, let‚Äôs put it in the loop of the _on_Grid_waiting_started method.\n### Grid.gd ### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \"timeout\") # Add here # If the number of matched groups is greater than 0 if matched_groups \u003e 0: # Loop over matched groups # Don't delete all of them at the same time, delete each matched group for index in range(1, matched_groups + 1): # Call method to delete matched pieces delete_matches(index) # Start WaitTimer timer (0.3 seconds) wait_timer.start() # Wait until WaitTimer times out yield(wait_timer, \"timeout\") # Set the number of matched groups back to 0 after all matched pieces are removed matched_groups = 0 is_waiting = false We should now be able to implement the matching piece to the point where it becomes translucent and then deleted. Let‚Äôs run the project and check it out.\nNext, we will implement the process of filling (dropping) the top piece into the grid space vacated by the removed piece. Let‚Äôs start by defining the method.\n### Grid.gd ### # Method to collapse (drop) the top piece into the empty grid space func collapse_columns(): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of y-axis grids in the board for j in height: # If there is no piece at that grid coordinate if board[i][j] == null: # Loop over the remaining y-axis grids starting from the grid one above that y-coordinate for k in range(j + 1, height): # If the piece exists at that grid coordinate if board[i][k] ! = null: # Move the piece at that grid coordinate to an empty space board[i][k].move(grid_to_pixel(i, j)) # Replace the elements of the two-dimensional array board board[i][j] = board[i][k]. board[i][k] = null # End of loop break Now that we have defined the collapse_columns method, let‚Äôs add it to the loop of the _on_Grid_waiting_started method.\n### Grid.gd ### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \"timeout\") if matched_groups \u003e 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \"timeout\") matched_groups = 0 # Add here # Call the method to collapse (drop) the top piece into the empty grid space collapse_columns() # Start timer for WaitTimer (0.3 seconds) wait_timer.start() # Wait until WaitTimer times out yield(wait_timer, \"timeout\") is_waiting = false Now, after the matched and translucent piece is removed, the top piece should now be collapsed (dropped) into that empty space. Let‚Äôs run the project and check it out.\nFinally, after the piece is dropped down, the empty space above it needs to be refilled with a new piece. The method for this is the already defined spawn_pieces method, which is also executed in the _ready function. When the game play starts, the is_initializing property is false, so the block in this method that re-generates the piece if it matches is skipped. In other words, a new match may already occur when the piece is generated by executing this method. This should generate more combos than expected and make the game experience more pleasant and fun.\nLet‚Äôs add the spawn_pieces method inside the loop of the _on_Grid_waiting_started method.\n### Grid.gd ### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \"timeout\") if matched_groups \u003e 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \"timeout\") matched_groups = 0 collapse_columns() wait_timer.start() yield(wait_timer, \"timeout\") # Add here. # call a method to spawn pieces in the empty space spawn_pieces() # Start WaitTimer timer (0.3 seconds) wait_timer.start() # Wait until WaitTimer times out yield(wait_timer, \"timeout\") is_waiting = false This completes the coding of the match process. This is the end of the work for this tutorial as well. Let‚Äôs finish up by running the project to make sure this puzzle game is working properly.\nSample game I have prepared a sample game that is a further brushed-up version of the project created in this tutorial.\nYour browser does not support the video tag. The project file of the sample game is located in GitHub repository . Please download the .zip file from there and import the \" project.godot‚Äù file in the ‚ÄúSample‚Äù folder and import it into Godot Engine.\nGame Rules:\nThe player can move a piece for up to 5 seconds at a time; after 5 seconds, the piece leaves his/her finger. If the piece the player is moving goes out of the board, the piece leaves his/her finger and moves only that far. The number of combos goes up by the number of matched pairs of pieces. The player can attack aliens (enemy characters) by the number of combos, and their power is also increased. Attacking an alien reduces its HP by the amount of its power, and when the alien‚Äôs HP is reduced to 0, it can be defeated. Aliens attack players at regular intervals. The player has a maximum of 10 lives, which is reduced by one when the alien attacks, and the game is over when the player is attacked 10 times. Each time an enemy is defeated, the player‚Äôs level increases by one. The player‚Äôs power increases slightly as the level increases, while the enemy characters also increase their HP and attack at slightly shorter intervals. The enemy‚Äôs time gauge pauses during the automatic processing of matched pieces (during combo counting and attacking the enemy) after the player moves a piece and releases his finger. Ultimately, the number of aliens defeated is the game‚Äôs score. Conclusion In this tutorial, I created a puzzle game in the style of Puzzle and Dragons, which I call an evolutionary Match-3 puzzle game. Unlike the standard Match-3 game, we made the pieces move freely on the board for a certain period of time, and also made each matched piece disappear in turn, just like in Puzzle and Dragons. I hope you were able to make it through to the end.\nLet me summarize the key points when creating an advanced match-3 puzzle game like this one.\nAt a minimum, you need only two scenes: the board and the pieces. Create a template piece scene and then inherit it to create a piece scene for each color. Use a two-dimensional array to manage the pieces to be placed on the board grid. Use Area2D signals to detect the following When a finger touches a piece When a finger leaves a piece When a moving piece hits a stationary piece When a moving piece moves out of the board. Provide properties for flags to manage the state of the piece. For example Whether a piece is being moved or not whether a piece is being replaced or not whether a piece is being matched or not Whether the matched piece is being automatically processed or not When a piece is being swapped, the position of the piece on the screen and the elements of the two-dimensional array must be updated, respectively. Links KidsCanCode: OBJECT HEALTHBARS KidsCanCode: HEART CONTAINERS: 3 WAYS App Store: PuzzleÔºÜDragons Google Play:PuzzleÔºÜDragons ","wordCount":"7299","inLanguage":"en","image":"https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif","datePublished":"2022-07-15T18:40:00+09:00","dateModified":"2022-07-15T18:40:00+09:00","author":{"@type":"Person","name":"Gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/en/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/en/ title=Home><span>Home</span></a></li><li><a href=https://www.peanuts-code.com/en/portfolio/ title="Published Games"><span>Published Games</span></a></li><li><a href=https://www.peanuts-code.com/en/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://www.peanuts-code.com/en/tutorials/ title=Tutorials><span>Tutorials</span></a></li><li><a href=https://www.peanuts-code.com/en/about/ title=About><span>About</span></a></li><li><a href=https://www.peanuts-code.com/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/en/>Home</a>&nbsp;¬ª&nbsp;<a href=https://www.peanuts-code.com/en/tutorials/>ü§ñ Tutorials</a></div><h1 class=post-title>ü§ñ Advanced Match 3 Puzzle Game in Godot3</h1><div class=post-meta><span title='2022-07-15 18:40:00 +0900 +0900'>2022-07-15</span>&nbsp;¬∑&nbsp;35 min&nbsp;¬∑&nbsp;Gobo&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/ja/tutorials/gd0013_advanced_match3/>Ja</a></li></ul></div></header><figure class=entry-cover><img loading=lazy src=https://www.peanuts-code.com/images/tutorials/gd0013_advanced_match3/img0.gif alt="Advanced Match 3 Puzzle Game in Godot"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#creating-a-new-project aria-label="Creating a new project">Creating a new project</a></li><li><a href=#creating-a-grid-scene aria-label="Creating a Grid scene">Creating a Grid scene</a><ul><li><a href=#adding-a-node-to-the-grid-scene aria-label="Adding a node to the Grid scene">Adding a node to the Grid scene</a></li><li><a href=#editing-a-node-in-a-grid-scene aria-label="Editing a node in a Grid scene">Editing a node in a Grid scene</a><ul><li><a href=#grid-area2d-root-node aria-label="Grid (Area2D) Root node">Grid (Area2D) Root node</a></li><li><a href=#collisionshape2d-node aria-label="CollisionShape2D node">CollisionShape2D node</a></li><li><a href=#piecescontainer-node2d-node aria-label="PiecesContainer (Node2D) node">PiecesContainer (Node2D) node</a></li><li><a href=#touchtimer-node aria-label="TouchTimer node">TouchTimer node</a></li><li><a href=#waittimer-node aria-label="WaitTimer node">WaitTimer node</a></li></ul></li></ul></li><li><a href=#creating-a-piece-scene aria-label="Creating a Piece scene">Creating a Piece scene</a><ul><li><a href=#adding-nodes-to-the-piece-scene aria-label="Adding nodes to the Piece scene">Adding nodes to the Piece scene</a></li><li><a href=#editing-a-node-in-a-piece-scene aria-label="Editing a node in a Piece scene">Editing a node in a Piece scene</a><ul><li><a href=#piece-area2d-root-node aria-label="Piece (Area2D) Root node">Piece (Area2D) Root node</a></li><li><a href=#sprite-node aria-label="Sprite node">Sprite node</a></li><li><a href=#collisionshape2d-node-1 aria-label="CollisionShape2D node">CollisionShape2D node</a></li><li><a href=#tween-node aria-label="Tween node">Tween node</a></li></ul></li><li><a href=#attaching-and-editing-a-script-to-the-piece-node aria-label="Attaching and editing a script to the Piece node">Attaching and editing a script to the Piece node</a></li></ul></li><li><a href=#creating-a-scene-for-each-color-that-inherits-from-the-piece-scene aria-label="Creating a scene for each color that inherits from the Piece scene">Creating a scene for each color that inherits from the Piece scene</a></li><li><a href=#controlling-a-grid-scene-with-scripts aria-label="Controlling a Grid scene with scripts">Controlling a Grid scene with scripts</a></li><li><a href=#sample-game aria-label="Sample game">Sample game</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#links aria-label=Links>Links</a></li></ul></div></details></div><div class=post-content><p>In this tutorial, we will create an advanced match-3 puzzle game, a type of puzzle game in which one piece is moved freely on the board for a certain period of time to erase three or more pieces of the same color in a row.</p><p>This is easy to understand if you imagine a puzzle game like &ldquo;Puzzle & Dragons&rdquo; (a.k.a. &ldquo;Puzzle Dora&rdquo;), which has gained popularity as a mobile game.</p><p>However, the tutorial would be too large if it included all game elements such as decks, gacha, and battles with enemy characters, so we will focus on the puzzle part of the tutorial this time.</p><p>For more information on how to create an standard match-3 puzzle game like &ldquo;Candy Crush&rdquo; or a puzzle game like &ldquo;LINE Tsum Tsum&rdquo;, please refer to the following tutorial.</p><blockquote><p><em><strong><span style=color:salmon>Other Tutorials</span></strong><br>If you want to make a game like &ldquo;Candy Crush&rdquo;:<br><a href=https://www.peanuts-code.com/en/tutorials/gd0012_match3/ title="Match 3 puzzle game in Godot">Match 3 puzzle game in Godot</a><br>If you want to make a game like &ldquo;LINE: Disney Tsum Tsum&rdquo;:<br><a href=https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/ title="Connecting matching colors puzzle game in Godot">Connecting matching colors puzzle game in Godot</a></em></p></blockquote><br><p>The project file that will be created at the end of this tutorial is located in the <a href=https://github.com/msnsk/AdvancedMatch3.git target=_blank>GitHub repository</a>
. You can also check the project directly by downloading the .zip file and importing the &ldquo;project.godot&rdquo; file in the &ldquo;End&rdquo; folder with the Godot Engine.<br><br></p><blockquote><p><em><strong><span style=color:salmon>Environment</span></strong><br>This tutorial was created in the following environment</em><br>„Éª<em>Godot version: <strong>3.4.4</strong></em><br>„Éª<em>Computer OS version: <strong>macOS 11.6.5</strong></em></p></blockquote><blockquote><p><em><strong><span style=color:salmon>Memo:</span></strong><br>Please also use the following articles to help you start creating your game.<br><a href=https://www.peanuts-code.com/en/tutorials/gd0001_download/>Downloading Godot</a><br><a href=https://www.peanuts-code.com/en/tutorials/gd0002_project_manager/>Project Manager of Godot</a></em><br><br></p></blockquote><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-new-project>Creating a new project<a hidden class=anchor aria-hidden=true href=#creating-a-new-project>#</a></h2><p>Start Godot Engine and create a new project. The name of the project is up to you. If you can&rsquo;t think of one, let&rsquo;s call it &ldquo;Advanced Match3 Start&rdquo;.</p><br><p>###Updating project settings</p><p>Once the editor appears, let&rsquo;s go ahead and update project settings for the entire project.</p><p>First, set the display size for the game. In this case, we will assume a smartphone screen in portrait orientation and set the aspect ratio to <strong>16 : 9</strong>.</p><ol><li>Open the &ldquo;Project&rdquo; menu > &ldquo;Project Settings&rdquo;.</li><li>In the &ldquo;General&rdquo; tab, search for &ldquo;window&rdquo; and select &ldquo;Display&rdquo; > &ldquo;Window&rdquo; in the sidebar.</li><li>In the &ldquo;Size&rdquo; section, change the values of the following items<ul><li>Width: 630</li><li>Height: 1120</li><li>Test Width: 315</li><li>Test Height: 560<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img1.png alt="project settings - Display - Window - Size"></li></ul></li><li>In the &ldquo;Stretch&rdquo; section, change the values of the following items<ul><li>Mode: 2d</li><li>Aspect: keep<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img2.png alt="project settings - Display - Window - Stretch"></li></ul></li></ol><br><p>With the &ldquo;Project Settings&rdquo; window open as it is, configure the settings to substitute the mouse for the phone&rsquo;s touch operation in the debug panel.</p><ol><li>Search for &ldquo;mouse&rdquo; in the &ldquo;General&rdquo; tab and select &ldquo;Input Devices&rdquo; > &ldquo;Pointing&rdquo; in the sidebar.</li><li>Check the On checkbox for &ldquo;Emulate Touch From Mouse&rdquo;.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img3.png alt="Input Devices - Pointing - Emulate Touch From Mouse"></li></ol><br><p>In addition, with the &ldquo;Project Settings&rdquo; window open, let&rsquo;s add an action to the input map that corresponds to a smartphone touch operation.</p><ol><li>Switch to the &ldquo;Input Map&rdquo; tab and add &ldquo;touch&rdquo; to the action.</li><li>Add a left mouse click to the &ldquo;touch&rdquo; action.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img4.png alt="Inputmap - action - tap"></li></ol><br><p>###Downloading and importing assets</p><p>Next, let&rsquo;s download assets from KENNEY&rsquo;s site and use them. This time, we will use an asset pack called &ldquo;<a href=https://www.kenney.nl/assets/physics-assets target=_blank>Physics Assets</a>
&rdquo;. I will use the cute alien face images in this asset pack as textures for the pieces I will place on the game board. I can&rsquo;t help but be thankful for this wonderful free resource.</p><p>Once downloaded, delete the images in the &ldquo;/physicspack/PNG/Aliens&rdquo; folder with the file name &ldquo;~_round.png&rdquo; and drag the &ldquo;Aliens&rdquo; folder to the file system dock of the editor to import them into your project.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-grid-scene>Creating a Grid scene<a hidden class=anchor aria-hidden=true href=#creating-a-grid-scene>#</a></h2><p>First, let&rsquo;s create a &ldquo;Grid&rdquo; scene as the board on which the pieces are placed in a match-3 puzzle game.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;Other Node&rdquo; in &ldquo;Generate Root Node&rdquo;.</li><li>When the root node of the &ldquo;Area2D&rdquo; class is generated, rename it to &ldquo;Grid&rdquo;.</li><li>Save the scene. Create a folder and save the scene with the file path &ldquo;res://Grid/Grid.tscn&rdquo;.<br><br></li></ol><h3 id=adding-a-node-to-the-grid-scene>Adding a node to the Grid scene<a hidden class=anchor aria-hidden=true href=#adding-a-node-to-the-grid-scene>#</a></h3><p>Let&rsquo;s add more nodes to the &ldquo;Grid&rdquo; root node.</p><ol><li>Add a &ldquo;CollisionShape2D&rdquo; node to the &ldquo;Grid&rdquo; root node.</li><li>Add a &ldquo;Node2D&rdquo; node to the &ldquo;Grid&rdquo; root node and rename it to &ldquo;PiecesContainer&rdquo;.</li><li>Add two &ldquo;Timer&rdquo; nodes to the &ldquo;Grid&rdquo; root node and rename them &ldquo;TouchTimer&rdquo; and &ldquo;WaitTimer&rdquo; respectively.</li></ol><p>The scene tree should now look like the following.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img5.png alt="Scene Dock"></p><p>Let&rsquo;s continue editing the nodes we have added.</p><br><h3 id=editing-a-node-in-a-grid-scene>Editing a node in a Grid scene<a hidden class=anchor aria-hidden=true href=#editing-a-node-in-a-grid-scene>#</a></h3><h4 id=grid-area2d-root-node>Grid (Area2D) Root node<a hidden class=anchor aria-hidden=true href=#grid-area2d-root-node>#</a></h4><p>In this puzzle, you can move the pieces freely on the board, but the pieces you are moving must not extend beyond the board. Otherwise, the pieces can be moved outside of the board and replaced with pieces that are far away from the board. In this puzzle game, the pieces you are moving and the adjacent drops are exchanged one after another.</p><p>The root node is an Area2D class node that uses a signal to detect when a finger (the piece being moved) moves off the board. As long as detection is possible, the movable area of the piece can be restricted by scripts. We will attach the script to this scene at the end, so we will connect the signals again at that time.</p><p>There is no need to edit the properties of this node itself.</p><br><h4 id=collisionshape2d-node>CollisionShape2D node<a hidden class=anchor aria-hidden=true href=#collisionshape2d-node>#</a></h4><p>This node is used to detect when a finger (the piece you are moving) protrudes outside of the board. Edit each property in the inspector as follows</p><ul><li>Shape: Apply a new RectangleShape2D resource.<ul><li>RectangleShape2D ><ul><li>Extents: (x: 225, y: 190)<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img6.png alt="CollisionShape2D Properties - Shape"></li></ul></li><li>Transform ><ul><li>Position: (x: 315, y: 840)<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img7.png alt="CollisionShape2D Properties - Position"></li></ul></li></ul></li></ul><p>On a 2D workspace, it should have looked like this.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img8.png alt="CollisionShape2D in 2D workspace"></p><br><h4 id=piecescontainer-node2d-node>PiecesContainer (Node2D) node<a hidden class=anchor aria-hidden=true href=#piecescontainer-node2d-node>#</a></h4><p>This node is used to organize the pieces that will be placed on the board. During the game, every instance of a piece that is created by the script will be added as a child of this &ldquo;PiecesContainer&rdquo; node. This way, no matter how many instances of a piece are created, the order of the nodes in the scene tree will be maintained.</p><p>There are no particular properties that need to be edited, so let&rsquo;s move on.</p><br><h4 id=touchtimer-node>TouchTimer node<a hidden class=anchor aria-hidden=true href=#touchtimer-node>#</a></h4><p>This node of the Timer class is used to start a countdown after the player starts moving the pieces with his/her finger, so that when the time runs out, the pieces he/she was moving will automatically leave his/her finger. This gives the player a certain sense of urgency to line up the pieces within the time limit. In this case, we will set the pieces to be able to move for 5 seconds.</p><p>Let&rsquo;s edit the inspector as follows.</p><ul><li>Wait Time: 5</li><li>One Shot: On<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img8.1.png alt="TouchTimer properties"></li></ul><br><h4 id=waittimer-node>WaitTimer node<a hidden class=anchor aria-hidden=true href=#waittimer-node>#</a></h4><p>This node of the Timer class is used to pause for a moment between each process in the automatic process of matching pieces, deleting the matched pieces, filling the empty grid, and adding the missing pieces after the pieces leave the fingers. The node is used to pause for a moment between each process.</p><p>Edit as follows in the inspector.</p><ul><li>Wait Time: 0.3</li><li>One Shot: On<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img8.2.png alt="WaitTimer properties"></li></ul><br><p>This completes the editing of the &ldquo;Grid&rdquo; scene.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-piece-scene>Creating a Piece scene<a hidden class=anchor aria-hidden=true href=#creating-a-piece-scene>#</a></h2><p>Next, create a &ldquo;Piece&rdquo; scene for the pieces to be placed on the board. However, this &ldquo;Piece&rdquo; scene is only a model, and the actual pieces of each color to be used in the game will be prepared later by inheriting this &ldquo;Piece&rdquo; scene.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;Other Scene&rdquo; in &ldquo;Generate Root Node&rdquo;.</li><li>When the root node of &ldquo;Area2D&rdquo; class is generated, rename it to &ldquo;Piece&rdquo;.</li><li>Save the scene. Create a folder and save the scene with the file path &ldquo;res://Pieces/Piece.tscn&rdquo;.<br><br></li></ol><h3 id=adding-nodes-to-the-piece-scene>Adding nodes to the Piece scene<a hidden class=anchor aria-hidden=true href=#adding-nodes-to-the-piece-scene>#</a></h3><p>Let&rsquo;s continue adding the necessary nodes to the &ldquo;Piece&rdquo; scene.</p><ol><li>Add a &ldquo;Sprite&rdquo; node to the &ldquo;Piece&rdquo; root node.</li><li>Add a &ldquo;CollisionShape2D&rdquo; node to the &ldquo;Piece&rdquo; root node.</li><li>Add a &ldquo;Tween&rdquo; node to the &ldquo;Piece&rdquo; root node.<br><br></li></ol><p>The scene tree for the Piece scene should now look like this.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img9.png alt="Piece scene tree"></p><br><h3 id=editing-a-node-in-a-piece-scene>Editing a node in a Piece scene<a hidden class=anchor aria-hidden=true href=#editing-a-node-in-a-piece-scene>#</a></h3><h4 id=piece-area2d-root-node>Piece (Area2D) Root node<a hidden class=anchor aria-hidden=true href=#piece-area2d-root-node>#</a></h4><p>The root node is an Area2D class so that we can detect when a finger hits the piece we want to move, moves away from the piece, or when the pieces collide with each other.</p><p>The properties of this node do not need to be edited, but one property needs to be added to the group. After selecting the &ldquo;Piece&rdquo; root node in the scene dock, select the Node Dock > Groups tab and create and add a group named &ldquo;Pieces.&rdquo;<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img9.1.png alt="Group Pieces"><br>In the &ldquo;Grid&rdquo; scene, the &ldquo;Grid&rdquo; root node has a collision shape set up to detect overhang from the board, and this is a necessary group to distinguish collisions between pieces, since it is always in contact with all pieces.</p><br><h4 id=sprite-node>Sprite node<a hidden class=anchor aria-hidden=true href=#sprite-node>#</a></h4><p>As mentioned above, the &ldquo;Piece&rdquo; is only the inheritance source (template), so in this scene, no resource is applied to the &ldquo;Texture&rdquo; property of the &ldquo;Sprite&rdquo; node and it is left as it is. The plan is to apply an image that matches the color of each piece in the inherited scene.</p><p>In the scene of each color piece inheriting this scene, we will apply the KENNEY image imported earlier to the &ldquo;Texture&rdquo; property, but since the size of the image is 70 px in height and width, let&rsquo;s shift the center of the image to the upper right and set the &ldquo;Offset&rdquo; property so that the center of the image is shifted to the upper right and the lower left corner of the image fits (x: 0, y: 0).</p><ul><li>Offset:<br>Offset: (x: 35, y: -35)<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img10.png alt="Sprite - offset"></li></ul><p>The grid of the board on which the piece is to be placed should count from left to right on the x-axis and from bottom to top on the y-axis, and the size of one grid on the board should be 70 px to match the size of the texture. If the lower left corner of the piece&rsquo;s texture image is aligned with (x: 0, y: 0), then when the &ldquo;Piece&rdquo; root node is positioned (x: 0, y: 0) on the grid, the &ldquo;Sprite&rdquo; image will be aligned exactly with the grid.</p><br><h4 id=collisionshape2d-node-1>CollisionShape2D node<a hidden class=anchor aria-hidden=true href=#collisionshape2d-node-1>#</a></h4><p>The role of this node is to give the root node a collision shape. This node is needed to detect when a piece is touched by a finger, taken off a finger, or collides with a neighboring piece.</p><p>If the collision shape is perfectly aligned with the 70 px Sprite texture, the collision with the neighboring piece will be detected even if the piece is moved slightly.</p><p>On the other hand, if the collision shape is too small, the collision will not be detected even though the user intends to touch the piece with a finger, or when moving the piece, the collision between pieces will not be detected properly and the piece will pass between pieces.</p><p>Therefore, it is best to make the collision shape half the size of the Sprite&rsquo;s Texture. The position of the collision should be adjusted so that it overlaps the Sprite texture nicely.</p><ul><li>Shape: Apply a new CircleShape2D resource<ul><li>CircleShape2D:<ul><li>Radius: 17.5<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img11.png alt="CollisionShape2D - Shape, Radius"></li></ul></li></ul></li><li>Transform:<ul><li>Position: x: 35, y: -35<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img12.png alt="CollisionShape2D - Position"></li></ul></li></ul><p>On the 2D workspace, it should have looked like this.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img13.png alt="CollisionShape2D - 2D workspace"></p><br><h4 id=tween-node>Tween node<a hidden class=anchor aria-hidden=true href=#tween-node>#</a></h4><p>This node can animate only a single property of a given node. The reason for using this node in this case is to animate the movement of the pieces when they are swapped positions or when a piece is packed in the position of a piece that has been matched and disappeared.</p><p>However, since the animation is implemented in a script, there is no need to edit the properties here.<br><br></p><h3 id=attaching-and-editing-a-script-to-the-piece-node>Attaching and editing a script to the Piece node<a hidden class=anchor aria-hidden=true href=#attaching-and-editing-a-script-to-the-piece-node>#</a></h3><p>Let&rsquo;s attach a new script to the &ldquo;Piece&rdquo; root node. Create a script file with the file path &ldquo;res://Pieces/Piece.gd&rdquo;.</p><p>Edit the script as follows.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Piece.gd ###</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Area2D</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Signal to send out if the piece collides with a piece the player is moving</span>
</span></span><span style=display:flex><span><span style=color:#75715e># (pass the piece itself as an argument)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>signal</span> <span style=color:#a6e22e>collided</span>(self_piece)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Property to set the color of the piece</span>
</span></span><span style=display:flex><span>export (<span style=color:#a6e22e>String</span>) <span style=color:#66d9ef>var</span> color
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Property that flags if a match occurs</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> matched <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Index assigned to the group of matched pieces</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> matched_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Property that will be a flag if the player is moving the piece</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> held <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Offset equal to the texture of the piece</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> offset <span style=color:#f92672>=</span> <span style=color:#a6e22e>Vector2</span>(<span style=color:#ae81ff>35</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>35</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Reference to the Sprite node</span>
</span></span><span style=display:flex><span>onready <span style=color:#66d9ef>var</span> sprite <span style=color:#f92672>=</span> <span style=color:#a6e22e>$Sprite</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Reference to a Tween node</span>
</span></span><span style=display:flex><span>onready <span style=color:#66d9ef>var</span> tween <span style=color:#f92672>=</span> <span style=color:#a6e22e>$Tween</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Built-in method called every frame in the main loop</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_process</span>(_delta):
</span></span><span style=display:flex><span>    <span style=color:#75715e># If the player is moving a piece</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> held:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Shift the position of the piece by (35, -35) to follow the mouse</span>
</span></span><span style=display:flex><span>		position <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_global_mouse_position</span>() <span style=color:#f92672>-</span> offset
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to move the piece</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>move</span>(destination):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Set the animation of the tween node.</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Move the piece from the current position to the argument destination in 0.1 seconds</span>
</span></span><span style=display:flex><span>	tween<span style=color:#f92672>.</span><span style=color:#a6e22e>interpolate_property</span>(self, <span style=color:#e6db74>&#34;position&#34;</span>, position, destination, <span style=color:#f92672>.</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>Tween</span><span style=color:#f92672>.</span>TRANS_QUINT, <span style=color:#a6e22e>Tween</span><span style=color:#f92672>.</span>EASE_IN)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Start the animation of the tween node</span>
</span></span><span style=display:flex><span>	tween<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method called when a piece is matched</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>make_matched</span>(index):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Flag a match</span>
</span></span><span style=display:flex><span>	matched <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Assign an index (argument index) for each matched group</span>
</span></span><span style=display:flex><span>	matched_index <span style=color:#f92672>=</span> index
</span></span><span style=display:flex><span>    <span style=color:#75715e># Make the piece color translucent</span>
</span></span><span style=display:flex><span>	modulate <span style=color:#f92672>=</span> <span style=color:#a6e22e>Color</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>1</span>,<span style=color:#f92672>.</span><span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method called when a player&#39;s finger touches a piece</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>enable_held</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Set the flag that the player is moving the piece</span>
</span></span><span style=display:flex><span>	held <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Make the color of the piece 20% transparent</span>
</span></span><span style=display:flex><span>	modulate <span style=color:#f92672>=</span> <span style=color:#a6e22e>Color</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0.8</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method called when the player removes his/her finger from the piece</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>disable_held</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Disable the flag that the player is moving</span>
</span></span><span style=display:flex><span>	held <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Restore the piece&#39;s color to default</span>
</span></span><span style=display:flex><span>	modulate <span style=color:#f92672>=</span> <span style=color:#a6e22e>Color</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><br><p>The next step is to use signals of the <strong>Area2D</strong> class. After selecting the &ldquo;Piece&rdquo; root node in the scene dock, go to the Node dock > Signal tab and connect <code>area_entered(area: Area2D)</code> to the &ldquo;Piece.gd&rdquo; script that you are currently editing.</p><p>When the piece the player is moving is hit, we want to send out a custom signal <code>collided(self_piece)</code>, so let&rsquo;s write the code for that in the auto-generated method <code>_on_Piece_area_entered(area)</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Piece.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method called when Area2D is hit and a signal is sent out</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_on_Piece_area_entered</span>(area):
</span></span><span style=display:flex><span>    <span style=color:#75715e># If the Area2D hit is a &#34;Pieces&#34; group (i.e. an instance of Piece)...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># and if it is a Piece being moved by the player</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> area<span style=color:#f92672>.</span><span style=color:#a6e22e>is_in_group</span>(<span style=color:#e6db74>&#34;Pieces&#34;</span>) <span style=color:#f92672>and</span> area<span style=color:#f92672>.</span>held:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Send a signal collided with the piece itself as argument</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>emit_signal</span>(<span style=color:#e6db74>&#34;collided&#34;</span>, self)
</span></span></code></pre></div><br><p>This completes the editing of the &ldquo;Piece.gd&rdquo; script.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-scene-for-each-color-that-inherits-from-the-piece-scene>Creating a scene for each color that inherits from the Piece scene<a hidden class=anchor aria-hidden=true href=#creating-a-scene-for-each-color-that-inherits-from-the-piece-scene>#</a></h2><p>Now that the &ldquo;Piece&rdquo; scene, which will serve as a template, is complete, let&rsquo;s create a scene that inherits the &ldquo;Piece&rdquo; scene in the number of colors of the piece. There are five piece colors: beige, blue, green, pink, and yellow. First, let&rsquo;s proceed with the procedure using the &ldquo;beige&rdquo; drop as an example.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Inherited Scene</li><li>Select &ldquo;Piece.tscn&rdquo; as the source scene</li><li>After the inherited scene is generated, rename the root node to &ldquo;PieceBeige.<br>*The name of this root node should match the color of each drop.</li><li>Save the scene once. Save the scene with the file path &ldquo;res://Pieces/PieceBeige.tscn&rdquo;.</li><li>With the root node &ldquo;PieceBeige&rdquo; selected in the scene dock, set the value of the &ldquo;Color&rdquo; property of &ldquo;Script Variables&rdquo; to &ldquo;beige&rdquo; in the inspector.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img14.png alt="BlueDrop - Color property"></li><li>Select the &ldquo;Sprite&rdquo; node in the scene dock and apply the previously imported resource &ldquo;res://Aliens/alienBeige_round.png&rdquo; to the &ldquo;Texture&rdquo; property (you can drag it from the file system dock).<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img15.png alt="Sprite - Texture Region"><br>On the 2D workspace, it should now look like the following screenshot.<br>! <a href=/images/tutorials/gd0013_advanced_match3/img16.png>Sprite - Texture Region</a><br>The &ldquo;PieceBeige&rdquo; scene is now complete. Follow the same procedure to create scenes for the remaining four colored pieces. Please refer to the following for details on the different parts of each scene.</li></ol><ul><li><strong>Blue piece</strong>.<ul><li>Root node name: PieceBlue</li><li>Color property: blue</li><li>Sprite > Texture property: res://Aliens/alienBlue_round.png</li><li>File path when saving the scene: res://Pieces/PieceBlue.tscn</li></ul></li><li><strong>Green piece</strong>.<ul><li>Root node name: PieceGreen</li><li>Color property: green</li><li>Sprite > Texture property: res://Aliens/alienGreen_round.png</li><li>File path when saving the scene: res://Pieces/PieceGreen.tscn</li></ul></li><li><strong>Pink piece</strong>.<ul><li>Root node name: PiecePink</li><li>Color property: green</li><li>Sprite > Texture property: res://Aliens/alienPink_round.png</li><li>File path when saving the scene: res://Pieces/PiecePink.tscn</li></ul></li><li><strong>Yellow piece</strong>.<ul><li>Root node name: PieceYellow</li><li>Color property: yellow</li><li>Sprite > Texture property: res://Aliens/alienYellow_round.png</li><li>File path when saving the scene: res://Pieces/PieceYellow.tscn</li></ul></li></ul><p>When the inherited scene of all 5 colored pieces has been created, the work is complete.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=controlling-a-grid-scene-with-scripts>Controlling a Grid scene with scripts<a hidden class=anchor aria-hidden=true href=#controlling-a-grid-scene-with-scripts>#</a></h2><p>From here on, we will code scripts to control the game. The amount of code is rather large, so do your best.</p><p>After switching to the &ldquo;Grid.tscn&rdquo; scene in the Godot editor, attach a new script to the &ldquo;Grid&rdquo; root node. The file path should be &ldquo;res://Grid/Grid.gd&rdquo;.</p><p>In the comments in the script, &ldquo;finger touched&rdquo; or &ldquo;finger released&rdquo; should be replaced with &ldquo;left mouse button pressed&rdquo; or &ldquo;left mouse button released&rdquo; on the Godot debug panel.</p><p>Also, please note that &ldquo;match&rdquo; is defined as three or more of the same color.</p><p>Now, once the script editor is open, let&rsquo;s define the necessary properties.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Area2D</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Signal sent out at the start of automatic matching process</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>signal</span> waiting_started
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Array with scene files for each color piece as elements</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> pieces_scn <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>	preload(<span style=color:#e6db74>&#34;res://Pieces/PieceBeige.tscn&#34;</span>),
</span></span><span style=display:flex><span>	preload(<span style=color:#e6db74>&#34;res://Pieces/PieceBlue.tscn&#34;</span>),
</span></span><span style=display:flex><span>	preload(<span style=color:#e6db74>&#34;res://Pieces/PieceGreen.tscn&#34;</span>),
</span></span><span style=display:flex><span>	preload(<span style=color:#e6db74>&#34;res://Pieces/PiecePink.tscn&#34;</span>),
</span></span><span style=display:flex><span>	preload(<span style=color:#e6db74>&#34;res://Pieces/PieceYellow.tscn&#34;</span>)
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Number of grids in x-axis</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> width: <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Number of grids in y-axis</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> height: <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Grid start position in x-axis direction (pixels)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> x_start: <span style=color:#f92672>=</span> <span style=color:#ae81ff>70</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Grid start position in y-axis direction (pixel)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> y_start: <span style=color:#f92672>=</span> <span style=color:#ae81ff>1050</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Size of one grid (should be the same as Texture of Sprite in Piece)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> grid_size: <span style=color:#f92672>=</span> <span style=color:#ae81ff>70</span>
</span></span><span style=display:flex><span><span style=color:#75715e># How many grid y-axis displacements to drop when the Piece is generated</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> y_offset: <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Array representing the placement of the pieces on the board (two-dimensional array)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> board <span style=color:#f92672>=</span> []<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Reference to the piece the player is moving</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> moving_piece
</span></span><span style=display:flex><span><span style=color:#75715e># Last grid position of the piece the player is moving </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> last_pos <span style=color:#f92672>=</span> <span style=color:#a6e22e>Vector2</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Flag for preparing at the start of the game</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> is_initializing <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Flag if the player is moving the piece</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> is_touching <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Flag if the player is swapping pieces</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> is_swapping <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Flag during automatic match processing after the player moves the piece</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> is_waiting <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Number of groups of matched pieces (to be counted up)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> matched_groups <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Reference to the PiecesContainer node</span>
</span></span><span style=display:flex><span>onready <span style=color:#66d9ef>var</span> pieces_container <span style=color:#f92672>=</span> <span style=color:#a6e22e>$PiecesContainer</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Reference to the TouchTimer node</span>
</span></span><span style=display:flex><span>onready <span style=color:#66d9ef>var</span> touch_timer <span style=color:#f92672>=</span> <span style=color:#a6e22e>$TouchTimer</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Reference the WaitTimer node</span>
</span></span><span style=display:flex><span>onready <span style=color:#66d9ef>var</span> wait_timer <span style=color:#f92672>=</span> <span style=color:#a6e22e>$WaitTimer</span>
</span></span></code></pre></div><br><p>Then from here on, we will be adding methods. Note that the <strong>two-dimensional array</strong> that appears in the following code is an array that stores arrays as elements, that is, an array of arrays.</p><p>In the case of the two-dimensional array used in this script, the first level of the array contains as many empty arrays as the number of grids in the x-axis direction of the board, and the second level of the array contains as many elements as the number of grids in the vertical direction within each array. By storing piece objects as its elements, we can manage where each piece is located on the board (how many grids in the x-axis direction and how many grids in the y-axis direction).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Function called when scene is loaded</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_ready</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Call a built-in function to randomize the output result of a function that generates a random number each time</span>
</span></span><span style=display:flex><span>	randomize()
</span></span><span style=display:flex><span>    <span style=color:#75715e># Make the board (array) into a 2d array that makes up the grid of the board</span>
</span></span><span style=display:flex><span>	board <span style=color:#f92672>=</span> <span style=color:#a6e22e>make_2d_array</span>() <span style=color:#75715e># define after this</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Spawn the pieces and place them on the board and reflect the board information on the board</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>spawn_pieces</span>() <span style=color:#75715e># define after this</span>
</span></span><span style=display:flex><span>	is_initializing <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to create a 2d array that makes up the grid of the board</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>make_2d_array</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Array</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Prepare an array named array</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> array <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#75715e># Fill array with an empty array with the number of grids along the x-axis</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> width:
</span></span><span style=display:flex><span>		array<span style=color:#f92672>.</span><span style=color:#a6e22e>append</span>([])
</span></span><span style=display:flex><span>        <span style=color:#75715e># Append null to each array for the number of grids along the y-axis for j in height:</span>
</span></span><span style=display:flex><span>			array[i]<span style=color:#f92672>.</span><span style=color:#a6e22e>append</span>(<span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Return the resulting two-dimensional array</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> array
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to spawn pieces, place them on the board, and reflect the board information to the board</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>spawn_pieces</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Loop for the number of grids along the x-axis</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> width:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Loop over the number of grids along the y-axis</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> height:
</span></span><span style=display:flex><span>            <span style=color:#75715e># If no piece exists in the corresponding grid on the 2D array of all pieces</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># (all are null at the start of the game)</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> board[i][j] <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Select one piece at random from the scene of pieces of each color and instantiate it</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> index <span style=color:#f92672>=</span> floor(<span style=color:#a6e22e>rand_range</span>(<span style=color:#ae81ff>0</span>, pieces_scn<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span>()))
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> piece <span style=color:#f92672>=</span> pieces_scn[index]<span style=color:#f92672>.</span><span style=color:#a6e22e>instance</span>()
</span></span><span style=display:flex><span>                <span style=color:#75715e># If the game is being prepared at the start</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> is_initializing:
</span></span><span style=display:flex><span>                    <span style=color:#75715e># If a match has occurred, delete the piece instance and start over</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>while</span> <span style=color:#a6e22e>match_at</span>(i, j, piece<span style=color:#f92672>.</span>color): <span style=color:#75715e># define after this</span>
</span></span><span style=display:flex><span>						piece<span style=color:#f92672>.</span><span style=color:#a6e22e>queue_free</span>()
</span></span><span style=display:flex><span>						index <span style=color:#f92672>=</span> floor(<span style=color:#a6e22e>rand_range</span>(<span style=color:#ae81ff>0</span>, pieces_scn<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span>()))
</span></span><span style=display:flex><span>						piece <span style=color:#f92672>=</span> pieces_scn[index]<span style=color:#f92672>.</span><span style=color:#a6e22e>instance</span>()
</span></span><span style=display:flex><span>                <span style=color:#75715e># Make a piece instance a child of a PiecesContainer node</span>
</span></span><span style=display:flex><span>				pieces_container<span style=color:#f92672>.</span><span style=color:#a6e22e>add_child</span>(piece)
</span></span><span style=display:flex><span>                <span style=color:#75715e># Collided signal for a piece instance...</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># connect to the _on_Piece_collided method (defined later)</span>
</span></span><span style=display:flex><span>				piece<span style=color:#f92672>.</span><span style=color:#a6e22e>connect</span>(<span style=color:#e6db74>&#34;collided&#34;</span>, self, <span style=color:#e6db74>&#34;_on_Piece_collided&#34;</span>)
</span></span><span style=display:flex><span>                <span style=color:#75715e># Place the piece instance y_offset from the placement position...</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># move the piece instance to the placement position from there (drop it)</span>
</span></span><span style=display:flex><span>				piece<span style=color:#f92672>.</span>position <span style=color:#f92672>=</span> <span style=color:#a6e22e>grid_to_pixel</span>(i, j <span style=color:#f92672>+</span> y_offset) <span style=color:#75715e># define after this</span>
</span></span><span style=display:flex><span>				piece<span style=color:#f92672>.</span><span style=color:#a6e22e>move</span>(<span style=color:#a6e22e>grid_to_pixel</span>(i, j)) <span style=color:#75715e># defined after this</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e># Add the generated piece to the element at the appropriate index of the board as board information</span>
</span></span><span style=display:flex><span>				board[i][j] <span style=color:#f92672>=</span> piece
</span></span></code></pre></div><br><p>Let&rsquo;s define the undefined <code>match_at</code> and <code>grid_to_pixel</code> methods in the above code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to check if 3 or more pieces of the same color are lined up at the specified grid position</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Arguments column is the x-axis grid position, the row is the y-axis grid position, and color is the color of the piece</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>match_at</span>(column, row, color):
</span></span><span style=display:flex><span>    <span style=color:#75715e># If the x-axis position of the given grid is greater than or equal to 3</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> column <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># If there is a piece to the left of the specified grid position and one more to the left</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> board[column<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][row] <span style=color:#f92672>!</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span> \
</span></span><span style=display:flex><span>        <span style=color:#f92672>and</span> board[column<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>][row] <span style=color:#f92672>!</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># If the left neighbor and another left neighbor have the same color as the specified piece</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> board[column<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>][row]<span style=color:#f92672>.</span>color <span style=color:#f92672>==</span> color \
</span></span><span style=display:flex><span>            <span style=color:#f92672>and</span> board[column<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>][row]<span style=color:#f92672>.</span>color <span style=color:#f92672>==</span> color:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Return true</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># If y-axis position of the specified grid is 3 or more</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> row <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># If there are pieces below the specified grid position and one more below</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> board[column][row<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>!</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span> \
</span></span><span style=display:flex><span>        <span style=color:#f92672>and</span> board[column][row<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>!</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># If the color of the piece below and one more piece below is the same as the color of the specified piece</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> board[column][row<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>color <span style=color:#f92672>==</span> color \
</span></span><span style=display:flex><span>            <span style=color:#f92672>and</span> board[column][row<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>]<span style=color:#f92672>.</span>color <span style=color:#f92672>==</span> color:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Return true</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to convert grid position to pixel position</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>grid_to_pixel</span>(column, row) <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Vector2</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Define a variable of type Vector2 for pixel position output</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> pixel_pos <span style=color:#f92672>=</span> <span style=color:#a6e22e>Vector2</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e># Pixel x-coordinate = grid start position along x-axis + grid size * grid x-coordinate</span>
</span></span><span style=display:flex><span>	pixel_pos<span style=color:#f92672>.</span>x <span style=color:#f92672>=</span> x_start <span style=color:#f92672>+</span> grid_size <span style=color:#f92672>*</span> column
</span></span><span style=display:flex><span>    <span style=color:#75715e># Pixel y-coordinate = grid start position along y-axis - grid size x grid y-coordinate</span>
</span></span><span style=display:flex><span>	pixel_pos<span style=color:#f92672>.</span>y <span style=color:#f92672>=</span> y_start <span style=color:#f92672>-</span> grid_size <span style=color:#f92672>*</span> row
</span></span><span style=display:flex><span>    <span style=color:#75715e># Return pixel coordinates</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> pixel_pos
</span></span></code></pre></div><p>Now the pieces of each color should be randomly arranged on the board at the start of the game. Let&rsquo;s run the project once to check it out. When you run the project for the first time, a dialog box for selecting the main scene will appear, so select &ldquo;Grid.tscn&rdquo; as the main scene.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img17.png alt="run project - distribute pieces on the grid board"></p><br><p>Since we just defined the <code>grid_to_pixel</code> method, let&rsquo;s define the <code>pixel_to_grid</code> method for later use. As the name suggests, this method is the opposite of <code>grid_to_pixel</code> defined earlier and converts pixel positions to grid positions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to convert a pixel position to a grid position</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>pixel_to_grid</span>(pixel_x, pixel_y) <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Vector2</span>:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> grid_pos <span style=color:#f92672>=</span> <span style=color:#a6e22e>Vector2</span>()
</span></span><span style=display:flex><span>	grid_pos<span style=color:#f92672>.</span>x <span style=color:#f92672>=</span> floor((pixel_x <span style=color:#f92672>-</span> x_start) <span style=color:#f92672>/</span> grid_size)
</span></span><span style=display:flex><span>	grid_pos<span style=color:#f92672>.</span>y <span style=color:#f92672>=</span> floor((pixel_y <span style=color:#f92672>-</span> y_start) <span style=color:#f92672>/</span> <span style=color:#f92672>-</span>grid_size)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> grid_pos
</span></span></code></pre></div><br><p>In addition, we define one more method <code>is_in_grid</code> to be used later. This method determines whether the position passed as an argument is within the range of the board grid and returns the result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method that returns whether the specified position is within the grid of the board</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>is_in_grid</span>(grid_position: <span style=color:#a6e22e>Vector2</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>bool</span>:
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> grid_position<span style=color:#f92672>.</span>x <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> grid_position<span style=color:#f92672>.</span>x <span style=color:#f92672>&lt;</span> width \
</span></span><span style=display:flex><span>	<span style=color:#f92672>and</span> grid_position<span style=color:#f92672>.</span>y <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> grid_position<span style=color:#f92672>.</span>y <span style=color:#f92672>&lt;</span> height:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Return true if within the grid of the board</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Return false if out of range of the board grid</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span></code></pre></div><br><p>From this point on, we will write a program to process the game player&rsquo;s input (screen touch operation).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Function called every frame in the main loop of the game</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_process</span>(_delta):
</span></span><span style=display:flex><span>    <span style=color:#75715e># if not in the process of matching</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> is_waiting:
</span></span><span style=display:flex><span>        <span style=color:#75715e># call a method to process the player&#39;s input</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>touch_input</span>() <span style=color:#75715e># defined after this</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method for handling player input</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>touch_input</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># If a finger touches the screen</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>Input</span><span style=color:#f92672>.</span><span style=color:#a6e22e>is_action_just_pressed</span>(<span style=color:#e6db74>&#34;touch&#34;</span>):
</span></span><span style=display:flex><span>        <span style=color:#75715e># Call a method to perform processing when a piece is touched</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>touch_piece</span>() <span style=color:#75715e># defined after this</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># If the finger leaves the screen</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>Input</span><span style=color:#f92672>.</span><span style=color:#a6e22e>is_action_just_released</span>(<span style=color:#e6db74>&#34;touch&#34;</span>) <span style=color:#f92672>and</span> is_touching:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Call the method that executes the action when the finger leaves the piece</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>release_piece</span>() <span style=color:#75715e># defined after this</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Methods to execute when a piece is touched</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>touch_piece</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get the pixel coordinates of the piece when a finger touches it</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> pos <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_global_mouse_position</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e># Convert from pixel coordinates to grid coordinates</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> grid_pos <span style=color:#f92672>=</span> <span style=color:#a6e22e>pixel_to_grid</span>(pos<span style=color:#f92672>.</span>x, pos<span style=color:#f92672>.</span>y)
</span></span><span style=display:flex><span>    <span style=color:#75715e># If grid coordinates are within the board</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>is_in_grid</span>(grid_pos):
</span></span><span style=display:flex><span>        <span style=color:#75715e># Register the grid coordinates as the last position of the piece being moved</span>
</span></span><span style=display:flex><span>		last_pos <span style=color:#f92672>=</span> grid_pos
</span></span><span style=display:flex><span>        <span style=color:#75715e># register the piece at grid coordinates as the moving piece</span>
</span></span><span style=display:flex><span>		moving_piece <span style=color:#f92672>=</span> board[last_pos<span style=color:#f92672>.</span>x][last_pos<span style=color:#f92672>.</span>y]
</span></span><span style=display:flex><span>        <span style=color:#75715e># Flag the piece as moving</span>
</span></span><span style=display:flex><span>		is_touching <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Also flag the moving piece instance itself as moving</span>
</span></span><span style=display:flex><span>		moving_piece<span style=color:#f92672>.</span><span style=color:#a6e22e>enable_held</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e># Start a timer to limit the time the piece can be moved</span>
</span></span><span style=display:flex><span>		touch_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to execute when the finger leaves the piece</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>release_piece</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># If we find a piece we were moving among the elements of the two-dimensional array board...</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Fit the moved piece exactly on the board grid</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> width:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> height:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> board[i][j] <span style=color:#f92672>==</span> moving_piece:
</span></span><span style=display:flex><span>				moving_piece<span style=color:#f92672>.</span><span style=color:#a6e22e>move</span>(<span style=color:#a6e22e>grid_to_pixel</span>(i, j))
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Disable the moving flag of the moving piece instance itself</span>
</span></span><span style=display:flex><span>	moving_piece<span style=color:#f92672>.</span><span style=color:#a6e22e>disable_held</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e># Disable the moving flag of the moving piece</span>
</span></span><span style=display:flex><span>	is_touching <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Stop the timer for the time limit for moving the piece</span>
</span></span><span style=display:flex><span>	touch_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>stop</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e># Signal the start of automatic matching process after this</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>emit_signal</span>(<span style=color:#e6db74>&#34;waiting_started&#34;</span>)
</span></span></code></pre></div><br><p>Although we have not yet implemented the exchange of pieces, the coding up to this point should have implemented the movement of a piece that is touched by a finger, and when the finger is released, the piece that is being moved will settle exactly where it was last. Let&rsquo;s run the project and check it out.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img18.gif alt="run project - touch and release a piece"></p><br><p>The next method we will define, <code>_on_Piece_collided</code>, has already been coded to connect a <code>collided</code> signal when the Piece instance is created. Recall that we coded this signal in the &ldquo;Piece.gd&rdquo; script to be sent out when a piece is hit by a piece being moved by the player.</p><p>Let&rsquo;s define a method to swap the location of the moving piece and the piece that hit it, and call it in <code>_on_Piece_collided</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method called on collided signal of a Piece instance</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_on_Piece_collided</span>(self_piece):
</span></span><span style=display:flex><span>    <span style=color:#75715e># If the piece is moving and not in the process of swapping pieces</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> is_touching <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> is_swapping:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Flag the piece is being swapped</span>
</span></span><span style=display:flex><span>		is_swapping <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Call a method to swap pieces</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>swap_pieces</span>(self_piece) <span style=color:#75715e># define later</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Remove the flag that a piece is being swapped</span>
</span></span><span style=display:flex><span>		is_swapping <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to swap the location of the piece being moved and the piece that hit it</span>
</span></span><span style=display:flex><span><span style=color:#75715e># The collided_piece argument is passed the piece that hit the piece being moved</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>swap_pieces</span>(collided_piece):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get the grid coordinates of the piece that hit it.</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> collided_pos <span style=color:#f92672>=</span> <span style=color:#a6e22e>pixel_to_grid</span>(collided_piece<span style=color:#f92672>.</span>position<span style=color:#f92672>.</span>x, collided_piece<span style=color:#f92672>.</span>position<span style=color:#f92672>.</span>y)
</span></span><span style=display:flex><span>    <span style=color:#75715e># If the piece being moved on the two-dimensional array board matches the piece being moved</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> board[last_pos<span style=color:#f92672>.</span>x][last_pos<span style=color:#f92672>.</span>y] <span style=color:#f92672>==</span> moving_piece:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Put the piece that hit the position of the moving piece on the board</span>
</span></span><span style=display:flex><span>		board[last_pos<span style=color:#f92672>.</span>x][last_pos<span style=color:#f92672>.</span>y] <span style=color:#f92672>=</span> collided_piece
</span></span><span style=display:flex><span>        <span style=color:#75715e># Move the hit piece to the last grid coordinate of the piece being moved</span>
</span></span><span style=display:flex><span>		collided_piece<span style=color:#f92672>.</span><span style=color:#a6e22e>move</span>(<span style=color:#a6e22e>grid_to_pixel</span>(last_pos<span style=color:#f92672>.</span>x, last_pos<span style=color:#f92672>.</span>y))
</span></span><span style=display:flex><span>        <span style=color:#75715e># Put the piece being moved into the position of the hit piece on the board</span>
</span></span><span style=display:flex><span>		board[collided_pos<span style=color:#f92672>.</span>x][collided_pos<span style=color:#f92672>.</span>y] <span style=color:#f92672>=</span> moving_piece
</span></span><span style=display:flex><span>        <span style=color:#75715e># Register the grid coordinates of the hit piece as the last position of the moving piece</span>
</span></span><span style=display:flex><span>		last_pos <span style=color:#f92672>=</span> collided_pos
</span></span></code></pre></div><br><p>Now you should be able to implement the exchange of pieces. Let&rsquo;s actually run the project and move the pieces. Let&rsquo;s see how the pieces of the route are exchanged one after another.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img19.gif alt="run project - swapping piece"></p><p>Now, at this point, there are two problems.</p><ul><li>Being able to move freely outside of the board.</li><li>Being able to grab the piece forever.</li></ul><p>These problems can be solved using signals.</p><p>Let&rsquo;s connect the signals of the &ldquo;Grid&rdquo; root node of the Area2D class to the script. Remember how we adjusted the collision shape to the size of the board? The signal that is sent out when the finger (the piece that is being moved) goes out of that area will cause the <code>release_piece</code> method to be called so that the piece that was being moved will also go away from the finger and return to its last position on the board.</p><p>Select the &ldquo;Grid&rdquo; root node in the Scene dock, select Node dock > Signals tab, and connect the <code>erea_exited</code> signal to this script.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img20.png alt="Grid - Connect signal - area_exited"></p><p>Another signal that is sent out when the time limit for moving the piece in the &ldquo;TouchTimer&rdquo; node times out is also connected to the script. In this case, the <code>release_piece</code> method should be called by the signal as well. Let&rsquo;s connect the <code>timeout</code> signal.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img21.png alt="TouchTimer - Connect signal - timeout"></p><p>Continuing on, let&rsquo;s edit the methods generated by the connection of each signal as follows.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method called with a signal when Area2D is out of the board</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_on_Grid_area_exited</span>(area):
</span></span><span style=display:flex><span>    <span style=color:#75715e># If the area2D that has been moved out of the grid is a piece that is being moved</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> area<span style=color:#f92672>.</span><span style=color:#a6e22e>is_in_group</span>(<span style=color:#e6db74>&#34;Pieces&#34;</span>) <span style=color:#f92672>and</span> area<span style=color:#f92672>.</span>held:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Call the method that handles when the finger leaves the piece</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>release_piece</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method called with a signal when the time limit for moving a piece expires</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_on_TouchTimer_timeout</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># if the piece is moving</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> is_touching:
</span></span><span style=display:flex><span>        <span style=color:#75715e># call a method that will do something when the finger leaves the piece</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>release_piece</span>()
</span></span></code></pre></div><br><p>Now, if the piece is out of the board, the piece should now leave your finger and return to its last position on the board. Also, if you grabbed the piece for more than 5 seconds, the timer should now cause the piece to leave your finger and return to the last grid coordinate on the board.</p><p>Now let&rsquo;s actually run the project and see how it works.<br><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img22.gif alt="run project - signal effects"></p><br><p>From here, we will create a program to automatically process the matched pieces. At the end of the <code>release_piece</code> method, we used the code <code>emit_signal("waiting_started")</code> to send out a <code>waiting_started</code> signal, and we will start by connecting this signal to the script.</p><p>Select the &ldquo;Grid&rdquo; root node in Scene dock and connect the <code>waiting_started</code> signal to the script in the Node dock > Signals tab. Once the <code>_on_Grid_waiting_started</code> method is added to the script, we will write the automatic processing of the matched piece in the method. Roughly speaking, the automatic process is as follows.</p><ol><li>Set the flag for automatic matching process in progress.</li><li>Check if there is at least one matched piece; if there is at least one, loop through the following process.<ol><li>Check all pieces and flag matched pieces.</li><li>Delete the flagged piece.</li><li>Fill the empty space by moving a piece from the grid above in the same row or column.</li><li>After the pieces are moved down, a new piece is created in the empty space at the end.</li></ol></li><li>When there are no more matched pieces, the automatic processing flag is cleared.<br><br></li></ol><p>Let&rsquo;s implement the above process step by step. Let&rsquo;s start with the &ldquo;check all the pieces and flag the matching pieces&rdquo; part.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method called with a signal sent out at the end of the release method</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_on_Grid_waiting_started</span>():
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#75715e># Set a flag that automatic Matching processing is in progress.</span>
</span></span><span style=display:flex><span>	is_waiting <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Keep looping if there is at least one matched piece in a group of people</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#a6e22e>check_matches</span>(): <span style=color:#75715e># define after this</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Call method to flag matched pieces</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>find_matches</span>(): <span style=color:#75715e># define after this</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Start WaitTimer timer (0.3 seconds)</span>
</span></span><span style=display:flex><span>		wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e># Wait until WaitTimer times out</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Clear the flag during automatic processing</span>
</span></span><span style=display:flex><span>	is_waiting <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to check if there is at least one pair of matched pieces</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>check_matches</span>() <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>bool</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Loop over the number of x-axis grids on the board</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> width:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Loop over the number of grids in y-axis of the board</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> height:
</span></span><span style=display:flex><span>            <span style=color:#75715e># If a piece exists at that grid coordinate</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> board[i][j] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># If the piece is matched</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>match_at</span>(i, j, board[i][j]<span style=color:#f92672>.</span>color):
</span></span><span style=display:flex><span>                    <span style=color:#75715e># Return true</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Return false if none of the pieces match</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to flag matched pieces</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>find_matches</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Loop over the number of x-axis grids on the board</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> width:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Loop over the number of grids in y-axis of the board</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> height:
</span></span><span style=display:flex><span>            <span style=color:#75715e># If a piece exists at that grid coordinate</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> board[i][j] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Define current color as the color of the piece at that grid coordinate</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> current_color <span style=color:#f92672>=</span> board[i][j]<span style=color:#f92672>.</span>color
</span></span><span style=display:flex><span>                <span style=color:#75715e># If its x-axis coordinates are less than the number of grids along the x-axis - 2</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> width <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>                    <span style=color:#75715e># If there are pieces to the right of that piece and further to its right</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> board[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][j] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> \
</span></span><span style=display:flex><span>					<span style=color:#f92672>and</span> board[i<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>][j] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>                        <span style=color:#75715e># If the color of those pieces is the same as the current color</span>
</span></span><span style=display:flex><span>						<span style=color:#66d9ef>if</span> board[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][j]<span style=color:#f92672>.</span>color <span style=color:#f92672>==</span> current_color \
</span></span><span style=display:flex><span>						<span style=color:#f92672>and</span> board[i<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>][j]<span style=color:#f92672>.</span>color <span style=color:#f92672>==</span> current_color:
</span></span><span style=display:flex><span>                            <span style=color:#75715e># Define a variable for the index to assign to the matched pairs</span>
</span></span><span style=display:flex><span>							<span style=color:#66d9ef>var</span> matched_index: <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>                            <span style=color:#75715e># If the piece is already flagged as matched</span>
</span></span><span style=display:flex><span>							<span style=color:#66d9ef>if</span> board[i][j]<span style=color:#f92672>.</span>matched:
</span></span><span style=display:flex><span>                                <span style=color:#75715e># Index should be the same as the index information the piece has</span>
</span></span><span style=display:flex><span>								matched_index <span style=color:#f92672>=</span> board[i][j]<span style=color:#f92672>.</span>matched_index
</span></span><span style=display:flex><span>                            <span style=color:#75715e># If the piece is not flagged as matched</span>
</span></span><span style=display:flex><span>							<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                                <span style=color:#75715e># Increment the number of groups in the matched pair</span>
</span></span><span style=display:flex><span>								matched_groups <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                                <span style=color:#75715e># Set the index to the number of groups in the matched pairs</span>
</span></span><span style=display:flex><span>								matched_index <span style=color:#f92672>=</span> matched_groups
</span></span><span style=display:flex><span>                            <span style=color:#75715e># Flag the piece at those coordinates as matched, assign an index, and make it translucent</span>
</span></span><span style=display:flex><span>														board[i][j]<span style=color:#f92672>.</span><span style=color:#a6e22e>make_matched</span>(matched_index)
</span></span><span style=display:flex><span>                            <span style=color:#75715e># Do the same for the piece to the right of those coordinates</span>
</span></span><span style=display:flex><span>							board[i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>][j]<span style=color:#f92672>.</span><span style=color:#a6e22e>make_matched</span>(matched_index)
</span></span><span style=display:flex><span>                            <span style=color:#75715e># Do the same for the piece one more place to the right</span>
</span></span><span style=display:flex><span>							board[i<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>][j]<span style=color:#f92672>.</span><span style=color:#a6e22e>make_matched</span>(matched_index)
</span></span><span style=display:flex><span>                <span style=color:#75715e># Do the same for the y-axis direction</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> j <span style=color:#f92672>&lt;</span> height <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> board[i][j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#960050;background-color:#1e0010>\</span>f}
</span></span><span style=display:flex><span>					<span style=color:#f92672>and</span> board[i][j<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>						<span style=color:#66d9ef>if</span> board[i][j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>color <span style=color:#f92672>==</span> current_color \
</span></span><span style=display:flex><span>						<span style=color:#f92672>and</span> board[i][j<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]<span style=color:#f92672>.</span>color <span style=color:#f92672>==</span> current_color
</span></span><span style=display:flex><span>							<span style=color:#66d9ef>var</span> matched_index: <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>							<span style=color:#66d9ef>if</span> board[i][j]<span style=color:#f92672>.</span>matched:
</span></span><span style=display:flex><span>								matched_index <span style=color:#f92672>=</span> board[i][j]<span style=color:#f92672>.</span>matched_index
</span></span><span style=display:flex><span>							<span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>								matched_groups <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>								matched_index <span style=color:#f92672>=</span> matched_groups
</span></span><span style=display:flex><span>							board[i][j]<span style=color:#f92672>.</span><span style=color:#a6e22e>make_matched</span>(matched_index)
</span></span><span style=display:flex><span>							board[i][j<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span><span style=color:#a6e22e>make_matched</span>(matched_index)
</span></span><span style=display:flex><span>							board[i][j<span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>]<span style=color:#f92672>.</span><span style=color:#a6e22e>make_matched</span>(matched_index)
</span></span></code></pre></div><p><br><br>Of the processing of the matched pieces, we have implemented the flagging of the matched pieces. Let&rsquo;s run the project and see if the matched pieces become translucent.</p><p><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img24.gif alt="run project - add flag on matched pieces"></p><br><p>The next step is to define a method to delete pieces that are flagged for match status.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to delete a piece that is flagged as a match</span>
</span></span><span style=display:flex><span><span style=color:#75715e># The argument index is the index of the match pair to delete</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>delete_matches</span>(index):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Loop over the number of x-axis grids on the board</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> width:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Loop over the number of grids in the y-axis of the board</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> height:
</span></span><span style=display:flex><span>            <span style=color:#75715e># If a piece exists at that grid coordinate</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> board[i][j] <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># If the piece at that grid coordinate is flagged as a match</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>if</span> board[i][j]<span style=color:#f92672>.</span>matched:
</span></span><span style=display:flex><span>                    <span style=color:#75715e># If the pair number of the piece at that grid coordinate matches the pair number of the piece to be deleted</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> board[i][j]<span style=color:#f92672>.</span>matched_index <span style=color:#f92672>==</span> index:
</span></span><span style=display:flex><span>                        <span style=color:#75715e># Release the piece at those grid coordinates</span>
</span></span><span style=display:flex><span>						board[i][j]<span style=color:#f92672>.</span><span style=color:#a6e22e>queue_free</span>()
</span></span><span style=display:flex><span>                        <span style=color:#75715e># Set the corresponding element of the two-dimensional array board to null</span>
</span></span><span style=display:flex><span>						board[i][j] <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>
</span></span></code></pre></div><br><p>Now that we have defined the <code>delete_matches</code> method, let&rsquo;s put it in the loop of the <code>_on_Grid_waiting_started</code> method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_on_Grid_waiting_started</span>():
</span></span><span style=display:flex><span>	is_waiting <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#a6e22e>check_matches</span>():
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>find_matches</span>()
</span></span><span style=display:flex><span>		wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>        <span style=color:#75715e># Add here</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># If the number of matched groups is greater than 0</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> matched_groups <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># Loop over matched groups</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Don&#39;t delete all of them at the same time, delete each matched group</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> index <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, matched_groups <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>                <span style=color:#75715e># Call method to delete matched pieces</span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>delete_matches</span>(index)
</span></span><span style=display:flex><span>                <span style=color:#75715e># Start WaitTimer timer (0.3 seconds)</span>
</span></span><span style=display:flex><span>				wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>                <span style=color:#75715e># Wait until WaitTimer times out</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e># Set the number of matched groups back to 0 after all matched pieces are removed</span>
</span></span><span style=display:flex><span>			matched_groups <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	is_waiting <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span></code></pre></div><p><br><br>We should now be able to implement the matching piece to the point where it becomes translucent and then deleted. Let&rsquo;s run the project and check it out.</p><p><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img25.gif alt="run project - delete matched pieces"></p><br><p>Next, we will implement the process of filling (dropping) the top piece into the grid space vacated by the removed piece. Let&rsquo;s start by defining the method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Method to collapse (drop) the top piece into the empty grid space</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>collapse_columns</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Loop over the number of x-axis grids on the board</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> width:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Loop over the number of y-axis grids in the board</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> height:
</span></span><span style=display:flex><span>            <span style=color:#75715e># If there is no piece at that grid coordinate</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> board[i][j] <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># Loop over the remaining y-axis grids starting from the grid one above that y-coordinate</span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>for</span> k <span style=color:#f92672>in</span> range(j <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, height):
</span></span><span style=display:flex><span>                    <span style=color:#75715e># If the piece exists at that grid coordinate</span>
</span></span><span style=display:flex><span>					<span style=color:#66d9ef>if</span> board[i][k] <span style=color:#f92672>!</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>:
</span></span><span style=display:flex><span>                        <span style=color:#75715e># Move the piece at that grid coordinate to an empty space</span>
</span></span><span style=display:flex><span>						board[i][k]<span style=color:#f92672>.</span><span style=color:#a6e22e>move</span>(<span style=color:#a6e22e>grid_to_pixel</span>(i, j))
</span></span><span style=display:flex><span>                        <span style=color:#75715e># Replace the elements of the two-dimensional array board</span>
</span></span><span style=display:flex><span>						board[i][j] <span style=color:#f92672>=</span> board[i][k]<span style=color:#f92672>.</span>
</span></span><span style=display:flex><span>						board[i][k] <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>                        <span style=color:#75715e># End of loop</span>
</span></span><span style=display:flex><span>						<span style=color:#66d9ef>break</span>
</span></span></code></pre></div><br><p>Now that we have defined the <code>collapse_columns</code> method, let&rsquo;s add it to the loop of the <code>_on_Grid_waiting_started</code> method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_on_Grid_waiting_started</span>():
</span></span><span style=display:flex><span>	is_waiting <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#a6e22e>check_matches</span>():
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>find_matches</span>()
</span></span><span style=display:flex><span>		wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> matched_groups <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> index <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, matched_groups <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>delete_matches</span>(index)
</span></span><span style=display:flex><span>				wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>			matched_groups <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Add here</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Call the method to collapse (drop) the top piece into the empty grid space</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>collapse_columns</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e># Start timer for WaitTimer (0.3 seconds)</span>
</span></span><span style=display:flex><span>		wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e># Wait until WaitTimer times out</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	is_waiting <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span></code></pre></div><br><p>Now, after the matched and translucent piece is removed, the top piece should now be collapsed (dropped) into that empty space. Let&rsquo;s run the project and check it out.</p><p><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img26.gif alt="run project - delete matched pieces"></p><br><p>Finally, after the piece is dropped down, the empty space above it needs to be refilled with a new piece. The method for this is the already defined <code>spawn_pieces</code> method, which is also executed in the <code>_ready</code> function. When the game play starts, the <code>is_initializing</code> property is <code>false</code>, so the block in this method that re-generates the piece if it matches is skipped. In other words, a new match may already occur when the piece is generated by executing this method. This should generate more combos than expected and make the game experience more pleasant and fun.</p><p>Let&rsquo;s add the <code>spawn_pieces</code> method inside the loop of the <code>_on_Grid_waiting_started</code> method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GDScript data-lang=GDScript><span style=display:flex><span><span style=color:#75715e>### Grid.gd ###</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>_on_Grid_waiting_started</span>():
</span></span><span style=display:flex><span>	is_waiting <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>while</span> <span style=color:#a6e22e>check_matches</span>():
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>find_matches</span>()
</span></span><span style=display:flex><span>		wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> matched_groups <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> index <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, matched_groups <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>delete_matches</span>(index)
</span></span><span style=display:flex><span>				wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>			matched_groups <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>collapse_columns</span>()
</span></span><span style=display:flex><span>		wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Add here.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># call a method to spawn pieces in the empty space</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>spawn_pieces</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e># Start WaitTimer timer (0.3 seconds)</span>
</span></span><span style=display:flex><span>		wait_timer<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e># Wait until WaitTimer times out</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>yield</span>(wait_timer, <span style=color:#e6db74>&#34;timeout&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	is_waiting <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>
</span></span></code></pre></div><br><p>This completes the coding of the match process. This is the end of the work for this tutorial as well. Let&rsquo;s finish up by running the project to make sure this puzzle game is working properly.</p><p><img loading=lazy src=/images/tutorials/gd0013_advanced_match3/img27.gif alt="run project - delete matched pieces"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=sample-game>Sample game<a hidden class=anchor aria-hidden=true href=#sample-game>#</a></h2><p>I have prepared a sample game that is a further brushed-up version of the project created in this tutorial.</p><p><div><video controls autoplay loop muted playsinline aria-label='Sample game demo' style=zgotmplz>
<source src=/images/tutorials/gd0013_advanced_match3/img28.mp4 type=video/mp4>Your browser does not support the video tag.</video></div><br><br></p><p>The project file of the sample game is located in <a href=https://github.com/msnsk/AdvancedMatch3.git target=_blank>GitHub repository</a>
. Please download the .zip file from there and import the " project.godot&rdquo; file in the &ldquo;Sample&rdquo; folder and import it into Godot Engine.<br><br></p><p><strong>Game Rules:</strong></p><ul><li>The player can move a piece for up to 5 seconds at a time; after 5 seconds, the piece leaves his/her finger.</li><li>If the piece the player is moving goes out of the board, the piece leaves his/her finger and moves only that far.</li><li>The number of combos goes up by the number of matched pairs of pieces. The player can attack aliens (enemy characters) by the number of combos, and their power is also increased.</li><li>Attacking an alien reduces its HP by the amount of its power, and when the alien&rsquo;s HP is reduced to 0, it can be defeated.</li><li>Aliens attack players at regular intervals.</li><li>The player has a maximum of 10 lives, which is reduced by one when the alien attacks, and the game is over when the player is attacked 10 times.</li><li>Each time an enemy is defeated, the player&rsquo;s level increases by one. The player&rsquo;s power increases slightly as the level increases, while the enemy characters also increase their HP and attack at slightly shorter intervals.</li><li>The enemy&rsquo;s time gauge pauses during the automatic processing of matched pieces (during combo counting and attacking the enemy) after the player moves a piece and releases his finger.</li><li>Ultimately, the number of aliens defeated is the game&rsquo;s score.</li></ul><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In this tutorial, I created a puzzle game in the style of Puzzle and Dragons, which I call an evolutionary Match-3 puzzle game. Unlike the standard Match-3 game, we made the pieces move freely on the board for a certain period of time, and also made each matched piece disappear in turn, just like in Puzzle and Dragons. I hope you were able to make it through to the end.</p><p>Let me summarize the key points when creating an advanced match-3 puzzle game like this one.</p><ul><li>At a minimum, you need only two scenes: the board and the pieces.</li><li>Create a template piece scene and then inherit it to create a piece scene for each color.</li><li>Use a two-dimensional array to manage the pieces to be placed on the board grid.</li><li>Use Area2D signals to detect the following<ul><li>When a finger touches a piece</li><li>When a finger leaves a piece</li><li>When a moving piece hits a stationary piece</li><li>When a moving piece moves out of the board.</li></ul></li><li>Provide properties for flags to manage the state of the piece. For example<ul><li>Whether a piece is being moved or not</li><li>whether a piece is being replaced or not</li><li>whether a piece is being matched or not</li><li>Whether the matched piece is being automatically processed or not</li></ul></li><li>When a piece is being swapped, the position of the piece on the screen and the elements of the two-dimensional array must be updated, respectively.</li></ul><br><hr><h2 id=links>Links<a hidden class=anchor aria-hidden=true href=#links>#</a></h2><ul><li><a href=http://kidscancode.org/godot_recipes/ui/unit_healthbar/ target=_blank>KidsCanCode: OBJECT HEALTHBARS</a></li><li><a href=http://kidscancode.org/godot_recipes/ui/heart_containers_3/ target=_blank>KidsCanCode: HEART CONTAINERS: 3 WAYS</a></li><li><a href="https://apps.apple.com/jp/app/puzzle-dragons/id493470467?l=en" target=_blank>App Store: PuzzleÔºÜDragons</a></li><li><a href="https://play.google.com/store/apps/details?id=jp.gungho.padEN&amp;hl=en&amp;gl=US" target=_blank>Google Play:PuzzleÔºÜDragons</a></li></ul><hr></div><footer class=post-footer><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Advanced Match 3 Puzzle Game in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Advanced%20Match%203%20Puzzle%20Game%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0013_advanced_match3%2f&amp;hashtags=GameDev%2cGodotEngine%2cGodot3%2c2D%2cPuzzleGame%2cMobileGame%2cMatch3%2cPuzzleAndDragonsCopy"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Advanced Match 3 Puzzle Game in Godot3 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0013_advanced_match3%2f&amp;title=%f0%9f%a4%96%20Advanced%20Match%203%20Puzzle%20Game%20in%20Godot3&amp;summary=%f0%9f%a4%96%20Advanced%20Match%203%20Puzzle%20Game%20in%20Godot3&amp;source=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0013_advanced_match3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Advanced Match 3 Puzzle Game in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0013_advanced_match3%2f&title=%f0%9f%a4%96%20Advanced%20Match%203%20Puzzle%20Game%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Advanced Match 3 Puzzle Game in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0013_advanced_match3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Advanced Match 3 Puzzle Game in Godot3 on whatsapp" href="https://api.whatsapp.com/send?text=%f0%9f%a4%96%20Advanced%20Match%203%20Puzzle%20Game%20in%20Godot3%20-%20https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0013_advanced_match3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Advanced Match 3 Puzzle Game in Godot3 on telegram" href="https://telegram.me/share/url?text=%f0%9f%a4%96%20Advanced%20Match%203%20Puzzle%20Game%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0013_advanced_match3%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Advanced Match 3 Puzzle Game in Godot3 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%f0%9f%a4%96%20Advanced%20Match%203%20Puzzle%20Game%20in%20Godot3&u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0013_advanced_match3%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/puzzlegame/>PuzzleGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/mobilegame/>MobileGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/match3/>Match3</a></li><li><a href=https://www.peanuts-code.com/en/tags/puzzleanddragonscopy/>PuzzleAndDragonsCopy</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/en/tutorials/gd0014_screen_shake/><span class=title>¬´ Prev</span><br><span>ü§ñ 2D Screen Shake in Godot3</span>
</a><a class=next href=https://www.peanuts-code.com/en/tutorials/gd0012_match3/><span class=title>Next ¬ª</span><br><span>ü§ñ Match 3 Puzzle Game in Godot3</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/en/>Peanuts Code</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>