<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ü§ñ Homing Missiles in Godot3 | Peanuts Code</title>
<meta name=keywords content="GodotEngine,GameDev,2D,TopDown,Shooter"><meta name=description content="In this tutorial, we will create a homing missile in a 2D top-down shooter. A homing missile is a missile that tracks its target.

Environment

This tutorial was created in the following environment
„ÉªGodot version: 3.4.2
„ÉªComputer OS version: macOS 11.6.5


To focus on the creation of the homing missile, the rest of the project has been pre-created in advance.
The project file for this tutorial is located at GitHub repository
. After downloading the .zip file, import the &ldquo;project.godot&rdquo; file in the &ldquo;Start&rdquo; folder into the Godot Engine, and you can start the project with only the preliminary work completed. If you would like to see the completed project in a hurry, import the &ldquo;project.godot&rdquo; file from the &ldquo;End&rdquo; folder.
All the assets imported into the project were downloaded from KENNEY
 website. I used an asset pack called Tower Defense (top-down)
. I just want to thank them for making such a great asset pack available to the public."><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/en/tutorials/gd0008_homing_missiles/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0008_homing_missiles/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0008_homing_missiles/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="ü§ñ Homing Missiles in Godot3"><meta property="og:description" content="In this tutorial, we will create a homing missile in a 2D top-down shooter. A homing missile is a missile that tracks its target.

Environment

This tutorial was created in the following environment
„ÉªGodot version: 3.4.2
„ÉªComputer OS version: macOS 11.6.5


To focus on the creation of the homing missile, the rest of the project has been pre-created in advance.
The project file for this tutorial is located at GitHub repository
. After downloading the .zip file, import the &ldquo;project.godot&rdquo; file in the &ldquo;Start&rdquo; folder into the Godot Engine, and you can start the project with only the preliminary work completed. If you would like to see the completed project in a hurry, import the &ldquo;project.godot&rdquo; file from the &ldquo;End&rdquo; folder.
All the assets imported into the project were downloaded from KENNEY
 website. I used an asset pack called Tower Defense (top-down)
. I just want to thank them for making such a great asset pack available to the public."><meta property="og:type" content="article"><meta property="og:url" content="https://www.peanuts-code.com/en/tutorials/gd0008_homing_missiles/"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0008_homing_missiles/img25.gif"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-05-28T18:41:00+09:00"><meta property="article:modified_time" content="2022-05-28T18:41:00+09:00"><meta property="og:site_name" content="Peanuts Code ü•ú"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0008_homing_missiles/img25.gif"><meta name=twitter:title content="ü§ñ Homing Missiles in Godot3"><meta name=twitter:description content="In this tutorial, we will create a homing missile in a 2D top-down shooter. A homing missile is a missile that tracks its target.

Environment

This tutorial was created in the following environment
„ÉªGodot version: 3.4.2
„ÉªComputer OS version: macOS 11.6.5


To focus on the creation of the homing missile, the rest of the project has been pre-created in advance.
The project file for this tutorial is located at GitHub repository
. After downloading the .zip file, import the &ldquo;project.godot&rdquo; file in the &ldquo;Start&rdquo; folder into the Godot Engine, and you can start the project with only the preliminary work completed. If you would like to see the completed project in a hurry, import the &ldquo;project.godot&rdquo; file from the &ldquo;End&rdquo; folder.
All the assets imported into the project were downloaded from KENNEY
 website. I used an asset pack called Tower Defense (top-down)
. I just want to thank them for making such a great asset pack available to the public."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ü§ñ Tutorials","item":"https://www.peanuts-code.com/en/tutorials/"},{"@type":"ListItem","position":2,"name":"ü§ñ Homing Missiles in Godot3","item":"https://www.peanuts-code.com/en/tutorials/gd0008_homing_missiles/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ü§ñ Homing Missiles in Godot3","name":"ü§ñ Homing Missiles in Godot3","description":"In this tutorial, we will create a homing missile in a 2D top-down shooter. A homing missile is a missile that tracks its target.\nEnvironment This tutorial was created in the following environment\n„ÉªGodot version: 3.4.2\n„ÉªComputer OS version: macOS 11.6.5\nTo focus on the creation of the homing missile, the rest of the project has been pre-created in advance.\nThe project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;Start\u0026rdquo; folder into the Godot Engine, and you can start the project with only the preliminary work completed. If you would like to see the completed project in a hurry, import the \u0026ldquo;project.godot\u0026rdquo; file from the \u0026ldquo;End\u0026rdquo; folder.\nAll the assets imported into the project were downloaded from KENNEY website. I used an asset pack called Tower Defense (top-down) . I just want to thank them for making such a great asset pack available to the public.\n","keywords":["GodotEngine","GameDev","2D","TopDown","Shooter"],"articleBody":"In this tutorial, we will create a homing missile in a 2D top-down shooter. A homing missile is a missile that tracks its target.\nEnvironment This tutorial was created in the following environment\n„ÉªGodot version: 3.4.2\n„ÉªComputer OS version: macOS 11.6.5\nTo focus on the creation of the homing missile, the rest of the project has been pre-created in advance.\nThe project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the ‚Äúproject.godot‚Äù file in the ‚ÄúStart‚Äù folder into the Godot Engine, and you can start the project with only the preliminary work completed. If you would like to see the completed project in a hurry, import the ‚Äúproject.godot‚Äù file from the ‚ÄúEnd‚Äù folder.\nAll the assets imported into the project were downloaded from KENNEY website. I used an asset pack called Tower Defense (top-down) . I just want to thank them for making such a great asset pack available to the public.\nPreliminary Preparation The following game specifications, except for the homing missile part, which is listed as (planned), have already been prepared as a preliminary.\nPlayer Character (Fighter): The following keys can be used. move_up: W key - the player character moves up. move_down: S key - the player character moves down. move_right: D key - moves the player character to the right. move_left: A key - moves the player character left. magic: Spacebar or left mouse button - fires the machine gun. Bullets of the machine gun disappear when they hit the enemy character‚Äôs tank and the homing missiles it fires. Bullets of the machine gun disappear when they go off-screen. Enemy characters (tanks): Up to 5 tanks appear on the game screen. When there are no tanks left, 5 new tanks will be created. They always move toward the player character. When the player gets close to a certain distance, they will fire homing missiles (planned). The homing missiles will disappear when the player character or the machine gun is hit by a bullet (planned). HUD: A simple HUD (Heads Up Display) with only Life and Score displayed in the upper left corner. Life: Number of remaining lives of the player character (up to 5). If the player‚Äôs plane is hit by a homing missile from a tank, it will be reduced by 1. When it reaches 0, the game is over (debug panel will close). Score: Enemy character‚Äôs life (max 3) is reduced by 1 when the tank is hit by a machine gun round, and 1 point is added when it reaches 0 and the tank is destroyed. Making a homing missile Creating a scene First, follow the steps below to create a scene for a homing missile.\nselect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Scene‚Äù. Select ‚ÄúOther Node‚Äù in ‚ÄúGenerate Root Node‚Äù. Select a node of ‚ÄúArea2D‚Äù class as a root node. Rename the root node ‚ÄúArea2D‚Äù to ‚ÄúMissile‚Äù. Save the scene here once, and set the file path to ‚Äúres://Enemy/Missile.tscn‚Äù. Next, add child nodes to the root node ‚ÄúMissile‚Äù.\nadd a node of ‚ÄúSprite‚Äù class to the root node ‚ÄúMissile‚Äù. This is the appearance of a missile. Add a node of the ‚ÄúCollisionShape2D‚Äù class to the root node ‚ÄúMissile. This is used to detect the collision of the missile with the player‚Äôs plane and the machine gun projectile it fired. Add a node of the ‚ÄúTimer‚Äù class to the root node ‚ÄúMissile‚Äù. This is to release the missile instance after a certain period of time. The scene tree should now look like the following.\nEditing node properties Let‚Äôs edit the properties of each node in the scene tree in the inspector.\nMissile (Area2D) Root node Edit the ‚ÄúCollision‚Äù \u003e ‚ÄúLayer‚Äù property and ‚ÄúCollision‚Äù \u003e ‚ÄúMask‚Äù property of the ‚ÄúCollisionObject2D‚Äù class.\nThe ‚ÄúLayer‚Äù property allows you to set which collision layer the object (in this case, the ‚ÄúMissile‚Äù node) will be assigned to.\nThe ‚ÄúMask‚Äù property allows you to set which collision layer the object will enable collisions with objects in that layer. In other words, objects in layers not selected by the ‚ÄúMask‚Äù property will pass through each other without colliding, even if their positions overlap.\nFor example, a homing missile will pass through without collision with an enemy character‚Äôs tank, but collisions with the player character or machine gun bullets must be detected. Since the player character‚Äôs plane is flying over the tank, collisions with the tank are ignored, while collisions with homing missiles need to be detected.\nTo make it easier to understand which object is assigned to which collision layer, I have already named the collision layers to be used by following the steps below.\nopen the ‚ÄúProject‚Äù menu \u003e ‚ÄúProject Settings Select ‚ÄúLayer Names‚Äù \u003e ‚Äú2d Physics‚Äù from the sidebar. Set the names of Layers 1 to 4 as follows. Layer 1: Player Layer 2: Enemies Layer 3: PlayerBullets Layer 4: EnemyMissiles\nThe ‚ÄúLayer‚Äù and ‚ÄúMask‚Äù properties of the player character, machine gun bullets, and enemy characters have already been set as follows, according to the collision layer names above.\nPlayer Character: Player.tscn scene \u003e Player (KinematicBody2D) root node Layer properties: Layer 1 Mask property: Layer 4 (detects collisions with missiles)\nEnemy character: Enemy.tscn scene \u003e Enemy (KinematicBody2D) root node Layer property: Layer 2 Mask property: Layer 2, 3 (detects collisions with other tanks and machine gun bullets)\nMachine gun bullet: Bullet.tscn scene \u003e Bullet (Area2D) root node Layer property: Layer 3 Mask property: Layer 2, 4 (detects collisions between tanks and homing missiles)\nAnd I would like you to set up the homing missile you are editing now as well, as follows\nHoming missile: Missile.tscn \u003e Missile (Area2D) root node Layer property: Layer 4 Mask property: Layer 1, 3 (detects collisions between planes and machine gun bullets)\nOnce we have edited the properties of the root node ‚ÄúMissile‚Äù, we should incidentally add this node by creating a group called ‚ÄúMissiles‚Äù. This is used to determine whether a missile is a missile or not when a machine gun bullet hits a missile.\nselect ‚ÄúMissile‚Äù in the scene tree dock open the node dock \u003e group tab and add the group ‚ÄúMissiles‚Äù.\nSprite Node The method of setting a texture for a sprite by specifying the range of textures you want to use from a single sprite sheet that contains many textures is used.\nIn the inspector, apply the resource file ‚Äúres://towerDefense_tilesheet.png‚Äù to the ‚ÄúTexture‚Äù property.\nTurn on ‚ÄúRegion‚Äù \u003e ‚ÄúEnabled‚Äù.\nopen the ‚ÄúTexture Region‚Äù panel at the bottom of the editor and specify the region of the texture you want to use in the sprite sheet.\nFirst, expand the panel to the top of the editor so that it is easy to see, and then enlarge the sprite sheet to a size that is easy to see.\nselect ‚ÄúGrid Snap‚Äù in ‚ÄúSnap Mode‚Äù at the top of the ‚ÄúTexture Region‚Äù panel.\nset the ‚Äústep‚Äù at the top of the panel to 64px 64px as well. This will make the grid the same size as the sprites on the sprite sheet.\nselect the texture of the larger missile on the sprite sheet.\nReturn to the inspector and set the ‚ÄúTransform‚Äù \u003e ‚ÄúRotation‚Äù property to 90.\nThis will rotate the texture by 90¬∞. Since the object‚Äôs normal orientation is 0¬∞ along the positive x-axis and the missile‚Äôs direction of travel is based on this, the sprite‚Äôs orientation was adjusted accordingly.\nCollisionShape2D node This node sets the collision shape of the homing missile. It is required to determine the collision between the missile and the player character, and the system will alert you if a child node that sets the collision shape has not been added to the ‚ÄúArea2D‚Äù class node.\nIn the inspector, apply the ‚ÄúNew CapsuleShape2D‚Äù resource to the ‚ÄúShape‚Äù property.\nIn the 2D workspace, match the collision shape to the size of the ‚ÄúSprite‚Äù node texture.\nIf you want to enter directly in the inspector, set the properties of the ‚ÄúCapsuleShape2D‚Äù resource as follows Set the ‚ÄúRadius‚Äù property to 8. Set the ‚ÄúHeight‚Äù property to 24.\nTimer node This node is a timer for homing missiles to self-destruct after a certain amount of time. If missiles continue to exist in the game indefinitely, the number of missiles will grow and the computer will run out of memory to handle them. To avoid this, the system is designed to release instances when the time expires. For missiles that fly in a straight line, it is possible to use the signal of the ‚ÄúVisibilityNotifier2D‚Äù node to release instances when they go off the screen, but for homing missiles that track the player character, a timer is more appropriate.\nIn the inspector, set the ‚ÄúWait Time‚Äù property to 3. This is the effective time of the missile. You can tweak it to your liking, but be aware that if it is too long, there will be too many missiles at the same time, which will consume too much memory. Turn on the ‚ÄúOne Shot‚Äù property. Turn on the ‚ÄúAuto Start‚Äù property.\nThis completes the property editing for each node.\nControlling it with a script Next, we will create a script to control the missile. We want you to attach a new script to the root node ‚ÄúMissile‚Äù. The file path should be created as ‚Äúres://Enemy/Missile.gd‚Äù.\nFirst, edit the ‚ÄúMissile.gd‚Äù script as follows.\n### Missile.gd ### extends Node2D # Missile speed export var speed = 400 # Velocity of the missile var velocity = Vector2() # Physics process func _physics_process(delta): # velocity = current orientation x speed velocity = transform.x * speed # Update position: current position + velocity x delta (seconds per frame) position += velocity * delta # Update orientation: match current velocity rotation = velocity.angle() Now, the missile should fly straight for the time being. Let‚Äôs run the scene and check it out.\nCan you see the missile flying from left to right across the top portion of the GIF image?\nNext, we will add the motion to track the player character to the script. First, let‚Äôs define some necessary properties. In the following code, please add the commented ‚Äú# Add‚Äù.\n### Missile.gd ### extends Node2D export var speed = 400 # Add: the ability to steer in the direction the player is in. # The higher the value, the quicker the direction correction export var steering_force = 20.0 var velocity = Vector2() # Add: acceleration var acceleration = Vector2() # Reference to the target Player object (as soon as detected) var target = null Next, define the method by which the missile will steer toward the player character (correct its trajectory).\n### Missile.gd ### # method to steer the missile towards the player character func steer(): # Define as velocity to steer var steering = Vector2() # Define ideal velocity (direction x speed towards player character from current position) var ideal_velocity = (target.position - position).normalized() * speed # speed to steer = direction vector obtained by ideal_velocity - current_velocity x force to steer steering = (ideal_velocity - velocity).normalized() * steering_force # output velocity to steer return steering Since it may be difficult to visualize from the comments on the code alone, I will supplement this with a diagram.\nWhen the homing missile detects the player character‚Äôs plane, it will track it as a target. The ideal velocity is the variable ideal_velocity, assuming that the missile could travel in a straight line in the direction of the target. In reality, however, the missile is flying in the direction that the property velocity has, and we want to steer it toward ideal_velocity to correct its trajectory.\nThat‚Äôs where the vector calculation comes in. If we take the vector ideal_velocity minus velocity and turn it into a direction vector (a vector of length 1) using the method normalized. Then, multiply it by the value of the property steering_force, which is the force to steer, the value of the variable steering is determined, which is the velocity to steer.\nNow, let‚Äôs use the value of the variable steering output by the method steer to modify the missile so that it flies while correcting its trajectory. Please add the comment ‚Äú# Add‚Äù to the method _physics_process.\n### Missile.gd ### func _physics_process(delta): velocity = transform.x * speed # Add: add velocity to steer to acceleration acceleration += steer() # Add: add the velocity plus the acceleration x delta value to the velocity velocity += acceleration * delta # Add: limit the length of the velocity vector so that it does not exceed the speed velocity = velocity.clamped(speed) position += velocity * delta rotation = velocity.angle() This should have implemented the movement of the homing missile tracking the player character.\nLet‚Äôs continue by adding a program for when the missile hits the player character or the machine gun projectile. For this, we will use the signal of the Area2D class of the root node ‚ÄúMissile‚Äù.\nNow, after selecting ‚ÄúMissile‚Äù in the scene tree dock, go to the node dock \u003e Signal tab and connect the signal ‚Äúbody_entered(body: Node)‚Äù to this ‚ÄúMissile.gd‚Äù script.\nAfter connecting, edit the automatically generated method _on_Missile_body_entered as follows.\n### Missile.gd ### # Method called by the signal sent when the physical body is hit by a missile func _on_Missile_body_entered(body): # If the physical body is the player character if body.name == \"Player\": print(\"Missile hit \", body.name) # Play the animation \"hit\" of the AnimationPlayer in the Player scene body.anim_player.play(\"hit\") # Emit the signal player_hit for the Player node body.emit_signal(\"player_hit\") # If the Player's Life is greater than 1, set it to -1 if body.life \u003e 1: body.life -= 1 # if the Player's Life is less than 1 else: # wait for animation hit to finish playing yield(body.anim_player, \"animation_finished\") # release the Player object body.queue_free() print(\"Game Over!\") # Close debug panel and exit get_tree().quit() # release the missile itself queue_free() Now, when a missile hits the player character‚Äôs plane, it animates (flashes red) and the player‚Äôs Life is reduced by one, and the game is over when there are no more than 0 planes left.\nThe next step is to create a mechanism to release the missile when the time expires using the timer in the ‚ÄúTimer‚Äù node. This also uses the signal of the ‚ÄúTimer‚Äù node. Now, select ‚ÄúTimer‚Äù in the scene tree dock, and connect the signal ‚Äútimeout()‚Äù to the script.\nIn the block of the method _on_Timer_timeout generated by the connection, simply add the method queue_free.\n### Missile.gd ### func _on_Timer_timeout(): queue_free() The missile is now complete.\nMaking the enemy character launch a homing missile The next step is for the ‚ÄúEnemy.tscn‚Äù scene to create an instance of the ‚ÄúMissile.tscn‚Äù scene that we just created, so that the enemy character‚Äôs tank fires homing missiles.\nEditing and controlling the script Let‚Äôs open and edit the ‚ÄúEnemy.gd‚Äù script attached to the root node ‚ÄúEnemy‚Äù in the ‚ÄúEnemy.tscn‚Äù scene.\nFirst, let‚Äôs preload the missile scene file. At the beginning of the script, define constants for references. You will see the comment ‚Äú# Add‚Äù.\n### Enemy.gd ### extends KinematicBody2D signal enemy_killed # Add: reference to preloaded Missile.tscn scene file const missile_scn = preload(\"res://Enemy/Missile.tscn\") Next, since the block of the method _on_Timer_timeout contains only pass, please update it as follows. Incidentally, this method was generated by connecting the signal ‚Äútimeout()‚Äù of the ‚ÄúLaunchTimer‚Äù node (Timer class). In other words, this method is called every time the timer times out.\n### Enemy.gd ### # Method called by a signal sent out when a LaunchTimer node times out func _on_LaunchTimer_timeout(): # If the parent node (World) has a node named Player if get_parent().has_node(\"Player\"): # call the method to launch the missile launch_missile() Please insert the following code defining the method launch_missile, which is described at the end of the above code, after the above _on_LaunchTimer_timeout.\n### Enemy.gd ### # Method to launch a missile func launch_missile(): # Instantiate the Missile.tscn scene var missile = missile_scn.instance() # Assign the Player object to Missile's target property missile.target = get_parent().get_node(\"Player\") # Add a missile instance to the parent node (World) get_parent().add_child(missile) # Align the missile with the tip of the tank's cannon missile.position = muzzle.global_position # Align the direction of the missile with the direction of the tip of the tank's cannon missile.rotation = muzzle.global_rotation The missile should now be able to be launched. Let‚Äôs run the project to see if the implementation so far works without problem.\nExtra: Adding visual effects For visual effect, we have prepared explosion particles when the missile hits and smoke particles coming out from behind the missile in the preliminary stage. Let‚Äôs use these by adding code to the ‚ÄúMissile.gd‚Äù script to give the missile a more visually appealing performance.\nAfter opening the ‚ÄúMissile.gd‚Äù script, add the line ‚Äú# Add‚Äù to the code.\n### Missile.gd ### # Add: See preloading Smoke.tscn (scene with only smoke particles) const smoke_scn = preload(\"res://Effect/Smoke.tscn\") # Add: Preload reference to Explosion.tscn (scene with only explosion particles) const explosion_scn = preload(\"res://Effect/Explosion.tscn\") export var speed = 400 export var steering_force = 20.0 var velocity = Vector2() var acceleration = Vector2() var target = null # Add: count to space out the smoke var smoke_count = 0 Next, call the method that produces the smoke within the _physics_process method.\n### Missile.gd ### func _physics_process(delta): velocity = transform.x * speed acceleration += steer() velocity += acceleration * delta velocity = velocity.clamped(speed) position += velocity * delta rotation = velocity.angle() # Add the value of delta to smoke_count smoke_count += delta # If smoke_count is greater than 0.05 if smoke_count \u003e 0.05: # Set smoke_count back to 0 smoke_count = 0 # Call the method that spawns the smoke spawn_smoke() And let‚Äôs define the last method spawn_smoke as follows. This code should be inserted under the steer method.\n### Missile.gd ### # spawn_smoke() method func spawn_smoke(): # Instantiate a scene of smoke particles var smoke = smoke_scn.instance() # Add instance node to parent node (World) get_parent().add_child(smoke) # Put smoke at current missile position smoke.position = global_position # Align the direction of the smoke with the direction of the current missile (doesn't make much sense) smoke.rotation = global_rotation Next, we now define a method to generate explosion particles. Add it under the method spawn_smoke above.\n### Missile.gd ### # ÁàÜÁô∫„Åï„Åõ„Çã„É°„ÇΩ„ÉÉ„Éâ func explode(): # Instantiate a scene of explosion particles var explosion = explosion_scn.instance() # Add instance node to parent node (World) get_parent().add_child(explosion) # Place the explosion particle at the current missile position explosion.position = global_position # Align the orientation of the explosion particle with the orientation of the current missile (doesn't make much sense) explosion.rotation = global_rotation Let‚Äôs update the code to call the method explode at the three places with the following ‚Äú# Add‚Äù comments.\n### Missile.gd ### func _on_Missile_body_entered(body): if body.name == \"Player\": print(\"Missile hit \", body.name) body.anim_player.play(\"hit\") body.emit_signal(\"player_hit\") if body.life \u003e 1: body.life -= 1 else: explode() # Add yield(body.anim_player, \"animation_finished\") body.queue_free() print(\"Game Over!\") get_tree().quit() explode() # Add queue_free() func _on_Timer_timeout(): explode() # Add queue_free() That‚Äôs all for the update. Let‚Äôs run the project one last time to see the direction we added.\nBy the way, both smoke and explosion particles use the ‚ÄúParticles2D‚Äù class node. macOS seems to have some performance issues with this node. I‚Äôm a macOS user, and it certainly caused a delay. You may be able to see it in the gif image above.\nIf you are using macOS, you can convert the root node (Particles2D class) to the ‚ÄúCPUParticles2D‚Äù class using ‚ÄúConvert to CPUParticles2D‚Äù from ‚ÄúParicles‚Äù on the toolbar with the root node selected in the scene tree dock. It seems to be possible to convert it to the ‚ÄúCPUParticles2D‚Äù class.\nConclusion In this tutorial, we created a homing missile in top-down shooting. Let‚Äôs summarize the key points in creating it.\nThe missile scene should be programmed to fly by itself as soon as an instance is added. To reproduce the tracking motion of the missile, sequentially perform the following every frame in the physics process. Multiply the direction vector to the target (the ‚ÄúPlayer‚Äù in this tutorial) by the speed to obtain the ideal velocity. Normalize the vector of the difference between the ideal velocity and the actual velocity to find the direction to steer. Multiply the direction to steer by the force to steer predefined by the property to obtain the speed to steer. Add the velocity to steer to the current acceleration. Add the updated acceleration to the current velocity. When creating an instance of a missile scene, make it a child of an object that does not move, such as its parent node (‚ÄúWorld‚Äù in this tutorial), rather than of an object that rotates or moves (‚ÄúEnemy‚Äù in this tutorial), so that the missile will fly correctly. To reduce memory consumption, use Timer‚Äôs signal so that the missile instance is released at timeout. Links The YouTube videos and articles on KidsCanCode were very helpful in preparing this tutorial. I would like to take this opportunity to thank them. For a better understanding, we recommend that you also view those contents.\nGodot Docs: Matrices and transforms YouTube: Godot Recipes: Homing Missiles YouTube: Godot 3.0: Top-down Tank Battle - Part 10: Homing Missiles KidsCanCode: HOMING MISSILE ","wordCount":"3533","inLanguage":"en","image":"https://www.peanuts-code.com/images/tutorials/gd0008_homing_missiles/img25.gif","datePublished":"2022-05-28T18:41:00+09:00","dateModified":"2022-05-28T18:41:00+09:00","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/en/tutorials/gd0008_homing_missiles/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/en/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/ja/ title=Japanese aria-label=üáØüáµÊó•Êú¨Ë™û>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/en/ title=Home><span>Home</span></a></li><li><a href=https://www.peanuts-code.com/en/portfolio/ title=Works><span>Works</span></a></li><li><a href=https://www.peanuts-code.com/en/posts/ title=Blogs><span>Blogs</span></a></li><li><a href=https://www.peanuts-code.com/en/tutorials/ title=Tutorials><span>Tutorials</span></a></li><li><a href=https://www.peanuts-code.com/en/about/ title=About><span>About</span></a></li><li><a href=https://www.peanuts-code.com/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/en/>Home</a>&nbsp;¬ª&nbsp;<a href=https://www.peanuts-code.com/en/tutorials/>ü§ñ Tutorials</a></div><h1 class="post-title entry-hint-parent">ü§ñ Homing Missiles in Godot3</h1><div class=post-meta><span title='2022-05-28 18:41:00 +0900 +0900'>2022-05-28</span>&nbsp;¬∑&nbsp;8 min&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/ja/tutorials/gd0008_homing_missiles/>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Homing Missiles in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Homing%20Missiles%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0008_homing_missiles%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cTopDown%2cShooter"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Homing Missiles in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0008_homing_missiles%2f&title=%f0%9f%a4%96%20Homing%20Missiles%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Homing Missiles in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0008_homing_missiles%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/topdown/>TopDown</a></li><li><a href=https://www.peanuts-code.com/en/tags/shooter/>Shooter</a></li></ul></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0008_homing_missiles/img25.gif alt="Homing Missiles in Godot"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#preliminary-preparation>Preliminary Preparation</a></li><li><a href=#making-a-homing-missile>Making a homing missile</a><ul><li><a href=#creating-a-scene>Creating a scene</a></li><li><a href=#editing-node-properties>Editing node properties</a></li><li><a href=#controlling-it-with-a-script>Controlling it with a script</a></li></ul></li><li><a href=#making-the-enemy-character-launch-a-homing-missile>Making the enemy character launch a homing missile</a><ul><li><a href=#editing-and-controlling-the-script>Editing and controlling the script</a></li></ul></li><li><a href=#extra-adding-visual-effects>Extra: Adding visual effects</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#links>Links</a></li></ul></nav></div></details></div><div class=post-content><p>In this tutorial, we will create a homing missile in a 2D top-down shooter. A homing missile is a missile that tracks its target.</p><blockquote><p><em><strong><span style=color:salmon>Environment</span></strong><br>This tutorial was created in the following environment</em><br>„Éª<em>Godot version: <strong>3.4.2</strong></em><br>„Éª<em>Computer OS version: <strong>macOS 11.6.5</strong></em></p></blockquote><br><p>To focus on the creation of the homing missile, the rest of the project has been pre-created in advance.</p><p>The project file for this tutorial is located at <strong><a href=https://github.com/msnsk/HomingMissiles.git target=_blank>GitHub repository</a>
</strong>. After downloading the .zip file, import the &ldquo;project.godot&rdquo; file in the &ldquo;Start&rdquo; folder into the Godot Engine, and you can start the project with only the preliminary work completed. If you would like to see the completed project in a hurry, import the &ldquo;project.godot&rdquo; file from the &ldquo;End&rdquo; folder.</p><p>All the assets imported into the project were downloaded from <strong><a href=https://www.kenney.nl/assets target=_blank>KENNEY</a>
</strong>website. I used an asset pack called <strong><a href=https://www.kenney.nl/assets/tower-defense-top-down target=_blank>Tower Defense (top-down)</a>
</strong>. I just want to thank them for making such a great asset pack available to the public.</p><br><h2 id=preliminary-preparation>Preliminary Preparation</h2><p>The following game specifications, except for the homing missile part, which is listed as (planned), have already been prepared as a preliminary.</p><ul><li>Player Character (Fighter):<ul><li>The following keys can be used.<ul><li><strong>move_up</strong>: W key - the player character moves up.</li><li><strong>move_down</strong>: S key - the player character moves down.</li><li><strong>move_right</strong>: D key - moves the player character to the right.</li><li><strong>move_left</strong>: A key - moves the player character left.</li><li><strong>magic</strong>: Spacebar or left mouse button - fires the machine gun.</li></ul></li><li>Bullets of the machine gun disappear when they hit the enemy character&rsquo;s tank and the homing missiles it fires.</li><li>Bullets of the machine gun disappear when they go off-screen.</li></ul></li><li>Enemy characters (tanks):<ul><li>Up to 5 tanks appear on the game screen. When there are no tanks left, 5 new tanks will be created.</li><li>They always move toward the player character.</li><li>When the player gets close to a certain distance, they will fire <strong>homing missiles</strong> (planned).</li><li>The homing missiles will disappear when the player character or the machine gun is hit by a bullet (planned).</li></ul></li><li>HUD:<ul><li>A simple HUD (Heads Up Display) with only Life and Score displayed in the upper left corner.</li><li>Life: Number of remaining lives of the player character (up to 5). If the player&rsquo;s plane is hit by a homing missile from a tank, it will be reduced by 1. When it reaches 0, the game is over (debug panel will close).</li><li>Score: Enemy character&rsquo;s life (max 3) is reduced by 1 when the tank is hit by a machine gun round, and 1 point is added when it reaches 0 and the tank is destroyed.</li></ul></li></ul><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=making-a-homing-missile>Making a homing missile</h2><h3 id=creating-a-scene>Creating a scene</h3><p>First, follow the steps below to create a scene for a homing missile.</p><ol><li>select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;Other Node&rdquo; in &ldquo;Generate Root Node&rdquo;.</li><li>Select a node of &ldquo;Area2D&rdquo; class as a root node.</li><li>Rename the root node &ldquo;Area2D&rdquo; to &ldquo;Missile&rdquo;.</li><li>Save the scene here once, and set the file path to &ldquo;res://Enemy/Missile.tscn&rdquo;.</li></ol><br><p>Next, add child nodes to the root node &ldquo;Missile&rdquo;.</p><ol><li>add a node of &ldquo;Sprite&rdquo; class to the root node &ldquo;Missile&rdquo;. This is the appearance of a missile.</li><li>Add a node of the &ldquo;CollisionShape2D&rdquo; class to the root node &ldquo;Missile. This is used to detect the collision of the missile with the player&rsquo;s plane and the machine gun projectile it fired.</li><li>Add a node of the &ldquo;Timer&rdquo; class to the root node &ldquo;Missile&rdquo;. This is to release the missile instance after a certain period of time.</li></ol><p>The scene tree should now look like the following.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img2.png alt="Missile Scene Tree"></p><br><h3 id=editing-node-properties>Editing node properties</h3><p>Let&rsquo;s edit the properties of each node in the scene tree in the inspector.</p><br><h4 id=missile-area2d-root-node>Missile (Area2D) Root node</h4><p>Edit the &ldquo;Collision&rdquo; > &ldquo;Layer&rdquo; property and &ldquo;Collision&rdquo; > &ldquo;Mask&rdquo; property of the &ldquo;CollisionObject2D&rdquo; class.</p><p>The &ldquo;Layer&rdquo; property allows you to set which collision layer the object (in this case, the &ldquo;Missile&rdquo; node) will be assigned to.</p><p>The &ldquo;Mask&rdquo; property allows you to set which collision layer the object will enable collisions with objects in that layer. In other words, objects in layers not selected by the &ldquo;Mask&rdquo; property will pass through each other without colliding, even if their positions overlap.</p><p>For example, a homing missile will pass through without collision with an enemy character&rsquo;s tank, but collisions with the player character or machine gun bullets must be detected. Since the player character&rsquo;s plane is flying over the tank, collisions with the tank are ignored, while collisions with homing missiles need to be detected.</p><p>To make it easier to understand which object is assigned to which collision layer, I have already named the collision layers to be used by following the steps below.</p><ol><li>open the &ldquo;Project&rdquo; menu > &ldquo;Project Settings</li><li>Select &ldquo;Layer Names&rdquo; > &ldquo;2d Physics&rdquo; from the sidebar.</li><li>Set the names of Layers 1 to 4 as follows.<ul><li>Layer 1: Player</li><li>Layer 2: Enemies</li><li>Layer 3: PlayerBullets</li><li>Layer 4: EnemyMissiles<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img3.png alt="2D Physics Layers"></li></ul></li></ol><p>The &ldquo;Layer&rdquo; and &ldquo;Mask&rdquo; properties of the player character, machine gun bullets, and enemy characters have already been set as follows, according to the collision layer names above.</p><ul><li>Player Character: Player.tscn scene > Player (KinematicBody2D) root node<ul><li>Layer properties: Layer 1</li><li>Mask property: Layer 4 (detects collisions with missiles)<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img4.png alt="CollisionObject2D properties"></li></ul></li><li>Enemy character: Enemy.tscn scene > Enemy (KinematicBody2D) root node<ul><li>Layer property: Layer 2</li><li>Mask property: Layer 2, 3 (detects collisions with other tanks and machine gun bullets)<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img5.png alt="CollisionObject2D properties"></li></ul></li><li>Machine gun bullet: Bullet.tscn scene > Bullet (Area2D) root node<ul><li>Layer property: Layer 3</li><li>Mask property: Layer 2, 4 (detects collisions between tanks and homing missiles)<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img6.png alt="CollisionObject2D properties"></li></ul></li></ul><br><p>And I would like you to set up the homing missile you are editing now as well, as follows</p><ul><li>Homing missile: Missile.tscn > Missile (Area2D) root node<ul><li>Layer property: Layer 4</li><li>Mask property: Layer 1, 3 (detects collisions between planes and machine gun bullets)<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img7.png alt="CollisionObject2D properties"></li></ul></li></ul><br><p>Once we have edited the properties of the root node &ldquo;Missile&rdquo;, we should incidentally add this node by creating a group called &ldquo;Missiles&rdquo;. This is used to determine whether a missile is a missile or not when a machine gun bullet hits a missile.</p><ol><li>select &ldquo;Missile&rdquo; in the scene tree dock</li><li>open the node dock > group tab and add the group &ldquo;Missiles&rdquo;.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img7.1.png alt="CollisionObject2D properties"></li></ol><br><h4 id=sprite-node>Sprite Node</h4><p>The method of setting a texture for a sprite by specifying the range of textures you want to use from a single sprite sheet that contains many textures is used.</p><ol><li>In the inspector, apply the resource file &ldquo;res://towerDefense_tilesheet.png&rdquo; to the &ldquo;Texture&rdquo; property.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img8.png alt="Texture property of Sprite"></li><li>Turn on &ldquo;Region&rdquo; > &ldquo;Enabled&rdquo;.<br><img loading=lazy src="/images/tutorials/gd_common/node/Sprite/property/Region%3eEnabled=On.png" alt="Region>Enabled property of Sprite"></li><li>open the &ldquo;Texture Region&rdquo; panel at the bottom of the editor and specify the region of the texture you want to use in the sprite sheet.<br><img loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/tab_name.png alt="Region pannel"><ol><li>First, expand the panel to the top of the editor so that it is easy to see, and then enlarge the sprite sheet to a size that is easy to see.<br><img loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/expand_icon.png alt="Region pannel"></li><li>select &ldquo;Grid Snap&rdquo; in &ldquo;Snap Mode&rdquo; at the top of the &ldquo;Texture Region&rdquo; panel.<br><img loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/snap_mode=grid_snap.png" alt="Region pannel > choose grid snap"></li><li>set the &ldquo;step&rdquo; at the top of the panel to 64px 64px as well. This will make the grid the same size as the sprites on the sprite sheet.<br><img loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/step=64x64.png" alt="Region pannel > input grid step"></li><li>select the texture of the larger missile on the sprite sheet.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img14.png alt="Region pannel Select region"><br>Return to the inspector and set the &ldquo;Transform&rdquo; > &ldquo;Rotation&rdquo; property to 90.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img15.png alt="Transform > Rotation property"><br>This will rotate the texture by 90¬∞. Since the object&rsquo;s normal orientation is 0¬∞ along the positive x-axis and the missile&rsquo;s direction of travel is based on this, the sprite&rsquo;s orientation was adjusted accordingly.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img16.png alt="Sprite in 2D workspace"></li></ol></li></ol><br><h4 id=collisionshape2d-node>CollisionShape2D node</h4><p>This node sets the collision shape of the homing missile. It is required to determine the collision between the missile and the player character, and the system will alert you if a child node that sets the collision shape has not been added to the &ldquo;Area2D&rdquo; class node.</p><ol><li>In the inspector, apply the &ldquo;New CapsuleShape2D&rdquo; resource to the &ldquo;Shape&rdquo; property.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img17.png alt="Shape property"></li><li>In the 2D workspace, match the collision shape to the size of the &ldquo;Sprite&rdquo; node texture.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img18.png alt="CollisionShape in 2D workspace"></li><li>If you want to enter directly in the inspector, set the properties of the &ldquo;CapsuleShape2D&rdquo; resource as follows<ul><li>Set the &ldquo;Radius&rdquo; property to 8.</li><li>Set the &ldquo;Height&rdquo; property to 24.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img19.png alt="Radius, Height property"></li></ul></li></ol><br><h4 id=timer-node>Timer node</h4><p>This node is a timer for homing missiles to self-destruct after a certain amount of time. If missiles continue to exist in the game indefinitely, the number of missiles will grow and the computer will run out of memory to handle them. To avoid this, the system is designed to release instances when the time expires. For missiles that fly in a straight line, it is possible to use the signal of the &ldquo;VisibilityNotifier2D&rdquo; node to release instances when they go off the screen, but for homing missiles that track the player character, a timer is more appropriate.</p><ol><li>In the inspector, set the &ldquo;Wait Time&rdquo; property to 3. This is the effective time of the missile. You can tweak it to your liking, but be aware that if it is too long, there will be too many missiles at the same time, which will consume too much memory.</li><li>Turn on the &ldquo;One Shot&rdquo; property.</li><li>Turn on the &ldquo;Auto Start&rdquo; property.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img20.png alt="Timer node properties"></li></ol><br><p>This completes the property editing for each node.</p><br><h3 id=controlling-it-with-a-script>Controlling it with a script</h3><p>Next, we will create a script to control the missile. We want you to attach a new script to the root node &ldquo;Missile&rdquo;. The file path should be created as &ldquo;res://Enemy/Missile.gd&rdquo;.</p><p>First, edit the &ldquo;Missile.gd&rdquo; script as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Missile speed</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>speed</span> <span class=o>=</span> <span class=mi>400</span>
</span></span><span class=line><span class=cl><span class=c1># Velocity of the missile</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>velocity</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Physics process</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_physics_process</span><span class=p>(</span><span class=n>delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># velocity = current orientation x speed</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>=</span> <span class=n>transform</span><span class=o>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>speed</span>
</span></span><span class=line><span class=cl>	<span class=c1># Update position: current position + velocity x delta (seconds per frame)</span>
</span></span><span class=line><span class=cl>	<span class=n>position</span> <span class=o>+=</span> <span class=n>velocity</span> <span class=o>*</span> <span class=n>delta</span>
</span></span><span class=line><span class=cl>	<span class=c1># Update orientation: match current velocity</span>
</span></span><span class=line><span class=cl>	<span class=n>rotation</span> <span class=o>=</span> <span class=n>velocity</span><span class=o>.</span><span class=nf>angle</span><span class=p>()</span>
</span></span></code></pre></div><br><p>Now, the missile should fly straight for the time being. Let&rsquo;s run the scene and check it out.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img21.gif alt="Run Missile Scene"></p><p>Can you see the missile flying from left to right across the top portion of the GIF image?</p><p>Next, we will add the motion to track the player character to the script. First, let&rsquo;s define some necessary properties. In the following code, please add the commented &ldquo;# Add&rdquo;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>speed</span> <span class=o>=</span> <span class=mi>400</span>
</span></span><span class=line><span class=cl><span class=c1># Add: the ability to steer in the direction the player is in.</span>
</span></span><span class=line><span class=cl><span class=c1># The higher the value, the quicker the direction correction</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>steering_force</span> <span class=o>=</span> <span class=mf>20.0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>velocity</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># Add: acceleration</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>acceleration</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># Reference to the target Player object (as soon as detected)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>target</span> <span class=o>=</span> <span class=kt>null</span>
</span></span></code></pre></div><br><p>Next, define the method by which the missile will steer toward the player character (correct its trajectory).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># method to steer the missile towards the player character</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>steer</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Define as velocity to steer</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>steering</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1># Define ideal velocity (direction x speed towards player character from current position)</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>ideal_velocity</span> <span class=o>=</span> <span class=p>(</span><span class=n>target</span><span class=o>.</span><span class=n>position</span> <span class=o>-</span> <span class=n>position</span><span class=p>)</span><span class=o>.</span><span class=nf>normalized</span><span class=p>()</span> <span class=o>*</span> <span class=n>speed</span>
</span></span><span class=line><span class=cl>	<span class=c1># speed to steer = direction vector obtained by ideal_velocity - current_velocity x force to steer</span>
</span></span><span class=line><span class=cl>	<span class=n>steering</span> <span class=o>=</span> <span class=p>(</span><span class=n>ideal_velocity</span> <span class=o>-</span> <span class=n>velocity</span><span class=p>)</span><span class=o>.</span><span class=nf>normalized</span><span class=p>()</span> <span class=o>*</span> <span class=n>steering_force</span>
</span></span><span class=line><span class=cl>  <span class=c1># output velocity to steer</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>steering</span>
</span></span></code></pre></div><br><p>Since it may be difficult to visualize from the comments on the code alone, I will supplement this with a diagram.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/diagram1.png alt=Diagram></p><p>When the homing missile detects the player character&rsquo;s plane, it will track it as a <code>target</code>. The ideal velocity is the variable <code>ideal_velocity</code>, assuming that the missile could travel in a straight line in the direction of the <code>target</code>. In reality, however, the missile is flying in the direction that the property <code>velocity</code> has, and we want to steer it toward <code>ideal_velocity</code> to correct its trajectory.</p><p>That&rsquo;s where the vector calculation comes in. If we take the vector <code>ideal_velocity</code> minus <code>velocity</code> and turn it into a direction vector (a vector of length 1) using the method <code>normalized</code>. Then, multiply it by the value of the property <code>steering_force</code>, which is the force to steer, the value of the variable <code>steering</code> is determined, which is the velocity to steer.</p><p>Now, let&rsquo;s use the value of the variable <code>steering</code> output by the method <code>steer</code> to modify the missile so that it flies while correcting its trajectory. Please add the comment &ldquo;# Add&rdquo; to the method <code>_physics_process</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_physics_process</span><span class=p>(</span><span class=n>delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>=</span> <span class=n>transform</span><span class=o>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>speed</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add: add velocity to steer to acceleration</span>
</span></span><span class=line><span class=cl>	<span class=n>acceleration</span> <span class=o>+=</span> <span class=nf>steer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add: add the velocity plus the acceleration x delta value to the velocity</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>+=</span> <span class=n>acceleration</span> <span class=o>*</span> <span class=n>delta</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add: limit the length of the velocity vector so that it does not exceed the speed</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>=</span> <span class=n>velocity</span><span class=o>.</span><span class=nf>clamped</span><span class=p>(</span><span class=n>speed</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>position</span> <span class=o>+=</span> <span class=n>velocity</span> <span class=o>*</span> <span class=n>delta</span>
</span></span><span class=line><span class=cl>	<span class=n>rotation</span> <span class=o>=</span> <span class=n>velocity</span><span class=o>.</span><span class=nf>angle</span><span class=p>()</span>
</span></span></code></pre></div><br><p>This should have implemented the movement of the homing missile tracking the player character.<br><br></p><p>Let&rsquo;s continue by adding a program for when the missile hits the player character or the machine gun projectile. For this, we will use the signal of the Area2D class of the root node &ldquo;Missile&rdquo;.</p><p>Now, after selecting &ldquo;Missile&rdquo; in the scene tree dock, go to the node dock > Signal tab and connect the signal &ldquo;body_entered(body: Node)&rdquo; to this &ldquo;Missile.gd&rdquo; script.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img22.png alt="Connect signal body_entered"></p><p>After connecting, edit the automatically generated method <code>_on_Missile_body_entered</code> as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># Method called by the signal sent when the physical body is hit by a missile</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Missile_body_entered</span><span class=p>(</span><span class=n>body</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># If the physical body is the player character</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>body</span><span class=o>.</span><span class=n>name</span> <span class=o>==</span> <span class=s2>&#34;Player&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Missile hit &#34;</span><span class=p>,</span> <span class=n>body</span><span class=o>.</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1># Play the animation &#34;hit&#34; of the AnimationPlayer in the Player scene</span>
</span></span><span class=line><span class=cl>		<span class=n>body</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;hit&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1># Emit the signal player_hit for the Player node</span>
</span></span><span class=line><span class=cl>		<span class=n>body</span><span class=o>.</span><span class=nf>emit_signal</span><span class=p>(</span><span class=s2>&#34;player_hit&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1># If the Player&#39;s Life is greater than 1, set it to -1</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>body</span><span class=o>.</span><span class=n>life</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>body</span><span class=o>.</span><span class=n>life</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=c1># if the Player&#39;s Life is less than 1</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=c1># wait for animation hit to finish playing</span>
</span></span><span class=line><span class=cl>			<span class=k>yield</span><span class=p>(</span><span class=n>body</span><span class=o>.</span><span class=n>anim_player</span><span class=p>,</span> <span class=s2>&#34;animation_finished&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=c1># release the Player object</span>
</span></span><span class=line><span class=cl>			<span class=n>body</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Game Over!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=c1># Close debug panel and exit</span>
</span></span><span class=line><span class=cl>			<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>quit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1># release the missile itself</span>
</span></span><span class=line><span class=cl>	<span class=nf>queue_free</span><span class=p>()</span>
</span></span></code></pre></div><p>Now, when a missile hits the player character&rsquo;s plane, it animates (flashes red) and the player&rsquo;s Life is reduced by one, and the game is over when there are no more than 0 planes left.</p><br><p>The next step is to create a mechanism to release the missile when the time expires using the timer in the &ldquo;Timer&rdquo; node. This also uses the signal of the &ldquo;Timer&rdquo; node. Now, select &ldquo;Timer&rdquo; in the scene tree dock, and connect the signal &ldquo;timeout()&rdquo; to the script.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img23.png alt="Connect signal timeout"></p><p>In the block of the method <code>_on_Timer_timeout</code> generated by the connection, simply add the method <code>queue_free</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Timer_timeout</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nf>queue_free</span><span class=p>()</span>
</span></span></code></pre></div><br><p>The missile is now complete.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=making-the-enemy-character-launch-a-homing-missile>Making the enemy character launch a homing missile</h2><p>The next step is for the &ldquo;Enemy.tscn&rdquo; scene to create an instance of the &ldquo;Missile.tscn&rdquo; scene that we just created, so that the enemy character&rsquo;s tank fires homing missiles.</p><br><h3 id=editing-and-controlling-the-script>Editing and controlling the script</h3><p>Let&rsquo;s open and edit the &ldquo;Enemy.gd&rdquo; script attached to the root node &ldquo;Enemy&rdquo; in the &ldquo;Enemy.tscn&rdquo; scene.</p><p>First, let&rsquo;s preload the missile scene file. At the beginning of the script, define constants for references. You will see the comment &ldquo;# Add&rdquo;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Enemy.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>KinematicBody2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>signal</span> <span class=n>enemy_killed</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Add: reference to preloaded Missile.tscn scene file</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>missile_scn</span> <span class=o>=</span> <span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Enemy/Missile.tscn&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>Next, since the block of the method <code>_on_Timer_timeout</code> contains only <code>pass</code>, please update it as follows. Incidentally, this method was generated by connecting the signal &ldquo;timeout()&rdquo; of the &ldquo;LaunchTimer&rdquo; node (Timer class). In other words, this method is called every time the timer times out.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Enemy.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># Method called by a signal sent out when a LaunchTimer node times out</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_LaunchTimer_timeout</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># If the parent node (World) has a node named Player</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nf>get_parent</span><span class=p>()</span><span class=o>.</span><span class=nf>has_node</span><span class=p>(</span><span class=s2>&#34;Player&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># call the method to launch the missile</span>
</span></span><span class=line><span class=cl>		<span class=nf>launch_missile</span><span class=p>()</span>
</span></span></code></pre></div><p>Please insert the following code defining the method <code>launch_missile</code>, which is described at the end of the above code, after the above <code>_on_LaunchTimer_timeout</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Enemy.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># Method to launch a missile</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>launch_missile</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Instantiate the Missile.tscn scene</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>missile</span> <span class=o>=</span> <span class=n>missile_scn</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1># Assign the Player object to Missile&#39;s target property</span>
</span></span><span class=line><span class=cl>	<span class=n>missile</span><span class=o>.</span><span class=n>target</span> <span class=o>=</span> <span class=nf>get_parent</span><span class=p>()</span><span class=o>.</span><span class=nf>get_node</span><span class=p>(</span><span class=s2>&#34;Player&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add a missile instance to the parent node (World)</span>
</span></span><span class=line><span class=cl>	<span class=nf>get_parent</span><span class=p>()</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>missile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Align the missile with the tip of the tank&#39;s cannon</span>
</span></span><span class=line><span class=cl>	<span class=n>missile</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>muzzle</span><span class=o>.</span><span class=n>global_position</span>
</span></span><span class=line><span class=cl>	<span class=c1># Align the direction of the missile with the direction of the tip of the tank&#39;s cannon</span>
</span></span><span class=line><span class=cl>	<span class=n>missile</span><span class=o>.</span><span class=n>rotation</span> <span class=o>=</span> <span class=n>muzzle</span><span class=o>.</span><span class=n>global_rotation</span>
</span></span></code></pre></div><p>The missile should now be able to be launched. Let&rsquo;s run the project to see if the implementation so far works without problem.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img24.gif alt="Run project"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=extra-adding-visual-effects>Extra: Adding visual effects</h2><p>For visual effect, we have prepared explosion particles when the missile hits and smoke particles coming out from behind the missile in the preliminary stage. Let&rsquo;s use these by adding code to the &ldquo;Missile.gd&rdquo; script to give the missile a more visually appealing performance.</p><p>After opening the &ldquo;Missile.gd&rdquo; script, add the line &ldquo;# Add&rdquo; to the code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># Add: See preloading Smoke.tscn (scene with only smoke particles)</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>smoke_scn</span> <span class=o>=</span> <span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Effect/Smoke.tscn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># Add: Preload reference to Explosion.tscn (scene with only explosion particles)</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>explosion_scn</span> <span class=o>=</span> <span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Effect/Explosion.tscn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>speed</span> <span class=o>=</span> <span class=mi>400</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>steering_force</span> <span class=o>=</span> <span class=mf>20.0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>velocity</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>acceleration</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>target</span> <span class=o>=</span> <span class=kt>null</span>
</span></span><span class=line><span class=cl><span class=c1># Add: count to space out the smoke</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>smoke_count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span></code></pre></div><br><p>Next, call the method that produces the smoke within the <code>_physics_process</code> method.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_physics_process</span><span class=p>(</span><span class=n>delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>=</span> <span class=n>transform</span><span class=o>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>speed</span>
</span></span><span class=line><span class=cl>	<span class=n>acceleration</span> <span class=o>+=</span> <span class=nf>steer</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>+=</span> <span class=n>acceleration</span> <span class=o>*</span> <span class=n>delta</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>=</span> <span class=n>velocity</span><span class=o>.</span><span class=nf>clamped</span><span class=p>(</span><span class=n>speed</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>position</span> <span class=o>+=</span> <span class=n>velocity</span> <span class=o>*</span> <span class=n>delta</span>
</span></span><span class=line><span class=cl>	<span class=n>rotation</span> <span class=o>=</span> <span class=n>velocity</span><span class=o>.</span><span class=nf>angle</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>  <span class=c1># Add the value of delta to smoke_count</span>
</span></span><span class=line><span class=cl>	<span class=n>smoke_count</span> <span class=o>+=</span> <span class=n>delta</span>
</span></span><span class=line><span class=cl>	<span class=c1># If smoke_count is greater than 0.05</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>smoke_count</span> <span class=o>&gt;</span> <span class=mf>0.05</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1># Set smoke_count back to 0</span>
</span></span><span class=line><span class=cl>		<span class=n>smoke_count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=c1># Call the method that spawns the smoke</span>
</span></span><span class=line><span class=cl>		<span class=nf>spawn_smoke</span><span class=p>()</span>
</span></span></code></pre></div><br><p>And let&rsquo;s define the last method <code>spawn_smoke</code> as follows. This code should be inserted under the <code>steer</code> method.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># spawn_smoke() method</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>spawn_smoke</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Instantiate a scene of smoke particles</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>smoke</span> <span class=o>=</span> <span class=n>smoke_scn</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add instance node to parent node (World)</span>
</span></span><span class=line><span class=cl>	<span class=nf>get_parent</span><span class=p>()</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>smoke</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Put smoke at current missile position</span>
</span></span><span class=line><span class=cl>	<span class=n>smoke</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>global_position</span>
</span></span><span class=line><span class=cl>	<span class=c1># Align the direction of the smoke with the direction of the current missile (doesn&#39;t make much sense)</span>
</span></span><span class=line><span class=cl>	<span class=n>smoke</span><span class=o>.</span><span class=n>rotation</span> <span class=o>=</span> <span class=n>global_rotation</span>
</span></span></code></pre></div><br><p>Next, we now define a method to generate explosion particles. Add it under the method <code>spawn_smoke</code> above.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># ÁàÜÁô∫„Åï„Åõ„Çã„É°„ÇΩ„ÉÉ„Éâ</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>explode</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Instantiate a scene of explosion particles</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>explosion</span> <span class=o>=</span> <span class=n>explosion_scn</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add instance node to parent node (World)</span>
</span></span><span class=line><span class=cl>	<span class=nf>get_parent</span><span class=p>()</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>explosion</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Place the explosion particle at the current missile position</span>
</span></span><span class=line><span class=cl>	<span class=n>explosion</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>global_position</span>
</span></span><span class=line><span class=cl>	<span class=c1># Align the orientation of the explosion particle with the orientation of the current missile (doesn&#39;t make much sense)</span>
</span></span><span class=line><span class=cl>	<span class=n>explosion</span><span class=o>.</span><span class=n>rotation</span> <span class=o>=</span> <span class=n>global_rotation</span>
</span></span></code></pre></div><br><p>Let&rsquo;s update the code to call the method <code>explode</code> at the three places with the following &ldquo;# Add&rdquo; comments.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Missile.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Missile_body_entered</span><span class=p>(</span><span class=n>body</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>body</span><span class=o>.</span><span class=n>name</span> <span class=o>==</span> <span class=s2>&#34;Player&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Missile hit &#34;</span><span class=p>,</span> <span class=n>body</span><span class=o>.</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>body</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;hit&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>body</span><span class=o>.</span><span class=nf>emit_signal</span><span class=p>(</span><span class=s2>&#34;player_hit&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>body</span><span class=o>.</span><span class=n>life</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>body</span><span class=o>.</span><span class=n>life</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nf>explode</span><span class=p>()</span> <span class=c1># Add</span>
</span></span><span class=line><span class=cl>			<span class=k>yield</span><span class=p>(</span><span class=n>body</span><span class=o>.</span><span class=n>anim_player</span><span class=p>,</span> <span class=s2>&#34;animation_finished&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>body</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Game Over!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>quit</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>explode</span><span class=p>()</span> <span class=c1># Add</span>
</span></span><span class=line><span class=cl>	<span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Timer_timeout</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nf>explode</span><span class=p>()</span> <span class=c1># Add</span>
</span></span><span class=line><span class=cl>	<span class=nf>queue_free</span><span class=p>()</span>
</span></span></code></pre></div><br><p>That&rsquo;s all for the update. Let&rsquo;s run the project one last time to see the direction we added.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img25.gif alt="Run project 2"></p><br><p>By the way, both smoke and explosion particles use the &ldquo;Particles2D&rdquo; class node. macOS seems to have some performance issues with this node. I&rsquo;m a macOS user, and it certainly caused a delay. You may be able to see it in the gif image above.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img26.png alt="Particles2D alert"></p><p>If you are using macOS, you can convert the root node (Particles2D class) to the &ldquo;CPUParticles2D&rdquo; class using &ldquo;Convert to CPUParticles2D&rdquo; from &ldquo;Paricles&rdquo; on the toolbar with the root node selected in the scene tree dock. It seems to be possible to convert it to the &ldquo;CPUParticles2D&rdquo; class.<br><img loading=lazy src=/images/tutorials/gd0008_homing_missiles/img27.png alt="convert to CPUParticles2D"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=conclusion>Conclusion</h2><p>In this tutorial, we created a homing missile in top-down shooting. Let&rsquo;s summarize the key points in creating it.</p><ul><li>The missile scene should be programmed to fly by itself as soon as an instance is added.</li><li>To reproduce the tracking motion of the missile, sequentially perform the following every frame in the physics process.<ol><li>Multiply the direction vector to the target (the &ldquo;Player&rdquo; in this tutorial) by the speed to obtain the ideal velocity.</li><li>Normalize the vector of the difference between the ideal velocity and the actual velocity to find the direction to steer.</li><li>Multiply the direction to steer by the force to steer predefined by the property to obtain the speed to steer.</li><li>Add the velocity to steer to the current acceleration.</li><li>Add the updated acceleration to the current velocity.</li></ol></li><li>When creating an instance of a missile scene, make it a child of an object that does not move, such as its parent node (&ldquo;World&rdquo; in this tutorial), rather than of an object that rotates or moves (&ldquo;Enemy&rdquo; in this tutorial), so that the missile will fly correctly.</li><li>To reduce memory consumption, use Timer&rsquo;s signal so that the missile instance is released at timeout.</li></ul><br><hr><h2 id=links>Links</h2><p>The YouTube videos and articles on KidsCanCode were very helpful in preparing this tutorial. I would like to take this opportunity to thank them. For a better understanding, we recommend that you also view those contents.</p><ul><li><a href=https://docs.godotengine.org/en/stable/tutorials/math/matrices_and_transforms.html target=_blank>Godot Docs: Matrices and transforms</a></li><li><a href="https://www.youtube.com/watch?v=pRYMy5uQSpo" target=_blank>YouTube: Godot Recipes: Homing Missiles</a></li><li><a href="https://www.youtube.com/watch?v=KAUP4nlJyz0" target=_blank>YouTube: Godot 3.0: Top-down Tank Battle - Part 10: Homing Missiles</a></li><li><a href=http://kidscancode.org/godot_recipes/ai/homing_missile/ target=_blank>KidsCanCode: HOMING MISSILE</a></li></ul><br><hr></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Homing Missiles in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Homing%20Missiles%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0008_homing_missiles%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cTopDown%2cShooter"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Homing Missiles in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0008_homing_missiles%2f&title=%f0%9f%a4%96%20Homing%20Missiles%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Homing Missiles in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0008_homing_missiles%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/topdown/>TopDown</a></li><li><a href=https://www.peanuts-code.com/en/tags/shooter/>Shooter</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/><span class=title>¬´ Prev</span><br><span>ü§ñ Connecting Matching Colors Puzzle Game in Godot3</span>
</a><a class=next href=https://www.peanuts-code.com/en/tutorials/gd0007_bullethell/><span class=title>Next ¬ª</span><br><span>ü§ñ Bullet Hell in Godot3</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/en/>Peanuts Code</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>