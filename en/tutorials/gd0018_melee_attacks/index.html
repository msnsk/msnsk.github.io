<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3 | Peanuts Code</title>
<meta name=keywords content="GameDev,GodotEngine,Godot3,2D,MeleeAttack,Collision,Animation"><meta name=description content="This article introduces a method for implementing simple hit detection for melee attacks in 2D games. This is a commonly used method where the object to attack (e.g., player character) has a collision shape (called &ldquo;Hit Box&rdquo;) that is only active during the attack, and the object to be attacked (e.g., enemy character, destructible barrels, crates, grass, etc.) has a collision shape (called &ldquo;Hurt Box). The hit judgment of the attack can be implemented by enabling/disabling the Hit Box and Hurt Box, and changing their size and position in accordance with the animation of the attack. This is relatively easy to implement, so let&rsquo;s get started. Environment Godot version: 3.5.1 Computer OS version: macOS 11.6.5 Basic Articles You may also find the following articles useful. Downloading Godot Project Manager of Godot Add Actions to Input Map First, go to &ldquo;Project&rdquo; > &ldquo;Project Settings&rdquo; > &ldquo;Input Map&rdquo; tab and add the following actions: right: D key left: A key down: S key up: W key attack: Space bar Create a Player scene Create a scene for the player character. Create the"><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/en/tutorials/gd0018_melee_attacks/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0018_melee_attacks/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0018_melee_attacks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3"><meta property="og:description" content="This article introduces a method for implementing simple hit detection for melee attacks in 2D games. This is a commonly used method where the object to attack (e.g., player character) has a collision shape (called &ldquo;Hit Box&rdquo;) that is only active during the attack, and the object to be attacked (e.g., enemy character, destructible barrels, crates, grass, etc.) has a collision shape (called &ldquo;Hurt Box). The hit judgment of the attack can be implemented by enabling/disabling the Hit Box and Hurt Box, and changing their size and position in accordance with the animation of the attack. This is relatively easy to implement, so let&rsquo;s get started. Environment Godot version: 3.5.1 Computer OS version: macOS 11.6.5 Basic Articles You may also find the following articles useful. Downloading Godot Project Manager of Godot Add Actions to Input Map First, go to &ldquo;Project&rdquo; > &ldquo;Project Settings&rdquo; > &ldquo;Input Map&rdquo; tab and add the following actions: right: D key left: A key down: S key up: W key attack: Space bar Create a Player scene Create a scene for the player character. Create the"><meta property="og:type" content="article"><meta property="og:url" content="https://www.peanuts-code.com/en/tutorials/gd0018_melee_attacks/"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0018_melee_attacks/img28.gif"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-10-05T02:55:00+09:00"><meta property="article:modified_time" content="2022-10-05T02:55:00+09:00"><meta property="og:site_name" content="Peanuts Code ğŸ¥œ"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0018_melee_attacks/img28.gif"><meta name=twitter:title content="ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3"><meta name=twitter:description content="This article introduces a method for implementing simple hit detection for melee attacks in 2D games. This is a commonly used method where the object to attack (e.g., player character) has a collision shape (called &ldquo;Hit Box&rdquo;) that is only active during the attack, and the object to be attacked (e.g., enemy character, destructible barrels, crates, grass, etc.) has a collision shape (called &ldquo;Hurt Box). The hit judgment of the attack can be implemented by enabling/disabling the Hit Box and Hurt Box, and changing their size and position in accordance with the animation of the attack. This is relatively easy to implement, so let&rsquo;s get started. Environment Godot version: 3.5.1 Computer OS version: macOS 11.6.5 Basic Articles You may also find the following articles useful. Downloading Godot Project Manager of Godot Add Actions to Input Map First, go to &ldquo;Project&rdquo; > &ldquo;Project Settings&rdquo; > &ldquo;Input Map&rdquo; tab and add the following actions: right: D key left: A key down: S key up: W key attack: Space bar Create a Player scene Create a scene for the player character. Create the"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ğŸ¤– Tutorials","item":"https://www.peanuts-code.com/en/tutorials/"},{"@type":"ListItem","position":2,"name":"ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3","item":"https://www.peanuts-code.com/en/tutorials/gd0018_melee_attacks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3","name":"ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3","description":"This article introduces a method for implementing simple hit detection for melee attacks in 2D games. This is a commonly used method where the object to attack (e.g., player character) has a collision shape (called \u0026ldquo;Hit Box\u0026rdquo;) that is only active during the attack, and the object to be attacked (e.g., enemy character, destructible barrels, crates, grass, etc.) has a collision shape (called \u0026ldquo;Hurt Box). The hit judgment of the attack can be implemented by enabling/disabling the Hit Box and Hurt Box, and changing their size and position in accordance with the animation of the attack. This is relatively easy to implement, so let\u0026rsquo;s get started. Environment Godot version: 3.5.1 Computer OS version: macOS 11.6.5 Basic Articles You may also find the following articles useful. Downloading Godot Project Manager of Godot Add Actions to Input Map First, go to \u0026ldquo;Project\u0026rdquo; \u0026gt; \u0026ldquo;Project Settings\u0026rdquo; \u0026gt; \u0026ldquo;Input Map\u0026rdquo; tab and add the following actions: right: D key left: A key down: S key up: W key attack: Space bar Create a Player scene Create a scene for the player character. Create the","keywords":["GameDev","GodotEngine","Godot3","2D","MeleeAttack","Collision","Animation"],"articleBody":"This article introduces a method for implementing simple hit detection for melee attacks in 2D games.\nThis is a commonly used method where the object to attack (e.g., player character) has a collision shape (called â€œHit Boxâ€) that is only active during the attack, and the object to be attacked (e.g., enemy character, destructible barrels, crates, grass, etc.) has a collision shape (called â€œHurt Box). The hit judgment of the attack can be implemented by enabling/disabling the Hit Box and Hurt Box, and changing their size and position in accordance with the animation of the attack.\nThis is relatively easy to implement, so letâ€™s get started.\nEnvironment Godot version: 3.5.1\nComputer OS version: macOS 11.6.5\nBasic Articles You may also find the following articles useful.\nDownloading Godot Project Manager of Godot Add Actions to Input Map First, go to â€œProjectâ€ \u003e â€œProject Settingsâ€ \u003e â€œInput Mapâ€ tab and add the following actions:\nright: D key left: A key down: S key up: W key attack: Space bar Create a Player scene Create a scene for the player character. Create the following scene tree by setting the root node to â€œKinematicBody2Dâ€ and adding the necessary nodes. Player (KinematicBody2D) Sprite (KinematicBody2D) BodyCollisionShape (CollisionShape2D) HitBox (Area2D) HitBoxCollisionShape (CollisionShape2D) AnimationPlayer\nSave this scene as a file named â€œPlayer.tscnâ€. Edit nodes in the Player scene Sprite node For the sprite sheet containing the player characterâ€™s melee attack animations, I downloaded and used the Pixel Art Dwarf Sprites from itch.io . In particular, we will use lines 3 to 5 as the animation for melee attacks.\nDrag the downloaded sprite sheet to the file system dock and import it. Since the image will appear a little blurry as it is, select the file, apply the 2D Pixel preset from the Import dock, and reimport it. Apply the imported sprite sheet to the â€œTextureâ€ property in the inspector dock.\nSince this is a sprite sheet with 8 frames for each of the vertical and horizontal sides, set the values of â€œAnimationâ€ \u003e â€œHframesâ€/â€œVframesâ€ to 8 respectively.\nIt is OK if a texture for one frame appears on the 2D workspace.\nBodyCollisionShape (CollisionShape2D) node The parent â€œPlayerâ€ root node is a KinematicBody2D class, so it is necessary to set up a collision shape. To distinguish it from the Hit Box collision shape we will create later, we rename it â€œBodyCollisionShapeâ€.\nApply the â€œRectangleShapeâ€ resource to the â€œShapeâ€ property.\nIn the 2D workspace, match the collision shape to the body part of the spriteâ€™s texture.\nIf the collision shape is visually distracting, you can set the node to be hidden in the scene dock if necessary.\nHitBox (Area2D) node A hit box is a collision shape used to determine when a character is hit by a melee attack, and since it is called a hit box, a rectangular collision shape is generally used. for the â€œArea2Dâ€ and its child node â€œCollisionShape2Dâ€.\nThe parent â€œHitBoxâ€ node does not need to be edited, but the signals from this node will be used when scripting later.\nHitBoxCollisionShape (CollisonShape2D) node To distinguish it from the â€œBodyCollisionShapeâ€ node, it is named â€œHitBoxCollisionShapeâ€.\nApply a new â€œRectangleShapeâ€ resource to the â€œShapeâ€ property and set a rectangle collision shape. The â€œExtentsâ€ property of â€œRectangleShapeâ€ can be left as default at this point, since the size and position will be changed later in the animation during the attack.\nSince we want to enable collision detection only when the player character attacks, the â€œDisabledâ€ property should be set to ON to disable collisions.\nAnimationPlayer nodeï¼ˆCreate animationsï¼‰ To create melee attack animations with the â€œAnimationPlayerâ€ node.\nSelect the â€œAnimationPlayerâ€ node in the scene dock. Open the animation panel. Create a new animation and name it â€œright_attack1â€.\n*It is assumed that we will create attack1, 2, and 3 for each of the left and right directions. First, make the following settings. Automatic playback on loading: Off Animation length (seconds): 0.6 Looping animation: Off Add a track for the â€œFrame Coordsâ€ property of the â€œSpriteâ€ node: at 0.1 second intervals, add a texture for the third row of the sprite sheet, starting from the left end to the sixth row. Specifically, (0, 2), (1, 2), (2, 2), (3, 2), (4, 2), (5, 2), and only the x value (column of the sprite sheet) is changed from 0 to 5 while the y value (row of the sprite sheet) remains the same.\nChange the â€œInterpolationâ€ type of this track to â€œNearestâ€.\nAdd a track with the â€œDisabledâ€ property of â€œBodyCollisionShapeâ€. Turn on the â€œDisabledâ€ property of â€œBodyCollisionShapeâ€ at the 0.3 second position in the timeline and turn it back off at the 0.5 second position in order to prevent enemies from taking damage when the player character is attacking them.\nAdd a track for the â€œDisabledâ€ property of â€œHitBoxCollisionShapeâ€. In reverse order of the previous step, turn off the â€œDisabledâ€ property at the 0.3 second position in the timeline and turn it back on at the 0.5 second position. This will enable the Hit Box hit detection only during the very animation frame of the player characterâ€™s attack animation when the axe is being swung down. Continue by adding the â€œPositionâ€ property of the â€œHitBoxCollisionShapeâ€ and the â€œShapeâ€ \u003e â€œExtentsâ€ property track. Adjust the size and position of the collision shape of the HitBox to match the animation of the axe swinging down at 0.3 seconds in the timeline. The â€œPositionâ€ value was set to (7.5, -2.25) and the â€œExtentsâ€ value was set to (9.5, 12.25) (slightly larger than the axe track on the texture).\nThe final â€œright_attack1â€ looked like this:\nSprite node frame_coords property Time: 0 / Value: (0, 2) / Easing: 1.00 Time: 0.1 / Value: (1, 2) / Easing: 1.00 Time: 0.2 / Value: (2, 2) / Easing: 1.00 Time: 0.3 / Value: (3, 2) / Easing: 1.00 Time: 0.4 / Value: (4, 2) / Easing: 1.00 Time: 0.5 / Value: (5, 2) / Easing: 1.00 BodyCollisionShape node disabled property Time: 0.1 / Value: On / Easing: 1.00 HitBoxCollisionShape node disabled property Time: 0.3 / Value; Off / Easing: 1.00 Time: 0.5 / Value; On / Easing: 1.00 position property Time: 0.3 / Value: (7.5, -2.25) / Easing: 1.00 Time: 0.4 / Value: (4, 4) / Easing: 1.00 shape:extents property Time: 0.3 / Value: (9.5, 12.25) / Easing: 1.00 Time: 0.4 / Value: (6, 6) / Easing: 1.00 The following GIF image shows the â€œright_attack1â€ animation we just created, played back at 0.5x speed. You can see that the HitBox collision shape is activated (green) only at the timing when the axe is swung down.\nA similar procedure was used to create the â€œright_attack2â€ animation. The texture of line 4 of the sprite sheet was used. During 0.1 ~ 0.4 seconds of the timeline, the â€œPositionâ€ and â€œExtentsâ€ of â€œHitBoxCollisionShapeâ€ were changed slightly every 0.1 second.\nIf you play â€œright_attack2â€ at 0.5x speed, it will look like this.\nIn addition, an animation of â€œright_attack3â€ was created. This one used the texture on line 5 of the sprite sheet. The texture is only two frames long, but the two are repeated four times. The â€œSpriteâ€ nodeâ€™s â€œPositionâ€ property track was added to make the animation move forward a little and then back.\nIf â€œright_attack3â€ is played back at 0.5x speed, the result is as follows.\nWhen creating a left-facing animation, it is easier to work with the Offset \u003e Flip H property of the Sprite node turned on. It is easy to duplicate a previously created right-facing melee attack animation and adjust it for a left-facing animation.\nAttach a script to the Player node To control the player characterâ€™s movement and melee attacks, attach a script to the â€œPlayerâ€ root node and code it like below:\n###Player.gd### extends KinematicBody2D ## Movement speed var speed = 80.0 # Movement speed var velocity: Vector2 # Number of attack animations (1 ~ 3) var attack_num = 1 # Referencing a Sprite node onready var sprite = $Sprite # Reference to AnimationPlayer node onready var anim_player = $AnimationPlayer # Methods to control character movement inputs func move(): velocity = Vector2() if Input.is_action_pressed(\"right\"): velocity.x += 1 sprite.flip_h = false if Input.is_action_pressed(\"left\"): velocity.x -= 1 sprite.flip_h = true if Input.is_action_pressed(\"down\"): velocity.y += 1 if Input.is_action_pressed(\"up\"): velocity.y -= 1 velocity = velocity.normalized() * speed # Play idle animation if velocity is 0 if velocity.length() == 0: play(\"idle\") # Play run animation if velocity is greater than 0 if velocity.length() \u003e 0: anim_player.play(\"run\") # Built-in physics process function func _physics_process(_delta): move() # reflect inputs related to movement as character's motion velocity = move_and_slide(velocity) # Built-in callback function for input func _unhandled_input(event): # if spacebar is pressed if event.is_action_pressed(\"attack\"): # stop physics process to prevent movement set_physics_process(false) # if sprite is flipped left/right (facing left) if sprite.flip_h: # Play left-facing attack animation anim_player.play(\"left_attack\" + str(attack_num)) # if sprite is not flipped (right-facing) else: # Play the right-facing attack animation anim_player.play(\"right_attack\" + str(attack_num)) # If current attack animation number is less than 3, add 1 to the number if attack_num \u003c 3: attack_num += 1 # Reset the number to 1 if the current attack animation number is 3 or more else: attack_num = 1 Connect the â€œanimation_finishedâ€ signal of the â€œAnimationPlayerâ€ node to the script and edit the auto-generated method as follows\nfunc _on_AnimationPlayer_animation_finished(anim_name): # Resume the physical process if the animation name contains \"attack\" if \"attack\" in anim_name: set_physics_process(true) Letâ€™s run the â€œPlayerâ€ scene.\nIf you enable the setting to display collision shapes in the â€œDebugâ€ menu in advance, it will be easier to see the changes in collision shapes during the animation.\nThe movement of the player character will look like the following GIF image.\nCreate a Enemy scene Prepare an â€œEnemyâ€ scene to check the hit detection of the player characterâ€™s melee attacks. Since this is similar to the â€œPlayerâ€ scene, I will briefly describe it here.\nThe scene tree is as follows.\nEnemy (KinematicBody2D) Sprite BodyCollisionShape (CollisionShape2D) AnimationPlayer ReviveTimer (Timer) Edit nodes in the Enemy scene Sprite node We will use the assets from itch.io - mystic woods for the sprite textures of the enemy characters. Apply the â€œslime.pngâ€ sprite sheet from the downloaded assets to the â€œTextureâ€ property of the â€œSpriteâ€ node.\nBodyCollisionShape node For the â€œShapeâ€ property, apply â€œCircleShape2Dâ€ to make the collision shape slightly smaller than the sprite. In this tutorial, this will be the so-called Hurt Box. When the player characterâ€™s hit box overlaps this collision shape, the hit detection becomes effective. This control will be done later in the script.\nAnimationPlayer node In the Animation panel, prepare the following four animations. All of them are set to change to the texture of the next frame on the sprite sheet every 0.1 second.\njump: Animation of jumping when waiting (automatically played when loading) hurt: Animation for when the character takes damage. die: Animation for dying when life reaches 0. Turn on â€œDisabledâ€ for â€œBodyCollisionShape revive: Animation when the character comes back to life after a certain period of time after death. Turn off â€œDisabledâ€ of â€œBodyCollisionShape RevieTimer node Enable the â€œOne Shotâ€ property.\nAttach a script to the Enemy node Attach a script to the â€œEnemyâ€ root node and code it like below.\n###Enemy.gd### extends KinematicBody2D # Maximum value of life export (int) var max_life = 3 # Current life var life: int = max_life # Variable to refer to Player instance var player: KinematicBody2D # Reference to the Sprite node onready var sprite = $Sprite # Reference to the AnimationPlayer node onready var anim_player = $AnimationPlayer # ReviveTimer node reference onready var revive_timer = $ReviveTimer func _process(_delta): # flip the Sprite's orientation or not depending on the player's position sprite.flip_h = global_position.x \u003e player.global_position.x # Damage methods func hurt(): # Reduce life by 1 life -= 1 # Play the animation hurt anim_player.play(\"hurt\") In addition, connect the â€œanimation_finishedâ€ signal of â€œAnimationPlayerâ€ and the â€œtimeoutâ€ signal of â€œReviveTimerâ€ to the script and edit the respective generated methods as follows:\n###Enemy.gd### # Method called by AnimationPlayer's signal when animation is finished func _on_AnimationPlayer_animation_finished(anim_name): # If the finished animation is hurt if anim_name == \"hurt\": # Return to jump animation if life is greater than 0 if life \u003e 0: anim_player.play(\"jump\") # If life is less than 0, play die animation if life \u003c= 0: play(\"die\") # Start ReviveTimer if the animation that ended is die if anim_name == \"die\": revive_timer.start() # If the animation that ended is \"revive\" if anim_name == \"revive\": anim_player.play(\"jump\") # Method called on ReviveTimer timeout signal func _on_ReviveTimer_timeout(): # Play the revive animation anim_player.play(\"revive\") # Return life to its maximum value life = max_life Add a HitBox signal to the Playerâ€™s script Make the â€œPlayer.gdâ€ script call the hurt method of â€œEnemy.gdâ€ by the â€œHitBoxâ€ signal when it is hit by a melee attack.\nReturn to the â€œPlayer.tscnâ€ scene and connect the â€œbody_entered(body: Node)â€ signal of the â€œHitBoxâ€ node to the â€œPlayer.gdâ€ script.\n###Player.gd### # Omitted # Method called with a signal when the physical body is hit by the HitBox func _on_HitBox_body_entered(body): # If the name of the physical body is \"Enemy\", call its hurt method. if body.name == \"Enemy\": body.hurt() Create a World scene Finally, create a â€œWorldâ€ scene and add a â€œPlayerâ€ scene instance and an â€œEnemyâ€ scene instance to it.\nThe scene tree is simply as follows.\nWorld (Node2D) Enemy (instance of Enemy.tscn) Player (instance of Player.tscn) Place each instance appropriately on the 2D workspace.\nAttach a script to the World scene Attach a script to the World scene and code it as follows. The purpose is to pass a reference to the â€œPlayerâ€ instance from the â€œWorldâ€ root node to the variable player in the â€œEnemyâ€ node declared in â€œEnemy.gdâ€.\n###World.gd### extends Node2D onready var player = $Player onready var enemy = $Enemy func _ready(): enemy.player = self.player Run the project Finally, run the project to check the behavior of the hit judgment for melee attacks.\nYou can see that when the collision shape of the Playerâ€™s HitBox node overlaps with the Enemyâ€™s BodyCollisionShape (Hurt Box), the hit detection is activated and the Enemyâ€™s hurt animation is played.\nConclusion In this article, I introduced a simple hit detection method for melee attacks in 2D games, and the implementation of hit detection using Hit Boxes and Hurt Boxes is relatively easy to understand and can be applied to various games.\nIncidentally, in actual games, it is often the case that separate Hit Boxes and Hurt Boxes are set up for each body part, and more complex mechanisms are created by combining these Hit Boxes and Hurt Boxes.\nFor example, in a fighting game, if the attacker has several Hit Boxes for hands, feet, head, etc., and the receiver has Hurt Boxes for the upper, middle, and lower positions, the damage can be changed in complex ways depending on the combination of each Hit Box and Hurt Box.\nIn a zombie FPS game, you could have different Hurt Boxes for the zombieâ€™s head and body, so that shooting at the head would kill the zombie in one shot, but not the other parts of the body.\nAnyway, I hope this article has been of some help.\nReferences In preparing this article, we found the following links to be very helpful. We hope you will find them useful as well.\nIntroduction to the animation features KidsCanCode - MELEE ATTACKS YouTube - How to Make Melee Combat in Godot YouTube - Make an Action RPG in Godot 3.2 (P11 | Melee attacks with Hurtboxes and Hitboxes) itch.io - Pixel Art Dwarf Sprites *Resource\nitch.io - mystic woods *Resource\n","wordCount":"2611","inLanguage":"en","image":"https://www.peanuts-code.com/images/tutorials/gd0018_melee_attacks/img28.gif","datePublished":"2022-10-05T02:55:00+09:00","dateModified":"2022-10-05T02:55:00+09:00","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/en/tutorials/gd0018_melee_attacks/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/en/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/ja/ title=Japanese aria-label=ğŸ‡¯ğŸ‡µæ—¥æœ¬èª>ğŸ‡¯ğŸ‡µæ—¥æœ¬èª</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/en/ title=Home><span>Home</span></a></li><li><a href=https://www.peanuts-code.com/en/portfolio/ title=Works><span>Works</span></a></li><li><a href=https://www.peanuts-code.com/en/posts/ title=Blogs><span>Blogs</span></a></li><li><a href=https://www.peanuts-code.com/en/tutorials/ title=Tutorials><span>Tutorials</span></a></li><li><a href=https://www.peanuts-code.com/en/about/ title=About><span>About</span></a></li><li><a href=https://www.peanuts-code.com/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/en/>Home</a>&nbsp;Â»&nbsp;<a href=https://www.peanuts-code.com/en/tutorials/>ğŸ¤– Tutorials</a></div><h1 class="post-title entry-hint-parent">ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3</h1><div class=post-meta><span title='2022-10-05 02:55:00 +0900 +0900'>2022-10-05</span>&nbsp;Â·&nbsp;6 min&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/ja/tutorials/gd0018_melee_attacks/>ğŸ‡¯ğŸ‡µæ—¥æœ¬èª</a></li></ul></div><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%202D%20Hit%20Detection%20for%20Melee%20Attacks%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0018_melee_attacks%2f&amp;hashtags=GameDev%2cGodotEngine%2cGodot3%2c2D%2cMeleeAttack%2cCollision%2cAnimation"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0018_melee_attacks%2f&title=%f0%9f%a4%96%202D%20Hit%20Detection%20for%20Melee%20Attacks%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0018_melee_attacks%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/meleeattack/>MeleeAttack</a></li><li><a href=https://www.peanuts-code.com/en/tags/collision/>Collision</a></li><li><a href=https://www.peanuts-code.com/en/tags/animation/>Animation</a></li></ul></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0018_melee_attacks/img28.gif alt="2D Melee Attacks in Godot3"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#add-actions-to-input-map>Add Actions to Input Map</a></li><li><a href=#create-a-player-scene>Create a Player scene</a></li><li><a href=#edit-nodes-in-the-player-scene>Edit nodes in the Player scene</a><ul><li><a href=#sprite-node>Sprite node</a></li><li><a href=#bodycollisionshape-collisionshape2d-node>BodyCollisionShape (CollisionShape2D) node</a></li><li><a href=#hitbox-area2d-node>HitBox (Area2D) node</a></li><li><a href=#hitboxcollisionshape-collisonshape2d-node>HitBoxCollisionShape (CollisonShape2D) node</a></li><li><a href=#animationplayer-nodecreate-animations>AnimationPlayer nodeï¼ˆCreate animationsï¼‰</a></li></ul></li><li><a href=#attach-a-script-to-the-player-node>Attach a script to the Player node</a></li><li><a href=#create-a-enemy-scene>Create a Enemy scene</a></li><li><a href=#edit-nodes-in-the-enemy-scene>Edit nodes in the Enemy scene</a><ul><li><a href=#sprite-node-1>Sprite node</a></li><li><a href=#bodycollisionshape-node>BodyCollisionShape node</a></li><li><a href=#animationplayer-node>AnimationPlayer node</a></li><li><a href=#revietimer-node>RevieTimer node</a></li></ul></li><li><a href=#attach-a-script-to-the-enemy-node>Attach a script to the Enemy node</a></li><li><a href=#add-a-hitbox-signal-to-the-players-script>Add a HitBox signal to the Player&rsquo;s script</a></li><li><a href=#create-a-world-scene>Create a World scene</a></li><li><a href=#attach-a-script-to-the-world-scene>Attach a script to the World scene</a></li><li><a href=#run-the-project>Run the project</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><p>This article introduces a method for implementing simple hit detection for melee attacks in 2D games.</p><p>This is a commonly used method where the object to attack (e.g., player character) has a collision shape (called &ldquo;Hit Box&rdquo;) that is only active during the attack, and the object to be attacked (e.g., enemy character, destructible barrels, crates, grass, etc.) has a collision shape (called &ldquo;Hurt Box). The hit judgment of the attack can be implemented by enabling/disabling the Hit Box and Hurt Box, and changing their size and position in accordance with the animation of the attack.</p><p>This is relatively easy to implement, so let&rsquo;s get started.</p><blockquote><p><strong><span style=color:salmon>Environment</span></strong><br><em>Godot version: <strong>3.5.1</strong></em><br><em>Computer OS version: <strong>macOS 11.6.5</strong></em></p></blockquote><blockquote><p><strong><span style=color:salmon>Basic Articles</span></strong><br><em>You may also find the following articles useful.</em><br><em><a href=https://www.peanuts-code.com/en/tutorials/gd0001_download/>Downloading Godot</a></em><br><em><a href=https://www.peanuts-code.com/en/tutorials/gd0002_project_manager/>Project Manager of Godot</a></em><br><br></p></blockquote><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=add-actions-to-input-map>Add Actions to Input Map</h2><p>First, go to &ldquo;Project&rdquo; > &ldquo;Project Settings&rdquo; > &ldquo;Input Map&rdquo; tab and add the following actions:</p><ul><li>right: D key</li><li>left: A key</li><li>down: S key</li><li>up: W key</li><li>attack: Space bar</li></ul><p><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img1.png alt="Input Map"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=create-a-player-scene>Create a Player scene</h2><ol><li>Create a scene for the player character. Create the following scene tree by setting the root node to &ldquo;KinematicBody2D&rdquo; and adding the necessary nodes.<ul><li>Player (KinematicBody2D)<ul><li>Sprite (KinematicBody2D)</li><li>BodyCollisionShape (CollisionShape2D)</li><li>HitBox (Area2D)<ul><li>HitBoxCollisionShape (CollisionShape2D)</li></ul></li><li>AnimationPlayer<br>Save this scene as a file named &ldquo;Player.tscn&rdquo;.</li></ul></li></ul></li></ol><p><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img2.png alt="Player scene tree"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=edit-nodes-in-the-player-scene>Edit nodes in the Player scene</h2><h3 id=sprite-node>Sprite node</h3><p>For the sprite sheet containing the player character&rsquo;s melee attack animations, I downloaded and used the <a href=https://elthen.itch.io/pixel-art-dwarf-sprites target=_blank>Pixel Art Dwarf Sprites</a>
from <a href=https://elthen.itch.io/pixel-art-dwarf-sprites target=_blank>itch.io</a>
. In particular, we will use lines 3 to 5 as the animation for melee attacks.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img3.png alt="Sprite sheet"></p><ol><li>Drag the downloaded sprite sheet to the file system dock and import it. Since the image will appear a little blurry as it is, select the file, apply the 2D Pixel preset from the Import dock, and reimport it.</li><li>Apply the imported sprite sheet to the &ldquo;Texture&rdquo; property in the inspector dock.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img4.png alt="Sprite - Texture"></li><li>Since this is a sprite sheet with 8 frames for each of the vertical and horizontal sides, set the values of &ldquo;Animation&rdquo; > &ldquo;Hframes&rdquo;/&ldquo;Vframes&rdquo; to 8 respectively.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img5.png alt="Sprite - Animation - Hframes / Vframes"></li></ol><p>It is OK if a texture for one frame appears on the 2D workspace.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img6.png alt="Sprite - 2D workspace"></p><br><h3 id=bodycollisionshape-collisionshape2d-node>BodyCollisionShape (CollisionShape2D) node</h3><p>The parent &ldquo;Player&rdquo; root node is a KinematicBody2D class, so it is necessary to set up a collision shape. To distinguish it from the Hit Box collision shape we will create later, we rename it &ldquo;BodyCollisionShape&rdquo;.</p><ol><li>Apply the &ldquo;RectangleShape&rdquo; resource to the &ldquo;Shape&rdquo; property.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img7.png alt="BodyCollisionShape - Shape"></li><li>In the 2D workspace, match the collision shape to the body part of the sprite&rsquo;s texture.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img8.png alt="BodyCollisionShape - 2D workspace"></li><li>If the collision shape is visually distracting, you can set the node to be hidden in the scene dock if necessary.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img9.png alt="BodyCollisionShape - hide"></li></ol><br><h3 id=hitbox-area2d-node>HitBox (Area2D) node</h3><p>A hit box is a collision shape used to determine when a character is hit by a melee attack, and since it is called a hit box, a rectangular collision shape is generally used. for the &ldquo;Area2D&rdquo; and its child node &ldquo;CollisionShape2D&rdquo;.</p><p>The parent &ldquo;HitBox&rdquo; node does not need to be edited, but the signals from this node will be used when scripting later.</p><br><h3 id=hitboxcollisionshape-collisonshape2d-node>HitBoxCollisionShape (CollisonShape2D) node</h3><p>To distinguish it from the &ldquo;BodyCollisionShape&rdquo; node, it is named &ldquo;HitBoxCollisionShape&rdquo;.</p><ol><li>Apply a new &ldquo;RectangleShape&rdquo; resource to the &ldquo;Shape&rdquo; property and set a rectangle collision shape. The &ldquo;Extents&rdquo; property of &ldquo;RectangleShape&rdquo; can be left as default at this point, since the size and position will be changed later in the animation during the attack.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img10.png alt="HitBoxCollisionShape - Shape"></li><li>Since we want to enable collision detection only when the player character attacks, the &ldquo;Disabled&rdquo; property should be set to <strong>ON</strong> to disable collisions.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img11.png alt="HitBoxCollisionShape - Disabled"></li></ol><br><h3 id=animationplayer-nodecreate-animations>AnimationPlayer nodeï¼ˆCreate animationsï¼‰</h3><p>To create melee attack animations with the &ldquo;AnimationPlayer&rdquo; node.</p><ol><li>Select the &ldquo;AnimationPlayer&rdquo; node in the scene dock.</li><li>Open the animation panel.</li><li>Create a new animation and name it &ldquo;right_attack1&rdquo;.<br>*It is assumed that we will create attack1, 2, and 3 for each of the left and right directions.</li><li>First, make the following settings.<ul><li>Automatic playback on loading: Off</li><li>Animation length (seconds): 0.6</li><li>Looping animation: Off</li></ul></li><li>Add a track for the &ldquo;Frame Coords&rdquo; property of the &ldquo;Sprite&rdquo; node: at 0.1 second intervals, add a texture for the third row of the sprite sheet, starting from the left end to the sixth row. Specifically, (0, 2), (1, 2), (2, 2), (3, 2), (4, 2), (5, 2), and only the x value (column of the sprite sheet) is changed from 0 to 5 while the y value (row of the sprite sheet) remains the same.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img12.png alt="AnimationPlayer - Animation pannel - Sprite node frame_coords track - adding value"></li><li>Change the &ldquo;Interpolation&rdquo; type of this track to &ldquo;Nearest&rdquo;.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img13.png alt="AnimationPlayer - Animation pannel - Sprite node frame_coords track - Interpolation"></li><li>Add a track with the &ldquo;Disabled&rdquo; property of &ldquo;BodyCollisionShape&rdquo;. Turn on the &ldquo;Disabled&rdquo; property of &ldquo;BodyCollisionShape&rdquo; at the 0.3 second position in the timeline and turn it back off at the 0.5 second position in order to prevent enemies from taking damage when the player character is attacking them.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img14.png alt="AnimationPlayer - Animation pannel - BodyCollisionShape track - adding value"></li><li>Add a track for the &ldquo;Disabled&rdquo; property of &ldquo;HitBoxCollisionShape&rdquo;. In reverse order of the previous step, turn off the &ldquo;Disabled&rdquo; property at the 0.3 second position in the timeline and turn it back on at the 0.5 second position. This will enable the Hit Box hit detection only during the very animation frame of the player character&rsquo;s attack animation when the axe is being swung down.</li><li>Continue by adding the &ldquo;Position&rdquo; property of the &ldquo;HitBoxCollisionShape&rdquo; and the &ldquo;Shape&rdquo; > &ldquo;Extents&rdquo; property track. Adjust the size and position of the collision shape of the HitBox to match the animation of the axe swinging down at 0.3 seconds in the timeline. The &ldquo;Position&rdquo; value was set to (7.5, -2.25) and the &ldquo;Extents&rdquo; value was set to (9.5, 12.25) (slightly larger than the axe track on the texture).<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img15.png alt="AnimationPlayer - 2D workspace"></li></ol><p>The final &ldquo;right_attack1&rdquo; looked like this:<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img16.png alt="AnimationPlayer - Animation pannel - right_attack1"></p><ul><li>Sprite node<ul><li>frame_coords property<ul><li>Time: 0 / Value: (0, 2) / Easing: 1.00</li><li>Time: 0.1 / Value: (1, 2) / Easing: 1.00</li><li>Time: 0.2 / Value: (2, 2) / Easing: 1.00</li><li>Time: 0.3 / Value: (3, 2) / Easing: 1.00</li><li>Time: 0.4 / Value: (4, 2) / Easing: 1.00</li><li>Time: 0.5 / Value: (5, 2) / Easing: 1.00</li></ul></li></ul></li><li>BodyCollisionShape node<ul><li>disabled property<ul><li>Time: 0.1 / Value: On / Easing: 1.00</li></ul></li></ul></li><li>HitBoxCollisionShape node<ul><li>disabled property<ul><li>Time: 0.3 / Value; Off / Easing: 1.00</li><li>Time: 0.5 / Value; On / Easing: 1.00</li></ul></li><li>position property<ul><li>Time: 0.3 / Value: (7.5, -2.25) / Easing: 1.00</li><li>Time: 0.4 / Value: (4, 4) / Easing: 1.00</li></ul></li><li>shape:extents property<ul><li>Time: 0.3 / Value: (9.5, 12.25) / Easing: 1.00</li><li>Time: 0.4 / Value: (6, 6) / Easing: 1.00</li></ul></li></ul></li></ul><p>The following GIF image shows the &ldquo;right_attack1&rdquo; animation we just created, played back at 0.5x speed. You can see that the HitBox collision shape is activated (green) only at the timing when the axe is swung down.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img17.gif alt="AnimationPlayer - playback animation"></p><br><p>A similar procedure was used to create the &ldquo;right_attack2&rdquo; animation. The texture of line 4 of the sprite sheet was used. During 0.1 ~ 0.4 seconds of the timeline, the &ldquo;Position&rdquo; and &ldquo;Extents&rdquo; of &ldquo;HitBoxCollisionShape&rdquo; were changed slightly every 0.1 second.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img18.png alt="AnimationPlayer - 2D workplace"></p><p>If you play &ldquo;right_attack2&rdquo; at 0.5x speed, it will look like this.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img19.gif alt="AnimationPlayer - playback animation"></p><br><p>In addition, an animation of &ldquo;right_attack3&rdquo; was created. This one used the texture on line 5 of the sprite sheet. The texture is only two frames long, but the two are repeated four times. The &ldquo;Sprite&rdquo; node&rsquo;s &ldquo;Position&rdquo; property track was added to make the animation move forward a little and then back.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img20.png alt="AnimationPlayer - 2D workplace"></p><p>If &ldquo;right_attack3&rdquo; is played back at 0.5x speed, the result is as follows.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img21.gif alt="AnimationPlayer - 2D workplace"></p><br><p>When creating a left-facing animation, it is easier to work with the Offset > Flip H property of the Sprite node turned on. It is easy to duplicate a previously created right-facing melee attack animation and adjust it for a left-facing animation.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=attach-a-script-to-the-player-node>Attach a script to the Player node</h2><p>To control the player character&rsquo;s movement and melee attacks, attach a script to the &ldquo;Player&rdquo; root node and code it like below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Player.gd###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>KinematicBody2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>## Movement speed</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>speed</span> <span class=o>=</span> <span class=mf>80.0</span>
</span></span><span class=line><span class=cl><span class=c1># Movement speed</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>velocity</span><span class=p>:</span> <span class=nc>Vector2</span>
</span></span><span class=line><span class=cl><span class=c1># Number of attack animations (1 ~ 3)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>attack_num</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=c1># Referencing a Sprite node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>sprite</span> <span class=o>=</span> <span class=nx>$Sprite</span>
</span></span><span class=line><span class=cl><span class=c1># Reference to AnimationPlayer node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>anim_player</span> <span class=o>=</span> <span class=nx>$AnimationPlayer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Methods to control character movement inputs</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>move</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_pressed</span><span class=p>(</span><span class=s2>&#34;right&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=n>velocity</span><span class=o>.</span><span class=n>x</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=n>sprite</span><span class=o>.</span><span class=n>flip_h</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_pressed</span><span class=p>(</span><span class=s2>&#34;left&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=n>velocity</span><span class=o>.</span><span class=n>x</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=n>sprite</span><span class=o>.</span><span class=n>flip_h</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_pressed</span><span class=p>(</span><span class=s2>&#34;down&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=n>velocity</span><span class=o>.</span><span class=n>y</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_pressed</span><span class=p>(</span><span class=s2>&#34;up&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=n>velocity</span><span class=o>.</span><span class=n>y</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>=</span> <span class=n>velocity</span><span class=o>.</span><span class=nf>normalized</span><span class=p>()</span> <span class=o>*</span> <span class=n>speed</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># Play idle animation if velocity is 0</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>velocity</span><span class=o>.</span><span class=nf>length</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nf>play</span><span class=p>(</span><span class=s2>&#34;idle&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Play run animation if velocity is greater than 0</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>velocity</span><span class=o>.</span><span class=nf>length</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;run&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Built-in physics process function</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_physics_process</span><span class=p>(</span><span class=n>_delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=nf>move</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1># reflect inputs related to movement as character&#39;s motion</span>
</span></span><span class=line><span class=cl>	<span class=n>velocity</span> <span class=o>=</span> <span class=nf>move_and_slide</span><span class=p>(</span><span class=n>velocity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Built-in callback function for input</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_unhandled_input</span><span class=p>(</span><span class=n>event</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># if spacebar is pressed</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>event</span><span class=o>.</span><span class=nf>is_action_pressed</span><span class=p>(</span><span class=s2>&#34;attack&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># stop physics process to prevent movement</span>
</span></span><span class=line><span class=cl>		<span class=nf>set_physics_process</span><span class=p>(</span><span class=kc>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1># if sprite is flipped left/right (facing left)</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>sprite</span><span class=o>.</span><span class=n>flip_h</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=c1># Play left-facing attack animation</span>
</span></span><span class=line><span class=cl>			<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;left_attack&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>attack_num</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=c1># if sprite is not flipped (right-facing)</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=c1># Play the right-facing attack animation</span>
</span></span><span class=line><span class=cl>			<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;right_attack&#34;</span> <span class=o>+</span> <span class=nb>str</span><span class=p>(</span><span class=n>attack_num</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1># If current attack animation number is less than 3, add 1 to the number</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>attack_num</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>attack_num</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=c1># Reset the number to 1 if the current attack animation number is 3 or more</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>attack_num</span> <span class=o>=</span> <span class=mi>1</span>
</span></span></code></pre></div><br><p>Connect the &ldquo;animation_finished&rdquo; signal of the &ldquo;AnimationPlayer&rdquo; node to the script and edit the auto-generated method as follows</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_AnimationPlayer_animation_finished</span><span class=p>(</span><span class=n>anim_name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># Resume the physical process if the animation name contains &#34;attack&#34;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=s2>&#34;attack&#34;</span> <span class=ow>in</span> <span class=n>anim_name</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=nf>set_physics_process</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span>
</span></span></code></pre></div><br><p>Let&rsquo;s run the &ldquo;Player&rdquo; scene.</p><p>If you enable the setting to display collision shapes in the &ldquo;Debug&rdquo; menu in advance, it will be easier to see the changes in collision shapes during the animation.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img21.1.png alt="run project"></p><p>The movement of the player character will look like the following GIF image.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img22.gif alt="Player - run scene"></p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=create-a-enemy-scene>Create a Enemy scene</h2><p>Prepare an &ldquo;Enemy&rdquo; scene to check the hit detection of the player character&rsquo;s melee attacks. Since this is similar to the &ldquo;Player&rdquo; scene, I will briefly describe it here.</p><p>The scene tree is as follows.</p><ul><li>Enemy (KinematicBody2D)<ul><li>Sprite</li><li>BodyCollisionShape (CollisionShape2D)</li><li>AnimationPlayer</li><li>ReviveTimer (Timer)</li></ul></li></ul><p><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img23.png alt="Enemy - Scene tree"></p><br><h2 id=edit-nodes-in-the-enemy-scene>Edit nodes in the Enemy scene</h2><h3 id=sprite-node-1>Sprite node</h3><p>We will use the assets from <a href=https://game-endeavor.itch.io/mystic-woods target=_blank>itch.io - mystic woods</a>
for the sprite textures of the enemy characters. Apply the &ldquo;slime.png&rdquo; sprite sheet from the downloaded assets to the &ldquo;Texture&rdquo; property of the &ldquo;Sprite&rdquo; node.</p><h3 id=bodycollisionshape-node>BodyCollisionShape node</h3><p>For the &ldquo;Shape&rdquo; property, apply &ldquo;CircleShape2D&rdquo; to make the collision shape slightly smaller than the sprite. In this tutorial, this will be the so-called Hurt Box. When the player character&rsquo;s hit box overlaps this collision shape, the hit detection becomes effective. This control will be done later in the script.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img24.png alt="Enemy - BodyCollisionShape"></p><h3 id=animationplayer-node>AnimationPlayer node</h3><p>In the Animation panel, prepare the following four animations. All of them are set to change to the texture of the next frame on the sprite sheet every 0.1 second.</p><ul><li><strong>jump</strong>: Animation of jumping when waiting (automatically played when loading)</li><li><strong>hurt</strong>: Animation for when the character takes damage.</li><li><strong>die</strong>: Animation for dying when life reaches 0.<ul><li>Turn on &ldquo;Disabled&rdquo; for &ldquo;BodyCollisionShape</li></ul></li><li><strong>revive</strong>: Animation when the character comes back to life after a certain period of time after death.<ul><li>Turn off &ldquo;Disabled&rdquo; of &ldquo;BodyCollisionShape</li></ul></li></ul><h3 id=revietimer-node>RevieTimer node</h3><p>Enable the &ldquo;One Shot&rdquo; property.</p><br><h2 id=attach-a-script-to-the-enemy-node>Attach a script to the Enemy node</h2><p>Attach a script to the &ldquo;Enemy&rdquo; root node and code it like below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Enemy.gd###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>KinematicBody2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Maximum value of life</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kd>var</span> <span class=n>max_life</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=c1># Current life</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>life</span><span class=p>:</span> <span class=kt>int</span> <span class=o>=</span> <span class=n>max_life</span>
</span></span><span class=line><span class=cl><span class=c1># Variable to refer to Player instance</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>player</span><span class=p>:</span> <span class=n>KinematicBody2D</span>
</span></span><span class=line><span class=cl><span class=c1># Reference to the Sprite node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>sprite</span> <span class=o>=</span> <span class=nx>$Sprite</span>
</span></span><span class=line><span class=cl><span class=c1># Reference to the AnimationPlayer node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>anim_player</span> <span class=o>=</span> <span class=nx>$AnimationPlayer</span>
</span></span><span class=line><span class=cl><span class=c1># ReviveTimer node reference</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>revive_timer</span> <span class=o>=</span> <span class=nx>$ReviveTimer</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_process</span><span class=p>(</span><span class=n>_delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># flip the Sprite&#39;s orientation or not depending on the player&#39;s position</span>
</span></span><span class=line><span class=cl>	<span class=n>sprite</span><span class=o>.</span><span class=n>flip_h</span> <span class=o>=</span> <span class=n>global_position</span><span class=o>.</span><span class=n>x</span> <span class=o>&gt;</span> <span class=n>player</span><span class=o>.</span><span class=n>global_position</span><span class=o>.</span><span class=n>x</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Damage methods</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hurt</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Reduce life by 1</span>
</span></span><span class=line><span class=cl>	<span class=n>life</span> <span class=o>-=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=c1># Play the animation hurt</span>
</span></span><span class=line><span class=cl>	<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;hurt&#34;</span><span class=p>)</span>
</span></span></code></pre></div><br><p>In addition, connect the &ldquo;animation_finished&rdquo; signal of &ldquo;AnimationPlayer&rdquo; and the &ldquo;timeout&rdquo; signal of &ldquo;ReviveTimer&rdquo; to the script and edit the respective generated methods as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Enemy.gd###</span>
</span></span><span class=line><span class=cl><span class=c1># Method called by AnimationPlayer&#39;s signal when animation is finished</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_AnimationPlayer_animation_finished</span><span class=p>(</span><span class=n>anim_name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># If the finished animation is hurt</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>anim_name</span> <span class=o>==</span> <span class=s2>&#34;hurt&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1># Return to jump animation if life is greater than 0</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>life</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;jump&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1># If life is less than 0, play die animation</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>life</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nf>play</span><span class=p>(</span><span class=s2>&#34;die&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Start ReviveTimer if the animation that ended is die</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>anim_name</span> <span class=o>==</span> <span class=s2>&#34;die&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>revive_timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=c1># If the animation that ended is &#34;revive&#34; </span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>anim_name</span> <span class=o>==</span> <span class=s2>&#34;revive&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;jump&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method called on ReviveTimer timeout signal</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_ReviveTimer_timeout</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Play the revive animation</span>
</span></span><span class=line><span class=cl>	<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;revive&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Return life to its maximum value</span>
</span></span><span class=line><span class=cl>	<span class=n>life</span> <span class=o>=</span> <span class=n>max_life</span>
</span></span></code></pre></div><br><hr><h2 id=add-a-hitbox-signal-to-the-players-script>Add a HitBox signal to the Player&rsquo;s script</h2><p>Make the &ldquo;Player.gd&rdquo; script call the <code>hurt</code> method of &ldquo;Enemy.gd&rdquo; by the &ldquo;HitBox&rdquo; signal when it is hit by a melee attack.</p><p>Return to the &ldquo;Player.tscn&rdquo; scene and connect the &ldquo;body_entered(body: Node)&rdquo; signal of the &ldquo;HitBox&rdquo; node to the &ldquo;Player.gd&rdquo; script.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###Player.gd###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Omitted</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method called with a signal when the physical body is hit by the HitBox</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_HitBox_body_entered</span><span class=p>(</span><span class=n>body</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># If the name of the physical body is &#34;Enemy&#34;, call its hurt method.</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>body</span><span class=o>.</span><span class=n>name</span> <span class=o>==</span> <span class=s2>&#34;Enemy&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>body</span><span class=o>.</span><span class=nf>hurt</span><span class=p>()</span>
</span></span></code></pre></div><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=create-a-world-scene>Create a World scene</h2><p>Finally, create a &ldquo;World&rdquo; scene and add a &ldquo;Player&rdquo; scene instance and an &ldquo;Enemy&rdquo; scene instance to it.</p><p>The scene tree is simply as follows.</p><ul><li>World (Node2D)<ul><li>Enemy (instance of Enemy.tscn)</li><li>Player (instance of Player.tscn)</li></ul></li></ul><p><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img25.png alt="World - Scene tree"></p><p>Place each instance appropriately on the 2D workspace.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img26.png alt="World - 2D workspace"></p><br><hr><h2 id=attach-a-script-to-the-world-scene>Attach a script to the World scene</h2><p>Attach a script to the World scene and code it as follows. The purpose is to pass a reference to the &ldquo;Player&rdquo; instance from the &ldquo;World&rdquo; root node to the variable <code>player</code> in the &ldquo;Enemy&rdquo; node declared in &ldquo;Enemy.gd&rdquo;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>###World.gd###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>player</span> <span class=o>=</span> <span class=nx>$Player</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>enemy</span> <span class=o>=</span> <span class=nx>$Enemy</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>enemy</span><span class=o>.</span><span class=n>player</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>player</span>
</span></span></code></pre></div><br><hr><h2 id=run-the-project>Run the project</h2><p>Finally, run the project to check the behavior of the hit judgment for melee attacks.</p><p>You can see that when the collision shape of the Player&rsquo;s HitBox node overlaps with the Enemy&rsquo;s BodyCollisionShape (Hurt Box), the hit detection is activated and the Enemy&rsquo;s hurt animation is played.<br><img loading=lazy src=/images/tutorials/gd0018_melee_attacks/img28.gif alt="run project"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=conclusion>Conclusion</h2><p>In this article, I introduced a simple hit detection method for melee attacks in 2D games, and the implementation of hit detection using Hit Boxes and Hurt Boxes is relatively easy to understand and can be applied to various games.</p><p>Incidentally, in actual games, it is often the case that separate Hit Boxes and Hurt Boxes are set up for each body part, and more complex mechanisms are created by combining these Hit Boxes and Hurt Boxes.</p><p>For example, in a fighting game, if the attacker has several Hit Boxes for hands, feet, head, etc., and the receiver has Hurt Boxes for the upper, middle, and lower positions, the damage can be changed in complex ways depending on the combination of each Hit Box and Hurt Box.</p><p>In a zombie FPS game, you could have different Hurt Boxes for the zombie&rsquo;s head and body, so that shooting at the head would kill the zombie in one shot, but not the other parts of the body.</p><p>Anyway, I hope this article has been of some help.</p><hr><h2 id=references>References</h2><p>In preparing this article, we found the following links to be very helpful. We hope you will find them useful as well.</p><ul><li><p><a href=https://docs.godotengine.org/en/stable/tutorials/animation/introduction.html target=_blank>Introduction to the animation features</a></p></li><li><p><a href=http://kidscancode.org/godot_recipes/3.x/animation/melee_attacks/ target=_blank>KidsCanCode - MELEE ATTACKS</a></p></li><li><p><a href=https://youtu.be/dBvfwLxoY3I target=_blank>YouTube - How to Make Melee Combat in Godot</a></p></li><li><p><a href=https://youtu.be/vDbEfmPcv-Q target=_blank>YouTube - Make an Action RPG in Godot 3.2 (P11 | Melee attacks with Hurtboxes and Hitboxes)</a></p></li><li><p><a href=https://elthen.itch.io/pixel-art-dwarf-sprites target=_blank>itch.io - Pixel Art Dwarf Sprites</a>
*Resource</p></li><li><p><a href=https://game-endeavor.itch.io/mystic-woods target=_blank>itch.io - mystic woods</a>
*Resource</p></li></ul><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%202D%20Hit%20Detection%20for%20Melee%20Attacks%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0018_melee_attacks%2f&amp;hashtags=GameDev%2cGodotEngine%2cGodot3%2c2D%2cMeleeAttack%2cCollision%2cAnimation"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0018_melee_attacks%2f&title=%f0%9f%a4%96%202D%20Hit%20Detection%20for%20Melee%20Attacks%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ğŸ¤– 2D Hit Detection for Melee Attacks in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0018_melee_attacks%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/meleeattack/>MeleeAttack</a></li><li><a href=https://www.peanuts-code.com/en/tags/collision/>Collision</a></li><li><a href=https://www.peanuts-code.com/en/tags/animation/>Animation</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/en/tutorials/gd0019_2d_animation_state_machine/><span class=title>Â« Prev</span><br><span>ğŸ¤– Animation State Machine in Godot3</span>
</a><a class=next href=https://www.peanuts-code.com/en/tutorials/gd0017_2d_grid_based_path_finding/><span class=title>Next Â»</span><br><span>ğŸ¤– 2D Grid Based Path Finding in Godot3</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/en/>Peanuts Code</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>