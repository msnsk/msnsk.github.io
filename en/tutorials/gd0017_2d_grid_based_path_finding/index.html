<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ü§ñ 2D Grid Based Path Finding in Godot3 | Peanuts Code</title>
<meta name=keywords content="GameDev,GodotEngine,Godot3,2D,GridBased,PathFinding,AStar"><meta name=description content="This article is a tutorial on how to implement grid-based path finding in 2D games using the AStar algorithm. For 2D pathfinding that is not grid-based, please refer to the article 2D Path Finding in Godot3 . I hope you will choose the article that best suits the game you want to make. The final project file in this tutorial is located in the GitHub repository . After downloading and extracting the .zip file, you can import the &ldquo;project.godot&rdquo; file into the Godot Engine to see the project directly. Translated with www.DeepL.com/Translator (free version) Environment Godot version: 3.5 Computer OS: macOS 11.6.5 Basic Articles You may also find the following articles useful. Downloading Godot Project Manager of Godot About AStar In this article, we will implement grid-based routing using a search algorithm called AStar. It is useful when you want to automatically move objects along a grid from the current location to the destination. For example, this method is ideal for puzzle games where you move pieces on the board, or strategy simulation games where you move characters of both"><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/en/tutorials/gd0017_2d_grid_based_path_finding/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0017_2d_grid_based_path_finding/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0017_2d_grid_based_path_finding/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="ü§ñ 2D Grid Based Path Finding in Godot3"><meta property="og:description" content="This article is a tutorial on how to implement grid-based path finding in 2D games using the AStar algorithm. For 2D pathfinding that is not grid-based, please refer to the article 2D Path Finding in Godot3 . I hope you will choose the article that best suits the game you want to make. The final project file in this tutorial is located in the GitHub repository . After downloading and extracting the .zip file, you can import the &ldquo;project.godot&rdquo; file into the Godot Engine to see the project directly. Translated with www.DeepL.com/Translator (free version) Environment Godot version: 3.5 Computer OS: macOS 11.6.5 Basic Articles You may also find the following articles useful. Downloading Godot Project Manager of Godot About AStar In this article, we will implement grid-based routing using a search algorithm called AStar. It is useful when you want to automatically move objects along a grid from the current location to the destination. For example, this method is ideal for puzzle games where you move pieces on the board, or strategy simulation games where you move characters of both"><meta property="og:type" content="article"><meta property="og:url" content="https://www.peanuts-code.com/en/tutorials/gd0017_2d_grid_based_path_finding/"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0017_2d_astar_path_finding/img14.gif"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-09-22T19:45:00+09:00"><meta property="article:modified_time" content="2022-09-22T19:45:00+09:00"><meta property="og:site_name" content="Peanuts Code ü•ú"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0017_2d_astar_path_finding/img14.gif"><meta name=twitter:title content="ü§ñ 2D Grid Based Path Finding in Godot3"><meta name=twitter:description content="This article is a tutorial on how to implement grid-based path finding in 2D games using the AStar algorithm. For 2D pathfinding that is not grid-based, please refer to the article 2D Path Finding in Godot3 . I hope you will choose the article that best suits the game you want to make. The final project file in this tutorial is located in the GitHub repository . After downloading and extracting the .zip file, you can import the &ldquo;project.godot&rdquo; file into the Godot Engine to see the project directly. Translated with www.DeepL.com/Translator (free version) Environment Godot version: 3.5 Computer OS: macOS 11.6.5 Basic Articles You may also find the following articles useful. Downloading Godot Project Manager of Godot About AStar In this article, we will implement grid-based routing using a search algorithm called AStar. It is useful when you want to automatically move objects along a grid from the current location to the destination. For example, this method is ideal for puzzle games where you move pieces on the board, or strategy simulation games where you move characters of both"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ü§ñ Tutorials","item":"https://www.peanuts-code.com/en/tutorials/"},{"@type":"ListItem","position":2,"name":"ü§ñ 2D Grid Based Path Finding in Godot3","item":"https://www.peanuts-code.com/en/tutorials/gd0017_2d_grid_based_path_finding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ü§ñ 2D Grid Based Path Finding in Godot3","name":"ü§ñ 2D Grid Based Path Finding in Godot3","description":"This article is a tutorial on how to implement grid-based path finding in 2D games using the AStar algorithm. For 2D pathfinding that is not grid-based, please refer to the article 2D Path Finding in Godot3 . I hope you will choose the article that best suits the game you want to make. The final project file in this tutorial is located in the GitHub repository . After downloading and extracting the .zip file, you can import the \u0026ldquo;project.godot\u0026rdquo; file into the Godot Engine to see the project directly. Translated with www.DeepL.com/Translator (free version) Environment Godot version: 3.5 Computer OS: macOS 11.6.5 Basic Articles You may also find the following articles useful. Downloading Godot Project Manager of Godot About AStar In this article, we will implement grid-based routing using a search algorithm called AStar. It is useful when you want to automatically move objects along a grid from the current location to the destination. For example, this method is ideal for puzzle games where you move pieces on the board, or strategy simulation games where you move characters of both","keywords":["GameDev","GodotEngine","Godot3","2D","GridBased","PathFinding","AStar"],"articleBody":"This article is a tutorial on how to implement grid-based path finding in 2D games using the AStar algorithm. For 2D pathfinding that is not grid-based, please refer to the article 2D Path Finding in Godot3 . I hope you will choose the article that best suits the game you want to make.\nThe final project file in this tutorial is located in the GitHub repository . After downloading and extracting the .zip file, you can import the ‚Äúproject.godot‚Äù file into the Godot Engine to see the project directly.\nTranslated with www.DeepL.com/Translator (free version)\nEnvironment Godot version: 3.5\nComputer OS: macOS 11.6.5\nBasic Articles You may also find the following articles useful.\nDownloading Godot Project Manager of Godot About AStar In this article, we will implement grid-based routing using a search algorithm called AStar. It is useful when you want to automatically move objects along a grid from the current location to the destination. For example, this method is ideal for puzzle games where you move pieces on the board, or strategy simulation games where you move characters of both sides on the board to fight each other.\nWhat is AStar? AStar, also known as A*, is an algorithm that searches for the shortest path from the start point to the goal point while avoiding obstacles. In the case of Godot engine, you do not have to code the algorithm from scratch by using the AStar class. We will use it in this tutorial.\nWikipedia - A* Godot Docs - AStar2D Create a project First, create a new project. This time, name the project ‚Äú2D Grid Based Path Finding‚Äù.\nProject Settings The following settings are made in the ‚ÄúProject‚Äù menu \u003e ‚ÄúProject Settings‚Äù.\nGeneral\" tab Display \u003e Window Size section Width: 1024 Height: 576 Stretch section Mode: 2d Aspect: keep Input Map\" tab 1. add ‚Äúmove_to‚Äù action assign ‚Äúleft mouse button‚Äù to ‚Äúmove_to‚Äù action\nImport assets This time I used an asset pack called Board Game Icons from KENNEY‚Äôs site. I can‚Äôt help but be thankful for this wonderful free material.\nAfter downloading, drag and drop the following files from the ‚Äú/kenney_boardgameicons/PNG/Default (64px)‚Äù folder into the file system dock of the Godot editor to import them into your project.\ncharacter.png d3.png structure_wall.png Create the Game scene First, create the ‚ÄúGame‚Äù scene that will be the main part of the project. Select ‚ÄúNode2D‚Äù as the root node, add the necessary nodes to it, rename them, and create a scene tree as shown below.\nGame (Node2D) Board (TileMap) Obstacles (Node2D) *We will add a child node to this node later. Line (Line2D) Player (Sprite) AStarVisualizer (Control) Edit a node Board (TileMap) node To edit the ‚ÄúBoard‚Äù node as the board on which the player‚Äôs pieces move in the game:\nSelect the ‚ÄúBoard‚Äù node and apply the ‚ÄúNew TileSet‚Äù resource to the ‚ÄúTile Set‚Äù property in the inspector.\nClick on the ‚ÄúTileSet‚Äù applied in the inspector to open the Tile Set panel. Drag and drop the previously imported ‚Äúd3.png‚Äù from the file system dock to the sidebar of the TileSet panel to add it as a texture for the tileset. Select the added texture and add it as ‚ÄúNew Single Tile‚Äù specifying its ‚Äúarea‚Äù.\nIn the inspector, change the color of the tiles to the desired color using the ‚ÄúModulate‚Äù property.\nSelect the ‚ÄúBoard‚Äù node in the scene dock and create a tile map on the 2D workspace, paying attention to the following points Create a tile map within the window size of the game. The tiles to be placed should be used as movable areas for the player node. The tiles must be placed at the top-left grid coordinate (0, 0), because the player node will be placed there later.\nObstacles (Node2D) node The ‚ÄúObstacles‚Äù node is used as a container (parent node) for multiple obstacle nodes to be placed on the tile map. Therefore, this node itself does not need to be edited.\nCreate an Obstacle Scene Create a scene of an obstacle to be placed on the tile map. 1. Select ‚ÄúSprite‚Äù as the root node and rename it to ‚ÄúObstacle‚Äù.\nDrag and drop ‚Äústructure_wall.png‚Äù from the file system dock to the ‚ÄúTexture‚Äù property in the inspector and apply the resource.\nTurn off the ‚ÄúOffset‚Äù \u003e ‚ÄúCentered‚Äù property.\nChange the color with the ‚ÄúModulate‚Äù property. Change the color to a color that is easily visible when the Obstacle node is placed on top of the tiles of the ‚ÄúBoard (TileMap)‚Äù node prepared earlier.\nAdding Obstacle scene instances to the Obstacles node Return to the ‚ÄúGame‚Äù scene and add 10 instance nodes of the ‚ÄúObstacle‚Äù scene you created to the ‚ÄúObstacles‚Äù node and place them at appropriate locations on the tile map. However, be careful not to place them at the grid coordinates (0, 0), since the player‚Äôs pieces will be placed there.\nPlayer (Sprite) node This node is used as a player piece to be moved on the board by path finding using AStar.\nIn the Inspector, drag \u0026 drop ‚Äúcharacter.png‚Äù from the file system dock to the ‚ÄúTexture‚Äù property and apply the resource.\nTurn off the ‚ÄúOffset‚Äù \u003e ‚ÄúCentered‚Äù property.\nIn the 2D workspace, make sure the player is placed at the coordinates (0, 0), which is its initial position.\nControl by script Attach the script to the Board node Path finding by the AStar algorithm roughly follows the following flow.\nGet the position of a tile placed on the tile map. Add tile positions as AStar points. Connect each AStar point to the adjacent points on the top, bottom, left and right. Get the position of obstacles. Disable points on AStar corresponding to the position of an obstacles. Find paths in the line connecting the valid points of AStar. Attach the script to the ‚ÄúBoard‚Äù node and edit the code as follows:\nextends TileMap # Array to store the points of the path the Player will move var path: Array = []. # Array of cells where tiles are placed in Board(TileMap) var cells = get_used_cells() # Reference to the Obstacles node onready var obstacles = $Obstacles # An instance of the AStar2D class onready var astar = AStar2D.new() # Half the size of a cell in Board(TileMap) onready var half_cell_size = cell_size / 2 func _ready(): # Call the method to add points of AStar add_points() # Call a method to connect points of AStar connect_points() # Call a method to deactivate points of AStar # The argument is a method that returns the positions of the child nodes of the Obstacles node as an array disable_points(get_obstacles()) # Method to add points of AStar func add_points(): # Loop over the cells where tiles are placed on the tile map for cell in cells: # Generate cell IDs and add them as points of AStar astar.add_point(id(cell), cell) # Method to connect points of AStar func connect_points(): # Loop through the cells where tiles are placed on the tile map for cell in cells: # If the cell is in an AStar point if astar.has_point(id(cell)): # Create an array of direction vectors in the four adjacent directions var neighbors = [ Vector2.RIGHT, Vector2.LEFT, Vector2.DOWN, Vector2.UP ] # Loop processing for each direction vector for neighbor in neighbors: # Define neighbor cells var next_cell = cell + neighbor # If a tile is placed in a neighbor cell if cells.has(next_cell): # Connect the points on the original cell of AStar with the points on the neighbor cell astar.connect_points(id(cell), id(next_cell), false) # Method to return the positions of the child nodes of an Obstacles node as an array func get_obstacles() -\u003e Array: # An array containing the grid coordinates of the cell where the obstacle is located var obstacle_cells = []. # Loop over all child nodes of Obstacles (Obstacle instances) for child in obstacles.get_children(): # Add the grid coordinates of obstacles to the prepared array obstacle_cells.append(world_to_map(child.global_position)) # Return an array as a return value return obstacle_cells # Method to invalidate points of AStar # Pass an array whose elements are the grid coordinates of the cell as an argument func disable_points(target_cells): # Loop over the elements of the argument array (cell grid coordinates) for cell in target_cells: # disable the point of AStar corresponding to the cell astar.set_point_disabled(id(cell)) # Method to update the shortest path (array of points to pass) for the Player to move func update_path(start, end): # Find the shortest path from the starting point of the argument to the destination point in AStar path = astar.get_point_path(id(start), id(end)) # Method to generate ID from grid coordinates func id(point): var a = point.x var b = point.y return (a + b) * (a + b + 1) / 2 + b This will add AStar points to the coordinates of the cell where the tile is placed in the ‚ÄúBoard (TileMap)‚Äù node, and each point will be connected by a line. Furthermore, the points that correspond to the coordinates of the ‚ÄúObstacle‚Äù instance are deactivated, and the lines connecting them are also deactivated. The network of AStar finally formed in this way is used as a route.\nThe update_path() method will be called in the script of the ‚ÄúGame‚Äù node. When calling this method, pass the current position and the destination position of the ‚ÄúPlayer‚Äù node to the arguments start and end, respectively, and the Player node will move along the shortest path on the AStar network that has been formed.\nOf course, the positions of the ‚ÄúObstacle‚Äù instances is not connected to the line because the AStar points are disabled, so the Player node cannot move to the positions.\nIt may be difficult to visualize the AStar points and lines, so I will attach a script to ‚ÄúAStarVisualizer‚Äù to visualize them.\nAttach a script to the ‚ÄúAStarVisualizer (Control)‚Äù node To visualize AStar points and lines, attach a script to ‚ÄúAStarVisualizer‚Äù and edit the code as follows:\nextends Control onready var board: TileMap = get_parent().get_node(\"Board\") onready var astar: AStar2D = board.astar onready var offset: Vector2 = board.half_cell_size # Call the _draw() function when a node is loaded into the scene tree func _ready(): _draw() # Override built-in function _draw() to draw AStar points and lines on the screen func _draw(): # Loop over all points (IDs) in AStar for point in astar.get_points(): # Skip the next step if the point is deactivated if astar.is_point_disabled(point): print(\"astar point is disabled\") continue # Convert from AStar points (IDs) to grid coordinates var cell = astar.get_point_position(point) # Convert from grid coordinates to world coordinates var pos = board.map_to_world(cell) # Draw the world coordinate of the point of AStar shifted from the upper left corner of the cell to the center draw_circle(pos + offset, 4, Color.white) # Get all the points (IDs) connected to the acquired AStar point var point_connections = astar.get_point_connections(point) # Array to store all connected points as world coordinates var connected_positions = []. # Loop over connected points for connected_point in point_connections: # If connected points are deactivated, skip this step if astar.is_point_disabled(connected_point): print(\"connected point is disabled\") continue # Convert IDs of connected points to grid coordinates var connected_cell = astar.get_point_position(connected_point) # Convert grid coordinates to world coordinates var connected_pos = board.map_to_world(connected_cell) # Add world coordinates to array connected_positions.append(connected_pos) # Loop through the elements of the array of world coordinates of connected points for connected_pos in connected_positions: # Draw a line connecting the original point and the connected points draw_line(pos + offset, connected_pos + offset, Color.white, 2) With this script, the AStar points and lines are drawn on the screen and the AStar network can now be visualized. When you run the project, you should see the following.\nAttaching scripts to the Game node The last step is to code the ‚ÄúPlayer‚Äù node to move when the mouse is pressed.\nAfter attaching the script to the ‚ÄúGame‚Äù root node, edit the code as follows:\nextends Node2D # Referencing the Board node onready var board = $Board # Referencing the Line node onready var line = $Line # Referencing the Player node onready var player = $Player func _input(event): # If the left mouse button is clicked if event.is_action_pressed(\"move_to\"): # Get grid coordinates from mouse cursor world coordinates as destination var target_cell = board.world_to_map(get_global_mouse_position()) # Generate ID from the grid coordinates of the target cell var target_cell_id = board.id(target_cell) # If the ID is contained in a valid point for AStar if board.astar.has_point(target_cell_id): # Get the coordinates of the cell on the tile map from the Player's world coordinates var player_cell = board.world_to_map(player.global_position) # Update the path from Player's cell to the destination cell board.update_path(player_cell, target_cell) # Call a method to move the Player node move() # Method to move the Player's piece func move(): # Disable the input process so that no click operations are possible during the move set_process_input(false) # Draw the path of the Line node by looping through the grid coordinates of the path points for point in board.path: # Convert grid coordinates to world coordinates and add to path of Line node line.add_point(board.map_to_world(point) + board.half_cell_size) # Move Player node by looping through path in grid coordinates of the path points for point in board.path: # Convert the grid coordinates of the point to world coordinates and overwrite the position of the Player node with it player.global_position = board.map_to_world(point) # Wait 0.1 seconds yield(get_tree().create_timer(0.1), \"timeout\") # Clear the points in the path of the Line node when move is complete line.clear_points() # Enable input process set_process_input(true) With this script, the ‚ÄúPlayer‚Äù node can be moved by left mouse click. The AStar algorithm determines the shortest path from the grid coordinates where the ‚ÄúPlayer‚Äù node is located to the grid coordinates where the mouse cursor overlaps when left-clicked, and moves the ‚ÄúPlayer‚Äù node along that path.\nIf you run the project, you should see the following GIF image.\nConclusion In this article, I introduced a grid-based 2D path finding using the AStar algorithm. The project we have created should work equally well with different placement of tiles and obstacles.\nFinally, let me summarize the main points of this tutorial.\nGodot provides the AStar class, so we can use it. Convert world coordinates ‚áÑ grid coordinates ‚áÑ ID as appropriate. The sequence of path finding is as follows: Add a point of AStar. Connect adjacent points of AStar. Disable AStar points that overlap with obstacles.\n*Of course, you can also add only points excluding obstacles in step 1. Derive the shortest path between the current location and the destination location using the AStar algorithm. Also, you may be able to make an interesting game by adding the following arrangement.\nRandomly generate tiles and obstacles. Place and move multiple characters on the board, both friend and foe. In addition to the four directions of up, down, left, right, it is also possible to move diagonally. References The following resources were very helpful in preparing this article.\nYouTube - A* TileMap for Grid-Based PATHFINDING in Godot / HeartBeast YouTube - A* Path-Finding for Grid-Based Tilemap in Godot / AndOne YouTube - 2D Grid-Based Pathfinding (AStar) - Godot Tutorial / GamemakerPixel Godot Docs - AStar2D KENNEY - Board Game Icons Wikipedia - A* ","wordCount":"2510","inLanguage":"en","image":"https://www.peanuts-code.com/images/tutorials/gd0017_2d_astar_path_finding/img14.gif","datePublished":"2022-09-22T19:45:00+09:00","dateModified":"2022-09-22T19:45:00+09:00","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/en/tutorials/gd0017_2d_grid_based_path_finding/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/en/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/ja/ title=Japanese aria-label=üáØüáµÊó•Êú¨Ë™û>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/en/ title=Home><span>Home</span></a></li><li><a href=https://www.peanuts-code.com/en/portfolio/ title=Works><span>Works</span></a></li><li><a href=https://www.peanuts-code.com/en/posts/ title=Blogs><span>Blogs</span></a></li><li><a href=https://www.peanuts-code.com/en/tutorials/ title=Tutorials><span>Tutorials</span></a></li><li><a href=https://www.peanuts-code.com/en/about/ title=About><span>About</span></a></li><li><a href=https://www.peanuts-code.com/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/en/>Home</a>&nbsp;¬ª&nbsp;<a href=https://www.peanuts-code.com/en/tutorials/>ü§ñ Tutorials</a></div><h1 class="post-title entry-hint-parent">ü§ñ 2D Grid Based Path Finding in Godot3</h1><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/gridbased/>GridBased</a></li><li><a href=https://www.peanuts-code.com/en/tags/pathfinding/>PathFinding</a></li><li><a href=https://www.peanuts-code.com/en/tags/astar/>AStar</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ 2D Grid Based Path Finding in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%202D%20Grid%20Based%20Path%20Finding%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0017_2d_grid_based_path_finding%2f&amp;hashtags=GameDev%2cGodotEngine%2cGodot3%2c2D%2cGridBased%2cPathFinding%2cAStar"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ 2D Grid Based Path Finding in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0017_2d_grid_based_path_finding%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><div class=post-meta><span title='2022-09-22 19:45:00 +0900 +0900'>2022-09-22</span>&nbsp;¬∑&nbsp;6 min&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/ja/tutorials/gd0017_2d_grid_based_path_finding/>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0017_2d_astar_path_finding/img14.gif alt="2D Grid Based Path Finding in Godot3"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#about-astar aria-label="About AStar">About AStar</a><ul><li><a href=#what-is-astar aria-label="What is AStar?">What is AStar?</a></li></ul></li><li><a href=#create-a-project aria-label="Create a project">Create a project</a><ul><li><a href=#project-settings aria-label="Project Settings">Project Settings</a></li><li><a href=#import-assets aria-label="Import assets">Import assets</a></li></ul></li><li><a href=#create-the-game-scene aria-label="Create the Game scene">Create the Game scene</a></li><li><a href=#edit-a-node aria-label="Edit a node">Edit a node</a><ul><li><a href=#board-tilemap-node aria-label="Board (TileMap) node">Board (TileMap) node</a></li><li><a href=#obstacles-node2d-node aria-label="Obstacles (Node2D) node">Obstacles (Node2D) node</a><ul><li><a href=#create-an-obstacle-scene aria-label="Create an Obstacle Scene">Create an Obstacle Scene</a></li><li><a href=#adding-obstacle-scene-instances-to-the-obstacles-node aria-label="Adding Obstacle scene instances to the Obstacles node">Adding Obstacle scene instances to the Obstacles node</a></li></ul></li><li><a href=#player-sprite-node aria-label="Player (Sprite) node">Player (Sprite) node</a></li></ul></li><li><a href=#control-by-script aria-label="Control by script">Control by script</a><ul><li><a href=#attach-the-script-to-the-board-node aria-label="Attach the script to the Board node">Attach the script to the Board node</a></li><li><a href=#attach-a-script-to-the-astarvisualizer-control-node aria-label="Attach a script to the &ldquo;AStarVisualizer (Control)&rdquo; node">Attach a script to the &ldquo;AStarVisualizer (Control)&rdquo; node</a></li><li><a href=#attaching-scripts-to-the-game-node aria-label="Attaching scripts to the Game node">Attaching scripts to the Game node</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#references aria-label=References>References</a></li></ul></div></details></div><div class=post-content><p>This article is a tutorial on how to implement grid-based path finding in 2D games using the AStar algorithm. For 2D pathfinding that is not grid-based, please refer to the article <a href=https://www.peanuts-code.com/en/tutorials/gd0016_2d_path_finding/ title="2D Path Finding in Godot3">2D Path Finding in Godot3</a>
. I hope you will choose the article that best suits the game you want to make.</p><p>The final project file in this tutorial is located in the <a href=https://github.com/msnsk/2DGridBasedPathFInding.git target=_blank>GitHub repository</a>
. After downloading and extracting the .zip file, you can import the &ldquo;project.godot&rdquo; file into the Godot Engine to see the project directly.</p><p>Translated with <a href=https://www.DeepL.com/Translator target=_blank>www.DeepL.com/Translator</a>
(free version)</p><blockquote><p><strong><span style=color:salmon>Environment</span></strong><br><em>Godot version: <strong>3.5</strong></em><br><em>Computer OS: <strong>macOS 11.6.5</strong></em></p></blockquote><blockquote><p><strong><span style=color:salmon>Basic Articles</span></strong><br><em>You may also find the following articles useful.<br><a href=https://www.peanuts-code.com/en/tutorials/gd0001_download/>Downloading Godot</a><br><a href=https://www.peanuts-code.com/en/tutorials/gd0002_project_manager/>Project Manager of Godot</a></em></p></blockquote><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=about-astar>About AStar</h2><p>In this article, we will implement grid-based routing using a search algorithm called AStar. It is useful when you want to automatically move objects along a grid from the current location to the destination. For example, this method is ideal for puzzle games where you move pieces on the board, or strategy simulation games where you move characters of both sides on the board to fight each other.<br><br></p><h3 id=what-is-astar>What is AStar?</h3><p>AStar, also known as A*, is an algorithm that searches for the shortest path from the start point to the goal point while avoiding obstacles. In the case of Godot engine, you do not have to code the algorithm from scratch by using the AStar class. We will use it in this tutorial.</p><p><a href=https://en.wikipedia.org/wiki/A*_search_algorithm target=_blank>Wikipedia - A*</a><br><a href=https://docs.godotengine.org/en/stable/classes/class_astar2d.html target=_blank>Godot Docs - AStar2D</a></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=create-a-project>Create a project</h2><p>First, create a new project. This time, name the project &ldquo;2D Grid Based Path Finding&rdquo;.<br><br></p><h3 id=project-settings>Project Settings</h3><p>The following settings are made in the &ldquo;Project&rdquo; menu > &ldquo;Project Settings&rdquo;.</p><ul><li>General" tab<ul><li>Display > Window<ul><li>Size section<ul><li>Width: 1024</li><li>Height: 576</li></ul></li><li>Stretch section<ul><li>Mode: 2d</li><li>Aspect: keep</li></ul></li></ul></li></ul></li><li>Input Map" tab 1.<ol><li>add &ldquo;move_to&rdquo; action</li><li>assign &ldquo;left mouse button&rdquo; to &ldquo;move_to&rdquo; action<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img1.png alt="Inputmap - action - shake"></li></ol></li></ul><br><h3 id=import-assets>Import assets</h3><p>This time I used an asset pack called <a href=https://www.kenney.nl/assets/board-game-icons target=_blank>Board Game Icons</a>
from KENNEY&rsquo;s site. I can&rsquo;t help but be thankful for this wonderful free material.</p><p>After downloading, drag and drop the following files from the &ldquo;/kenney_boardgameicons/PNG/Default (64px)&rdquo; folder into the file system dock of the Godot editor to import them into your project.</p><ul><li>character.png</li><li>d3.png</li><li>structure_wall.png</li></ul><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=create-the-game-scene>Create the Game scene</h2><p>First, create the &ldquo;Game&rdquo; scene that will be the main part of the project. Select &ldquo;Node2D&rdquo; as the root node, add the necessary nodes to it, rename them, and create a scene tree as shown below.</p><ul><li>Game (Node2D)<ul><li>Board (TileMap)<ul><li>Obstacles (Node2D) *<em>We will add a child node to this node later.</em></li></ul></li><li>Line (Line2D)</li><li>Player (Sprite)</li><li>AStarVisualizer (Control)</li></ul></li></ul><p><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img1.1.png alt="Game scene tree"></p><hr><h2 id=edit-a-node>Edit a node</h2><h3 id=board-tilemap-node>Board (TileMap) node</h3><p>To edit the &ldquo;Board&rdquo; node as the board on which the player&rsquo;s pieces move in the game:</p><ol><li>Select the &ldquo;Board&rdquo; node and apply the &ldquo;New TileSet&rdquo; resource to the &ldquo;Tile Set&rdquo; property in the inspector.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img2.png alt="TileMap - add Tile Set resource to Tile Set property"></li><li>Click on the &ldquo;TileSet&rdquo; applied in the inspector to open the Tile Set panel.</li><li>Drag and drop the previously imported &ldquo;d3.png&rdquo; from the file system dock to the sidebar of the TileSet panel to add it as a texture for the tileset.</li><li>Select the added texture and add it as &ldquo;New Single Tile&rdquo; specifying its &ldquo;area&rdquo;.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img3.png alt="TileSet Pannel"></li><li>In the inspector, change the color of the tiles to the desired color using the &ldquo;Modulate&rdquo; property.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img4.png alt="TileSet Pannel"></li><li>Select the &ldquo;Board&rdquo; node in the scene dock and create a tile map on the 2D workspace, paying attention to the following points<ul><li>Create a tile map within the window size of the game.</li><li>The tiles to be placed should be used as movable areas for the player node.</li><li>The tiles must be placed at the top-left grid coordinate (0, 0), because the player node will be placed there later.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img5.png alt="editting Board node"></li></ul></li></ol><br><h3 id=obstacles-node2d-node>Obstacles (Node2D) node</h3><p>The &ldquo;Obstacles&rdquo; node is used as a container (parent node) for multiple obstacle nodes to be placed on the tile map. Therefore, this node itself does not need to be edited.<br><br></p><h4 id=create-an-obstacle-scene>Create an Obstacle Scene</h4><p>Create a scene of an obstacle to be placed on the tile map. 1. Select &ldquo;Sprite&rdquo; as the root node and rename it to &ldquo;Obstacle&rdquo;.</p><ol><li>Drag and drop &ldquo;structure_wall.png&rdquo; from the file system dock to the &ldquo;Texture&rdquo; property in the inspector and apply the resource.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img6.png alt="Obstacle - Texture"></li><li>Turn off the &ldquo;Offset&rdquo; > &ldquo;Centered&rdquo; property.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img7.png alt="Obstacle - Offset - Centered"></li><li>Change the color with the &ldquo;Modulate&rdquo; property. Change the color to a color that is easily visible when the Obstacle node is placed on top of the tiles of the &ldquo;Board (TileMap)&rdquo; node prepared earlier.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img8.png alt="Obstacle - Modulate"></li></ol><br><h4 id=adding-obstacle-scene-instances-to-the-obstacles-node>Adding Obstacle scene instances to the Obstacles node</h4><p>Return to the &ldquo;Game&rdquo; scene and add 10 instance nodes of the &ldquo;Obstacle&rdquo; scene you created to the &ldquo;Obstacles&rdquo; node and place them at appropriate locations on the tile map. However, be careful not to place them at the grid coordinates (0, 0), since the player&rsquo;s pieces will be placed there.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img9.png alt="Obstacles - 2D Workspace"></p><br><h3 id=player-sprite-node>Player (Sprite) node</h3><p>This node is used as a player piece to be moved on the board by path finding using AStar.</p><ol><li>In the Inspector, drag & drop &ldquo;character.png&rdquo; from the file system dock to the &ldquo;Texture&rdquo; property and apply the resource.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img10.png alt="Player - Texture"></li><li>Turn off the &ldquo;Offset&rdquo; > &ldquo;Centered&rdquo; property.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img11.png alt="Player - Offset - Centered"></li><li>In the 2D workspace, make sure the player is placed at the coordinates (0, 0), which is its initial position.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img12.png alt="Player - 2D Workspace"></li></ol><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=control-by-script>Control by script</h2><h3 id=attach-the-script-to-the-board-node>Attach the script to the Board node</h3><p>Path finding by the AStar algorithm roughly follows the following flow.</p><ol><li>Get the position of a tile placed on the tile map.</li><li>Add tile positions as AStar points.</li><li>Connect each AStar point to the adjacent points on the top, bottom, left and right.</li><li>Get the position of obstacles.</li><li>Disable points on AStar corresponding to the position of an obstacles.</li><li>Find paths in the line connecting the valid points of AStar.</li></ol><p>Attach the script to the &ldquo;Board&rdquo; node and edit the code as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>TileMap</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Array to store the points of the path the Player will move</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>path</span><span class=p>:</span> <span class=nc>Array</span> <span class=o>=</span> <span class=p>[]</span><span class=o>.</span>
</span></span><span class=line><span class=cl><span class=c1># Array of cells where tiles are placed in Board(TileMap)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>cells</span> <span class=o>=</span> <span class=nf>get_used_cells</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Reference to the Obstacles node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>obstacles</span> <span class=o>=</span> <span class=nx>$Obstacles</span>
</span></span><span class=line><span class=cl><span class=c1># An instance of the AStar2D class</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>astar</span> <span class=o>=</span> <span class=nc>AStar2D</span><span class=o>.</span><span class=nf>new</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># Half the size of a cell in Board(TileMap)</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>half_cell_size</span> <span class=o>=</span> <span class=n>cell_size</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Call the method to add points of AStar</span>
</span></span><span class=line><span class=cl>	<span class=nf>add_points</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Call a method to connect points of AStar</span>
</span></span><span class=line><span class=cl>	<span class=nf>connect_points</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Call a method to deactivate points of AStar</span>
</span></span><span class=line><span class=cl>    <span class=c1># The argument is a method that returns the positions of the child nodes of the Obstacles node as an array</span>
</span></span><span class=line><span class=cl>	<span class=nf>disable_points</span><span class=p>(</span><span class=nf>get_obstacles</span><span class=p>())</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to add points of AStar</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>add_points</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over the cells where tiles are placed on the tile map</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>cell</span> <span class=ow>in</span> <span class=n>cells</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Generate cell IDs and add them as points of AStar</span>
</span></span><span class=line><span class=cl>		<span class=n>astar</span><span class=o>.</span><span class=nf>add_point</span><span class=p>(</span><span class=nf>id</span><span class=p>(</span><span class=n>cell</span><span class=p>),</span> <span class=n>cell</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to connect points of AStar</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>connect_points</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop through the cells where tiles are placed on the tile map</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>cell</span> <span class=ow>in</span> <span class=n>cells</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># If the cell is in an AStar point</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>astar</span><span class=o>.</span><span class=nf>has_point</span><span class=p>(</span><span class=nf>id</span><span class=p>(</span><span class=n>cell</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>            <span class=c1># Create an array of direction vectors in the four adjacent directions</span>
</span></span><span class=line><span class=cl>			<span class=kd>var</span> <span class=n>neighbors</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>				<span class=nc>Vector2</span><span class=o>.</span><span class=n>RIGHT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nc>Vector2</span><span class=o>.</span><span class=n>LEFT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nc>Vector2</span><span class=o>.</span><span class=n>DOWN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>				<span class=nc>Vector2</span><span class=o>.</span><span class=n>UP</span>
</span></span><span class=line><span class=cl>			<span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=c1># Loop processing for each direction vector</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=n>neighbor</span> <span class=ow>in</span> <span class=n>neighbors</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># Define neighbor cells</span>
</span></span><span class=line><span class=cl>				<span class=kd>var</span> <span class=n>next_cell</span> <span class=o>=</span> <span class=n>cell</span> <span class=o>+</span> <span class=n>neighbor</span>
</span></span><span class=line><span class=cl>                <span class=c1># If a tile is placed in a neighbor cell</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=n>cells</span><span class=o>.</span><span class=nf>has</span><span class=p>(</span><span class=n>next_cell</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=c1># Connect the points on the original cell of AStar with the points on the neighbor cell</span>
</span></span><span class=line><span class=cl>					<span class=n>astar</span><span class=o>.</span><span class=nf>connect_points</span><span class=p>(</span><span class=nf>id</span><span class=p>(</span><span class=n>cell</span><span class=p>),</span> <span class=nf>id</span><span class=p>(</span><span class=n>next_cell</span><span class=p>),</span> <span class=kc>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to return the positions of the child nodes of an Obstacles node as an array</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>get_obstacles</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=nc>Array</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># An array containing the grid coordinates of the cell where the obstacle is located</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>obstacle_cells</span> <span class=o>=</span> <span class=p>[]</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over all child nodes of Obstacles (Obstacle instances)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>child</span> <span class=ow>in</span> <span class=n>obstacles</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=c1># Add the grid coordinates of obstacles to the prepared array</span>
</span></span><span class=line><span class=cl>		<span class=n>obstacle_cells</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=nf>world_to_map</span><span class=p>(</span><span class=n>child</span><span class=o>.</span><span class=n>global_position</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=c1># Return an array as a return value</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>obstacle_cells</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to invalidate points of AStar</span>
</span></span><span class=line><span class=cl><span class=c1># Pass an array whose elements are the grid coordinates of the cell as an argument</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>disable_points</span><span class=p>(</span><span class=n>target_cells</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over the elements of the argument array (cell grid coordinates)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>cell</span> <span class=ow>in</span> <span class=n>target_cells</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># disable the point of AStar corresponding to the cell</span>
</span></span><span class=line><span class=cl>		<span class=n>astar</span><span class=o>.</span><span class=nf>set_point_disabled</span><span class=p>(</span><span class=nf>id</span><span class=p>(</span><span class=n>cell</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to update the shortest path (array of points to pass) for the Player to move</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>update_path</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>end</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># Find the shortest path from the starting point of the argument to the destination point in AStar</span>
</span></span><span class=line><span class=cl>	<span class=n>path</span> <span class=o>=</span> <span class=n>astar</span><span class=o>.</span><span class=nf>get_point_path</span><span class=p>(</span><span class=nf>id</span><span class=p>(</span><span class=n>start</span><span class=p>),</span> <span class=nf>id</span><span class=p>(</span><span class=n>end</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to generate ID from grid coordinates</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>id</span><span class=p>(</span><span class=n>point</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>a</span> <span class=o>=</span> <span class=n>point</span><span class=o>.</span><span class=n>x</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>b</span> <span class=o>=</span> <span class=n>point</span><span class=o>.</span><span class=n>y</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span> <span class=o>+</span> <span class=n>b</span>
</span></span></code></pre></div><br><p>This will add AStar points to the coordinates of the cell where the tile is placed in the &ldquo;Board (TileMap)&rdquo; node, and each point will be connected by a line. Furthermore, the points that correspond to the coordinates of the &ldquo;Obstacle&rdquo; instance are deactivated, and the lines connecting them are also deactivated. The network of AStar finally formed in this way is used as a route.</p><p>The <code>update_path()</code> method will be called in the script of the &ldquo;Game&rdquo; node. When calling this method, pass the current position and the destination position of the &ldquo;Player&rdquo; node to the arguments <code>start</code> and <code>end</code>, respectively, and the Player node will move along the shortest path on the AStar network that has been formed.</p><p>Of course, the positions of the &ldquo;Obstacle&rdquo; instances is not connected to the line because the AStar points are disabled, so the Player node cannot move to the positions.</p><p>It may be difficult to visualize the AStar points and lines, so I will attach a script to &ldquo;AStarVisualizer&rdquo; to visualize them.<br><br></p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><h3 id=attach-a-script-to-the-astarvisualizer-control-node>Attach a script to the &ldquo;AStarVisualizer (Control)&rdquo; node</h3><p>To visualize AStar points and lines, attach a script to &ldquo;AStarVisualizer&rdquo; and edit the code as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Control</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>board</span><span class=p>:</span> <span class=nc>TileMap</span> <span class=o>=</span> <span class=nf>get_parent</span><span class=p>()</span><span class=o>.</span><span class=nf>get_node</span><span class=p>(</span><span class=s2>&#34;Board&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>astar</span><span class=p>:</span> <span class=nc>AStar2D</span> <span class=o>=</span> <span class=n>board</span><span class=o>.</span><span class=n>astar</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>offset</span><span class=p>:</span> <span class=nc>Vector2</span> <span class=o>=</span> <span class=n>board</span><span class=o>.</span><span class=n>half_cell_size</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Call the _draw() function when a node is loaded into the scene tree</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=nf>_draw</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Override built-in function _draw() to draw AStar points and lines on the screen</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_draw</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over all points (IDs) in AStar</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>point</span> <span class=ow>in</span> <span class=n>astar</span><span class=o>.</span><span class=nf>get_points</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=c1># Skip the next step if the point is deactivated</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>astar</span><span class=o>.</span><span class=nf>is_point_disabled</span><span class=p>(</span><span class=n>point</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;astar point is disabled&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>        <span class=c1># Convert from AStar points (IDs) to grid coordinates</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>cell</span> <span class=o>=</span> <span class=n>astar</span><span class=o>.</span><span class=nf>get_point_position</span><span class=p>(</span><span class=n>point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># Convert from grid coordinates to world coordinates</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>pos</span> <span class=o>=</span> <span class=n>board</span><span class=o>.</span><span class=nf>map_to_world</span><span class=p>(</span><span class=n>cell</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># Draw the world coordinate of the point of AStar shifted from the upper left corner of the cell to the center</span>
</span></span><span class=line><span class=cl>		<span class=nf>draw_circle</span><span class=p>(</span><span class=n>pos</span> <span class=o>+</span> <span class=n>offset</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=nc>Color</span><span class=o>.</span><span class=n>white</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>        <span class=c1># Get all the points (IDs) connected to the acquired AStar point</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>point_connections</span> <span class=o>=</span> <span class=n>astar</span><span class=o>.</span><span class=nf>get_point_connections</span><span class=p>(</span><span class=n>point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># Array to store all connected points as world coordinates</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>connected_positions</span> <span class=o>=</span> <span class=p>[]</span><span class=o>.</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>        <span class=c1># Loop over connected points</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>connected_point</span> <span class=ow>in</span> <span class=n>point_connections</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># If connected points are deactivated, skip this step</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>astar</span><span class=o>.</span><span class=nf>is_point_disabled</span><span class=p>(</span><span class=n>connected_point</span><span class=p>):</span>
</span></span><span class=line><span class=cl>				<span class=nb>print</span><span class=p>(</span><span class=s2>&#34;connected point is disabled&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>				<span class=k>continue</span>
</span></span><span class=line><span class=cl>            <span class=c1># Convert IDs of connected points to grid coordinates</span>
</span></span><span class=line><span class=cl>			<span class=kd>var</span> <span class=n>connected_cell</span> <span class=o>=</span> <span class=n>astar</span><span class=o>.</span><span class=nf>get_point_position</span><span class=p>(</span><span class=n>connected_point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=c1># Convert grid coordinates to world coordinates</span>
</span></span><span class=line><span class=cl>            <span class=kd>var</span> <span class=n>connected_pos</span> <span class=o>=</span> <span class=n>board</span><span class=o>.</span><span class=nf>map_to_world</span><span class=p>(</span><span class=n>connected_cell</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># Add world coordinates to array</span>
</span></span><span class=line><span class=cl>			<span class=n>connected_positions</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=n>connected_pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>        <span class=c1># Loop through the elements of the array of world coordinates of connected points</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>connected_pos</span> <span class=ow>in</span> <span class=n>connected_positions</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Draw a line connecting the original point and the connected points</span>
</span></span><span class=line><span class=cl>			<span class=nf>draw_line</span><span class=p>(</span><span class=n>pos</span> <span class=o>+</span> <span class=n>offset</span><span class=p>,</span> <span class=n>connected_pos</span> <span class=o>+</span> <span class=n>offset</span><span class=p>,</span> <span class=nc>Color</span><span class=o>.</span><span class=n>white</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span>
</span></span></code></pre></div><br><p>With this script, the AStar points and lines are drawn on the screen and the AStar network can now be visualized. When you run the project, you should see the following.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img13.png alt="run project"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><h3 id=attaching-scripts-to-the-game-node>Attaching scripts to the Game node</h3><p>The last step is to code the &ldquo;Player&rdquo; node to move when the mouse is pressed.</p><p>After attaching the script to the &ldquo;Game&rdquo; root node, edit the code as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Referencing the Board node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>board</span> <span class=o>=</span> <span class=nx>$Board</span>
</span></span><span class=line><span class=cl><span class=c1># Referencing the Line node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>line</span> <span class=o>=</span> <span class=nx>$Line</span>
</span></span><span class=line><span class=cl><span class=c1># Referencing the Player node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>player</span> <span class=o>=</span> <span class=nx>$Player</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_input</span><span class=p>(</span><span class=n>event</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># If the left mouse button is clicked</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>event</span><span class=o>.</span><span class=nf>is_action_pressed</span><span class=p>(</span><span class=s2>&#34;move_to&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Get grid coordinates from mouse cursor world coordinates as destination</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>target_cell</span> <span class=o>=</span> <span class=n>board</span><span class=o>.</span><span class=nf>world_to_map</span><span class=p>(</span><span class=nf>get_global_mouse_position</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=c1># Generate ID from the grid coordinates of the target cell</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>target_cell_id</span> <span class=o>=</span> <span class=n>board</span><span class=o>.</span><span class=nf>id</span><span class=p>(</span><span class=n>target_cell</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># If the ID is contained in a valid point for AStar</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>board</span><span class=o>.</span><span class=n>astar</span><span class=o>.</span><span class=nf>has_point</span><span class=p>(</span><span class=n>target_cell_id</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># Get the coordinates of the cell on the tile map from the Player&#39;s world coordinates</span>
</span></span><span class=line><span class=cl>			<span class=kd>var</span> <span class=n>player_cell</span> <span class=o>=</span> <span class=n>board</span><span class=o>.</span><span class=nf>world_to_map</span><span class=p>(</span><span class=n>player</span><span class=o>.</span><span class=n>global_position</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># Update the path from Player&#39;s cell to the destination cell</span>
</span></span><span class=line><span class=cl>			<span class=n>board</span><span class=o>.</span><span class=nf>update_path</span><span class=p>(</span><span class=n>player_cell</span><span class=p>,</span> <span class=n>target_cell</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># Call a method to move the Player node</span>
</span></span><span class=line><span class=cl>			<span class=nf>move</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to move the Player&#39;s piece</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>move</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Disable the input process so that no click operations are possible during the move</span>
</span></span><span class=line><span class=cl>	<span class=nf>set_process_input</span><span class=p>(</span><span class=kc>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># Draw the path of the Line node by looping through the grid coordinates of the path points</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>point</span> <span class=ow>in</span> <span class=n>board</span><span class=o>.</span><span class=n>path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Convert grid coordinates to world coordinates and add to path of Line node</span>
</span></span><span class=line><span class=cl>		<span class=n>line</span><span class=o>.</span><span class=nf>add_point</span><span class=p>(</span><span class=n>board</span><span class=o>.</span><span class=nf>map_to_world</span><span class=p>(</span><span class=n>point</span><span class=p>)</span> <span class=o>+</span> <span class=n>board</span><span class=o>.</span><span class=n>half_cell_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># Move Player node by looping through path in grid coordinates of the path points</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>point</span> <span class=ow>in</span> <span class=n>board</span><span class=o>.</span><span class=n>path</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Convert the grid coordinates of the point to world coordinates and overwrite the position of the Player node with it</span>
</span></span><span class=line><span class=cl>		<span class=n>player</span><span class=o>.</span><span class=n>global_position</span> <span class=o>=</span> <span class=n>board</span><span class=o>.</span><span class=nf>map_to_world</span><span class=p>(</span><span class=n>point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># Wait 0.1 seconds</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.1</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Clear the points in the path of the Line node when move is complete</span>
</span></span><span class=line><span class=cl>	<span class=n>line</span><span class=o>.</span><span class=nf>clear_points</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Enable input process</span>
</span></span><span class=line><span class=cl>	<span class=nf>set_process_input</span><span class=p>(</span><span class=kc>true</span><span class=p>)</span>
</span></span></code></pre></div><p>With this script, the &ldquo;Player&rdquo; node can be moved by left mouse click. The AStar algorithm determines the shortest path from the grid coordinates where the &ldquo;Player&rdquo; node is located to the grid coordinates where the mouse cursor overlaps when left-clicked, and moves the &ldquo;Player&rdquo; node along that path.</p><p>If you run the project, you should see the following GIF image.<br><img loading=lazy src=/images/tutorials/gd0017_2d_astar_path_finding/img14.gif alt="run project"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=conclusion>Conclusion</h2><p>In this article, I introduced a grid-based 2D path finding using the AStar algorithm. The project we have created should work equally well with different placement of tiles and obstacles.</p><p>Finally, let me summarize the main points of this tutorial.</p><ul><li>Godot provides the AStar class, so we can use it.</li><li>Convert world coordinates ‚áÑ grid coordinates ‚áÑ ID as appropriate.</li><li>The sequence of path finding is as follows:<ol><li>Add a point of AStar.</li><li>Connect adjacent points of AStar.</li><li>Disable AStar points that overlap with obstacles.<br>*Of course, you can also add only points excluding obstacles in step 1.</li><li>Derive the shortest path between the current location and the destination location using the AStar algorithm.</li></ol></li></ul><p>Also, you may be able to make an interesting game by adding the following arrangement.</p><ul><li>Randomly generate tiles and obstacles.</li><li>Place and move multiple characters on the board, both friend and foe.</li><li>In addition to the four directions of up, down, left, right, it is also possible to move diagonally.</li></ul><hr><h2 id=references>References</h2><p>The following resources were very helpful in preparing this article.</p><ul><li><a href=https://youtu.be/EPkaQFyEGQg target=_blank>YouTube - A* TileMap for Grid-Based PATHFINDING in Godot / HeartBeast</a></li><li><a href=https://youtu.be/dVNH6mIDksQ target=_blank>YouTube - A* Path-Finding for Grid-Based Tilemap in Godot / AndOne</a></li><li><a href=https://youtu.be/VQqSlXPa6QY target=_blank>YouTube - 2D Grid-Based Pathfinding (AStar) - Godot Tutorial / GamemakerPixel</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_astar2d.html target=_blank>Godot Docs - AStar2D</a></li><li><a href=https://www.kenney.nl/assets/board-game-icons target=_blank>KENNEY - Board Game Icons</a></li><li><a href=https://en.wikipedia.org/wiki/A*_search_algorithm target=_blank>Wikipedia - A*</a></li></ul><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ 2D Grid Based Path Finding in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%202D%20Grid%20Based%20Path%20Finding%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0017_2d_grid_based_path_finding%2f&amp;hashtags=GameDev%2cGodotEngine%2cGodot3%2c2D%2cGridBased%2cPathFinding%2cAStar"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ 2D Grid Based Path Finding in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0017_2d_grid_based_path_finding%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/gridbased/>GridBased</a></li><li><a href=https://www.peanuts-code.com/en/tags/pathfinding/>PathFinding</a></li><li><a href=https://www.peanuts-code.com/en/tags/astar/>AStar</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/en/tutorials/gd0018_melee_attacks/><span class=title>¬´ Prev</span><br><span>ü§ñ 2D Hit Detection for Melee Attacks in Godot3</span>
</a><a class=next href=https://www.peanuts-code.com/en/posts/post0004_my_first_game_jam/><span class=title>Next ¬ª</span><br><span>üìî Grow with game jams</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/en/>Peanuts Code</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>