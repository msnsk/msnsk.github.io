<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ü§ñ Match 3 Puzzle Game in Godot3 | Peanuts Code</title>
<meta name=keywords content="GodotEngine,GameDev,2D,PuzzleGame,MobileGame,Match3"><meta name=description content="In this tutorial, we will create a match 3 puzzle game. Match 3 is a puzzle game in which players move multiple colorful pieces evenly arranged along a grid on the board to eliminate three or more pieces of the same color in a row. This genre is particularly popular among mobile game players because it is easy to operate and enjoyable.
Candy Crush, Toon Blast, and Royal Match are just a few examples of popular games. Puzzle & Dragons and LINE Tsum Tsum are also based on Match 3, although the controls are slightly different. In this tutorial, we will create a puzzle like Candy Crush, in which the pieces are moved only one square at a time to match colors. If you want to make a game like &ldquo;LINE tsum tsum&rdquo;, check another tutorial, Connecting matching colors puzzle game in Godot
.
The final project file for this tutorial is located at GitHub repository
. If you download the .zip file and import the &ldquo;project.godot&rdquo; file in the &ldquo;End&rdquo; folder with the Godot Engine, you can check the project directly."><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/en/tutorials/gd0012_match3/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0012_match3/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0012_match3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://www.peanuts-code.com/en/tutorials/gd0012_match3/"><meta property="og:site_name" content="Peanuts Code"><meta property="og:title" content="ü§ñ Match 3 Puzzle Game in Godot3"><meta property="og:description" content="In this tutorial, we will create a match 3 puzzle game. Match 3 is a puzzle game in which players move multiple colorful pieces evenly arranged along a grid on the board to eliminate three or more pieces of the same color in a row. This genre is particularly popular among mobile game players because it is easy to operate and enjoyable.
Candy Crush, Toon Blast, and Royal Match are just a few examples of popular games. Puzzle & Dragons and LINE Tsum Tsum are also based on Match 3, although the controls are slightly different. In this tutorial, we will create a puzzle like Candy Crush, in which the pieces are moved only one square at a time to match colors. If you want to make a game like ‚ÄúLINE tsum tsum‚Äù, check another tutorial, Connecting matching colors puzzle game in Godot .
The final project file for this tutorial is located at GitHub repository . If you download the .zip file and import the ‚Äúproject.godot‚Äù file in the ‚ÄúEnd‚Äù folder with the Godot Engine, you can check the project directly."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-07-02T06:05:00+09:00"><meta property="article:modified_time" content="2022-07-02T06:05:00+09:00"><meta property="article:tag" content="GodotEngine"><meta property="article:tag" content="GameDev"><meta property="article:tag" content="2D"><meta property="article:tag" content="PuzzleGame"><meta property="article:tag" content="MobileGame"><meta property="article:tag" content="Match3"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0012_match3/img20.gif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0012_match3/img20.gif"><meta name=twitter:title content="ü§ñ Match 3 Puzzle Game in Godot3"><meta name=twitter:description content="In this tutorial, we will create a match 3 puzzle game. Match 3 is a puzzle game in which players move multiple colorful pieces evenly arranged along a grid on the board to eliminate three or more pieces of the same color in a row. This genre is particularly popular among mobile game players because it is easy to operate and enjoyable.
Candy Crush, Toon Blast, and Royal Match are just a few examples of popular games. Puzzle & Dragons and LINE Tsum Tsum are also based on Match 3, although the controls are slightly different. In this tutorial, we will create a puzzle like Candy Crush, in which the pieces are moved only one square at a time to match colors. If you want to make a game like &ldquo;LINE tsum tsum&rdquo;, check another tutorial, Connecting matching colors puzzle game in Godot
.
The final project file for this tutorial is located at GitHub repository
. If you download the .zip file and import the &ldquo;project.godot&rdquo; file in the &ldquo;End&rdquo; folder with the Godot Engine, you can check the project directly."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ü§ñ Tutorials","item":"https://www.peanuts-code.com/en/tutorials/"},{"@type":"ListItem","position":2,"name":"ü§ñ Match 3 Puzzle Game in Godot3","item":"https://www.peanuts-code.com/en/tutorials/gd0012_match3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ü§ñ Match 3 Puzzle Game in Godot3","name":"ü§ñ Match 3 Puzzle Game in Godot3","description":"In this tutorial, we will create a match 3 puzzle game. Match 3 is a puzzle game in which players move multiple colorful pieces evenly arranged along a grid on the board to eliminate three or more pieces of the same color in a row. This genre is particularly popular among mobile game players because it is easy to operate and enjoyable.\nCandy Crush, Toon Blast, and Royal Match are just a few examples of popular games. Puzzle \u0026amp; Dragons and LINE Tsum Tsum are also based on Match 3, although the controls are slightly different. In this tutorial, we will create a puzzle like Candy Crush, in which the pieces are moved only one square at a time to match colors. If you want to make a game like \u0026ldquo;LINE tsum tsum\u0026rdquo;, check another tutorial, Connecting matching colors puzzle game in Godot .\nThe final project file for this tutorial is located at GitHub repository . If you download the .zip file and import the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;End\u0026rdquo; folder with the Godot Engine, you can check the project directly.\n","keywords":["GodotEngine","GameDev","2D","PuzzleGame","MobileGame","Match3"],"articleBody":"In this tutorial, we will create a match 3 puzzle game. Match 3 is a puzzle game in which players move multiple colorful pieces evenly arranged along a grid on the board to eliminate three or more pieces of the same color in a row. This genre is particularly popular among mobile game players because it is easy to operate and enjoyable.\nCandy Crush, Toon Blast, and Royal Match are just a few examples of popular games. Puzzle \u0026 Dragons and LINE Tsum Tsum are also based on Match 3, although the controls are slightly different. In this tutorial, we will create a puzzle like Candy Crush, in which the pieces are moved only one square at a time to match colors. If you want to make a game like ‚ÄúLINE tsum tsum‚Äù, check another tutorial, Connecting matching colors puzzle game in Godot .\nThe final project file for this tutorial is located at GitHub repository . If you download the .zip file and import the ‚Äúproject.godot‚Äù file in the ‚ÄúEnd‚Äù folder with the Godot Engine, you can check the project directly.\nEnvironment This tutorial was created in the following environment\n„ÉªGodot version: 3.4.4\n„ÉªComputer OS version: macOS 11.6.5\nMemo: Please also use the following articles to help you start creating your game.\nDownloading Godot Project Manager of Godot Creating a new project Start Godot Engine and create a new project. You can name your project as you like. If you can‚Äôt think of one, let‚Äôs call it ‚ÄúMatch3 Start‚Äù.\nUpdating project settings When the editor appears, let‚Äôs go ahead and update project settings for the entire project.\nFirst, set the display size for the game. In this case, we will assume a smartphone screen in portrait orientation and set the aspect ratio to 16 : 9.\nOpen the ‚ÄúProject‚Äù menu \u003e ‚ÄúProject Settings‚Äù. In the ‚ÄúGeneral‚Äù tab, search for ‚Äúwindow‚Äù and select ‚ÄúDisplay‚Äù \u003e ‚ÄúWindow‚Äù in the sidebar. In the ‚ÄúSize‚Äù section, change the values of the following items Width: 630 Height: 1120 Test Width: 315 Test Height: 560\nIn the ‚ÄúStretch‚Äù section, change the values of the following items Mode: 2d Aspect: keep\nWith the ‚ÄúProject Settings‚Äù window open as it is, configures the settings to substitute the mouse for the phone‚Äôs touch operation in the debug panel.\nSearch for ‚Äúmouse‚Äù in the ‚ÄúGeneral‚Äù tab and select ‚ÄúInput Devices‚Äù \u003e ‚ÄúPointing‚Äù in the sidebar. Check ‚ÄúOn‚Äù for ‚ÄúEmulate Touch From Mouse‚Äù.\nIn addition, with the ‚ÄúProject Settings‚Äù window open, add an action to the input map corresponding to a smartphone touch operation.\nSwitch to the ‚ÄúInput Map‚Äù tab and add ‚Äútouch‚Äù to the action. Add a left mouse click to the ‚Äútouch‚Äù action.\nDownloading and importing assets Next, let‚Äôs download assets from KENNEY‚Äôs site and use them. This time, we will use an asset pack called ‚ÄúPhysics Assets ‚Äù. I‚Äôm going to use the cute alien face images in this asset pack as textures for the pieces on the game board. I can‚Äôt help but be thankful for this wonderful free resource.\nAfter downloading, delete the images in the ‚Äú/physicspack/PNG/Aliens‚Äù folder, leaving only the one with the file name ‚Äú~_round.png‚Äù and drag the ‚ÄúAliens‚Äù folder into the file system dock of the editor to import it into your project.\nCreating a Grid scene First, let‚Äôs create a ‚ÄúGrid‚Äù scene as the board on which the pieces are placed in a match 3 puzzle game.\nSelect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Scene‚Äù. Select ‚Äú2D Scene‚Äù in ‚ÄúGenerate Root Node‚Äù. When the root node of the ‚ÄúNode2D‚Äù class is generated, rename it to ‚ÄúGrid‚Äù. Save the scene. Create a folder and save the scene with the file path ‚Äúres://Grid/Grid.tscn‚Äù.\nAdding a node to the Grid scene Let‚Äôs add another child node of class ‚ÄúNode2D‚Äù to the ‚ÄúGrid‚Äù root node and rename it to ‚ÄúPiecesContainer‚Äù. This node is used to organize the pieces placed on the board. During the game, when instances of the pieces are created by the script, they will all be added as children of this ‚ÄúPiecesContainer‚Äù node.\nThe scene tree dock should now look like the following.\nNote that there is no need to edit the properties of the ‚ÄúGrid‚Äù scene node.\nTranslated with www.DeepL.com/Translator (free version)\nCreating a Piece scene Next, create a ‚ÄúPiece‚Äù scene for the pieces to be placed on the board. However, this ‚ÄúPiece‚Äù scene is only a blueprint, and the actual pieces of each color to be used in the game will be prepared later by inheriting this ‚ÄúPiece‚Äù scene.\nSelect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Scene‚Äù. Select ‚Äú2D Scene‚Äù in the ‚ÄúCreate Root Node‚Äù section. When the root node of ‚ÄúNode2D‚Äù class is generated, rename it to ‚ÄúPiece‚Äù. Save the scene. Create a folder and save the scene with the file path ‚Äúres://Pieces/Piece.tscn‚Äù.\nAdding a child node to the Piece node Let‚Äôs add a child node of class ‚ÄúSprite‚Äù to the ‚ÄúPiece‚Äù root node. The scene tree dock should now look like the following.\nEditing the properties of the Sprite node Let‚Äôs edit a few properties of the ‚ÄúSprite‚Äù node. As mentioned above, the ‚ÄúPiece‚Äù is only a blueprint, so we will leave the ‚ÄúTexture‚Äù property of the ‚ÄúSprite‚Äù node as it is without applying any resources to it in this scene. In the inherited scene, apply an image that matches the color of each piece.\nChange the value of the ‚ÄúOffset‚Äù property to ‚Äú(x: 35, y: -35)‚Äù. In the scene of each piece of color that inherits this scene, we will apply the KENNEY image imported earlier to the ‚ÄúTexture‚Äù property. Since the size of the image is 70 px in height and width, we shifted the center of the image to the upper right and set the lower left corner of the image to (x: 0, y: 0).\nThe grid of the board on which the pieces are placed is set to count from left to right on the x-axis and from bottom to top on the y-axis, and the size of one grid on the board is set to 70 px to match the size of the texture. If the lower left corner of the piece‚Äôs texture image is aligned with (x: 0, y: 0), then when the ‚ÄúPiece‚Äù root node is positioned (x: 0, y: 0) to the grid, the ‚ÄúSprite‚Äù image will be placed exactly along the grid.\nAttaching and editing a script to the Piece node Let‚Äôs attach a new script to the ‚ÄúPiece‚Äù root node. Create a script file with the file path ‚Äúres://Pieces/Piece.tscn‚Äù.\nEdit the script as follows.\nextends Node2D # Property to set the color of the piece as string data export (String) var color # Property to indicate matched (3 or more of the same color in a row) var matched = false # Reference to a Sprite node onready var sprite = $Sprite # Method to move a piece # Move the Piece instance to the position passed in the target argument func move(target): position = target # Method called when a match is found (3 or more of the same color in a row) # Set the matched property to true and make the color translucent func make_matched(): matched = true sprite.modulate = Color(1,1,1,.5) This completes the editing of the ‚ÄúPiece.gd‚Äù script.\nCreating a scene for each color that inherits from the Piece scene Now that the ‚ÄúPiece‚Äù scene, which will serve as a template, is complete, let‚Äôs create a scene that inherits the ‚ÄúPiece‚Äù scene in the number of colors of the piece. There are five Piece colors: beige, blue, green, pink, and yellow. First, let‚Äôs proceed with the steps using the ‚Äúbeige‚Äù drop as an example.\nSelect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Inherited Scene‚Äù. Select ‚ÄúPiece.tscn‚Äù as the source scene. After the inherited scene is generated, rename the root node to ‚ÄúPieceBeige‚Äù.\n*The name of this root node should match the color of each drop. Save the scene once. Save the file path as ‚Äúres://Pieces/PieceBeige.tscn‚Äù. With the root node ‚ÄúPieceBeige‚Äù selected in the scene tree dock, set the value of the ‚ÄúColor‚Äù property of ‚ÄúScript Variables‚Äù to ‚Äúbeige‚Äù in the inspector.\nSelect the ‚ÄúSprite‚Äù node in the scene tree dock and apply the previously imported resource ‚Äúres://Aliens/alienBeige_round.png‚Äù to the ‚ÄúTexture‚Äù property (you can drag it from the file system dock).\nOn the 2D workspace it should now look like the following screenshot.\nThe ‚ÄúPieceBeige‚Äù scene is now complete. Follow the same procedure to create scenes for the remaining four colored pieces. Please refer to the following for details on the different parts of each scene. Blue Piece Root node name: PieceBlue Color property: blue Sprite \u003e Texture property: res://Aliens/alienBlue_round.png File path when saving the scene: res://Pieces/PieceBlue.tscn Green Piece Root node name: PieceGreen Color property: green Sprite \u003e Texture property: res://Aliens/alienGreen_round.png File path when saving the scene: res://Pieces/PieceGreen.tscn Pink Piece Root node name: PiecePink Color property: green Sprite \u003e Texture property: res://Aliens/alienPink_round.png File path when saving the scene: res://Pieces/PiecePink.tscn Yellow Piece Root node name: PieceYellow Color property: yellow Sprite \u003e Texture property: res://Aliens/alienYellow_round.png File path when saving the scene: res://Pieces/PieceYellow.tscn When the inherited scenes of all 5 colored pieces have been created, the work is complete.\nControlling the Grid scene with scripts Now that we have created a scene for each color piece, we can now program and control the game. The amount of code is a bit large this time, so let‚Äôs do our best.\nAfter switching to the ‚ÄúGrid.tscn‚Äù scene, attach a new script to the ‚ÄúGrid‚Äù root node. The file path should be ‚Äúres://Grid/Grid.gd‚Äù.\nIn the comments in the script, ‚Äúfinger touched‚Äù or ‚Äúfinger released‚Äù should be replaced with ‚Äúleft mouse button pressed‚Äù or ‚Äúleft mouse button released‚Äù on the Godot debug panel.\nAlso, please note that ‚Äúmatch‚Äù is defined as three or more of the same color.\nNow, once the script editor is open, let‚Äôs define the necessary properties.\n### Grid.gd ### extends Node2D # An array with scene files for each color piece as elements const pieces_scn = [ preload(\"res://Pieces/PieceBeige.tscn\"), preload(\"res://Pieces/PieceBlue.tscn\"), preload(\"res://Pieces/PieceGreen.tscn\"), preload(\"res://Pieces/PiecePink.tscn\"), preload(\"res://Pieces/PieceYellow.tscn\") ] # Number of grids in x-axis direction var width: = 7 # Number of grids in y-axis direction var height: = 10 # Grid start position (pixels) in x-axis direction var x_start: = 70 # Grid start position (pixels) in y-axis direction var y_start: = 910 # Size of one grid (should be the same as Texture of Sprite in Piece) var grid_size: = 70 # A two-dimensional array (initially empty) that manages all the pieces of the board as elements and their grid coordinates var all_pieces = []. # Position where finger touches the screen var touched_pos = Vector2() # The position where the finger leaves the screen var released_pos = Vector2() # State where finger is touching the screen, touched: true / away: false var is_touching = false # State of automatic processing of matching, processing: true / stopped: false var is_waiting = false # Referencing the PiecesContainer node onready var pieces_container = $PiecesContainer Then let‚Äôs add the following method. Note that the two-dimensional array that appears in the following code is an array that stores arrays as elements.\nIn the case of the two-dimensional array used in this script, the first level of the array contains as many empty arrays as the number of grids in the x-axis direction of the board, and the second level of the array contains as many elements as the number of vertical grids in each array. By storing piece objects as elements, it is possible to manage where each piece is located on the board (how many grids along the x-axis and how many grids along the y-axis).\n### Grid.gd ### # Function called when the scene is loaded func _ready(): # Method to randomize the output result of a function that generates a random number each time randomize() # Make all_pieces a 2d array that makes up the grid of the board all_pieces = make_2d_array() # define after this # Spawn the pieces and place them on each grid spawn_pieces() # define after this # Method to create a 2d array that makes up the grid of the board func make_2d_array(): # Prepare an array named array for output var array = []. # Fill the prepared array with the number of empty arrays for the number of grids along the x-axis for i in width: array.append([]) # Add a value of null for the number of grids in the y-axis to each array for j in height: array[i].append(null) # return the two-dimensional array return array # Method to spawn pieces and place them on each grid func spawn_pieces(): # Loop for the number of grids along the x-axis for i in width: # Loop over the number of grids in the y-axis for j in height: # If no piece exists in the corresponding grid on the 2D array of all pieces # (All null at the start of the game) if all_pieces[i][j] == null: # Randomly select one from the scenes of each color and instantiate it var index = floor(rand_range(0, pieces_scn.size())) var piece = pieces_scn[index].instance() # If it matches, delete the piece instance and start over while match_at(i, j, piece.color): # define after this piece.queue_free() index = floor(rand_range(0, pieces_scn.size())) piece = pieces_scn[index].instance() # Make a piece instance a child of a PiecesContainer node pieces_container.add_child(piece) # Place the piece instance at the position converted from grid to pixels piece.position = grid_to_pixel(i, j) # define after this # Update the 2D array of all pieces all_pieces[i][j] = piece Let‚Äôs define the match_at and grid_to_pixel methods in the above code.\n### Grid.gd ### # Method to check if 3 or more pieces of the same color are lined up at the specified grid position. # column is the grid position on the x-axis, row is the grid position on the y-axis, and color is the color of the piece func match_at(column, row, color): # If the x-axis value of the specified grid coordinate is 3 or greater if column \u003e= 2: # If there is a piece to the left of the specified grid coordinate and one more to the left if all_pieces[column-1][row] ! = null \\ and all_pieces[column-2][row] ! = null: # If the color of those pieces is the same as the color of the given piece if all_pieces[column-1][row].color == color \\ and all_pieces[column-2][row].color == color: # Return true return true # If the y-axis value of the specified grid coordinate is 3 or greater if row \u003e= 2: # If there are pieces below the specified grid coordinates and one more below if all_pieces[column][row-1] ! = null \\frz and all_pieces[column][row-2] ! = null: # If the color of those pieces is the same as the color of the given piece if all_pieces[column][row-1].color == color \\ and all_pieces[column][row-2].color == color: # return true return true # Method to convert grid position to pixel position func grid_to_pixel(column, row): # Define a Vector2 variable pixel_pos for pixel position output var pixel_pos = Vector2() # Pixel x-coordinate = grid start position along x-axis + grid size * grid x-coordinate pixel_pos.x = x_start + grid_size * column # Pixel y-coordinate = grid start position along y-axis - grid size * grid y-coordinate pixel_pos.y = y_start - grid_size * row # Return pixel position return pixel_pos Now the pieces of each color should be randomly arranged on the board at the start of the game. Let‚Äôs run the project once to check it out. If you are running the project for the first time, select ‚ÄúGrid.tscn‚Äù as the main scene when the dialog for selecting the main scene appears.\nSince we have just defined the grid_to_pixel method, we should also define the pixel_to_grid method to be used later. As the name suggests, this method is the opposite of grid_to_pixel defined earlier, and converts pixel positions to grid positions.\n### Grid.gd ### # Method to convert pixel position to grid position func pixel_to_grid(pixel_x, pixel_y) -\u003e Vector2: var grid_pos = Vector2() grid_pos.x = floor((pixel_x - x_start) / grid_size) grid_pos.y = floor((pixel_y - y_start) / -grid_size) return grid_pos In addition, we define one more method is_in_grid to be used later. This method determines whether the position passed as an argument is within the board grid and returns true or false.\n### Grid.gd ### # Method that returns whether the given position is in the grid or not. func is_in_grid(grid_position: Vector2): if grid_position.x \u003e= 0 and grid_position.x \u003c width \\ and grid_position.y \u003e= 0 and grid_position.y \u003c height # Return true if within the board grid return true else: # Return false if outside of the grid return false Here, we will write a program to handle the player‚Äôs input for the game.\n### Grid.gd ### # Function called every frame in the main loop of the game func _process(_delta): # If not in the process of matching if not is_waiting: # Process the player's input touch_input() # define after this # Method to process player input func touch_input(): # If a finger touches the screen if Input.is_action_just_pressed(\"touch\"): # Convert finger position from pixels to grid var start_pos = get_global_mouse_position() var start_grid = pixel_to_grid(start_pos.x, start_pos.y) # If the finger position is within the board grid if is_in_grid(start_grid): # Save the position where you touched your finger to the screen touched_pos = start_grid # Make the state with the finger touching the screen is_touching = true # If finger leaves the screen if Input.is_action_just_released(\"touch\"): # Convert finger position from pixels to grid var end_pos = get_global_mouse_position() var end_grid = pixel_to_grid(end_pos.x, end_pos.y) # If finger position is within the board grid... # and the state is with the finger touching the screen if Is_in_grid(end_grid) and is_touching: # Save as released position information released_pos = end_grid # Call a method that handles the movement of the piece at the touched and released positions touch_and_release() # define after this # State is finger off the screen is_touching = false In the above code, the touch_and_release method is called to acquire the position of the finger touching the screen and the position of the finger leaving the screen within the grid of the board, and to use this information to process the movement of the pieces.\nLet‚Äôs define this method and a helper method called swap_pieces that is called further in the method. A helper method is simply a method that is called within a method and serves to keep the parent method simple.\n### Grid.gd ### # Method that handles the movement of the piece using the position of the touched finger and the position of the released finger func touch_and_release(): # Calculate the difference between the position where the finger touched and the position where the finger released var difference = released_pos - touched_pos # If the absolute value of the difference along the x-axis is greater than the absolute value of the difference along the y-axis if abs(difference.x) \u003e abs(difference.y): # If difference along x-axis is greater than 0 if difference.x \u003e 0: # Call helper method to swap the piece at the touched position with the adjacent piece to the right swap_pieces(touched_pos, Vector2.RIGHT) # define after this # If the difference along the x-axis is less than 0 elif difference.x \u003c 0: # Call helper method to swap the piece at the touched position with the adjacent piece to the left swap_pieces(touched_pos, Vector2.LEFT) # defined after this # If the absolute difference along the x-axis is less than the absolute difference along the y-axis elif abs(difference.x) \u003c abs(difference.y): # If the difference along y-axis is greater than 0 if difference.y \u003e 0: # Call helper method to swap the piece at the touched position with the piece adjacent below swap_pieces(touched_pos, Vector2.DOWN) # define after this # If the difference along the y-axis is less than 0 elif difference.y \u003c 0: # Call helper method to swap the piece at the touched position with the one adjacent above it swap_pieces(touched_pos, Vector2.UP) # defined after this # Helper method to swap pieces func swap_pieces(pos, dir): # Get the piece at the touched position from the 2D array of all pieces var touched_piece = all_pieces[pos.x][pos.y]. # Get the piece adjacent to the piece in the direction of finger release from the 2D array of all pieces var target_piece = all_pieces[pos.x + dir.x][pos.y + dir.y] # If both pieces exist in the 2D array of all pieces if touched_piece ! = null and target_piece ! = null: # Overwrite the piece at the touched position in the 2D array of all pieces with the piece adjacent to the one you removed your finger from all_pieces[pos.x][pos.y] = target_piece # Overwrite the piece adjacent to the finger release position with the piece at the finger release position from the two-dimensional array of all pieces all_pieces[pos.x + dir.x][pos.y + dir.y] = touched_piece # Move the piece instance at the touched position on the board by 1 grid toward the one you removed your finger from touched_piece.move(grid_to_pixel(pos.x + dir.x, pos.y + dir.y)) # move the piece instance adjacent to the one you release your finger on the board to the position touched by your finger target_piece.move(grid_to_pixel(pos.x, pos.y)) # Set auto-processing state to \"processing in progress\" since processing of the matched piece starts here is_waiting = true With the above code, we have implemented a process whereby a piece dragged by the player is replaced by an adjacent piece.\nLet‚Äôs run the project to see if the input operation works correctly.\nFrom here, the process that should be executed automatically after the pieces are replaced is implemented. The general flow is as follows:\nChange the automatic processing state during processing. Check if there is at least one matched piece, and if so, loop through the following process. Check all pieces and flag matched pieces. Delete the flagged piece. Fill the empty space by moving a piece from the same column. After the pieces are packed down, a new piece is created in the empty space at the end. When there are no more matched pieces, the automatic processing state is stopped. Let‚Äôs code the general flow of the above.\nFirst, let‚Äôs add a line is_waiting = true at the end of the swap_pieces method that swaps the pieces defined earlier. This changes the automatic processing state to ‚Äúprocessing‚Äù.\n### Grid.gd ### func swap_pieces(pos, dir): var touched_piece = all_pieces[pos.x][pos.y] var target_piece = all_pieces[pos.x + dir.x][pos.y + dir.y] if touched_piece ! = null and target_piece ! = null: all_pieces[pos.x][pos.y] = target_piece all_pieces[pos.x + dir.x][pos.y + dir.y] = touched_piece touched_piece.move(grid_to_pixel(pos.x + dir.x, pos.y + dir.y)) target_piece.move(grid_to_pixel(pos.x, pos.y)) # Add the following # Set the auto-processing state to \"processing\" since this is where the automatic processing of the matched piece starts is_waiting = true Let‚Äôs write the if syntax ‚Äúif the state is in the process of executing automatic processing‚Äù in the touch_input method, and then add the processing we want to execute automatically in the block. The position for adding is just after the finger operation is finished. After the process is complete, let‚Äôs add a line is_waiting = false to set the automatic processing state to ‚Äústopped‚Äù.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\"touch\"): # Omit if Input.is_action_just_released(\"touch\"): # Omit # Add from here # If Input.is_action_just_pressed(\"touch\"): # omit if is_waiting: # Check if there is at least one pair of matched pieces \u003e loop as long as there are while check_matches(): # define after this pass # If no matched pieces are found and processing is complete, set autoprocessing state to waiting is_waiting = false A while loop is used to repeat the necessary process if there is at least one pair of matching pieces.\nFirst, define check_matches(), which is also the loop condition of the while loop, as follows.\n### Grid.gd ### # Method to check if there is at least one matched piece and return the result func check_matches() -\u003e bool: # Loop over the x-axis grid of the board for i in width: # Loop over the y-axis grid of the board for j in height: # if piece exists at that grid coordinate if all_pieces[i][j] ! = null: # return true if the piece matches at that grid coordinate, and method also terminates if match_at(i, j, all_pieces[i][j].color): return true # Check all pieces and return false if none of them match return false Then, let‚Äôs define the find_matches method to perform the ‚Äúfirst process in the while loop‚Äù, which is to check all the pieces and flag the matched ones, as follows. By ‚Äúflagging‚Äù here, I mean changing the value of the matched property of a piece instance to true.\n### Grid.gd ### # Find matching pieces and flag method func find_matches(): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of y-axis grids on the board for j in height: # If a piece exists at the coordinates of that grid if all_pieces[i][j] ! = null: # Define the current color as the color of that piece var current_color = all_pieces[i][j].color # If its x-axis coordinates are less than the number of x-axis grids - 2 if i \u003c width - 2: # If there are pieces to the right of that piece and further to its right if all_pieces[i+1][j] ! = null } and all_pieces[i+2][j] ! = null: # If the color of those pieces is the same as the current color if all_pieces[i+1][j].color == current_color \\ and all_pieces[i+2][j].color == current_color: # If the piece is not flagged if not all_pieces[i][j].matched: # Set the matched property of the piece to true to flag it # Make the piece's texture color translucent at the same time all_pieces[i][j].make_matched() # If the piece's right neighbor is not flagged if not all_pieces[i+1][j].matched: all_pieces[i+1][j].make_matched() # If the piece's two neighbors to the right are not flagged if not all_pieces[i+2][j].matched: all_pieces[i+2][j].make_matched() # If the piece's y-coordinate is less than the number of grids along the y-axis - 2 if j \u003c height - 2: # If there are pieces above and further to its above that piece if all_pieces[i][j+1] ! = null \\f} and all_pieces[i][j+2] ! = null: # If the color of those pieces is the same as the current color if all_pieces[i][j+1].color == current_color \\ and all_pieces[i][j+2].color == current_color: # If the piece is not flagged if not all_pieces[i][j].matched: # Set the matched property of the piece to true to flag it # Make the piece's texture color translucent at the same time all_pieces[i][j].make_matched() # If the piece above it is not flagged if not all_pieces[i][j+1].matched: all_pieces[i][j+1].make_matched() # If the piece two above it is not flagged if not all_pieces[i][j+2].matched: all_pieces[i][j+2].make_matched() We need to call this find_matches method in the while loop in the touch_input method, so let‚Äôs update it as follows.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\"touch\"): # Omit if Input.is_action_just_released(\"touch\"): # Omit if is_waiting: # Check if there is at least one pair of matched pieces \u003e loop as long as there are while check_matches(): # Find matched pieces and flag them find_matches() # Wait 0.3 seconds to make the process visually clear yield(get_tree().create_timer(0.3), \"timeout\") is_waiting = false Now the matched property of each matched piece instance should be true and the color of the piece should be translucent.\nLet‚Äôs run the project and check it out.\nNext, I would like you to define a delete_matches method that executes the second process ‚Äúdelete flagged pieces‚Äù in the while loop as follows.\n### Grid.gd ### # Method to delete matched pieces func delete_matches(): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of y-axis grids of the board for j in height: # If a piece exists at that grid coordinate if all_pieces[i][j] ! = null: # If a piece at that grid coordinate is flagged if all_pieces[i][j].matched: # Delete the piece at that grid coordinate all_pieces[i][j].queue_free() # Empty the element with that grid coordinate from the 2D array of all_pieces[i][j].queue_free() all_pieces[i][j] = null Let‚Äôs add this delete_matches method to the while loop of the touch_input method.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\"touch\"): # Omit if Input.is_action_just_released(\"touch\"): # Omit if is_waiting: # Check if there is at least one pair of matched pieces \u003e loop as long as there are while check_matches(): # Find matched pieces and flag them find_matches() # Wait 0.3 seconds to make the process visually clear yield(get_tree().create_timer(0.3), \"timeout\") # Delete flagged pieces delete_matches() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \"timeout\") # If no matched pieces are found and processing is complete, invalidate the in-process state is_waiting = false Now the matched pieces should become translucent and then be deleted.\nLet‚Äôs run the project and check it out.\nNext, I would like you to update the collapse_columns method that executes the third process in the while loop, ‚ÄúMove and pack pieces from the grid above the same column into the space vacated by the deletion‚Äù, as follows.\n### Grid.gd ### # Method to collapse a column by moving the piece above it in a space where no piece exists func collapse_columns(): # Loop over the number of x-axis grids in the board for i in width: # Loop over the number of y-axis grids in the board for j in height: # If no piece exists at that grid coordinate (null) if all_pieces[i][j] == null: # Loop from one row above the y-coordinate of that grid to the top row for k in range(j + 1, height): # If a piece exists on the grid one above if all_pieces[i][k] ! = null: # Move the piece on the grid above to an empty grid below all_pieces[i][k].move(grid_to_pixel(i, j)) # Put one piece above into the current grid coordinates of the 2D array of all_pieces all_pieces[i][j] = all_pieces[i][k]. # Empty the grid coordinate one above in the 2D array of all_pieces all_pieces[i][k] = null # Exit the loop break Let‚Äôs call this collapse_columns method inside the while loop of the touch_input method.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\"touch\"): # Omit if Input.is_action_just_released(\"touch\"): # Omit if is_waiting: # Check if there is at least one pair of matched pieces \u003e loop as long as there are while check_matches(): # Find matched pieces and flag them find_matches() # Wait 0.3 seconds to make the process visually clear yield(get_tree().create_timer(0.3), \"timeout\") # Delete flagged pieces delete_matches() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \"timeout\") # Move and collapse pieces on the same column into empty space collapse_columns() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \"timeout\") # If no matched pieces are found and processing is complete, invalidate the in-process state is_waiting = false Now we have an algorithm that fills the empty space with the piece above it after the piece has been deleted. The while loop should also continuously delete the matching piece after it has been stuffed into the empty space.\nLet‚Äôs run the project and check it out.\nFinally, if the spawn_pieces method is called after the pieces are packed down, new pieces will be placed in the empty space and the board will be filled. This method is already defined and called in the _ready method to place the pieces on the board at the beginning of the game.\nNow let‚Äôs update the touch_input method as follows.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\"touch\"): # Omit if Input.is_action_just_released(\"touch\"): # Omit if is_waiting: # Check if there is at least one pair of matched pieces \u003e loop as long as there are while check_matches(): # Find matched pieces and flag them find_matches() # Wait 0.3 seconds to make the process visually clear yield(get_tree().create_timer(0.3), \"timeout\") # Delete flagged pieces delete_matches() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \"timeout\") # Move and collapse pieces on the same column into empty space collapse_columns() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \"timeout\") # Spawn and place a new piece in an empty space spawn_pieces() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \"timeout\") # If no matched pieces are found and processing is complete, invalidate the in-process state is_waiting = false This completes the coding of the automatic processing part. This is the end of this tutorial. Finally, let‚Äôs run the project to see how it works.\nSample Game We have prepared a sample game that is a brushed-up version of the project created in this tutorial. Note that the GIF images below are played at 3x speed, so they are actually a bit calmer.\nThe project file is located in the GitHub repository . Please download the .zip file from there and import the ‚Äúproject.godot‚Äù file in the ‚ÄúSample‚Äù folder and import it into Godot Engine.\nConclusion This time, we created a match 3 puzzle game. This is a perfect game genre for mobile games with simple controls that can be enjoyed over and over again.\nLet me summarize the key points when creating a simple match 3 puzzle game like this one.\nThere are only two minimum scenes required: the board and the pieces. Create a blueprint piece scene and then inherit it to create a piece scene for each color. Use a two-dimensional array to manage the pieces to be placed on the board grid. When replacing a piece, it is necessary to both replace the position of the piece on the screen and replace the elements of the two-dimensional array. The following are the key points of the script. The process of the player moving the pieces Get the position where the finger touches the screen and the position where the finger leaves the screen. Determine if the two positions are within the grid (valid operation). Determine the direction in which the pieces are swapped based on the difference between the two positions. Automatic processing (loop) when a match is made. Checks if there is at least one pair of matching pieces (loop condition). Flag the matched pieces. Delete flagged pieces (loop condition). Fill the space vacated by the removed piece with the piece above it. Create a new piece in the space vacated by the filling. Links KENNEY YouTube: Part 0: Why Godot? - Make a Match 3 game like Candy Crush Using Godot. Candy Crush Royal Match Toon Blast ","wordCount":"5671","inLanguage":"en","image":"https://www.peanuts-code.com/images/tutorials/gd0012_match3/img20.gif","datePublished":"2022-07-02T06:05:00+09:00","dateModified":"2022-07-02T06:05:00+09:00","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/en/tutorials/gd0012_match3/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/en/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/ja/ title=Japanese aria-label=üáØüáµÊó•Êú¨Ë™û>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/en/ title=Home><span>Home</span></a></li><li><a href=https://www.peanuts-code.com/en/portfolio/ title=Works><span>Works</span></a></li><li><a href=https://www.peanuts-code.com/en/posts/ title=Blogs><span>Blogs</span></a></li><li><a href=https://www.peanuts-code.com/en/tutorials/ title=Tutorials><span>Tutorials</span></a></li><li><a href=https://www.peanuts-code.com/en/about/ title=About><span>About</span></a></li><li><a href=https://www.peanuts-code.com/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/en/>Home</a>&nbsp;¬ª&nbsp;<a href=https://www.peanuts-code.com/en/tutorials/>ü§ñ Tutorials</a></div><h1 class="post-title entry-hint-parent">ü§ñ Match 3 Puzzle Game in Godot3</h1><div class=post-meta><span title='2022-07-02 06:05:00 +0900 +0900'>2022-07-02</span>&nbsp;¬∑&nbsp;12 min&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/ja/tutorials/gd0012_match3/>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Match 3 Puzzle Game in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Match%203%20Puzzle%20Game%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0012_match3%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cPuzzleGame%2cMobileGame%2cMatch3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Match 3 Puzzle Game in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0012_match3%2f&title=%f0%9f%a4%96%20Match%203%20Puzzle%20Game%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Match 3 Puzzle Game in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0012_match3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/puzzlegame/>PuzzleGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/mobilegame/>MobileGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/match3/>Match3</a></li></ul></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0012_match3/img20.gif alt="Match 3 Puzzle Game in Godot"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#creating-a-new-project>Creating a new project</a><ul><li><a href=#updating-project-settings>Updating project settings</a></li><li><a href=#downloading-and-importing-assets>Downloading and importing assets</a></li></ul></li><li><a href=#creating-a-grid-scene>Creating a Grid scene</a><ul><li><a href=#adding-a-node-to-the-grid-scene>Adding a node to the Grid scene</a></li></ul></li><li><a href=#creating-a-piece-scene>Creating a Piece scene</a><ul><li><a href=#adding-a-child-node-to-the-piece-node>Adding a child node to the Piece node</a></li><li><a href=#editing-the-properties-of-the-sprite-node>Editing the properties of the Sprite node</a></li><li><a href=#attaching-and-editing-a-script-to-the-piece-node>Attaching and editing a script to the Piece node</a></li></ul></li></ul><ul><li><a href=#controlling-the-grid-scene-with-scripts>Controlling the Grid scene with scripts</a></li><li><a href=#sample-game>Sample Game</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#links>Links</a></li></ul></nav></div></details></div><div class=post-content><p>In this tutorial, we will create a match 3 puzzle game. Match 3 is a puzzle game in which players move multiple colorful pieces evenly arranged along a grid on the board to eliminate three or more pieces of the same color in a row. This genre is particularly popular among mobile game players because it is easy to operate and enjoyable.</p><p>Candy Crush, Toon Blast, and Royal Match are just a few examples of popular games. Puzzle & Dragons and LINE Tsum Tsum are also based on Match 3, although the controls are slightly different. In this tutorial, we will create a puzzle like Candy Crush, in which the pieces are moved only one square at a time to match colors. If you want to make a game like &ldquo;LINE tsum tsum&rdquo;, check another tutorial, <a href=https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/ title="Connecting matching colors puzzle game in Godot">Connecting matching colors puzzle game in Godot</a>
.</p><p>The final project file for this tutorial is located at <strong><a href=https://github.com/msnsk/Match3.git target=_blank>GitHub repository</a>
</strong>. If you download the .zip file and import the &ldquo;project.godot&rdquo; file in the &ldquo;End&rdquo; folder with the Godot Engine, you can check the project directly.</p><br><blockquote><p><em><strong><span style=color:salmon>Environment</span></strong><br>This tutorial was created in the following environment</em><br>„Éª<em>Godot version: <strong>3.4.4</strong></em><br>„Éª<em>Computer OS version: <strong>macOS 11.6.5</strong></em></p></blockquote><blockquote><p><em><strong><span style=color:salmon>Memo:</span></strong><br>Please also use the following articles to help you start creating your game.<br><a href=https://www.peanuts-code.com/en/tutorials/gd0001_download/>Downloading Godot</a><br><a href=https://www.peanuts-code.com/en/tutorials/gd0002_project_manager/>Project Manager of Godot</a></em><br><br></p></blockquote><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-new-project>Creating a new project</h2><p>Start Godot Engine and create a new project. You can name your project as you like. If you can&rsquo;t think of one, let&rsquo;s call it &ldquo;Match3 Start&rdquo;.</p><br><h3 id=updating-project-settings>Updating project settings</h3><p>When the editor appears, let&rsquo;s go ahead and update project settings for the entire project.</p><p>First, set the display size for the game. In this case, we will assume a smartphone screen in portrait orientation and set the aspect ratio to <strong>16 : 9</strong>.</p><ol><li>Open the &ldquo;Project&rdquo; menu > &ldquo;Project Settings&rdquo;.</li><li>In the &ldquo;General&rdquo; tab, search for &ldquo;window&rdquo; and select &ldquo;Display&rdquo; > &ldquo;Window&rdquo; in the sidebar.</li><li>In the &ldquo;Size&rdquo; section, change the values of the following items<ul><li>Width: 630</li><li>Height: 1120</li><li>Test Width: 315</li><li>Test Height: 560<br><img alt="project settings - Display - Window - Size" loading=lazy src=/images/tutorials/gd0012_match3/img1.png></li></ul></li><li>In the &ldquo;Stretch&rdquo; section, change the values of the following items<ul><li>Mode: 2d</li><li>Aspect: keep<br><img alt="project settings - Display - Window - Stretch" loading=lazy src=/images/tutorials/gd0012_match3/img2.png></li></ul></li></ol><br><p>With the &ldquo;Project Settings&rdquo; window open as it is, configures the settings to substitute the mouse for the phone&rsquo;s touch operation in the debug panel.</p><ol><li>Search for &ldquo;mouse&rdquo; in the &ldquo;General&rdquo; tab and select &ldquo;Input Devices&rdquo; > &ldquo;Pointing&rdquo; in the sidebar.</li><li>Check &ldquo;On&rdquo; for &ldquo;Emulate Touch From Mouse&rdquo;.<br><img alt="Input Devices - Pointing - Emulate Touch From Mouse" loading=lazy src=/images/tutorials/gd0012_match3/img3.png></li></ol><br><p>In addition, with the &ldquo;Project Settings&rdquo; window open, add an action to the input map corresponding to a smartphone touch operation.</p><ol><li>Switch to the &ldquo;Input Map&rdquo; tab and add &ldquo;touch&rdquo; to the action.</li><li>Add a left mouse click to the &ldquo;touch&rdquo; action.<br><img alt="Inputmap - action - tap" loading=lazy src=/images/tutorials/gd0012_match3/img4.png></li></ol><br><h3 id=downloading-and-importing-assets>Downloading and importing assets</h3><p>Next, let&rsquo;s download assets from KENNEY&rsquo;s site and use them. This time, we will use an asset pack called &ldquo;<a href=https://www.kenney.nl/assets/physics-assets target=_blank>Physics Assets</a>
&rdquo;. I&rsquo;m going to use the cute alien face images in this asset pack as textures for the pieces on the game board. I can&rsquo;t help but be thankful for this wonderful free resource.</p><p>After downloading, delete the images in the &ldquo;/physicspack/PNG/Aliens&rdquo; folder, leaving only the one with the file name &ldquo;~_round.png&rdquo; and drag the &ldquo;Aliens&rdquo; folder into the file system dock of the editor to import it into your project.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-grid-scene>Creating a Grid scene</h2><p>First, let&rsquo;s create a &ldquo;Grid&rdquo; scene as the board on which the pieces are placed in a match 3 puzzle game.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;2D Scene&rdquo; in &ldquo;Generate Root Node&rdquo;.</li><li>When the root node of the &ldquo;Node2D&rdquo; class is generated, rename it to &ldquo;Grid&rdquo;.</li><li>Save the scene. Create a folder and save the scene with the file path &ldquo;res://Grid/Grid.tscn&rdquo;.<br><br></li></ol><h3 id=adding-a-node-to-the-grid-scene>Adding a node to the Grid scene</h3><p>Let&rsquo;s add another child node of class &ldquo;Node2D&rdquo; to the &ldquo;Grid&rdquo; root node and rename it to &ldquo;PiecesContainer&rdquo;. This node is used to organize the pieces placed on the board. During the game, when instances of the pieces are created by the script, they will all be added as children of this &ldquo;PiecesContainer&rdquo; node.</p><p>The scene tree dock should now look like the following.<br><img alt="scene tree dock" loading=lazy src=/images/tutorials/gd0012_match3/img8.png></p><p>Note that there is no need to edit the properties of the &ldquo;Grid&rdquo; scene node.</p><p>Translated with <a href=https://www.DeepL.com/Translator target=_blank>www.DeepL.com/Translator</a>
(free version)</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-piece-scene>Creating a Piece scene</h2><p>Next, create a &ldquo;Piece&rdquo; scene for the pieces to be placed on the board. However, this &ldquo;Piece&rdquo; scene is only a blueprint, and the actual pieces of each color to be used in the game will be prepared later by inheriting this &ldquo;Piece&rdquo; scene.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;2D Scene&rdquo; in the &ldquo;Create Root Node&rdquo; section.</li><li>When the root node of &ldquo;Node2D&rdquo; class is generated, rename it to &ldquo;Piece&rdquo;.</li><li>Save the scene. Create a folder and save the scene with the file path &ldquo;res://Pieces/Piece.tscn&rdquo;.<br><br></li></ol><h3 id=adding-a-child-node-to-the-piece-node>Adding a child node to the Piece node</h3><p>Let&rsquo;s add a child node of class &ldquo;Sprite&rdquo; to the &ldquo;Piece&rdquo; root node. The scene tree dock should now look like the following.<br><img alt="Piece scene tree" loading=lazy src=/images/tutorials/gd0012_match3/img9.png></p><br><h3 id=editing-the-properties-of-the-sprite-node>Editing the properties of the Sprite node</h3><p>Let&rsquo;s edit a few properties of the &ldquo;Sprite&rdquo; node. As mentioned above, the &ldquo;Piece&rdquo; is only a blueprint, so we will leave the &ldquo;Texture&rdquo; property of the &ldquo;Sprite&rdquo; node as it is without applying any resources to it in this scene. In the inherited scene, apply an image that matches the color of each piece.</p><p>Change the value of the &ldquo;Offset&rdquo; property to &ldquo;(x: 35, y: -35)&rdquo;. In the scene of each piece of color that inherits this scene, we will apply the KENNEY image imported earlier to the &ldquo;Texture&rdquo; property. Since the size of the image is 70 px in height and width, we shifted the center of the image to the upper right and set the lower left corner of the image to (x: 0, y: 0).<br><img alt="Piece scene - Sprite - offset" loading=lazy src=/images/tutorials/gd0012_match3/img10.png></p><p>The grid of the board on which the pieces are placed is set to count from left to right on the x-axis and from bottom to top on the y-axis, and the size of one grid on the board is set to 70 px to match the size of the texture. If the lower left corner of the piece&rsquo;s texture image is aligned with (x: 0, y: 0), then when the &ldquo;Piece&rdquo; root node is positioned (x: 0, y: 0) to the grid, the &ldquo;Sprite&rdquo; image will be placed exactly along the grid.<br><img alt="Diagram - Sprite offset ajusted to grid" loading=lazy src=/images/tutorials/gd0012_match3/diagram0.png></p><br><h3 id=attaching-and-editing-a-script-to-the-piece-node>Attaching and editing a script to the Piece node</h3><p>Let&rsquo;s attach a new script to the &ldquo;Piece&rdquo; root node. Create a script file with the file path &ldquo;res://Pieces/Piece.tscn&rdquo;.</p><p>Edit the script as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Property to set the color of the piece as string data</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=p>(</span><span class=nc>String</span><span class=p>)</span> <span class=kd>var</span> <span class=n>color</span>
</span></span><span class=line><span class=cl><span class=c1># Property to indicate matched (3 or more of the same color in a row)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>matched</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># Reference to a Sprite node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>sprite</span> <span class=o>=</span> <span class=nx>$Sprite</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to move a piece</span>
</span></span><span class=line><span class=cl><span class=c1># Move the Piece instance to the position passed in the target argument</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>move</span><span class=p>(</span><span class=n>target</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>position</span> <span class=o>=</span> <span class=n>target</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method called when a match is found (3 or more of the same color in a row)</span>
</span></span><span class=line><span class=cl><span class=c1># Set the matched property to true and make the color translucent</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>make_matched</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>matched</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=n>sprite</span><span class=o>.</span><span class=n>modulate</span> <span class=o>=</span> <span class=nc>Color</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=o>.</span><span class=mi>5</span><span class=p>)</span>
</span></span></code></pre></div><br><p>This completes the editing of the &ldquo;Piece.gd&rdquo; script.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h1 id=creating-a-scene-for-each-color-that-inherits-from-the-piece-scene>Creating a scene for each color that inherits from the Piece scene</h1><p>Now that the &ldquo;Piece&rdquo; scene, which will serve as a template, is complete, let&rsquo;s create a scene that inherits the &ldquo;Piece&rdquo; scene in the number of colors of the piece. There are five Piece colors: beige, blue, green, pink, and yellow. First, let&rsquo;s proceed with the steps using the &ldquo;beige&rdquo; drop as an example.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Inherited Scene&rdquo;.</li><li>Select &ldquo;Piece.tscn&rdquo; as the source scene.</li><li>After the inherited scene is generated, rename the root node to &ldquo;PieceBeige&rdquo;.<br>*The name of this root node should match the color of each drop.</li><li>Save the scene once. Save the file path as &ldquo;res://Pieces/PieceBeige.tscn&rdquo;.</li><li>With the root node &ldquo;PieceBeige&rdquo; selected in the scene tree dock, set the value of the &ldquo;Color&rdquo; property of &ldquo;Script Variables&rdquo; to &ldquo;beige&rdquo; in the inspector.<br><img alt="PieceBeige - Color property" loading=lazy src=/images/tutorials/gd0012_match3/img11.png></li><li>Select the &ldquo;Sprite&rdquo; node in the scene tree dock and apply the previously imported resource &ldquo;res://Aliens/alienBeige_round.png&rdquo; to the &ldquo;Texture&rdquo; property (you can drag it from the file system dock).<br><img alt="Sprite - Texture Region" loading=lazy src=/images/tutorials/gd0012_match3/img12.png></li><li>On the 2D workspace it should now look like the following screenshot.<br><img alt="Sprite - Texture Region" loading=lazy src=/images/tutorials/gd0012_match3/img13.png></li><li>The &ldquo;PieceBeige&rdquo; scene is now complete. Follow the same procedure to create scenes for the remaining four colored pieces. Please refer to the following for details on the different parts of each scene.</li></ol><ul><li>Blue Piece<ul><li>Root node name: PieceBlue</li><li>Color property: blue</li><li>Sprite > Texture property: res://Aliens/alienBlue_round.png</li><li>File path when saving the scene: res://Pieces/PieceBlue.tscn</li></ul></li><li>Green Piece<ul><li>Root node name: PieceGreen</li><li>Color property: green</li><li>Sprite > Texture property: res://Aliens/alienGreen_round.png</li><li>File path when saving the scene: res://Pieces/PieceGreen.tscn</li></ul></li><li>Pink Piece<ul><li>Root node name: PiecePink</li><li>Color property: green</li><li>Sprite > Texture property: res://Aliens/alienPink_round.png</li><li>File path when saving the scene: res://Pieces/PiecePink.tscn</li></ul></li><li>Yellow Piece<ul><li>Root node name: PieceYellow</li><li>Color property: yellow</li><li>Sprite > Texture property: res://Aliens/alienYellow_round.png</li><li>File path when saving the scene: res://Pieces/PieceYellow.tscn</li></ul></li></ul><p>When the inherited scenes of all 5 colored pieces have been created, the work is complete.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=controlling-the-grid-scene-with-scripts>Controlling the Grid scene with scripts</h2><p>Now that we have created a scene for each color piece, we can now program and control the game. The amount of code is a bit large this time, so let&rsquo;s do our best.</p><p>After switching to the &ldquo;Grid.tscn&rdquo; scene, attach a new script to the &ldquo;Grid&rdquo; root node. The file path should be &ldquo;res://Grid/Grid.gd&rdquo;.</p><p>In the comments in the script, &ldquo;finger touched&rdquo; or &ldquo;finger released&rdquo; should be replaced with &ldquo;left mouse button pressed&rdquo; or &ldquo;left mouse button released&rdquo; on the Godot debug panel.</p><p>Also, please note that &ldquo;match&rdquo; is defined as three or more of the same color.</p><p>Now, once the script editor is open, let&rsquo;s define the necessary properties.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># An array with scene files for each color piece as elements</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>pieces_scn</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PieceBeige.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PieceBlue.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PieceGreen.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PiecePink.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Pieces/PieceYellow.tscn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Number of grids in x-axis direction</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>width</span><span class=p>:</span> <span class=o>=</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl><span class=c1># Number of grids in y-axis direction</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>height</span><span class=p>:</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=c1># Grid start position (pixels) in x-axis direction</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>x_start</span><span class=p>:</span> <span class=o>=</span> <span class=mi>70</span>
</span></span><span class=line><span class=cl><span class=c1># Grid start position (pixels) in y-axis direction</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>y_start</span><span class=p>:</span> <span class=o>=</span> <span class=mi>910</span>
</span></span><span class=line><span class=cl><span class=c1># Size of one grid (should be the same as Texture of Sprite in Piece)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>grid_size</span><span class=p>:</span> <span class=o>=</span> <span class=mi>70</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># A two-dimensional array (initially empty) that manages all the pieces of the board as elements and their grid coordinates</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>all_pieces</span> <span class=o>=</span> <span class=p>[]</span><span class=o>.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Position where finger touches the screen</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>touched_pos</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1># The position where the finger leaves the screen</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>released_pos</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># State where finger is touching the screen, touched: true / away: false</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_touching</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># State of automatic processing of matching, processing: true / stopped: false</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Referencing the PiecesContainer node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>pieces_container</span> <span class=o>=</span> <span class=nx>$PiecesContainer</span>
</span></span></code></pre></div><br><p>Then let&rsquo;s add the following method. Note that the <strong>two-dimensional array</strong> that appears in the following code is an array that stores arrays as elements.</p><p>In the case of the two-dimensional array used in this script, the first level of the array contains as many empty arrays as the number of grids in the x-axis direction of the board, and the second level of the array contains as many elements as the number of vertical grids in each array. By storing piece objects as elements, it is possible to manage where each piece is located on the board (how many grids along the x-axis and how many grids along the y-axis).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Function called when the scene is loaded</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Method to randomize the output result of a function that generates a random number each time</span>
</span></span><span class=line><span class=cl>	<span class=nb>randomize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Make all_pieces a 2d array that makes up the grid of the board</span>
</span></span><span class=line><span class=cl>	<span class=n>all_pieces</span> <span class=o>=</span> <span class=nf>make_2d_array</span><span class=p>()</span> <span class=c1># define after this</span>
</span></span><span class=line><span class=cl>    <span class=c1># Spawn the pieces and place them on each grid</span>
</span></span><span class=line><span class=cl>	<span class=nf>spawn_pieces</span><span class=p>()</span> <span class=c1># define after this</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to create a 2d array that makes up the grid of the board</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>make_2d_array</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Prepare an array named array for output</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=n>array</span> <span class=o>=</span> <span class=p>[]</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=c1># Fill the prepared array with the number of empty arrays for the number of grids along the x-axis</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>array</span><span class=o>.</span><span class=nf>append</span><span class=p>([])</span>
</span></span><span class=line><span class=cl>        <span class=c1># Add a value of null for the number of grids in the y-axis to each array</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=n>array</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=kt>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># return the two-dimensional array</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>array</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to spawn pieces and place them on each grid</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>spawn_pieces</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop for the number of grids along the x-axis</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Loop over the number of grids in the y-axis</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=c1># If no piece exists in the corresponding grid on the 2D array of all pieces</span>
</span></span><span class=line><span class=cl>            <span class=c1># (All null at the start of the game)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># Randomly select one from the scenes of each color and instantiate it</span>
</span></span><span class=line><span class=cl>				<span class=kd>var</span> <span class=n>index</span> <span class=o>=</span> <span class=nb>floor</span><span class=p>(</span><span class=nf>rand_range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>pieces_scn</span><span class=o>.</span><span class=nf>size</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>				<span class=kd>var</span> <span class=n>piece</span> <span class=o>=</span> <span class=n>pieces_scn</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># If it matches, delete the piece instance and start over</span>
</span></span><span class=line><span class=cl>				<span class=k>while</span> <span class=nf>match_at</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>piece</span><span class=o>.</span><span class=n>color</span><span class=p>):</span> <span class=c1># define after this</span>
</span></span><span class=line><span class=cl>					<span class=n>piece</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>					<span class=n>index</span> <span class=o>=</span> <span class=nb>floor</span><span class=p>(</span><span class=nf>rand_range</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=n>pieces_scn</span><span class=o>.</span><span class=nf>size</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>					<span class=n>piece</span> <span class=o>=</span> <span class=n>pieces_scn</span><span class=p>[</span><span class=n>index</span><span class=p>]</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Make a piece instance a child of a PiecesContainer node</span>
</span></span><span class=line><span class=cl>				<span class=n>pieces_container</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>piece</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># Place the piece instance at the position converted from grid to pixels</span>
</span></span><span class=line><span class=cl>				<span class=n>piece</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=c1># define after this</span>
</span></span><span class=line><span class=cl>                <span class=c1># Update the 2D array of all pieces</span>
</span></span><span class=line><span class=cl>				<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>piece</span>
</span></span></code></pre></div><br><p>Let&rsquo;s define the <code>match_at</code> and <code>grid_to_pixel</code> methods in the above code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to check if 3 or more pieces of the same color are lined up at the specified grid position.</span>
</span></span><span class=line><span class=cl><span class=c1># column is the grid position on the x-axis, row is the grid position on the y-axis, and color is the color of the piece</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>match_at</span><span class=p>(</span><span class=n>column</span><span class=p>,</span> <span class=n>row</span><span class=p>,</span> <span class=n>color</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># If the x-axis value of the specified grid coordinate is 3 or greater</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>column</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># If there is a piece to the left of the specified grid coordinate and one more to the left</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>column</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>row</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span> \
</span></span><span class=line><span class=cl>		<span class=ow>and</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>column</span><span class=o>-</span><span class=mi>2</span><span class=p>][</span><span class=n>row</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># If the color of those pieces is the same as the color of the given piece</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>column</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>row</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>color</span> \
</span></span><span class=line><span class=cl>			<span class=ow>and</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>column</span><span class=o>-</span><span class=mi>2</span><span class=p>][</span><span class=n>row</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># Return true</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=c1># If the y-axis value of the specified grid coordinate is 3 or greater</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>row</span> <span class=o>&gt;=</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># If there are pieces below the specified grid coordinates and one more below</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>column</span><span class=p>][</span><span class=n>row</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span> <span class=err>\</span><span class=n>frz</span>
</span></span><span class=line><span class=cl>		<span class=ow>and</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>column</span><span class=p>][</span><span class=n>row</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># If the color of those pieces is the same as the color of the given piece</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>column</span><span class=p>][</span><span class=n>row</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>color</span> \
</span></span><span class=line><span class=cl>			<span class=ow>and</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>column</span><span class=p>][</span><span class=n>row</span><span class=o>-</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># return true</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to convert grid position to pixel position</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>column</span><span class=p>,</span> <span class=n>row</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># Define a Vector2 variable pixel_pos for pixel position output</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>pixel_pos</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Pixel x-coordinate = grid start position along x-axis + grid size * grid x-coordinate</span>
</span></span><span class=line><span class=cl>	<span class=n>pixel_pos</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>x_start</span> <span class=o>+</span> <span class=n>grid_size</span> <span class=o>*</span> <span class=n>column</span>
</span></span><span class=line><span class=cl>    <span class=c1># Pixel y-coordinate = grid start position along y-axis - grid size * grid y-coordinate</span>
</span></span><span class=line><span class=cl>	<span class=n>pixel_pos</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>y_start</span> <span class=o>-</span> <span class=n>grid_size</span> <span class=o>*</span> <span class=n>row</span>
</span></span><span class=line><span class=cl>    <span class=c1># Return pixel position</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>pixel_pos</span>
</span></span></code></pre></div><p>Now the pieces of each color should be randomly arranged on the board at the start of the game. Let&rsquo;s run the project once to check it out. If you are running the project for the first time, select &ldquo;Grid.tscn&rdquo; as the main scene when the dialog for selecting the main scene appears.<br><img alt="run project - distribute pieces on the grid board" loading=lazy src=/images/tutorials/gd0012_match3/img14.png></p><br><p>Since we have just defined the <code>grid_to_pixel</code> method, we should also define the <code>pixel_to_grid</code> method to be used later. As the name suggests, this method is the opposite of <code>grid_to_pixel</code> defined earlier, and converts pixel positions to grid positions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to convert pixel position to grid position</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>pixel_to_grid</span><span class=p>(</span><span class=n>pixel_x</span><span class=p>,</span> <span class=n>pixel_y</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nc>Vector2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>grid_pos</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>grid_pos</span><span class=o>.</span><span class=n>x</span> <span class=o>=</span> <span class=nb>floor</span><span class=p>((</span><span class=n>pixel_x</span> <span class=o>-</span> <span class=n>x_start</span><span class=p>)</span> <span class=o>/</span> <span class=n>grid_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>grid_pos</span><span class=o>.</span><span class=n>y</span> <span class=o>=</span> <span class=nb>floor</span><span class=p>((</span><span class=n>pixel_y</span> <span class=o>-</span> <span class=n>y_start</span><span class=p>)</span> <span class=o>/</span> <span class=o>-</span><span class=n>grid_size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>grid_pos</span>
</span></span></code></pre></div><br><p>In addition, we define one more method <code>is_in_grid</code> to be used later. This method determines whether the position passed as an argument is within the board grid and returns true or false.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method that returns whether the given position is in the grid or not.</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>is_in_grid</span><span class=p>(</span><span class=n>grid_position</span><span class=p>:</span> <span class=nc>Vector2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>grid_position</span><span class=o>.</span><span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>grid_position</span><span class=o>.</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>width</span> \
</span></span><span class=line><span class=cl>	<span class=ow>and</span> <span class=n>grid_position</span><span class=o>.</span><span class=n>y</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>grid_position</span><span class=o>.</span><span class=n>y</span> <span class=o>&lt;</span> <span class=n>height</span>
</span></span><span class=line><span class=cl>        <span class=c1># Return true if within the board grid</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Return false if outside of the grid</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>Here, we will write a program to handle the player&rsquo;s input for the game.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Function called every frame in the main loop of the game</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_process</span><span class=p>(</span><span class=n>_delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># If not in the process of matching</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=ow>not</span> <span class=n>is_waiting</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Process the player&#39;s input</span>
</span></span><span class=line><span class=cl>		<span class=nf>touch_input</span><span class=p>()</span> <span class=c1># define after this</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to process player input</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>touch_input</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># If a finger touches the screen</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Convert finger position from pixels to grid</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>start_pos</span> <span class=o>=</span> <span class=nf>get_global_mouse_position</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>start_grid</span> <span class=o>=</span> <span class=nf>pixel_to_grid</span><span class=p>(</span><span class=n>start_pos</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=n>start_pos</span><span class=o>.</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># If the finger position is within the board grid</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>is_in_grid</span><span class=p>(</span><span class=n>start_grid</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># Save the position where you touched your finger to the screen</span>
</span></span><span class=line><span class=cl>			<span class=n>touched_pos</span> <span class=o>=</span> <span class=n>start_grid</span>
</span></span><span class=line><span class=cl>            <span class=c1># Make the state with the finger touching the screen</span>
</span></span><span class=line><span class=cl>			<span class=n>is_touching</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>	<span class=c1># If finger leaves the screen</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_released</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Convert finger position from pixels to grid</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>end_pos</span> <span class=o>=</span> <span class=nf>get_global_mouse_position</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>end_grid</span> <span class=o>=</span> <span class=nf>pixel_to_grid</span><span class=p>(</span><span class=n>end_pos</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=n>end_pos</span><span class=o>.</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># If finger position is within the board grid...</span>
</span></span><span class=line><span class=cl>        <span class=c1># and the state is with the finger touching the screen</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>Is_in_grid</span><span class=p>(</span><span class=n>end_grid</span><span class=p>)</span> <span class=ow>and</span> <span class=n>is_touching</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Save as released position information</span>
</span></span><span class=line><span class=cl>			<span class=n>released_pos</span> <span class=o>=</span> <span class=n>end_grid</span>
</span></span><span class=line><span class=cl>            <span class=c1># Call a method that handles the movement of the piece at the touched and released positions</span>
</span></span><span class=line><span class=cl>			<span class=nf>touch_and_release</span><span class=p>()</span> <span class=c1># define after this</span>
</span></span><span class=line><span class=cl>        <span class=c1># State is finger off the screen</span>
</span></span><span class=line><span class=cl>		<span class=n>is_touching</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>In the above code, the <code>touch_and_release</code> method is called to acquire the position of the finger touching the screen and the position of the finger leaving the screen within the grid of the board, and to use this information to process the movement of the pieces.</p><p>Let&rsquo;s define this method and a helper method called <code>swap_pieces</code> that is called further in the method. A helper method is simply a method that is called within a method and serves to keep the parent method simple.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method that handles the movement of the piece using the position of the touched finger and the position of the released finger</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>touch_and_release</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Calculate the difference between the position where the finger touched and the position where the finger released</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>difference</span> <span class=o>=</span> <span class=n>released_pos</span> <span class=o>-</span> <span class=n>touched_pos</span>
</span></span><span class=line><span class=cl>    <span class=c1># If the absolute value of the difference along the x-axis is greater than the absolute value of the difference along the y-axis</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>abs</span><span class=p>(</span><span class=n>difference</span><span class=o>.</span><span class=n>x</span><span class=p>)</span> <span class=o>&gt;</span> <span class=nb>abs</span><span class=p>(</span><span class=n>difference</span><span class=o>.</span><span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># If difference along x-axis is greater than 0</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>difference</span><span class=o>.</span><span class=n>x</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Call helper method to swap the piece at the touched position with the adjacent piece to the right</span>
</span></span><span class=line><span class=cl>			<span class=nf>swap_pieces</span><span class=p>(</span><span class=n>touched_pos</span><span class=p>,</span> <span class=nc>Vector2</span><span class=o>.</span><span class=n>RIGHT</span><span class=p>)</span> <span class=c1># define after this</span>
</span></span><span class=line><span class=cl>        <span class=c1># If the difference along the x-axis is less than 0</span>
</span></span><span class=line><span class=cl>		<span class=k>elif</span> <span class=n>difference</span><span class=o>.</span><span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Call helper method to swap the piece at the touched position with the adjacent piece to the left</span>
</span></span><span class=line><span class=cl>			<span class=nf>swap_pieces</span><span class=p>(</span><span class=n>touched_pos</span><span class=p>,</span> <span class=nc>Vector2</span><span class=o>.</span><span class=n>LEFT</span><span class=p>)</span> <span class=c1># defined after this</span>
</span></span><span class=line><span class=cl>    <span class=c1># If the absolute difference along the x-axis is less than the absolute difference along the y-axis</span>
</span></span><span class=line><span class=cl>	<span class=k>elif</span> <span class=nb>abs</span><span class=p>(</span><span class=n>difference</span><span class=o>.</span><span class=n>x</span><span class=p>)</span> <span class=o>&lt;</span> <span class=nb>abs</span><span class=p>(</span><span class=n>difference</span><span class=o>.</span><span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># If the difference along y-axis is greater than 0</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>difference</span><span class=o>.</span><span class=n>y</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Call helper method to swap the piece at the touched position with the piece adjacent below</span>
</span></span><span class=line><span class=cl>			<span class=nf>swap_pieces</span><span class=p>(</span><span class=n>touched_pos</span><span class=p>,</span> <span class=nc>Vector2</span><span class=o>.</span><span class=n>DOWN</span><span class=p>)</span> <span class=c1># define after this</span>
</span></span><span class=line><span class=cl>        <span class=c1># If the difference along the y-axis is less than 0</span>
</span></span><span class=line><span class=cl>		<span class=k>elif</span> <span class=n>difference</span><span class=o>.</span><span class=n>y</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Call helper method to swap the piece at the touched position with the one adjacent above it</span>
</span></span><span class=line><span class=cl>			<span class=nf>swap_pieces</span><span class=p>(</span><span class=n>touched_pos</span><span class=p>,</span> <span class=nc>Vector2</span><span class=o>.</span><span class=n>UP</span><span class=p>)</span> <span class=c1># defined after this</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Helper method to swap pieces</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>swap_pieces</span><span class=p>(</span><span class=n>pos</span><span class=p>,</span> <span class=n>dir</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># Get the piece at the touched position from the 2D array of all pieces</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>touched_piece</span> <span class=o>=</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>pos</span><span class=o>.</span><span class=n>y</span><span class=p>]</span><span class=o>.</span>
</span></span><span class=line><span class=cl>    <span class=c1># Get the piece adjacent to the piece in the direction of finger release from the 2D array of all pieces</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>target_piece</span> <span class=o>=</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>pos</span><span class=o>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>y</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=c1># If both pieces exist in the 2D array of all pieces</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>touched_piece</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span> <span class=ow>and</span> <span class=n>target_piece</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Overwrite the piece at the touched position in the 2D array of all pieces with the piece adjacent to the one you removed your finger from</span>
</span></span><span class=line><span class=cl>		<span class=n>all_pieces</span><span class=p>[</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>pos</span><span class=o>.</span><span class=n>y</span><span class=p>]</span> <span class=o>=</span> <span class=n>target_piece</span>
</span></span><span class=line><span class=cl>        <span class=c1># Overwrite the piece adjacent to the finger release position with the piece at the finger release position from the two-dimensional array of all pieces</span>
</span></span><span class=line><span class=cl>		<span class=n>all_pieces</span><span class=p>[</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>pos</span><span class=o>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>y</span><span class=p>]</span> <span class=o>=</span> <span class=n>touched_piece</span>
</span></span><span class=line><span class=cl>        <span class=c1># Move the piece instance at the touched position on the board by 1 grid toward the one you removed your finger from</span>
</span></span><span class=line><span class=cl>		<span class=n>touched_piece</span><span class=o>.</span><span class=nf>move</span><span class=p>(</span><span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=n>pos</span><span class=o>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>y</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1># move the piece instance adjacent to the one you release your finger on the board to the position touched by your finger</span>
</span></span><span class=line><span class=cl>		<span class=n>target_piece</span><span class=o>.</span><span class=nf>move</span><span class=p>(</span><span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=n>pos</span><span class=o>.</span><span class=n>y</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1># Set auto-processing state to &#34;processing in progress&#34; since processing of the matched piece starts here</span>
</span></span><span class=line><span class=cl>		<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>true</span>
</span></span></code></pre></div><br><p>With the above code, we have implemented a process whereby a piece dragged by the player is replaced by an adjacent piece.</p><p>Let&rsquo;s run the project to see if the input operation works correctly.<br><img alt="run project - swap pieces" loading=lazy src=/images/tutorials/gd0012_match3/img15.gif></p><br><p>From here, the process that should be executed automatically after the pieces are replaced is implemented. The general flow is as follows:</p><ol><li>Change the automatic processing state during processing.</li><li>Check if there is at least one matched piece, and if so, loop through the following process.<ol><li>Check all pieces and flag matched pieces.</li><li>Delete the flagged piece.</li><li>Fill the empty space by moving a piece from the same column.</li><li>After the pieces are packed down, a new piece is created in the empty space at the end.</li></ol></li><li>When there are no more matched pieces, the automatic processing state is stopped.</li></ol><br><p>Let&rsquo;s code the general flow of the above.</p><p>First, let&rsquo;s add a line <code>is_waiting = true</code> at the end of the <code>swap_pieces</code> method that swaps the pieces defined earlier. This changes the automatic processing state to &ldquo;processing&rdquo;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>swap_pieces</span><span class=p>(</span><span class=n>pos</span><span class=p>,</span> <span class=n>dir</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>touched_piece</span> <span class=o>=</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>pos</span><span class=o>.</span><span class=n>y</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>target_piece</span> <span class=o>=</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>pos</span><span class=o>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>y</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>touched_piece</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span> <span class=ow>and</span> <span class=n>target_piece</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>all_pieces</span><span class=p>[</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>pos</span><span class=o>.</span><span class=n>y</span><span class=p>]</span> <span class=o>=</span> <span class=n>target_piece</span>
</span></span><span class=line><span class=cl>		<span class=n>all_pieces</span><span class=p>[</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>x</span><span class=p>][</span><span class=n>pos</span><span class=o>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>y</span><span class=p>]</span> <span class=o>=</span> <span class=n>touched_piece</span>
</span></span><span class=line><span class=cl>		<span class=n>touched_piece</span><span class=o>.</span><span class=nf>move</span><span class=p>(</span><span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=n>pos</span><span class=o>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>dir</span><span class=o>.</span><span class=n>y</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=n>target_piece</span><span class=o>.</span><span class=nf>move</span><span class=p>(</span><span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>pos</span><span class=o>.</span><span class=n>x</span><span class=p>,</span> <span class=n>pos</span><span class=o>.</span><span class=n>y</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># Add the following</span>
</span></span><span class=line><span class=cl>        <span class=c1># Set the auto-processing state to &#34;processing&#34; since this is where the automatic processing of the matched piece starts</span>
</span></span><span class=line><span class=cl>		<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>true</span>
</span></span></code></pre></div><br><p>Let&rsquo;s write the <code>if</code> syntax &ldquo;if the state is in the process of executing automatic processing&rdquo; in the <code>touch_input</code> method, and then add the processing we want to execute automatically in the block. The position for adding is just after the finger operation is finished. After the process is complete, let&rsquo;s add a line <code>is_waiting = false</code> to set the automatic processing state to &ldquo;stopped&rdquo;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>touch_input</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_released</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># Add from here</span>
</span></span><span class=line><span class=cl>        <span class=c1># If Input.is_action_just_pressed(&#34;touch&#34;): # omit</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>is_waiting</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Check if there is at least one pair of matched pieces &gt; loop as long as there are</span>
</span></span><span class=line><span class=cl>			<span class=k>while</span> <span class=nf>check_matches</span><span class=p>():</span> <span class=c1># define after this</span>
</span></span><span class=line><span class=cl>                <span class=k>pass</span>
</span></span><span class=line><span class=cl>            <span class=c1># If no matched pieces are found and processing is complete, set autoprocessing state to waiting</span>
</span></span><span class=line><span class=cl>			<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>A <code>while</code> loop is used to repeat the necessary process if there is at least one pair of matching pieces.</p><br><p>First, define <code>check_matches()</code>, which is also the loop condition of the <code>while</code> loop, as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to check if there is at least one matched piece and return the result</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>check_matches</span><span class=p>()</span> <span class=o>-&gt;</span> <span class=kt>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over the x-axis grid of the board</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Loop over the y-axis grid of the board</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># if piece exists at that grid coordinate</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># return true if the piece matches at that grid coordinate, and method also terminates</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=nf>match_at</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>color</span><span class=p>):</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=c1># Check all pieces and return false if none of them match</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>Then, let&rsquo;s define the <code>find_matches</code> method to perform the &ldquo;first process in the <code>while</code> loop&rdquo;, which is to check all the pieces and flag the matched ones, as follows. By &ldquo;flagging&rdquo; here, I mean changing the value of the <code>matched</code> property of a piece instance to <code>true</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Find matching pieces and flag method</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>find_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over the number of x-axis grids on the board</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Loop over the number of y-axis grids on the board</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># If a piece exists at the coordinates of that grid</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># Define the current color as the color of that piece</span>
</span></span><span class=line><span class=cl>				<span class=kd>var</span> <span class=n>current_color</span> <span class=o>=</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>color</span>
</span></span><span class=line><span class=cl>                <span class=c1># If its x-axis coordinates are less than the number of x-axis grids - 2</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>width</span> <span class=o>-</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># If there are pieces to the right of that piece and further to its right</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=ow>and</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=c1># If the color of those pieces is the same as the current color</span>
</span></span><span class=line><span class=cl>						<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>current_color</span> \
</span></span><span class=line><span class=cl>						<span class=ow>and</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>current_color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                            <span class=c1># If the piece is not flagged</span>
</span></span><span class=line><span class=cl>							<span class=k>if</span> <span class=ow>not</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                                <span class=c1># Set the matched property of the piece to true to flag it</span>
</span></span><span class=line><span class=cl>                                <span class=c1># Make the piece&#39;s texture color translucent at the same time</span>
</span></span><span class=line><span class=cl>								<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                            <span class=c1># If the piece&#39;s right neighbor is not flagged</span>
</span></span><span class=line><span class=cl>							<span class=k>if</span> <span class=ow>not</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>								<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                            <span class=c1># If the piece&#39;s two neighbors to the right are not flagged</span>
</span></span><span class=line><span class=cl>							<span class=k>if</span> <span class=ow>not</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>								<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>2</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>()</span>
</span></span><span class=line><span class=cl>				<span class=c1># If the piece&#39;s y-coordinate is less than the number of grids along the y-axis - 2</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>height</span> <span class=o>-</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># If there are pieces above and further to its above that piece</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span> <span class=err>\</span><span class=n>f</span><span class=p>}</span>
</span></span><span class=line><span class=cl>					<span class=ow>and</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=c1># If the color of those pieces is the same as the current color</span>
</span></span><span class=line><span class=cl>						<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>current_color</span> \
</span></span><span class=line><span class=cl>						<span class=ow>and</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>current_color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                            <span class=c1># If the piece is not flagged</span>
</span></span><span class=line><span class=cl>							<span class=k>if</span> <span class=ow>not</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                                <span class=c1># Set the matched property of the piece to true to flag it</span>
</span></span><span class=line><span class=cl>                                <span class=c1># Make the piece&#39;s texture color translucent at the same time</span>
</span></span><span class=line><span class=cl>								<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                            <span class=c1># If the piece above it is not flagged</span>
</span></span><span class=line><span class=cl>							<span class=k>if</span> <span class=ow>not</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>								<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                            <span class=c1># If the piece two above it is not flagged</span>
</span></span><span class=line><span class=cl>							<span class=k>if</span> <span class=ow>not</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>								<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>+</span><span class=mi>2</span><span class=p>]</span><span class=o>.</span><span class=nf>make_matched</span><span class=p>()</span>
</span></span></code></pre></div><br><p>We need to call this <code>find_matches</code> method in the <code>while</code> loop in the <code>touch_input</code> method, so let&rsquo;s update it as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>touch_input</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_released</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>is_waiting</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Check if there is at least one pair of matched pieces &gt; loop as long as there are</span>
</span></span><span class=line><span class=cl>			<span class=k>while</span> <span class=nf>check_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>                <span class=c1># Find matched pieces and flag them</span>
</span></span><span class=line><span class=cl>				<span class=nf>find_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds to make the process visually clear</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>Now the <code>matched</code> property of each matched piece instance should be <code>true</code> and the color of the piece should be translucent.</p><p>Let&rsquo;s run the project and check it out.<br><img alt="run project - flag on matched pieces" loading=lazy src=/images/tutorials/gd0012_match3/img16.gif></p><br><p>Next, I would like you to define a <code>delete_matches</code> method that executes the second process &ldquo;delete flagged pieces&rdquo; in the <code>while</code> loop as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to delete matched pieces</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>delete_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over the number of x-axis grids on the board</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Loop over the number of y-axis grids of the board</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># If a piece exists at that grid coordinate</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                 <span class=c1># If a piece at that grid coordinate is flagged</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=n>matched</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=c1># Delete the piece at that grid coordinate</span>
</span></span><span class=line><span class=cl>					<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    <span class=c1># Empty the element with that grid coordinate from the 2D array of all_pieces[i][j].queue_free()</span>
</span></span><span class=line><span class=cl>					<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=kt>null</span>
</span></span></code></pre></div><br><p>Let&rsquo;s add this <code>delete_matches</code> method to the <code>while</code> loop of the <code>touch_input</code> method.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>touch_input</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_released</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>is_waiting</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Check if there is at least one pair of matched pieces &gt; loop as long as there are</span>
</span></span><span class=line><span class=cl>			<span class=k>while</span> <span class=nf>check_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>                <span class=c1># Find matched pieces and flag them</span>
</span></span><span class=line><span class=cl>				<span class=nf>find_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds to make the process visually clear</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># Delete flagged pieces</span>
</span></span><span class=line><span class=cl>				<span class=nf>delete_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># If no matched pieces are found and processing is complete, invalidate the in-process state</span>
</span></span><span class=line><span class=cl>			<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>Now the matched pieces should become translucent and then be deleted.</p><p>Let&rsquo;s run the project and check it out.<br><img alt="run project - delete matched pieces" loading=lazy src=/images/tutorials/gd0012_match3/img17.gif></p><br><p>Next, I would like you to update the <code>collapse_columns</code> method that executes the third process in the <code>while</code> loop, &ldquo;Move and pack pieces from the grid above the same column into the space vacated by the deletion&rdquo;, as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to collapse a column by moving the piece above it in a space where no piece exists</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>collapse_columns</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over the number of x-axis grids in the board</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>width</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Loop over the number of y-axis grids in the board</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=n>height</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># If no piece exists at that grid coordinate (null)</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># Loop from one row above the y-coordinate of that grid to the top row</span>
</span></span><span class=line><span class=cl>				<span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>height</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                    <span class=c1># If a piece exists on the grid one above</span>
</span></span><span class=line><span class=cl>					<span class=k>if</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>!</span> <span class=o>=</span> <span class=kt>null</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                        <span class=c1># Move the piece on the grid above to an empty grid below</span>
</span></span><span class=line><span class=cl>						<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span><span class=o>.</span><span class=nf>move</span><span class=p>(</span><span class=nf>grid_to_pixel</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                        <span class=c1># Put one piece above into the current grid coordinates of the 2D array of all_pieces</span>
</span></span><span class=line><span class=cl>						<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span><span class=o>.</span>
</span></span><span class=line><span class=cl>                        <span class=c1># Empty the grid coordinate one above in the 2D array of all_pieces</span>
</span></span><span class=line><span class=cl>						<span class=n>all_pieces</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=kt>null</span>
</span></span><span class=line><span class=cl>                        <span class=c1># Exit the loop</span>
</span></span><span class=line><span class=cl>						<span class=k>break</span>
</span></span></code></pre></div><br><p>Let&rsquo;s call this <code>collapse_columns</code> method inside the <code>while</code> loop of the <code>touch_input</code> method.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>touch_input</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_released</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>is_waiting</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Check if there is at least one pair of matched pieces &gt; loop as long as there are</span>
</span></span><span class=line><span class=cl>			<span class=k>while</span> <span class=nf>check_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>                <span class=c1># Find matched pieces and flag them</span>
</span></span><span class=line><span class=cl>				<span class=nf>find_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds to make the process visually clear</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># Delete flagged pieces</span>
</span></span><span class=line><span class=cl>				<span class=nf>delete_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># Move and collapse pieces on the same column into empty space</span>
</span></span><span class=line><span class=cl>				<span class=nf>collapse_columns</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># If no matched pieces are found and processing is complete, invalidate the in-process state</span>
</span></span><span class=line><span class=cl>			<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>Now we have an algorithm that fills the empty space with the piece above it after the piece has been deleted. The <code>while</code> loop should also continuously delete the matching piece <strong>after</strong> it has been stuffed into the empty space.</p><p>Let&rsquo;s run the project and check it out.<br><img alt="run project - collapse columns" loading=lazy src=/images/tutorials/gd0012_match3/img18.gif></p><br><p>Finally, if the <code>spawn_pieces</code> method is called after the pieces are packed down, new pieces will be placed in the empty space and the board will be filled. This method is already defined and called in the <code>_ready</code> method to place the pieces on the board at the beginning of the game.</p><p>Now let&rsquo;s update the <code>touch_input</code> method as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Grid.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>touch_input</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_released</span><span class=p>(</span><span class=s2>&#34;touch&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>		<span class=c1># Omit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>is_waiting</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Check if there is at least one pair of matched pieces &gt; loop as long as there are</span>
</span></span><span class=line><span class=cl>			<span class=k>while</span> <span class=nf>check_matches</span><span class=p>():</span>
</span></span><span class=line><span class=cl>                <span class=c1># Find matched pieces and flag them</span>
</span></span><span class=line><span class=cl>				<span class=nf>find_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds to make the process visually clear</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># Delete flagged pieces</span>
</span></span><span class=line><span class=cl>				<span class=nf>delete_matches</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># Move and collapse pieces on the same column into empty space</span>
</span></span><span class=line><span class=cl>				<span class=nf>collapse_columns</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=c1># Spawn and place a new piece in an empty space</span>
</span></span><span class=line><span class=cl>				<span class=nf>spawn_pieces</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=c1># Wait 0.3 seconds</span>
</span></span><span class=line><span class=cl>				<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.3</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># If no matched pieces are found and processing is complete, invalidate the in-process state</span>
</span></span><span class=line><span class=cl>			<span class=n>is_waiting</span> <span class=o>=</span> <span class=kc>false</span>
</span></span></code></pre></div><br><p>This completes the coding of the automatic processing part. This is the end of this tutorial. Finally, let&rsquo;s run the project to see how it works.<br><img alt="run project - whole check" loading=lazy src=/images/tutorials/gd0012_match3/img19.gif></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=sample-game>Sample Game</h2><p>We have prepared a sample game that is a brushed-up version of the project created in this tutorial. Note that the GIF images below are played at 3x speed, so they are actually a bit calmer.</p><p><img alt="sample game" loading=lazy src=/images/tutorials/gd0012_match3/img20.gif></p><br><p>The project file is located in the <a href=https://github.com/msnsk/Match3.git target=_blank>GitHub repository</a>
. Please download the .zip file from there and import the &ldquo;project.godot&rdquo; file in the &ldquo;Sample&rdquo; folder and import it into Godot Engine.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=conclusion>Conclusion</h2><p>This time, we created a match 3 puzzle game. This is a perfect game genre for mobile games with simple controls that can be enjoyed over and over again.</p><p>Let me summarize the key points when creating a simple match 3 puzzle game like this one.</p><ul><li>There are only two minimum scenes required: the board and the pieces.</li><li>Create a blueprint piece scene and then inherit it to create a piece scene for each color.</li><li>Use a two-dimensional array to manage the pieces to be placed on the board grid.</li><li>When replacing a piece, it is necessary to both replace the position of the piece on the screen and replace the elements of the two-dimensional array.</li><li>The following are the key points of the script.<ul><li>The process of the player moving the pieces<ol><li>Get the position where the finger touches the screen and the position where the finger leaves the screen.</li><li>Determine if the two positions are within the grid (valid operation).</li><li>Determine the direction in which the pieces are swapped based on the difference between the two positions.</li></ol></li><li>Automatic processing (loop) when a match is made.<ol><li>Checks if there is at least one pair of matching pieces (loop condition).</li><li>Flag the matched pieces.</li><li>Delete flagged pieces (loop condition).</li><li>Fill the space vacated by the removed piece with the piece above it.</li><li>Create a new piece in the space vacated by the filling.</li></ol></li></ul></li></ul><br><hr><h2 id=links>Links</h2><ul><li><a href=https://www.kenney.nl/assets target=_blank>KENNEY</a></li><li><a href=https://youtu.be/YhykrMFHOV4 target=_blank>YouTube: Part 0: Why Godot? - Make a Match 3 game like Candy Crush Using Godot.</a></li><li><a href=https://apps.apple.com/en/app/%E3%82%AD%E3%83%A3%E3%83%B3%E3%83%87%E3%82%A3%E3%83%BC%E3%82%AF%E3%83%A9%E3%83%83%E3%82%B7%E3%83%A5/id553834731 target=_blank>Candy Crush</a></li><li><a href=https://apps.apple.com/en/app/%E3%83%AD%E3%82%A4%E3%83%A4%E3%83%AB%E3%83%9E%E3%83%83%E3%83%81-royal-match/id1482155847 target=_blank>Royal Match</a></li><li><a href=https://apps.apple.com/en/app/%E3%83%88%E3%82%A5%E3%83%BC%E3%83%B3%E3%83%96%E3%83%A9%E3%82%B9%E3%83%88/id1176027022 target=_blank>Toon Blast</a></li></ul><br><hr></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Match 3 Puzzle Game in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Match%203%20Puzzle%20Game%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0012_match3%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cPuzzleGame%2cMobileGame%2cMatch3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Match 3 Puzzle Game in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0012_match3%2f&title=%f0%9f%a4%96%20Match%203%20Puzzle%20Game%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Match 3 Puzzle Game in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0012_match3%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/puzzlegame/>PuzzleGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/mobilegame/>MobileGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/match3/>Match3</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/en/posts/post0003_how_to_avoid_frustration/><span class=title>¬´ Prev</span><br><span>üìî How to avoid frustration of game development</span>
</a><a class=next href=https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/><span class=title>Next ¬ª</span><br><span>ü§ñ Connecting Matching Colors Puzzle Game in Godot3</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/en/>Peanuts Code</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>