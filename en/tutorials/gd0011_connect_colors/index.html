<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>🤖 Connecting Matching Colors Puzzle Game in Godot3 | Peanuts Code</title>
<meta name=keywords content="GodotEngine,GameDev,2D,PuzzleGame,MobileGame,Match3"><meta name=description content="In this tutorial, we will explain how to create a type of game in which you trace and erase drops of the same color, like the very popular Disney Tsum Tsum smartphone game.
LINE: Disney Tsum Tsum


Note that the final project file in this tutorial is located in the GitHub repository
. You can directly check the project by downloading the .zip file and importing the &ldquo;project.godot&rdquo; file in the &ldquo;End&rdquo; folder with the Godot Engine.


Environment

This tutorial was created in the following environment
・Godot version: 3.4.4
・Computer OS version: macOS 11.6.5


Memo:

Please also use the following articles to help you start creating your game.
Downloading Godot

Project Manager of Godot







Creating a new project
First, we would like you to start Godot Engine and create a new project. Let&rsquo;s name the project &ldquo;Connect Colors Start.

Editing project settings
Once the editor appears, let&rsquo;s editing the settings for the entire project."><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/"><meta property="og:site_name" content="Peanuts Code"><meta property="og:title" content="🤖 Connecting Matching Colors Puzzle Game in Godot3"><meta property="og:description" content="In this tutorial, we will explain how to create a type of game in which you trace and erase drops of the same color, like the very popular Disney Tsum Tsum smartphone game.
LINE: Disney Tsum Tsum Note that the final project file in this tutorial is located in the GitHub repository . You can directly check the project by downloading the .zip file and importing the “project.godot” file in the “End” folder with the Godot Engine.
Environment This tutorial was created in the following environment
・Godot version: 3.4.4
・Computer OS version: macOS 11.6.5
Memo: Please also use the following articles to help you start creating your game.
Downloading Godot Project Manager of Godot Creating a new project First, we would like you to start Godot Engine and create a new project. Let’s name the project “Connect Colors Start.
Editing project settings Once the editor appears, let’s editing the settings for the entire project."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-06-20T03:00:00+09:00"><meta property="article:modified_time" content="2022-06-20T03:00:00+09:00"><meta property="article:tag" content="GodotEngine"><meta property="article:tag" content="GameDev"><meta property="article:tag" content="2D"><meta property="article:tag" content="PuzzleGame"><meta property="article:tag" content="MobileGame"><meta property="article:tag" content="Match3"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0011_connect_colors/img36.gif"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0011_connect_colors/img36.gif"><meta name=twitter:title content="🤖 Connecting Matching Colors Puzzle Game in Godot3"><meta name=twitter:description content="In this tutorial, we will explain how to create a type of game in which you trace and erase drops of the same color, like the very popular Disney Tsum Tsum smartphone game.
LINE: Disney Tsum Tsum


Note that the final project file in this tutorial is located in the GitHub repository
. You can directly check the project by downloading the .zip file and importing the &ldquo;project.godot&rdquo; file in the &ldquo;End&rdquo; folder with the Godot Engine.


Environment

This tutorial was created in the following environment
・Godot version: 3.4.4
・Computer OS version: macOS 11.6.5


Memo:

Please also use the following articles to help you start creating your game.
Downloading Godot

Project Manager of Godot







Creating a new project
First, we would like you to start Godot Engine and create a new project. Let&rsquo;s name the project &ldquo;Connect Colors Start.

Editing project settings
Once the editor appears, let&rsquo;s editing the settings for the entire project."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"🤖 Tutorials","item":"https://www.peanuts-code.com/en/tutorials/"},{"@type":"ListItem","position":2,"name":"🤖 Connecting Matching Colors Puzzle Game in Godot3","item":"https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"🤖 Connecting Matching Colors Puzzle Game in Godot3","name":"🤖 Connecting Matching Colors Puzzle Game in Godot3","description":"In this tutorial, we will explain how to create a type of game in which you trace and erase drops of the same color, like the very popular Disney Tsum Tsum smartphone game.\nLINE: Disney Tsum Tsum Note that the final project file in this tutorial is located in the GitHub repository . You can directly check the project by downloading the .zip file and importing the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;End\u0026rdquo; folder with the Godot Engine.\nEnvironment This tutorial was created in the following environment\n・Godot version: 3.4.4\n・Computer OS version: macOS 11.6.5\nMemo: Please also use the following articles to help you start creating your game.\nDownloading Godot Project Manager of Godot Creating a new project First, we would like you to start Godot Engine and create a new project. Let\u0026rsquo;s name the project \u0026ldquo;Connect Colors Start.\nEditing project settings Once the editor appears, let\u0026rsquo;s editing the settings for the entire project.\n","keywords":["GodotEngine","GameDev","2D","PuzzleGame","MobileGame","Match3"],"articleBody":"In this tutorial, we will explain how to create a type of game in which you trace and erase drops of the same color, like the very popular Disney Tsum Tsum smartphone game.\nLINE: Disney Tsum Tsum Note that the final project file in this tutorial is located in the GitHub repository . You can directly check the project by downloading the .zip file and importing the “project.godot” file in the “End” folder with the Godot Engine.\nEnvironment This tutorial was created in the following environment\n・Godot version: 3.4.4\n・Computer OS version: macOS 11.6.5\nMemo: Please also use the following articles to help you start creating your game.\nDownloading Godot Project Manager of Godot Creating a new project First, we would like you to start Godot Engine and create a new project. Let’s name the project “Connect Colors Start.\nEditing project settings Once the editor appears, let’s editing the settings for the entire project.\nFirst, set the display size for the game. In this case, we set the aspect ratio to 16:9, assuming a smartphone screen in portrait orientation.\nOpen the “Project” menu \u003e “Project Settings”\nIn the “General” tab, search for “window” and select “Display” \u003e “Window” in the sidebar. In the “Size” section, change the values of the following items Width: 144 Height: 256 Test Width: 288 Test Height: 512\nChange the values of the following items in the “Stretch” section Mode: 2d Aspect: keep\nKeep the “Project Settings” open and configure the settings to substitute the mouse for the smartphone’s touch operation.\nSearch for “mouse” in the “General” tab and select “Input Devices” \u003e “Pointing” in the sidebar. Check “On” for “Emulate Touch From Mouse”.\nWith the “Project Settings” window open, add an action to the input map that corresponds to a smartphone touch operation.\nSwitch to the “Input Map” tab and add “tap” to the action. Add a left mouse click to the “tap” action.\nDownloading and importing the assets Next, let’s download assets from KENNEY and use them. The asset pack we will be using is called Pixel Platformer . I can’t help but be thankful for this wonderful free resource.\nOnce downloaded, drag and drop the “characters_packed.png” file from the “Tilemap” folder into the editor’s file system dock to import it into your project.\nImmediately after importing the file, the image will look blurry, so follow the steps below to correct this.\nMake the imported asset file selected in the file system dock\nSelect [Presets] \u003e [2D Pixel] in the import dock.\nClick the “Re-import” button at the bottom.\n! click reinport This will give the image the edgy look characteristic of pixel art.\nCreating a World Scene The first scene is to set the stage for the game. Let’s create a scene named “World”.\nSelect “Scene” menu \u003e “New Scene”. Select “Other Node” in “Generate Root Node”. Select a node of the “Node2D” class as the root node. Rename the root node to “World”. Save the scene at this point. Create a folder and save the scene with the file path “res://World/World.tscn”.\nAdding nodes to the World scene Let’s add nodes so that the world scene will look like the following scene tree. We will edit the properties of each node in turn later, so we can leave them as they are.\nWorld (Node2D) Bin (StaticBody2D) CollisionPolygon2D SpawnPath (Path2D) Spawner (PathFollow2D) AnimationPlayer Drops (Node2D) DropsLine (Line2D) Pointer (Area2D) CollisionShape2D The scene tree dock should now look like this.\nEditing nodes in the World scene Bin (StaticBody2D) node This node does not need to be edited. StaticBody2D is used in 2D games for obstacles and walls that do not move. In this case, we will use it as a container (bin) to keep falling drops (objects to be erased by tracing) on the screen.\nCollisionPolygon2D node This node is used to add a collision shape to the parent node “Bin”. The collision shape is created by dotting in the 2D workspace.\nActivate grid snap in the 2D workspace toolbar.\nBasically, the collision shape is formed by dotting around the outside of the window frame. However, the upper part of the shape should be shifted by -64px from the y-coordinate 0 of the display size. This is to generate a drop outside the upper part of the window frame and make it fall. The lower part of the collision polygon is placed slightly inside the display size and slanted so that the drop will roll.\nSpawnPath (Path2D) node This node is used to move the position of the spawning drop along the x-axis at all times. This makes the drops fall from the different positions at the top of the screen every time. Let’s place it outside the top of the window frame.\nCreate a straight path parallel to the x-axis by hitting two points (16, -32) and (128, -32) on the 2D workspace.\nSpawner (PathFollow2D) node This node moves along the path of the “SpawnPath” node edited earlier. This node should always move back and forth along the path to generate a drop from this node’s position. This will ensure that the drop’s position when spawned always changes within the path of the “SpawnPath” node.\nTurn off the property “Rotate”.\nAnimationPlayer node This node is used to move “Spawner” back and forth along the path of “SpawnPath” at all times. The “Spawner” property “Unit Offset” represents the starting point of the parent node “SpawnPath” path as 0 and the end point as 1. In other words, by constantly changing this property between 0 and 1, it is possible to make a round trip on the path.\nCreate an animation as follows Animation name: move_spawn_pos Auto play on load: Enabled Animation length (seconds): 0.4\n*0.4 seconds to move back and forth along the path Animation looping: Enabled Track: Spawner node - unit_offset property Time: 0 / Value: 0 / Easing: 1.00 Time: 0.2 / Value: 1 / Easing: 1.00\n*Wrap from the end of the path at 0.2 seconds\nDrops (Node2D) node No property editing is required for this node. Its role is just a container for multiple instances generated from a drop scene (to be created later).\nDropLine (Line2D) node This node is used to draw a line connecting drops of the same color when they are traced. This makes it easier to visually check which drop has been traced and how many drops are connected.\nChange the property “Width” to 2. This is the thickness of the line.\nChange the properties “Capping” \u003e “Joint Mode”, “Begin Cap Mode”, and “End Cap Mode” to “Round” respectively. This will make the shape of the joints, tips, and ends of the lines round.\nPointer (Area2D) node There is no need to edit this node. The purpose of this node is to follow the finger on a smartphone or the mouse cursor on a PC to detect when a drop is touched. Later, we will write code in the script to make the position of this node always the same as the position of the finger or mouse cursor.\nCollisionShape2D node This node gives the parent node “Pointer” a collision shape. Considering the operation of touching the drop with a finger or mouse cursor, the collision should be as small a shape as possible.\nApply the “New CircleShape2D” resource to the property “Shape”. Set the value of the property “Radius” of the applied resource “CircleShape2D” to 1.\nThis completes the editing of each node.\nCreating a Drop scene From here, we will create a “Drop” scene to be erased by tracing the same color.\nSelect “Scene” menu \u003e “New Scene”. Select “Other Node” in “Generate Root Node”. Select a node of the “RigidBody2D” class as the root node. Rename the root node to “Drop”. Save the scene at this point. Create a folder and save the scene with the file path “res://Drops/Drop.tscn”. Adding nodes to the Drop scene Let’s add nodes so that the Drop scene will look like the following scene tree. We will edit the properties of each node in turn later, so we can leave them as they are.\nDrop (RigidBody2D) Sprite CollisionShape2D PointableArea (Area2D) CollisionShape2D AnimationPlayer StickableArea (Area2D) CollisionShape2D The scene tree dock should now look like this.\nEditing nodes in the Drop scene Drop (RigidBody2D) root node We want the “Drop” scene to automatically fall or bounce according to gravity when its instance is added to the “World” scene. The RigidBody2D class automatically reproduces such physics-based movements according to the node’s properties.\nIn the inspector dock, apply a new “PhysicsMaterial” resource to the “Physics Material Override” property.\nSet the property “Gravity Scale” to 2. The purpose is to make the drop fall a little faster.\nGo to Node Dock \u003e Groups tab and create and add a group named “Drops”. This is important for the conditional branching process in the script.\nSprite node This node is used to give “Drop” a texture (appearance). The method of setting the texture of the sprite by specifying the range of textures you want to use from the sprite sheet that contains many textures imported at the beginning of this section is used.\nIn the inspector, drag the resource “res://characters_packed.png” from the file system to the property “Texture” and apply it.\nTurn on “Region” \u003e “Enabled”.\nOpen the Texture Region panel at the bottom of the editor.\nExpand the panel by clicking on the expand icon to make it easier to work with.\nSelect “grid snap” under “snap mode” at the top of the panel.\nSet the “step” at the top of the panel to 24px 24px. This will make the grid the same size as one texture on the sprite sheet.\nDrag on the sprite sheet to select a range of two different textures with a green drop (looks like an alien).\nGo back to the inspector and change the value of the “Animation” \u003e “Hframes” property to 2.\nCollisionShape2D node (child of root node Drop) This node provides a collision shape to the root node “Drop”. The root node is a “RigidBody2D” class, one of the physical bodies. The collision setting is essential to determine collisions between physical bodies. With this collision shape, it is assumed that multiple instances of the “Drop” scene will collide with each other and pile up on the screen.\nApply a new “CircleShape2D” resource to the “Shape” property. Furthermore, change the value of the property “Radius” of that resource to 12. This creates a circular collision shape with a radius of 12 px, which can be intuitively sized in the 2D workspace.\nPointableArea (Area2D) node This node is used to detect when a finger or mouse cursor touches or leaves its drop. No property editing is required, but a group needs to be added.\nGo to the Node Dock \u003e Groups tab and create and add a group named “Pointable”. This is used to determine if the finger or mouse cursor is touching the drop.\nCollisionShape2D (child of PointableArea) node This node provides a collision shape to the parent “PointableArea”. It should fit slightly inside the collision shape of the root node “Drop” so that it does not react when a finger or mouse cursor touches the edge of the drop.\nApply a new “CircleShape2D” resource to the property “Shape”. In addition, change the value of the property “Radius” of the resource to 10. The collision shape is one size smaller than the collision shape of the root node “Drop”. You can intuitively adjust the size in the 2D workspace.\n*The collision shape for this node is an inner circle AnimationPlayer node The first step here is to create a waiting animation for the drop when the finger or mouse cursor is not touching it, and a blinking animation to show it after it is touched. This node will be used to play those animation resources that we have created.\nCreate a drop waiting animation as follows. Animation name: idle Auto play on load: Enabled Animation length (seconds): 1 Animation looping: Enabled Track: Sprite node - frame property Time: 0 / Value: 0 / Easing: 1.00 Time: 0.5 / Value: 1 / Easing: 1.00 Sprite node - modulate property Time: 0 / Value: #ffffff / Easing: 1.00\n*A track to ensure that after modulate is changed in a “flash” animation, it is reset to its initial value when the “idle” animation is played.\nCreate an animation of the drop in standby as follows. Animation name: flash Auto play on load: disabled Animation length (seconds): 0.2 Animation looping: Enabled Track: Sprite node - frame property Time: 0 / Value: 0 / Easing: 1.00 Time: 0.1 / Value: 1 / Easing: 1.00 Sprite node - modulate property Time: 0 / Value: #ffffff / Easing: 1.00 Time: 0.1 / Value: #64ffffff / Easing: 1.00\nStickableArea (Area2D) node This node is used to detect if a drop is in contact with another drop. No property editing is required, but a group needs to be added.\nGo to Node Dock \u003e Groups tab and create and add a group named “Stickable”. This is important to determine if the drop is “adjacent” = “connectable” when you trace your finger or mouse cursor over it.\nCollisionShape2D node This node provides a collision shape for the parent “StickableArea” node. It is used to detect adjacent drops. In order to detect contact between adjacent drops, the collision shape should be slightly larger than the collision shape of the root node “Drop”.\nApply a new “CircleShape2D” resource to the property “Shape”. In addition, change the value of the property “Radius” of the resource to 18. This creates a circular collision shape with a radius of 18 px. It can also be intuitively sized in the 2D workspace.\n*The collision shape for this node is the outermost circle. This completes the editing of each node.\nControlling the Drop scene with a script Now let’s attach a new script to the root node “Drop”. Create a script file with the file path “res://Drops/Drop.gd”.\nEdit the script as follows.\n### Drop.gd ### extends RigidBody2D # Properties to assign each color name to a scene that inherits from the Drop scene export var color = \"\" # define stuck_drop as an array to contain adjacent drops var stuck_drops = [] # Reference to the AnimationPlayer node onready var anim_player = $AnimationPlayer Next, we will use signals from the Area2D node of the “StickableArea” node. Let’s connect the “area_entered” signal, which is sent out when a drop makes contact with an adjacent drop, and the “area_exited” signal, which is sent out when a drop that was in contact with a drop leaves the area, to the script.\nEdit the method generated when you connect each signal as follows.\n### Drop.gd ### # Method called when a StickableArea is collided by another area (Area2D) func _on_StickableArea_area_entered(area): # If the area was collided by a Stickable group node if area.is_in_group(\"Stickable\"): # Define its parent node as drop var drop = area.get_parent() # Add drop to the array stuck_drops stuck_drops.append(drop) # Method called when another area (Area2D) leaves StickableArea func _on_StickableArea_area_exited(area): # If the area that was exited from the collision shape is a Stickable group node if area.is_in_group(\"Stickable\"): # Define its parent node as drop var drop = area.get_parent() # Check the index of a drop in the array stuck_drops var index = stuck_drops.find(drop) # Remove the element (adjacent Drop) corresponding to index from the array stuck_drops stuck_drops.remove(index) This completes the editing of “Drop.gd”.\nCreating a scene that inherits from the Drop scene The “Drop” scene we just created is a template for the scene we will create. We will now create a scene that inherits the “Drop” scene in the number of drop colors. There are five drop colors: blue, green, orange, red, and yellow. Let’s start with the Blue drop as an example.\nSelect “Scene” menu \u003e “New Inherited Scene. Select “Drops.tscn” as the source scene for the minor injury. After the scene is generated, rename the root node to “Blue.\n*The name of this root node should match the color of each drop. Save the scene. Save the file path as “res://Drops/BlueDrop.tscn”. With the root node “BlueDrop” selected in the scene tree dock, set the value of “Color” in Script Variables to “Blue” in the inspector.\nSelect the “Sprite” node in the scene tree dock. Open the “Texture Area” panel at the bottom of the editor and select the two blue alien textures.\nThis completes the “BlueDrop” scene. Follow the same procedure to create the remaining four color scenes. The name of the root node of the scene and its property “Color” are as follows.\nRoot node: GreenDrop / Color: Green Root node: OrangeDrop / Color: Orange Root node: RedDrop / Color: Red Root node: YellowDrop / Color: Yellow When we have created an inheritance scene with a total of five drop colors, our work is complete.\nControlling a World Scene with Scripts We are now approaching the end of this tutorial. Let’s attach a script to the root node of the “World” scene. Create the file path as “res://World/World.tscn”.\nWhen the script editor opens, first define the properties as follows\n### World.gd ### extends Node2D # Define drop_scenes as an array with 5 preloaded color drop scenes as elements const drop_scenes = [ preload(\"res://Drops/BlueDrop.tscn\"), preload(\"res://Drops/GreenDrop.tscn\"), preload(\"res://Drops/OrangeDrop.tscn\"), preload(\"res://Drops/RedDrop.tscn\"), preload(\"res://Drops/YellowDrop.tscn\") ] # Minimum number of connecting drops that can be erased export (int) var min_erasable = 3 # Maximum number of drops displayed on the screen export (int) var max_drops = 50 # True if the game is currently playing var is_playing = false # True if finger on the screen or left mouse click is held down var is_holding = false # Referencing the drop where the finger or mouse cursor is currently held var pointed_drop # Color of the drops currently connected var active_color = \"\" # Array for list of held (traced and connected) drops var held_drops = [] # A reference to the Spawner node onready var spawner = $SpawnPath/Spawner # A reference to the Drops node onready var drops = $Drops # Reference to a DropsLine node onready var drops_line = $DropsLine # Reference to a Pointer node onready var pointer = $Pointer Next, let’s code the maximum number of drops (50) to fall from the top of the screen immediately after the game starts.\n### World.gd ### # Method called when all nodes in the World scene have been loaded func _ready(): # Built-in method that will randomize the output of random methods every time. randomize() # Loop for the number of max_drops (50) for _i in range(max_drops): # Call a method (defined later) to generate drops spawn_drop() # Wait 0.025 seconds after one drop is spawned, then spawn the next drop yield(get_tree().create_timer(0.025), \"timeout\") # Method to spawn a drop func spawn_drop(): # Reference to a scene file for a randomly chosen color drop from the array drop_scenes var drop_scene = drop_scenes[randi() % drop_scenes.size()] # Instantiate a drop scene of the selected color var drop = drop_scene.instance() # Make the position of the drop instance the same as the position of the Spawner node drop.position = spawner.global_position # Add the drop instance to the World scene drops.add_child(drop) Now let’s run the project and watch the behavior of 50 drops of randomly determined colors falling at the start of the game. Note that when we run the project for the first time, we should set the main scene as “World.tscn”.\nThe position of the “Pointer (Area2D)” node will be coded to follow the position of the finger or mouse cursor, and the “PointableArea (Area2D)” of the “Drop” instance will detect when the finger or mouse cursor overlaps with it and when it leaves it. The “Pointer” node detects this and sends a signal. Let’s use this to code the process when tracing a drop.\nSelect “Pointer” in the scene tree dock and connect the signals “area_entered(area: Area2D)” and “area_exited(area: Area2D)” to the script in the Node Dock \u003e Signal tab.\nEdit the automatically generated methods as follows.\n### World.gd ### # Method called when a Pointer node touches another area (Area2D object) func _on_Pointer_area_entered(area): # if area is a node in the \"Pointable\" group if area.is_in_group(\"Pointable\"): # Pass a reference to the parent node of area (Drop node) to pointed_drop pointed_drop = area.get_parent() # If drop in hold is non-zero.. # and the last drop in the hold is adjacent to pointed_drop if not held_drops.empty() and held_drops[-1] in pointed_drop.stuck_drops: # Call a method to update drop connections (defined later) update_drops_connection() # Method called when the area (Area2D object) that the Pointer node was touching leaves func _on_Pointer_area_exited(area): # If area is a node in the \"Pointable\" group if area.is_in_group(\"Pointable\"): # Set pointed_drop to null pointed_drop = null Next, use the built-in function _process to execute the method you want to call every frame (60FPS).\n### World.gd ### # Built-in function: called at 60FPS func _process(_delta): # Update the Points property of the DropsLine node update_drops_line() # Receive finger or mouse cursor actions get_input() # Method to update the Points property of a DropsLine node.. # to change the position of a drop as it rolls or falls func update_drops_line(): # If there is at least one drop in hold if not held_drops.empty(): # Create a temporary Vector2 array var temp_array = PoolVector2Array() # Loop over held drops for drop in held_drops: # Add the position of the drop in hold to the temporary array temp_array.append(drop.position) # Update the points property of the DropsLine node to the position of the currently held drop drops_line.points = temp_array # Methods to process finger or mouse input func get_input(): # Always set the Pointer node position to the finger or mouse cursor position pointer.position = get_global_mouse_position() # If you press the screen with a finger or the left mouse button if Input.is_action_just_pressed(\"tap\"): # Call a method (defined later) to hold the drop hold_drop() # Call a method (to be defined later) to update the connection of drops on hold update_drops_connection() # If the finger leaves the screen or the left mouse button is up if Input.is_action_just_released(\"tap\"): # Call a method (defined later) to erase drops on hold erase_drops() # Call a method to release holds (to be defined later). release_drops(). The following methods, which are called in the method get_input defined in the above code, will be defined in order after this.\nhold_drop update_drops_connection erase_drops release_drops First, let’s define the methods hold_drop and update_drops_connection to be called when a drop is held down.\n### World.gd ### # Methods to hold a drop while it is being held func hold_drop(): # If finger or mouse cursor is touching the drop if pointed_drop: # Hold the drop. is_holding = true # Method to update drop connections func update_drops_connection(): # If drop is holding and .. # if finger or mouse cursor is over the drop if is_holding and pointed_drop: # If is_holding and pointed_drop: # if held_drops.empty(): # if held_drops.empty() if held_drops.empty(): # If the color of the drop to be held is currently set to the color of the finger or .. # color of the drop that the mouse cursor is currently touching active_color = pointed_drop.color # Call a method (to be defined later) to connect drops connect_drop() # If the color of the drop currently touched by the finger or mouse cursor.. # is the same as the color of the drop being connected elif pointed_drop.color == active_color: # If the number of drops in hold is greater than or equal to 2 and .. # if the current touched drop is the same as the second last drop in the hold if held_drops.size() \u003e= 2 and pointed_drop == held_drops[-2]: # Call a method (defined later) to disconnect disconnect_drop() # If the drop currently touched by the finger or mouse cursor is not in the held drops elif not pointed_drop in held_drops: # Call a method (defined later) to connect the drops connect_drop() If you look inside the method update_drops_connection defined here, you will see that there are further undefined connect_drop and disconnect_drop methods called.\nLet’s continue to define these methods.\n### World.gd ### # Methods to connect drops func connect_drop(): # Play the animation \"flash\" on the currently touched drop pointed_drop.anim_player.play(\"flash\") # Add the currently touched drop to the list of held drops held_drops.append(pointed_drop) # Add the position of the currently touched drop to the Points property of the DropsLine node drops_line.add_point(pointed_drop.position) # Methods to disconnect drops func disconnect_drop(): # Define the last drop in the list of held drops as canceled_drop var canceled_drop = held_drops.pop_back() # Stop animation (\"flash\") in AnimationPlayer of canceled_drop canceled_drop.anim_player.stop() # Play the animation (\"idle\") in AnimationPlayer of canceled_drop canceled_drop.anim_player.play(\"idle\") # Remove the last point from the Points property of a DropsLine node drops_line.remove_point(drops_line.get_point_count() - 1) Within the get_input method, we will now define two methods, erase_drops and release_drops, which will be called when the finger leaves the screen or the left mouse button is raised.\n### World.gd ### # Methods to erase drops func erase_drops(): # If the number of held drops is less than the minimum number of drops that can be erased if held_drops.size() \u003c min_erasable: # Immediately terminate the method return # Duplicate the array of held drops as the value of variable erased var erased = held_drops.duplicate() # Loop over the elements of array erased for drop in erased: # Release the drops in array erased drop.queue_free() # Create a new drop for each erased drop spawn_drop() # Wait 0.1 seconds (then next loop) yield(get_tree().create_timer(0.1), \"timeout\")\t# Method to release holds from drops func release_drops(): # Release status while holding is_holding = false # Loop over the elements of the array of held drops for drop in held_drops: # Stop animation \"flash\" drop.anim_player.stop() # Play the animation \"idle\". drop.anim_player.play(\"idle\") # Empty the array of held drops held_drops.clear() # Empty the Points property of the DropsLine node drops_line.clear_points() This completes the editing of the “World.gd” script.\nExecuting the scene to check the operation Finally, let’s run a scene to see if it reproduces the movement as expected.\nHave you confirmed that the following is as expected?\nWhen the left mouse button is pressed while the mouse cursor is near the center of the drop, the drop is held and a “flash” animation is played. If you hold down the left mouse button and trace the adjacent drop, the “DropsLine” will be connected. If you return to the drop you have traced, the hold is released and the “idle” animation returns to playback. When three or more drops are traced, all drops in the hold disappear when the left mouse button is released. If less than three drops are traced, releasing the left mouse button does not erase the drops, only releases the hold. Sample Games We have prepared a sample game that further brushes up the project created in this tutorial.\nYour browser does not support the video tag. The project file is located in GitHub repository , so please download the .zip file from there and you can check it by importing the “project.godot” file in the “Sample” folder with the Godot Engine.\nConclusion In this tutorial, We created a puzzle game in which you have to trace the same color to make it disappear. It is the kind of game that one cannot help but feel addicted to. Let me summarize the key points in the creation of the game.\nUse RigidBody2D for the drop and let the engine do the physics. Add Area2D class nodes to the drop to detect fingers and cursors, and Area2D class nodes to detect adjacent drops, and use their signals. Always follow the Area2D class node to the finger or mouse cursor and use the signal of this node for contact with the drop. Links KENNEY Godot Docs: Physics introduction Godot Docs: RigidBody2D Godot Docs: Using Area2D Godot Docs: Area2D Godot Docs: CollisionShape2D Godot Docs: CollisionPolygon2D Godot Docs: Path2D Godot Docs: PathFollow2D Godot Docs: Line2D Godot Docs: Introduction to the animation features Godot Docs: AnimationPlayer ","wordCount":"4674","inLanguage":"en","image":"https://www.peanuts-code.com/images/tutorials/gd0011_connect_colors/img36.gif","datePublished":"2022-06-20T03:00:00+09:00","dateModified":"2022-06-20T03:00:00+09:00","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/en/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/ja/ title=Japanese aria-label=🇯🇵日本語>🇯🇵日本語</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/en/ title=Home><span>Home</span></a></li><li><a href=https://www.peanuts-code.com/en/portfolio/ title=Works><span>Works</span></a></li><li><a href=https://www.peanuts-code.com/en/posts/ title=Blogs><span>Blogs</span></a></li><li><a href=https://www.peanuts-code.com/en/tutorials/ title=Tutorials><span>Tutorials</span></a></li><li><a href=https://www.peanuts-code.com/en/about/ title=About><span>About</span></a></li><li><a href=https://www.peanuts-code.com/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/en/>Home</a>&nbsp;»&nbsp;<a href=https://www.peanuts-code.com/en/tutorials/>🤖 Tutorials</a></div><h1 class="post-title entry-hint-parent">🤖 Connecting Matching Colors Puzzle Game in Godot3</h1><div class=post-meta><span title='2022-06-20 03:00:00 +0900 +0900'>2022-06-20</span>&nbsp;·&nbsp;10 min&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/ja/tutorials/gd0011_connect_colors/>🇯🇵日本語</a></li></ul></div><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Connecting Matching Colors Puzzle Game in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Connecting%20Matching%20Colors%20Puzzle%20Game%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0011_connect_colors%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cPuzzleGame%2cMobileGame%2cMatch3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Connecting Matching Colors Puzzle Game in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0011_connect_colors%2f&title=%f0%9f%a4%96%20Connecting%20Matching%20Colors%20Puzzle%20Game%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Connecting Matching Colors Puzzle Game in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0011_connect_colors%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/puzzlegame/>PuzzleGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/mobilegame/>MobileGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/match3/>Match3</a></li></ul></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0011_connect_colors/img36.gif alt="Connecting Matching Colors Puzzle Game in Godot"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#creating-a-new-project>Creating a new project</a><ul><li><a href=#editing-project-settings>Editing project settings</a></li><li><a href=#downloading-and-importing-the-assets>Downloading and importing the assets</a></li></ul></li><li><a href=#creating-a-world-scene>Creating a World Scene</a><ul><li><a href=#adding-nodes-to-the-world-scene>Adding nodes to the World scene</a></li><li><a href=#editing-nodes-in-the-world-scene>Editing nodes in the World scene</a></li></ul></li><li><a href=#creating-a-drop-scene>Creating a Drop scene</a><ul><li><a href=#adding-nodes-to-the-drop-scene>Adding nodes to the Drop scene</a></li><li><a href=#editing-nodes-in-the-drop-scene>Editing nodes in the Drop scene</a></li><li><a href=#controlling-the-drop-scene-with-a-script>Controlling the Drop scene with a script</a></li></ul></li><li><a href=#creating-a-scene-that-inherits-from-the-drop-scene>Creating a scene that inherits from the Drop scene</a></li><li><a href=#controlling-a-world-scene-with-scripts>Controlling a World Scene with Scripts</a></li><li><a href=#executing-the-scene-to-check-the-operation>Executing the scene to check the operation</a></li><li><a href=#sample-games>Sample Games</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#links>Links</a></li></ul></nav></div></details></div><div class=post-content><p>In this tutorial, we will explain how to create a type of game in which you trace and erase drops of the same color, like the very popular Disney Tsum Tsum smartphone game.</p><p><a href=https://www.disney.co.jp/fc/tsum/tsum_en.html target=_blank>LINE: Disney Tsum Tsum</a></p><br><p>Note that the final project file in this tutorial is located in the <a href=https://github.com/msnsk/ConnectColors.git target=_blank>GitHub repository</a>
. You can directly check the project by downloading the .zip file and importing the &ldquo;project.godot&rdquo; file in the &ldquo;End&rdquo; folder with the Godot Engine.</p><br><blockquote><p><em><strong><span style=color:salmon>Environment</span></strong><br>This tutorial was created in the following environment</em><br>・<em>Godot version: <strong>3.4.4</strong></em><br>・<em>Computer OS version: <strong>macOS 11.6.5</strong></em></p></blockquote><blockquote><p><em><strong><span style=color:salmon>Memo:</span></strong><br>Please also use the following articles to help you start creating your game.<br><a href=https://www.peanuts-code.com/en/tutorials/gd0001_download/>Downloading Godot</a><br><a href=https://www.peanuts-code.com/en/tutorials/gd0002_project_manager/>Project Manager of Godot</a></em></p></blockquote><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-new-project>Creating a new project</h2><p>First, we would like you to start Godot Engine and create a new project. Let&rsquo;s name the project &ldquo;Connect Colors Start.</p><br><h3 id=editing-project-settings>Editing project settings</h3><p>Once the editor appears, let&rsquo;s editing the settings for the entire project.</p><p>First, set the display size for the game. In this case, we set the aspect ratio to 16:9, assuming a smartphone screen in portrait orientation.</p><ol><li>Open the &ldquo;Project&rdquo; menu > &ldquo;Project Settings&rdquo;<br>In the &ldquo;General&rdquo; tab, search for &ldquo;window&rdquo; and select &ldquo;Display&rdquo; > &ldquo;Window&rdquo; in the sidebar.</li><li>In the &ldquo;Size&rdquo; section, change the values of the following items<ul><li>Width: 144</li><li>Height: 256</li><li>Test Width: 288</li><li>Test Height: 512<br><img alt="Display - Window - Size" loading=lazy src=/images/tutorials/gd0011_connect_colors/img1.png></li></ul></li><li>Change the values of the following items in the &ldquo;Stretch&rdquo; section<ul><li>Mode: 2d</li><li>Aspect: keep<br><img alt="Display - Window - Stretch" loading=lazy src=/images/tutorials/gd0011_connect_colors/img2.png></li></ul></li></ol><br><p>Keep the &ldquo;Project Settings&rdquo; open and configure the settings to substitute the mouse for the smartphone&rsquo;s touch operation.</p><ol><li>Search for &ldquo;mouse&rdquo; in the &ldquo;General&rdquo; tab and select &ldquo;Input Devices&rdquo; > &ldquo;Pointing&rdquo; in the sidebar.</li><li>Check &ldquo;On&rdquo; for &ldquo;Emulate Touch From Mouse&rdquo;.<br><img alt="Input Devices - Pointing - Emulate Touch From Mouse" loading=lazy src=/images/tutorials/gd0011_connect_colors/img2.1.png></li></ol><br><p>With the &ldquo;Project Settings&rdquo; window open, add an action to the input map that corresponds to a smartphone touch operation.</p><ol><li>Switch to the &ldquo;Input Map&rdquo; tab and add &ldquo;tap&rdquo; to the action.</li><li>Add a left mouse click to the &ldquo;tap&rdquo; action.<br><img alt="Inputmap - action - tap" loading=lazy src=/images/tutorials/gd0011_connect_colors/img2.2.png></li></ol><br><h3 id=downloading-and-importing-the-assets>Downloading and importing the assets</h3><p>Next, let&rsquo;s download assets from KENNEY and use them. The asset pack we will be using is called <strong><a href=https://www.kenney.nl/assets/pixel-platformer target=_blank>Pixel Platformer</a>
</strong>. I can&rsquo;t help but be thankful for this wonderful free resource.</p><p>Once downloaded, drag and drop the &ldquo;characters_packed.png&rdquo; file from the &ldquo;Tilemap&rdquo; folder into the editor&rsquo;s file system dock to import it into your project.</p><p>Immediately after importing the file, the image will look blurry, so follow the steps below to correct this.</p><ol><li>Make the imported asset file selected in the file system dock<br><img alt="select the asset" loading=lazy src=/images/tutorials/gd0011_connect_colors/img3.png></li><li>Select [Presets] > [2D Pixel] in the import dock.<br><img alt="select 2D Pixel" loading=lazy src=/images/tutorials/gd0011_connect_colors/img4.png></li><li>Click the &ldquo;Re-import&rdquo; button at the bottom.<br>! <a href=/images/tutorials/gd0011_connect_colors/img5.png>click reinport</a></li></ol><p>This will give the image the edgy look characteristic of pixel art.<br><br></p><hr><h2 id=creating-a-world-scene>Creating a World Scene</h2><p>The first scene is to set the stage for the game. Let&rsquo;s create a scene named &ldquo;World&rdquo;.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;Other Node&rdquo; in &ldquo;Generate Root Node&rdquo;.</li><li>Select a node of the &ldquo;Node2D&rdquo; class as the root node.</li><li>Rename the root node to &ldquo;World&rdquo;.</li><li>Save the scene at this point. Create a folder and save the scene with the file path &ldquo;res://World/World.tscn&rdquo;.<br><br></li></ol><h3 id=adding-nodes-to-the-world-scene>Adding nodes to the World scene</h3><p>Let&rsquo;s add nodes so that the world scene will look like the following scene tree. We will edit the properties of each node in turn later, so we can leave them as they are.</p><ul><li>World (Node2D)<ul><li>Bin (StaticBody2D)<ul><li>CollisionPolygon2D</li></ul></li><li>SpawnPath (Path2D)<ul><li>Spawner (PathFollow2D)</li></ul></li><li>AnimationPlayer</li><li>Drops (Node2D)</li><li>DropsLine (Line2D)</li><li>Pointer (Area2D)<ul><li>CollisionShape2D</li></ul></li></ul></li></ul><p>The scene tree dock should now look like this.<br><img alt="scene tree dock" loading=lazy src=/images/tutorials/gd0011_connect_colors/img6.png></p><br><h3 id=editing-nodes-in-the-world-scene>Editing nodes in the World scene</h3><h4 id=bin-staticbody2d-node>Bin (StaticBody2D) node</h4><p>This node does not need to be edited. StaticBody2D is used in 2D games for obstacles and walls that do not move. In this case, we will use it as a container (bin) to keep falling drops (objects to be erased by tracing) on the screen.<br><br></p><h4 id=collisionpolygon2d-node>CollisionPolygon2D node</h4><p>This node is used to add a collision shape to the parent node &ldquo;Bin&rdquo;. The collision shape is created by dotting in the 2D workspace.</p><ol><li><p>Activate grid snap in the 2D workspace toolbar.<br><img alt="enable grid snap" loading=lazy src=/images/tutorials/gd0011_connect_colors/img7.png></p></li><li><p>Basically, the collision shape is formed by dotting around the outside of the window frame. However, the upper part of the shape should be shifted by -64px from the y-coordinate 0 of the display size. This is to generate a drop outside the upper part of the window frame and make it fall. The lower part of the collision polygon is placed slightly inside the display size and slanted so that the drop will roll.<br><img alt="create collisoin shape" loading=lazy src=/images/tutorials/gd0011_connect_colors/img8.png></p></li></ol><br><h4 id=spawnpath-path2d-node>SpawnPath (Path2D) node</h4><p>This node is used to move the position of the spawning drop along the x-axis at all times. This makes the drops fall from the different positions at the top of the screen every time. Let&rsquo;s place it outside the top of the window frame.</p><ol><li>Create a straight path parallel to the x-axis by hitting two points (16, -32) and (128, -32) on the 2D workspace.<br><img alt="create path2d path" loading=lazy src=/images/tutorials/gd0011_connect_colors/img9.png></li></ol><br><h4 id=spawner-pathfollow2d-node>Spawner (PathFollow2D) node</h4><p>This node moves along the path of the &ldquo;SpawnPath&rdquo; node edited earlier. This node should always move back and forth along the path to generate a drop from this node&rsquo;s position. This will ensure that the drop&rsquo;s position when spawned always changes within the path of the &ldquo;SpawnPath&rdquo; node.</p><ol><li>Turn off the property &ldquo;Rotate&rdquo;.<br><img alt="disable property rotate" loading=lazy src=/images/tutorials/gd0011_connect_colors/img10.png></li></ol><br><h4 id=animationplayer-node>AnimationPlayer node</h4><p>This node is used to move &ldquo;Spawner&rdquo; back and forth along the path of &ldquo;SpawnPath&rdquo; at all times. The &ldquo;Spawner&rdquo; property &ldquo;Unit Offset&rdquo; represents the starting point of the parent node &ldquo;SpawnPath&rdquo; path as 0 and the end point as 1. In other words, by constantly changing this property between 0 and 1, it is possible to make a round trip on the path.</p><ol><li>Create an animation as follows<ul><li>Animation name: move_spawn_pos</li><li>Auto play on load: Enabled</li><li>Animation length (seconds): 0.4<br>*0.4 seconds to move back and forth along the path</li><li>Animation looping: Enabled</li><li>Track:<ul><li>Spawner node - unit_offset property<ul><li>Time: 0 / Value: 0 / Easing: 1.00</li><li>Time: 0.2 / Value: 1 / Easing: 1.00<br>*Wrap from the end of the path at 0.2 seconds<br><img alt="create animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img11.png></li></ul></li></ul></li></ul></li></ol><br><h4 id=drops-node2d-node>Drops (Node2D) node</h4><p>No property editing is required for this node. Its role is just a container for multiple instances generated from a drop scene (to be created later).</p><br><h4 id=dropline-line2d-node>DropLine (Line2D) node</h4><p>This node is used to draw a line connecting drops of the same color when they are traced. This makes it easier to visually check which drop has been traced and how many drops are connected.</p><ol><li><p>Change the property &ldquo;Width&rdquo; to 2. This is the thickness of the line.<br><img alt="Line2D Width property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img12.png></p></li><li><p>Change the properties &ldquo;Capping&rdquo; > &ldquo;Joint Mode&rdquo;, &ldquo;Begin Cap Mode&rdquo;, and &ldquo;End Cap Mode&rdquo; to &ldquo;Round&rdquo; respectively. This will make the shape of the joints, tips, and ends of the lines round.<br><img alt="Line2D Capping each property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img13.png></p></li></ol><br><h4 id=pointer-area2d-node>Pointer (Area2D) node</h4><p>There is no need to edit this node. The purpose of this node is to follow the finger on a smartphone or the mouse cursor on a PC to detect when a drop is touched. Later, we will write code in the script to make the position of this node always the same as the position of the finger or mouse cursor.</p><br><h4 id=collisionshape2d-node>CollisionShape2D node</h4><p>This node gives the parent node &ldquo;Pointer&rdquo; a collision shape. Considering the operation of touching the drop with a finger or mouse cursor, the collision should be as small a shape as possible.</p><ol><li>Apply the &ldquo;New CircleShape2D&rdquo; resource to the property &ldquo;Shape&rdquo;.</li><li>Set the value of the property &ldquo;Radius&rdquo; of the applied resource &ldquo;CircleShape2D&rdquo; to 1.<br><img alt="CollisionShape2D Shape, Radius" loading=lazy src=/images/tutorials/gd0011_connect_colors/img14.png></li></ol><br><p>This completes the editing of each node.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-drop-scene>Creating a Drop scene</h2><p>From here, we will create a &ldquo;Drop&rdquo; scene to be erased by tracing the same color.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;Other Node&rdquo; in &ldquo;Generate Root Node&rdquo;.</li><li>Select a node of the &ldquo;RigidBody2D&rdquo; class as the root node.</li><li>Rename the root node to &ldquo;Drop&rdquo;.</li><li>Save the scene at this point. Create a folder and save the scene with the file path &ldquo;res://Drops/Drop.tscn&rdquo;.</li></ol><br><h3 id=adding-nodes-to-the-drop-scene>Adding nodes to the Drop scene</h3><p>Let&rsquo;s add nodes so that the Drop scene will look like the following scene tree. We will edit the properties of each node in turn later, so we can leave them as they are.</p><ul><li>Drop (RigidBody2D)<ul><li>Sprite</li><li>CollisionShape2D</li><li>PointableArea (Area2D)<ul><li>CollisionShape2D</li></ul></li><li>AnimationPlayer</li><li>StickableArea (Area2D)<ul><li>CollisionShape2D</li></ul></li></ul></li></ul><p>The scene tree dock should now look like this.<br><img alt="Drop scene tree" loading=lazy src=/images/tutorials/gd0011_connect_colors/img15.png></p><br><h3 id=editing-nodes-in-the-drop-scene>Editing nodes in the Drop scene</h3><h4 id=drop-rigidbody2d-root-node>Drop (RigidBody2D) root node</h4><p>We want the &ldquo;Drop&rdquo; scene to automatically fall or bounce according to gravity when its instance is added to the &ldquo;World&rdquo; scene. The RigidBody2D class automatically reproduces such physics-based movements according to the node&rsquo;s properties.</p><ol><li>In the inspector dock, apply a new &ldquo;PhysicsMaterial&rdquo; resource to the &ldquo;Physics Material Override&rdquo; property.<br><img alt="Physics Material Override" loading=lazy src=/images/tutorials/gd0011_connect_colors/img16.png></li><li>Set the property &ldquo;Gravity Scale&rdquo; to 2. The purpose is to make the drop fall a little faster.<br><img alt="Gravity Scale" loading=lazy src=/images/tutorials/gd0011_connect_colors/img17.png></li><li>Go to Node Dock > Groups tab and create and add a group named &ldquo;Drops&rdquo;. This is important for the conditional branching process in the script.<br><img alt="Node dock - groups - Drops" loading=lazy src=/images/tutorials/gd0011_connect_colors/img17.1.png></li></ol><br><h4 id=sprite-node>Sprite node</h4><p>This node is used to give &ldquo;Drop&rdquo; a texture (appearance). The method of setting the texture of the sprite by specifying the range of textures you want to use from the sprite sheet that contains many textures imported at the beginning of this section is used.</p><ol><li>In the inspector, drag the resource &ldquo;res://characters_packed.png&rdquo; from the file system to the property &ldquo;Texture&rdquo; and apply it.<br><img alt="Sprite node Texture property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img18.png></li><li>Turn on &ldquo;Region&rdquo; > &ldquo;Enabled&rdquo;.<br><img alt="Region > Enabled = on" loading=lazy src="/images/tutorials/gd_common/node/Sprite/property/Region%3EEnabled=On.png"></li><li>Open the <strong>Texture Region</strong> panel at the bottom of the editor.<br><img alt="Region panel" loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/tab_name.png><ol><li>Expand the panel by clicking on the expand icon to make it easier to work with.<br><img alt="Expand Region pannel" loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/expand_icon.png></li><li>Select &ldquo;grid snap&rdquo; under &ldquo;snap mode&rdquo; at the top of the panel.<br><img alt="Region pannel > choose grid snap" loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/snap_mode=grid_snap.png"></li><li>Set the &ldquo;step&rdquo; at the top of the panel to 24px 24px. This will make the grid the same size as one texture on the sprite sheet.<br><img alt="Region pannel > input grid step" loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/step=24x24.png"></li><li>Drag on the sprite sheet to select a range of two different textures with a green drop (looks like an alien).<br><img alt="Select region" loading=lazy src=/images/tutorials/gd0011_connect_colors/img19.png></li></ol></li><li>Go back to the inspector and change the value of the &ldquo;Animation&rdquo; > &ldquo;Hframes&rdquo; property to 2.<br><img alt="animation - hframes property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img20.png></li></ol><br><h4 id=collisionshape2d-node-child-of-root-node-drop>CollisionShape2D node (child of root node Drop)</h4><p>This node provides a collision shape to the root node &ldquo;Drop&rdquo;. The root node is a &ldquo;RigidBody2D&rdquo; class, one of the physical bodies. The collision setting is essential to determine collisions between physical bodies. With this collision shape, it is assumed that multiple instances of the &ldquo;Drop&rdquo; scene will collide with each other and pile up on the screen.</p><ol><li>Apply a new &ldquo;CircleShape2D&rdquo; resource to the &ldquo;Shape&rdquo; property.</li><li>Furthermore, change the value of the property &ldquo;Radius&rdquo; of that resource to 12. This creates a circular collision shape with a radius of 12 px, which can be intuitively sized in the 2D workspace.<br><img alt="CollisionShape2D - Shape - CircleShape2D" loading=lazy src=/images/tutorials/gd0011_connect_colors/img21.png> <img alt="CollisionShape2D - 2DWrokSpace" loading=lazy src=/images/tutorials/gd0011_connect_colors/img22.png></li></ol><br><h4 id=pointablearea-area2d-node>PointableArea (Area2D) node</h4><p>This node is used to detect when a finger or mouse cursor touches or leaves its drop. No property editing is required, but a group needs to be added.</p><ol><li>Go to the Node Dock > Groups tab and create and add a group named &ldquo;Pointable&rdquo;. This is used to determine if the finger or mouse cursor is touching the drop.<br><img alt="Node dock - Groups - Pointable" loading=lazy src=/images/tutorials/gd0011_connect_colors/img23.png></li></ol><br><h4 id=collisionshape2d-child-of-pointablearea-node>CollisionShape2D (child of PointableArea) node</h4><p>This node provides a collision shape to the parent &ldquo;PointableArea&rdquo;. It should fit slightly inside the collision shape of the root node &ldquo;Drop&rdquo; so that it does not react when a finger or mouse cursor touches the edge of the drop.</p><ol><li>Apply a new &ldquo;CircleShape2D&rdquo; resource to the property &ldquo;Shape&rdquo;.</li><li>In addition, change the value of the property &ldquo;Radius&rdquo; of the resource to 10. The collision shape is one size smaller than the collision shape of the root node &ldquo;Drop&rdquo;. You can intuitively adjust the size in the 2D workspace.<br><img alt="CollisionShape2D - Shape - CircleShape2D" loading=lazy src=/images/tutorials/gd0011_connect_colors/img24.png> <img alt="CollisionShape2D - 2DWrokSpace" loading=lazy src=/images/tutorials/gd0011_connect_colors/img25.png>*The collision shape for this node is an inner circle</li></ol><br><h4 id=animationplayer-node-1>AnimationPlayer node</h4><p>The first step here is to create a waiting animation for the drop when the finger or mouse cursor is not touching it, and a blinking animation to show it after it is touched. This node will be used to play those animation resources that we have created.</p><ol><li>Create a drop waiting animation as follows.<ul><li>Animation name: idle</li><li>Auto play on load: Enabled</li><li>Animation length (seconds): 1</li><li>Animation looping: Enabled</li><li>Track:<ul><li>Sprite node - frame property<ul><li>Time: 0 / Value: 0 / Easing: 1.00</li><li>Time: 0.5 / Value: 1 / Easing: 1.00</li></ul></li><li>Sprite node - modulate property<ul><li>Time: 0 / Value: #ffffff / Easing: 1.00<br>*A track to ensure that after modulate is changed in a &ldquo;flash&rdquo; animation, it is reset to its initial value when the &ldquo;idle&rdquo; animation is played.<br><img alt="2D Workspace - idle animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img26.gif> <img alt="Animation panel - idle animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img26.png></li></ul></li></ul></li></ul></li><li>Create an animation of the drop in standby as follows.<ul><li>Animation name: flash</li><li>Auto play on load: disabled</li><li>Animation length (seconds): 0.2</li><li>Animation looping: Enabled</li><li>Track:<ul><li>Sprite node - frame property<ul><li>Time: 0 / Value: 0 / Easing: 1.00</li><li>Time: 0.1 / Value: 1 / Easing: 1.00</li></ul></li><li>Sprite node - modulate property<ul><li>Time: 0 / Value: #ffffff / Easing: 1.00</li><li>Time: 0.1 / Value: #64ffffff / Easing: 1.00<br><img alt="2D Workspace - flash animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img27.gif> <img alt="Animation panel - flash animation" loading=lazy src=/images/tutorials/gd0011_connect_colors/img27.png></li></ul></li></ul></li></ul></li></ol><br><h4 id=stickablearea-area2d-node>StickableArea (Area2D) node</h4><p>This node is used to detect if a drop is in contact with another drop. No property editing is required, but a group needs to be added.</p><ol><li>Go to Node Dock > Groups tab and create and add a group named &ldquo;Stickable&rdquo;. This is important to determine if the drop is &ldquo;adjacent&rdquo; = &ldquo;connectable&rdquo; when you trace your finger or mouse cursor over it.<br><img alt="Node dock - Groups - Stickable" loading=lazy src=/images/tutorials/gd0011_connect_colors/img28.png></li></ol><br><h4 id=collisionshape2d-node-1>CollisionShape2D node</h4><p>This node provides a collision shape for the parent &ldquo;StickableArea&rdquo; node. It is used to detect adjacent drops. In order to detect contact between adjacent drops, the collision shape should be slightly larger than the collision shape of the root node &ldquo;Drop&rdquo;.</p><ol><li>Apply a new &ldquo;CircleShape2D&rdquo; resource to the property &ldquo;Shape&rdquo;.</li><li>In addition, change the value of the property &ldquo;Radius&rdquo; of the resource to 18. This creates a circular collision shape with a radius of 18 px. It can also be intuitively sized in the 2D workspace.<br><img alt="CollisionShape2D - Shape - CircleShape2D" loading=lazy src=/images/tutorials/gd0011_connect_colors/img29.png> <img alt="CollisionShape2D - 2DWrokSpace" loading=lazy src=/images/tutorials/gd0011_connect_colors/img30.png>*The collision shape for this node is the outermost circle.</li></ol><br><p>This completes the editing of each node.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><h3 id=controlling-the-drop-scene-with-a-script>Controlling the Drop scene with a script</h3><p>Now let&rsquo;s attach a new script to the root node &ldquo;Drop&rdquo;. Create a script file with the file path &ldquo;res://Drops/Drop.gd&rdquo;.</p><p>Edit the script as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Drop.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>RigidBody2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Properties to assign each color name to a scene that inherits from the Drop scene</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>color</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># define stuck_drop as an array to contain adjacent drops</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>stuck_drops</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Reference to the AnimationPlayer node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>anim_player</span> <span class=o>=</span> <span class=nx>$AnimationPlayer</span>
</span></span></code></pre></div><br><p>Next, we will use signals from the Area2D node of the &ldquo;StickableArea&rdquo; node. Let&rsquo;s connect the &ldquo;area_entered&rdquo; signal, which is sent out when a drop makes contact with an adjacent drop, and the &ldquo;area_exited&rdquo; signal, which is sent out when a drop that was in contact with a drop leaves the area, to the script.<br><img alt="StickableArea - signals" loading=lazy src=/images/tutorials/gd0011_connect_colors/img31.png></p><p>Edit the method generated when you connect each signal as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Drop.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># Method called when a StickableArea is collided by another area (Area2D)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_StickableArea_area_entered</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># If the area was collided by a Stickable group node</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Stickable&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Define its parent node as drop</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>drop</span> <span class=o>=</span> <span class=n>area</span><span class=o>.</span><span class=nf>get_parent</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># Add drop to the array stuck_drops</span>
</span></span><span class=line><span class=cl>		<span class=n>stuck_drops</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=n>drop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method called when another area (Area2D) leaves StickableArea</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_StickableArea_area_exited</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># If the area that was exited from the collision shape is a Stickable group node</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Stickable&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Define its parent node as drop</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>drop</span> <span class=o>=</span> <span class=n>area</span><span class=o>.</span><span class=nf>get_parent</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># Check the index of a drop in the array stuck_drops</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>index</span> <span class=o>=</span> <span class=n>stuck_drops</span><span class=o>.</span><span class=nf>find</span><span class=p>(</span><span class=n>drop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># Remove the element (adjacent Drop) corresponding to index from the array stuck_drops</span>
</span></span><span class=line><span class=cl>		<span class=n>stuck_drops</span><span class=o>.</span><span class=nf>remove</span><span class=p>(</span><span class=n>index</span><span class=p>)</span>
</span></span></code></pre></div><br><p>This completes the editing of &ldquo;Drop.gd&rdquo;.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-scene-that-inherits-from-the-drop-scene>Creating a scene that inherits from the Drop scene</h2><p>The &ldquo;Drop&rdquo; scene we just created is a template for the scene we will create. We will now create a scene that inherits the &ldquo;Drop&rdquo; scene in the number of drop colors. There are five drop colors: blue, green, orange, red, and yellow. Let&rsquo;s start with the <strong>Blue</strong> drop as an example.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Inherited Scene.</li><li>Select &ldquo;Drops.tscn&rdquo; as the source scene for the minor injury.</li><li>After the scene is generated, rename the root node to &ldquo;Blue.<br>*The name of this root node should match the color of each drop.</li><li>Save the scene. Save the file path as &ldquo;res://Drops/BlueDrop.tscn&rdquo;.</li><li>With the root node &ldquo;BlueDrop&rdquo; selected in the scene tree dock, set the value of &ldquo;Color&rdquo; in Script Variables to &ldquo;Blue&rdquo; in the inspector.<br><img alt="BlueDrop - Color property" loading=lazy src=/images/tutorials/gd0011_connect_colors/img32.png></li><li>Select the &ldquo;Sprite&rdquo; node in the scene tree dock. Open the &ldquo;Texture Area&rdquo; panel at the bottom of the editor and select the two <strong>blue</strong> alien textures.<br><img alt="Sprite - Texture Region" loading=lazy src=/images/tutorials/gd0011_connect_colors/img33.png></li></ol><p>This completes the &ldquo;BlueDrop&rdquo; scene. Follow the same procedure to create the remaining four color scenes. The name of the root node of the scene and its property &ldquo;Color&rdquo; are as follows.</p><ul><li>Root node: GreenDrop / Color: Green</li><li>Root node: OrangeDrop / Color: Orange</li><li>Root node: RedDrop / Color: Red</li><li>Root node: YellowDrop / Color: Yellow</li></ul><p>When we have created an inheritance scene with a total of five drop colors, our work is complete.<br><br></p><hr><h2 id=controlling-a-world-scene-with-scripts>Controlling a World Scene with Scripts</h2><p>We are now approaching the end of this tutorial. Let&rsquo;s attach a script to the root node of the &ldquo;World&rdquo; scene. Create the file path as &ldquo;res://World/World.tscn&rdquo;.</p><p>When the script editor opens, first define the properties as follows</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### World.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Define drop_scenes as an array with 5 preloaded color drop scenes as elements</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>drop_scenes</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/BlueDrop.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/GreenDrop.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/OrangeDrop.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/RedDrop.tscn&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Drops/YellowDrop.tscn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Minimum number of connecting drops that can be erased</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kd>var</span> <span class=n>min_erasable</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl><span class=c1># Maximum number of drops displayed on the screen</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kd>var</span> <span class=n>max_drops</span> <span class=o>=</span> <span class=mi>50</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># True if the game is currently playing</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_playing</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># True if finger on the screen or left mouse click is held down</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>is_holding</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=c1># Referencing the drop where the finger or mouse cursor is currently held</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>pointed_drop</span>
</span></span><span class=line><span class=cl><span class=c1># Color of the drops currently connected</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>active_color</span> <span class=o>=</span> <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># Array for list of held (traced and connected) drops</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>held_drops</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># A reference to the Spawner node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>spawner</span> <span class=o>=</span> <span class=nx>$SpawnPath/Spawner</span>
</span></span><span class=line><span class=cl><span class=c1># A reference to the Drops node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>drops</span> <span class=o>=</span> <span class=nx>$Drops</span>
</span></span><span class=line><span class=cl><span class=c1># Reference to a DropsLine node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>drops_line</span> <span class=o>=</span> <span class=nx>$DropsLine</span>
</span></span><span class=line><span class=cl><span class=c1># Reference to a Pointer node</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>pointer</span> <span class=o>=</span> <span class=nx>$Pointer</span>
</span></span></code></pre></div><br><p>Next, let&rsquo;s code the maximum number of drops (50) to fall from the top of the screen immediately after the game starts.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### World.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method called when all nodes in the World scene have been loaded</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Built-in method that will randomize the output of random methods every time.</span>
</span></span><span class=line><span class=cl>	<span class=nb>randomize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop for the number of max_drops (50)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>_i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>max_drops</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Call a method (defined later) to generate drops</span>
</span></span><span class=line><span class=cl>		<span class=nf>spawn_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># Wait 0.025 seconds after one drop is spawned, then spawn the next drop</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.025</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to spawn a drop</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>spawn_drop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Reference to a scene file for a randomly chosen color drop from the array drop_scenes</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>drop_scene</span> <span class=o>=</span> <span class=n>drop_scenes</span><span class=p>[</span><span class=nb>randi</span><span class=p>()</span> <span class=o>%</span> <span class=n>drop_scenes</span><span class=o>.</span><span class=nf>size</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>    <span class=c1># Instantiate a drop scene of the selected color</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>drop</span> <span class=o>=</span> <span class=n>drop_scene</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Make the position of the drop instance the same as the position of the Spawner node</span>
</span></span><span class=line><span class=cl>	<span class=n>drop</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>spawner</span><span class=o>.</span><span class=n>global_position</span>
</span></span><span class=line><span class=cl>    <span class=c1># Add the drop instance to the World scene</span>
</span></span><span class=line><span class=cl>	<span class=n>drops</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>drop</span><span class=p>)</span>
</span></span></code></pre></div><p>Now let&rsquo;s run the project and watch the behavior of 50 drops of randomly determined colors falling at the start of the game. Note that when we run the project for the first time, we should set the main scene as &ldquo;World.tscn&rdquo;.<br><img alt="run project" loading=lazy src=/images/tutorials/gd0011_connect_colors/img34.gif></p><br><p>The position of the &ldquo;Pointer (Area2D)&rdquo; node will be coded to follow the position of the finger or mouse cursor, and the &ldquo;PointableArea (Area2D)&rdquo; of the &ldquo;Drop&rdquo; instance will detect when the finger or mouse cursor overlaps with it and when it leaves it. The &ldquo;Pointer&rdquo; node detects this and sends a signal. Let&rsquo;s use this to code the process when tracing a drop.</p><p>Select &ldquo;Pointer&rdquo; in the scene tree dock and connect the signals &ldquo;area_entered(area: Area2D)&rdquo; and &ldquo;area_exited(area: Area2D)&rdquo; to the script in the Node Dock > Signal tab.<br><img alt="connect signals" loading=lazy src=/images/tutorials/gd0011_connect_colors/img35.png></p><p>Edit the automatically generated methods as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### World.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method called when a Pointer node touches another area (Area2D object)</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Pointer_area_entered</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># if area is a node in the &#34;Pointable&#34; group</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Pointable&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Pass a reference to the parent node of area (Drop node) to pointed_drop</span>
</span></span><span class=line><span class=cl>		<span class=n>pointed_drop</span> <span class=o>=</span> <span class=n>area</span><span class=o>.</span><span class=nf>get_parent</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># If drop in hold is non-zero..</span>
</span></span><span class=line><span class=cl>        <span class=c1># and the last drop in the hold is adjacent to pointed_drop</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=ow>not</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>empty</span><span class=p>()</span> <span class=ow>and</span> <span class=n>held_drops</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=ow>in</span> <span class=n>pointed_drop</span><span class=o>.</span><span class=n>stuck_drops</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Call a method to update drop connections (defined later)</span>
</span></span><span class=line><span class=cl>			<span class=nf>update_drops_connection</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method called when the area (Area2D object) that the Pointer node was touching leaves</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Pointer_area_exited</span><span class=p>(</span><span class=n>area</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># If area is a node in the &#34;Pointable&#34; group</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>area</span><span class=o>.</span><span class=nf>is_in_group</span><span class=p>(</span><span class=s2>&#34;Pointable&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Set pointed_drop to null</span>
</span></span><span class=line><span class=cl>		<span class=n>pointed_drop</span> <span class=o>=</span> <span class=kt>null</span>
</span></span></code></pre></div><p><br><br>Next, use the built-in function <code>_process</code> to execute the method you want to call every frame (60FPS).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### World.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Built-in function: called at 60FPS</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_process</span><span class=p>(</span><span class=n>_delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># Update the Points property of the DropsLine node</span>
</span></span><span class=line><span class=cl>	<span class=nf>update_drops_line</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Receive finger or mouse cursor actions</span>
</span></span><span class=line><span class=cl>	<span class=nf>get_input</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to update the Points property of a DropsLine node..</span>
</span></span><span class=line><span class=cl><span class=c1># to change the position of a drop as it rolls or falls</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>update_drops_line</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># If there is at least one drop in hold</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=ow>not</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>empty</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=c1># Create a temporary Vector2 array</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>temp_array</span> <span class=o>=</span> <span class=nf>PoolVector2Array</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># Loop over held drops</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=n>drop</span> <span class=ow>in</span> <span class=n>held_drops</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># Add the position of the drop in hold to the temporary array</span>
</span></span><span class=line><span class=cl>			<span class=n>temp_array</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=n>drop</span><span class=o>.</span><span class=n>position</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># Update the points property of the DropsLine node to the position of the currently held drop</span>
</span></span><span class=line><span class=cl>		<span class=n>drops_line</span><span class=o>.</span><span class=n>points</span> <span class=o>=</span> <span class=n>temp_array</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Methods to process finger or mouse input</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>get_input</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Always set the Pointer node position to the finger or mouse cursor position</span>
</span></span><span class=line><span class=cl>	<span class=n>pointer</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=nf>get_global_mouse_position</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># If you press the screen with a finger or the left mouse button</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_pressed</span><span class=p>(</span><span class=s2>&#34;tap&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Call a method (defined later) to hold the drop</span>
</span></span><span class=line><span class=cl>		<span class=nf>hold_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># Call a method (to be defined later) to update the connection of drops on hold</span>
</span></span><span class=line><span class=cl>		<span class=nf>update_drops_connection</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># If the finger leaves the screen or the left mouse button is up</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nc>Input</span><span class=o>.</span><span class=nf>is_action_just_released</span><span class=p>(</span><span class=s2>&#34;tap&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Call a method (defined later) to erase drops on hold</span>
</span></span><span class=line><span class=cl>		<span class=nf>erase_drops</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># Call a method to release holds (to be defined later).</span>
</span></span><span class=line><span class=cl>		<span class=nf>release_drops</span><span class=p>()</span><span class=o>.</span>
</span></span></code></pre></div><p>The following methods, which are called in the method <code>get_input</code> defined in the above code, will be defined in order after this.</p><ul><li><code>hold_drop</code></li><li><code>update_drops_connection</code></li><li><code>erase_drops</code></li><li><code>release_drops</code></li></ul><br><p>First, let&rsquo;s define the methods <code>hold_drop</code> and <code>update_drops_connection</code> to be called when a drop is held down.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### World.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Methods to hold a drop while it is being held</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hold_drop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># If finger or mouse cursor is touching the drop</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>pointed_drop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Hold the drop.</span>
</span></span><span class=line><span class=cl>		<span class=n>is_holding</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to update drop connections</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>update_drops_connection</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># If drop is holding and ..</span>
</span></span><span class=line><span class=cl>    <span class=c1># if finger or mouse cursor is over the drop</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>is_holding</span> <span class=ow>and</span> <span class=n>pointed_drop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># If is_holding and pointed_drop: # if held_drops.empty(): # if held_drops.empty()</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>empty</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=c1># If the color of the drop to be held is currently set to the color of the finger or ..</span>
</span></span><span class=line><span class=cl>            <span class=c1># color of the drop that the mouse cursor is currently touching</span>
</span></span><span class=line><span class=cl>			<span class=n>active_color</span> <span class=o>=</span> <span class=n>pointed_drop</span><span class=o>.</span><span class=n>color</span>
</span></span><span class=line><span class=cl>            <span class=c1># Call a method (to be defined later) to connect drops</span>
</span></span><span class=line><span class=cl>			<span class=nf>connect_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># If the color of the drop currently touched by the finger or mouse cursor..</span>
</span></span><span class=line><span class=cl>        <span class=c1># is the same as the color of the drop being connected</span>
</span></span><span class=line><span class=cl>		<span class=k>elif</span> <span class=n>pointed_drop</span><span class=o>.</span><span class=n>color</span> <span class=o>==</span> <span class=n>active_color</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># If the number of drops in hold is greater than or equal to 2 and ..</span>
</span></span><span class=line><span class=cl>            <span class=c1># if the current touched drop is the same as the second last drop in the hold</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>size</span><span class=p>()</span> <span class=o>&gt;=</span> <span class=mi>2</span> <span class=ow>and</span> <span class=n>pointed_drop</span> <span class=o>==</span> <span class=n>held_drops</span><span class=p>[</span><span class=o>-</span><span class=mi>2</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=c1># Call a method (defined later) to disconnect</span>
</span></span><span class=line><span class=cl>				<span class=nf>disconnect_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=c1># If the drop currently touched by the finger or mouse cursor is not in the held drops</span>
</span></span><span class=line><span class=cl>			<span class=k>elif</span> <span class=ow>not</span> <span class=n>pointed_drop</span> <span class=ow>in</span> <span class=n>held_drops</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=c1># Call a method (defined later) to connect the drops</span>
</span></span><span class=line><span class=cl>				<span class=nf>connect_drop</span><span class=p>()</span>
</span></span></code></pre></div><p>If you look inside the method <code>update_drops_connection</code> defined here, you will see that there are further undefined <code>connect_drop</code> and <code>disconnect_drop</code> methods called.</p><p>Let&rsquo;s continue to define these methods.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### World.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Methods to connect drops</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>connect_drop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># Play the animation &#34;flash&#34; on the currently touched drop</span>
</span></span><span class=line><span class=cl>	<span class=n>pointed_drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;flash&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># Add the currently touched drop to the list of held drops</span>
</span></span><span class=line><span class=cl>	<span class=n>held_drops</span><span class=o>.</span><span class=nf>append</span><span class=p>(</span><span class=n>pointed_drop</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># Add the position of the currently touched drop to the Points property of the DropsLine node</span>
</span></span><span class=line><span class=cl>	<span class=n>drops_line</span><span class=o>.</span><span class=nf>add_point</span><span class=p>(</span><span class=n>pointed_drop</span><span class=o>.</span><span class=n>position</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Methods to disconnect drops</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>disconnect_drop</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Define the last drop in the list of held drops as canceled_drop</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=n>canceled_drop</span> <span class=o>=</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>pop_back</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Stop animation (&#34;flash&#34;) in AnimationPlayer of canceled_drop</span>
</span></span><span class=line><span class=cl>	<span class=n>canceled_drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Play the animation (&#34;idle&#34;) in AnimationPlayer of canceled_drop</span>
</span></span><span class=line><span class=cl>	<span class=n>canceled_drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;idle&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># Remove the last point from the Points property of a DropsLine node</span>
</span></span><span class=line><span class=cl>	<span class=n>drops_line</span><span class=o>.</span><span class=nf>remove_point</span><span class=p>(</span><span class=n>drops_line</span><span class=o>.</span><span class=nf>get_point_count</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></div><br><p>Within the <code>get_input</code> method, we will now define two methods, <code>erase_drops</code> and <code>release_drops</code>, which will be called when the finger leaves the screen or the left mouse button is raised.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### World.gd ###</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Methods to erase drops</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>erase_drops</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># If the number of held drops is less than the minimum number of drops that can be erased</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>size</span><span class=p>()</span> <span class=o>&lt;</span> <span class=n>min_erasable</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Immediately terminate the method</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=c1># Duplicate the array of held drops as the value of variable erased</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>erased</span> <span class=o>=</span> <span class=n>held_drops</span><span class=o>.</span><span class=nf>duplicate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over the elements of array erased</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>drop</span> <span class=ow>in</span> <span class=n>erased</span><span class=p>:</span>
</span></span><span class=line><span class=cl>         <span class=c1># Release the drops in array erased</span>
</span></span><span class=line><span class=cl>		<span class=n>drop</span><span class=o>.</span><span class=nf>queue_free</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># Create a new drop for each erased drop</span>
</span></span><span class=line><span class=cl>		<span class=nf>spawn_drop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># Wait 0.1 seconds (then next loop)</span>
</span></span><span class=line><span class=cl>		<span class=k>yield</span><span class=p>(</span><span class=nf>get_tree</span><span class=p>()</span><span class=o>.</span><span class=nf>create_timer</span><span class=p>(</span><span class=mf>0.1</span><span class=p>),</span> <span class=s2>&#34;timeout&#34;</span><span class=p>)</span>	
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Method to release holds from drops</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>release_drops</span><span class=p>():</span> 
</span></span><span class=line><span class=cl>    <span class=c1># Release status while holding</span>
</span></span><span class=line><span class=cl>	<span class=n>is_holding</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=c1># Loop over the elements of the array of held drops</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>drop</span> <span class=ow>in</span> <span class=n>held_drops</span><span class=p>:</span>
</span></span><span class=line><span class=cl>       <span class=c1># Stop animation &#34;flash&#34;</span>
</span></span><span class=line><span class=cl>		<span class=n>drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1># Play the animation &#34;idle&#34;.</span>
</span></span><span class=line><span class=cl>		<span class=n>drop</span><span class=o>.</span><span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;idle&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># Empty the array of held drops</span>
</span></span><span class=line><span class=cl>	<span class=n>held_drops</span><span class=o>.</span><span class=nf>clear</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1># Empty the Points property of the DropsLine node</span>
</span></span><span class=line><span class=cl>	<span class=n>drops_line</span><span class=o>.</span><span class=nf>clear_points</span><span class=p>()</span>
</span></span></code></pre></div><br><p>This completes the editing of the &ldquo;World.gd&rdquo; script.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=executing-the-scene-to-check-the-operation>Executing the scene to check the operation</h2><p>Finally, let&rsquo;s run a scene to see if it reproduces the movement as expected.<br><img alt="run project finally" loading=lazy src=/images/tutorials/gd0011_connect_colors/img36.gif></p><p>Have you confirmed that the following is as expected?</p><ul><li>When the left mouse button is pressed while the mouse cursor is near the center of the drop, the drop is held and a &ldquo;flash&rdquo; animation is played.</li><li>If you hold down the left mouse button and trace the adjacent drop, the &ldquo;DropsLine&rdquo; will be connected.</li><li>If you return to the drop you have traced, the hold is released and the &ldquo;idle&rdquo; animation returns to playback.</li><li>When three or more drops are traced, all drops in the hold disappear when the left mouse button is released.</li><li>If less than three drops are traced, releasing the left mouse button does not erase the drops, only releases the hold.</li></ul><br><hr><h2 id=sample-games>Sample Games</h2><p>We have prepared a sample game that further brushes up the project created in this tutorial.</p><div><video controls autoplay loop muted playsinline aria-label='Sample game demo' style=zgotmplz>
<source src=/images/tutorials/gd0011_connect_colors/img37.mp4 type=video/mp4>Your browser does not support the video tag.</video></div><br><p>The project file is located in <a href=https://github.com/msnsk/ConnectColors.git target=_blank>GitHub repository</a>
, so please download the .zip file from there and you can check it by importing the &ldquo;project.godot&rdquo; file in the &ldquo;Sample&rdquo; folder with the Godot Engine.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=conclusion>Conclusion</h2><p>In this tutorial, We created a puzzle game in which you have to trace the same color to make it disappear. It is the kind of game that one cannot help but feel addicted to. Let me summarize the key points in the creation of the game.</p><ul><li>Use RigidBody2D for the drop and let the engine do the physics.</li><li>Add Area2D class nodes to the drop to detect fingers and cursors, and Area2D class nodes to detect adjacent drops, and use their signals.</li><li>Always follow the Area2D class node to the finger or mouse cursor and use the signal of this node for contact with the drop.</li></ul><br><hr><h2 id=links>Links</h2><ul><li><a href=https://www.kenney.nl/assets target=_blank>KENNEY</a></li><li><a href=https://docs.godotengine.org/en/stable/tutorials/physics/physics_introduction.html target=_blank>Godot Docs: Physics introduction</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_rigidbody2d.html target=_blank>Godot Docs: RigidBody2D</a></li><li><a href=https://docs.godotengine.org/en/stable/tutorials/physics/using_area_2d.html target=_blank>Godot Docs: Using Area2D</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_area2d.html target=_blank>Godot Docs: Area2D</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_collisionshape2d.html target=_blank>Godot Docs: CollisionShape2D</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_collisionpolygon2d.html target=_blank>Godot Docs: CollisionPolygon2D</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_path2d.html target=_blank>Godot Docs: Path2D</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_pathfollow2d.html target=_blank>Godot Docs: PathFollow2D</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_line2d.html target=_blank>Godot Docs: Line2D</a></li><li><a href=https://docs.godotengine.org/en/stable/tutorials/animation/introduction.html target=_blank>Godot Docs: Introduction to the animation features</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_animationplayer.html target=_blank>Godot Docs: AnimationPlayer</a></li></ul><hr></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Connecting Matching Colors Puzzle Game in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Connecting%20Matching%20Colors%20Puzzle%20Game%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0011_connect_colors%2f&amp;hashtags=GodotEngine%2cGameDev%2c2D%2cPuzzleGame%2cMobileGame%2cMatch3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Connecting Matching Colors Puzzle Game in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0011_connect_colors%2f&title=%f0%9f%a4%96%20Connecting%20Matching%20Colors%20Puzzle%20Game%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 🤖 Connecting Matching Colors Puzzle Game in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0011_connect_colors%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/puzzlegame/>PuzzleGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/mobilegame/>MobileGame</a></li><li><a href=https://www.peanuts-code.com/en/tags/match3/>Match3</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/en/tutorials/gd0012_match3/><span class=title>« Prev</span><br><span>🤖 Match 3 Puzzle Game in Godot3</span>
</a><a class=next href=https://www.peanuts-code.com/en/tutorials/gd0008_homing_missiles/><span class=title>Next »</span><br><span>🤖 Homing Missiles in Godot3</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/en/>Peanuts Code</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>