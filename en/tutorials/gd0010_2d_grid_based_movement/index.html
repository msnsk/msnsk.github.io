<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ü§ñ 2D Grid-based Movement in Godot3 | Peanuts Code</title>
<meta name=keywords content="GodotEngine,GameDev,Godot3,2D,GridBasedMovement"><meta name=description content="This tutorial explains how to implement &ldquo;grid-based movement&rdquo; in 2D games. Grid-based movement refers to the movement of objects such as characters on the game screen one grid at a time.
Many puzzle games such as the popular smartphone game &ldquo;Puzzle & Dragons&rdquo; and the original falling game &ldquo;Tetris,&rdquo; as well as tactical simulation games such as the &ldquo;Fire Emblem&rdquo; series and &ldquo;Tactics Ogre&rdquo; probably employ this type of movement.
On the other hand, RPGs such as the &ldquo;Final Fantasy&rdquo; series and the &ldquo;Dragon Quest&rdquo; series also use this grid-based movement when looking closely at character movement in the era of 2D graphics, when these games appeared as software for the NES and Super Nintendo.
Thus, grid-based movement is used in games of various genres, and its versatility is quite high.
In this article, we will focus as much as possible on only the implementation of grid-based movement. In addition, a sample game that uses grid-based movement will be introduced at the end of the article, so please feel free to refer to it as well.
Note that the project file that will be created at the end of this tutorial is located in the GitHub repository ."><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/en/tutorials/gd0010_2d_grid_based_movement/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0010_2d_grid_based_movement/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0010_2d_grid_based_movement/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="ü§ñ 2D Grid-based Movement in Godot3"><meta property="og:description" content="This tutorial explains how to implement &ldquo;grid-based movement&rdquo; in 2D games. Grid-based movement refers to the movement of objects such as characters on the game screen one grid at a time.
Many puzzle games such as the popular smartphone game &ldquo;Puzzle & Dragons&rdquo; and the original falling game &ldquo;Tetris,&rdquo; as well as tactical simulation games such as the &ldquo;Fire Emblem&rdquo; series and &ldquo;Tactics Ogre&rdquo; probably employ this type of movement.
On the other hand, RPGs such as the &ldquo;Final Fantasy&rdquo; series and the &ldquo;Dragon Quest&rdquo; series also use this grid-based movement when looking closely at character movement in the era of 2D graphics, when these games appeared as software for the NES and Super Nintendo.
Thus, grid-based movement is used in games of various genres, and its versatility is quite high.
In this article, we will focus as much as possible on only the implementation of grid-based movement. In addition, a sample game that uses grid-based movement will be introduced at the end of the article, so please feel free to refer to it as well.
Note that the project file that will be created at the end of this tutorial is located in the GitHub repository ."><meta property="og:type" content="article"><meta property="og:url" content="https://www.peanuts-code.com/en/tutorials/gd0010_2d_grid_based_movement/"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0010_2d_grid_based_movement/img0.gif"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-06-08T00:05:00+09:00"><meta property="article:modified_time" content="2022-06-09T00:00:00+00:00"><meta property="og:site_name" content="Peanuts Code ü•ú"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0010_2d_grid_based_movement/img0.gif"><meta name=twitter:title content="ü§ñ 2D Grid-based Movement in Godot3"><meta name=twitter:description content="This tutorial explains how to implement &ldquo;grid-based movement&rdquo; in 2D games. Grid-based movement refers to the movement of objects such as characters on the game screen one grid at a time.
Many puzzle games such as the popular smartphone game &ldquo;Puzzle & Dragons&rdquo; and the original falling game &ldquo;Tetris,&rdquo; as well as tactical simulation games such as the &ldquo;Fire Emblem&rdquo; series and &ldquo;Tactics Ogre&rdquo; probably employ this type of movement.
On the other hand, RPGs such as the &ldquo;Final Fantasy&rdquo; series and the &ldquo;Dragon Quest&rdquo; series also use this grid-based movement when looking closely at character movement in the era of 2D graphics, when these games appeared as software for the NES and Super Nintendo.
Thus, grid-based movement is used in games of various genres, and its versatility is quite high.
In this article, we will focus as much as possible on only the implementation of grid-based movement. In addition, a sample game that uses grid-based movement will be introduced at the end of the article, so please feel free to refer to it as well.
Note that the project file that will be created at the end of this tutorial is located in the GitHub repository ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ü§ñ Tutorials","item":"https://www.peanuts-code.com/en/tutorials/"},{"@type":"ListItem","position":2,"name":"ü§ñ 2D Grid-based Movement in Godot3","item":"https://www.peanuts-code.com/en/tutorials/gd0010_2d_grid_based_movement/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ü§ñ 2D Grid-based Movement in Godot3","name":"ü§ñ 2D Grid-based Movement in Godot3","description":"This tutorial explains how to implement \u0026ldquo;grid-based movement\u0026rdquo; in 2D games. Grid-based movement refers to the movement of objects such as characters on the game screen one grid at a time.\nMany puzzle games such as the popular smartphone game \u0026ldquo;Puzzle \u0026amp; Dragons\u0026rdquo; and the original falling game \u0026ldquo;Tetris,\u0026rdquo; as well as tactical simulation games such as the \u0026ldquo;Fire Emblem\u0026rdquo; series and \u0026ldquo;Tactics Ogre\u0026rdquo; probably employ this type of movement.\nOn the other hand, RPGs such as the \u0026ldquo;Final Fantasy\u0026rdquo; series and the \u0026ldquo;Dragon Quest\u0026rdquo; series also use this grid-based movement when looking closely at character movement in the era of 2D graphics, when these games appeared as software for the NES and Super Nintendo.\nThus, grid-based movement is used in games of various genres, and its versatility is quite high.\nIn this article, we will focus as much as possible on only the implementation of grid-based movement. In addition, a sample game that uses grid-based movement will be introduced at the end of the article, so please feel free to refer to it as well.\nNote that the project file that will be created at the end of this tutorial is located in the GitHub repository .","keywords":["GodotEngine","GameDev","Godot3","2D","GridBasedMovement"],"articleBody":"This tutorial explains how to implement ‚Äúgrid-based movement‚Äù in 2D games. Grid-based movement refers to the movement of objects such as characters on the game screen one grid at a time.\nMany puzzle games such as the popular smartphone game ‚ÄúPuzzle \u0026 Dragons‚Äù and the original falling game ‚ÄúTetris,‚Äù as well as tactical simulation games such as the ‚ÄúFire Emblem‚Äù series and ‚ÄúTactics Ogre‚Äù probably employ this type of movement.\nOn the other hand, RPGs such as the ‚ÄúFinal Fantasy‚Äù series and the ‚ÄúDragon Quest‚Äù series also use this grid-based movement when looking closely at character movement in the era of 2D graphics, when these games appeared as software for the NES and Super Nintendo.\nThus, grid-based movement is used in games of various genres, and its versatility is quite high.\nIn this article, we will focus as much as possible on only the implementation of grid-based movement. In addition, a sample game that uses grid-based movement will be introduced at the end of the article, so please feel free to refer to it as well.\nNote that the project file that will be created at the end of this tutorial is located in the GitHub repository . You can also directly check the project by downloading the .zip file and importing the ‚Äúproject.godot‚Äù file in the ‚ÄúEnd‚Äù folder with the Godot Engine.\nEnvironment This tutorial was created in the following environment\n„ÉªGodot version: 3.4.4\n„ÉªComputer OS version: macOS 11.6.5\nMemo: Please also use the following articles to help you start creating your game.\nDownloading Godot Project Manager of Godot Creating a new project First, we would like you to start Godot Engine and create a new project. Let‚Äôs name the project ‚ÄúGrid Based Movement Tutorial‚Äù.\nWhen the editor appears, set the display size of the game first.\nOpen the ‚ÄúProject‚Äù menu \u003e ‚ÄúProject Settings‚Äù. Search for ‚Äúwindow‚Äù and select ‚ÄúDisplay‚Äù \u003e ‚ÄúWindow‚Äù in the sidebar. In the ‚ÄúSize‚Äù section, change the values of the following items. Width: 256 Height: 160 Test Width: 1024 Test Height: 640\nIn the ‚ÄúStretch‚Äù section, change the values of the following items. Mode: 2d Aspect: keep\nNext, let‚Äôs download the assets from KENNEY‚Äôs site and use them. This time, We will use an asset pack called 1-Bit Pack . I can‚Äôt help but be thankful for this wonderful free material.\nAfter downloading, drag and drop the ‚Äúcolored-transparent_packed.png‚Äù file in the ‚ÄúTilesheet‚Äù folder into the editor‚Äôs file system dock to import it into your project.\nImmediately after importing the file, the image looks blurry. The following steps will give the image the edges characteristic of pixel art.\nMake the imported asset file selected in the file system dock.\nSelect ‚ÄúPreset‚Äù \u003e ‚Äú2D Pixel‚Äù in the import dock.\nClick the ‚ÄúRe-import‚Äù button at the bottom.\nCreating World scene The first scene is the game world. Let‚Äôs create a scene named ‚ÄúWorld‚Äù.\nSelect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Scene‚Äù. Select ‚ÄúOther Node‚Äù in ‚ÄúGenerate Root Node‚Äù. Select a node of the ‚ÄúNode2D‚Äù class as the root node. Rename the root node to ‚ÄúWorld‚Äù. Save the scene at this point. Create a folder and save the scene with the file path ‚Äúres://World/World.tscn‚Äù. Add a ‚ÄúTileMap‚Äù node to the root node. The scene tree should now look like this.\nEditing the TileMap node Editing the properties of the TileMap node Select the ‚ÄúTileMap‚Äù node in the scene tree dock and edit its properties in the inspector.\nAssign a ‚ÄúNew TileSet‚Äù resource to the ‚ÄúTileSet‚Äù property.\nSet the value of the ‚ÄúCell‚Äù \u003e ‚ÄúSize‚Äù property to (x: 16, y: 16). The size was set to match the size of the texture (16 px height and width) of the sprite sheet that will be used.\nEditing the TileSet resource Continue to edit the resource ‚ÄúTileSet‚Äù assigned to the ‚ÄúTileSet‚Äù property.\nClick on the resource in the inspector.\nWhen the ‚ÄúTileSet‚Äù panel at the bottom of the Godot editor opens, drag the sprite sheet resource ‚Äúres://colored-transparent_packed.png‚Äù from the file system dock to the left sidebar in the panel and add it. Click on the added resource to put it in edit mode.\nSelect ‚ÄúNew Single Tile‚Äù.\nWith the ‚ÄúRegion‚Äù tab selected, activate grid snapping.\nIn the inspector, set ‚ÄúSnap Options‚Äù \u003e ‚ÄúStep‚Äù to (x: 16, y: 16), which is the same size as one texture on the sprite sheet.\nselect the ‚Äúgrass‚Äù and ‚Äútree‚Äù texture areas in order and register them as Single Tile.\nFor the ‚ÄúTree‚Äù tile, select the ‚ÄúCollision‚Äù tab and set the collision shape as well.\nThis completes the editing of the TileSet resource.\nCreating a TileMap From here, we will create a TileMap by placing tiles from the ‚ÄúTileSet‚Äù resource created earlier.\nSelect the ‚ÄúTileMap‚Äù node in the scene tree dock. Activate grid snap from the 2D workspace toolbar.\nClick ‚ÄúSnapping Options‚Äù on the toolbar and select ‚ÄúConfigure Snap‚Äù.\nWhen the ‚ÄúConfigure Snap‚Äù setting panel opens, set ‚ÄúGrid Step‚Äù to (x: 16, y: 16) and click ‚ÄúOK‚Äù.\nYou should now see a grid separated by 16px in height and width on the 2D workspace. Since ‚ÄúGrid Snap‚Äù is enabled, you should be able to easily place tiles along the grid when editing the ‚ÄúTileMap‚Äù.\nNow we will place tiles in the 2D workspace. Let‚Äôs simply surround the screen with ‚Äútree‚Äù tiles and place ‚Äúgrass‚Äù tiles inside them so that the player character, which will be placed later, will not be outside the screen.\nThis completes the editing of the ‚ÄúTileMap‚Äù.\nCreating Player Scene From here, we will create a scene for the player character. This object will actually be used to move the grid base in this tutorial.\nSelect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Scene‚Äù. Select ‚ÄúOther Node‚Äù under ‚ÄúGenerate Root Node‚Äù. Select a node of the ‚ÄúKinematicBody2D‚Äù class as the root node. Rename the root node to ‚ÄúPlayer‚Äù. Save the scene at this point. Create a folder and save the scene with the file path ‚Äúres://Player/Player.tscn‚Äù. Add a ‚ÄúSprite‚Äù node to the root node. Add a ‚ÄúCollisionShape2D‚Äù node to the root node. Add a ‚ÄúRayCast2D‚Äù node to the root node. The ‚ÄúPlayer‚Äù scene tree should now look like this.\nEditing each node in the Player scene Sprite node The method of setting the texture of a sprite by specifying the range of textures you want to use from a single sprite sheet that contains many textures is used.\nIn the Inspector, apply the resource file ‚Äúres://colored-transparent_packed.png‚Äù to the ‚ÄúTexture‚Äù property.\nTurn off the ‚ÄúOffset‚Äù \u003e ‚ÄúCentered‚Äù property. This will make the position of this node (‚ÄúPosition‚Äù property) in the upper left corner of the texture instead of the center so that it just fits in the grid square.\nTurn on ‚ÄúRegion‚Äù \u003e ‚ÄúEnabled‚Äù.\nOpen the ‚ÄúTexture Region‚Äù panel at the bottom of the editor. The task here is to specify the region of the texture you want to use in the sprite sheet.\nExpand the panel by clicking on the expand icon to make it easier to work with.\nSelect ‚Äúgrid snap‚Äù under ‚Äúsnap mode‚Äù at the top of the panel.\nSet the ‚Äústep‚Äù at the top of the panel to 16px 16px. This will make the grid the same size as one texture on the sprite sheet.\nSelect the ‚Äúking‚Äù texture by dragging on the sprite sheet.\nCollisionShape2D node This node is used to set the collision shape for the root node ‚ÄúPlayer‚Äù.\nIn the inspector, apply the ‚ÄúNew RectangleShape2D‚Äù resource to the ‚ÄúShape‚Äù property.\nSet the Transform \u003e Position property to (x: 8, y: 8) to match the texture position of the Sprite node.\nIn the 2D workspace, match the collision shape to the size of the ‚ÄúSprite‚Äù node texture.\nTo enter directly in the inspector, the properties of the ‚ÄúRectangleShape2D‚Äù resource should be as follows. Extents: (x: 8, y: 8) RayCast2D node This node is very useful for collision detection in grid-based movement, represented as an arrow-shaped collision shape in the 2D workspace. When the arrow and an object overlap, a collision is detected. This can be used to detect collisions with objects in front of the player character and prevent it from moving forward.\nIn the Inspector, set the ‚ÄúEnabled‚Äù property to On. This will enable collision detection.\nSet the ‚ÄúTransform‚Äù \u003e ‚ÄúPosition‚Äù property to (x: 8, y: 8). This is to center the ‚ÄúSprite‚Äù texture.\nSet the ‚ÄúCast To‚Äù property to (x: 16, y: 0). This is just a temporary initial value, and once the project is actually executed, the value will be changed each time the player character is moved by the script.\nOn the 2D workspace it should now look like the following screenshot.\nLeave ‚ÄúCollide With‚Äù as default, ‚ÄúAreas‚Äù Off, and ‚ÄúBodies‚Äù On. The ‚ÄúTree‚Äù panel in the tileset you just created is a physical body, so if ‚ÄúBodies‚Äù is checked, collision will be detected.\nImplementing grid-based movement in the Player node Configuring the Input Map First, add an action to the Input Map in the Project Settings so that the player character can be moved by keyboard keystrokes.\nswitch to the ‚ÄúInput Map‚Äù tab after selecting ‚ÄúProject‚Äù menu \u003e ‚ÄúProject Settings‚Äù. add the following 4 ‚ÄúActions‚Äù. move_right: D key move_left: A key move_down: S key move_up: W key *It is also OK to assign Up, down, left, and right arrow keys.\nAttaching and editing the script Attach a script to the root node ‚ÄúPlayer‚Äù. Create a script file with the file path ‚Äúres://Player/Player.gd‚Äù.\nAfter creating the script file, open the script editor and edit the script code as follows.\nextends KinematicBody2D #1 const inputs = { \"move_right\": Vector2.RIGHT, \"move_left\": Vector2.LEFT, \"move_down\": Vector2.DOWN, \"move_up\": Vector2.UP } #2 var grid_size = 16 #3 onready var raycast = $RayCast2D #4 func _unhandled_input(event): for action in inputs.keys(): if event.is_action_pressed(action): move(action) #5 func move(action): var destination = inputs[action] * grid_size raycast.cast_to = destination raycast.force_raycast_update() if not raycast.is_colliding(): position += destination I numbered the scripts #1 ~ #5 in the comments. I will explain in this order.\n#1: Defined constants inputs of dictionary type. The value of the inputs is the direction vector of Vector2 type (vector of length 1) to be moved by each action. By the way, the built-in constants (RIGHT, LEFT, DOWN and UP) of the Vector2 class have the following values.\nRIGHT: Vector2(1, 0) LEFT: Vector2(-1, 0) DOWN: Vector2(0, 1) UP: Vector2(0, -1) #2: Defined the property grid_size. The value is set to 16, the same as the size (px) of tiles in ‚ÄúTileMap‚Äù.\n#3: Defined the property raycast. This is a property that refers to the ‚ÄúRayCast2D‚Äù node.\n#4: Override the built-in function _unhandled_input. This is a callback function that is called as soon as there is input from the keyboard, mouse, joystick, etc. It is similar to another function _input, but don‚Äôt worry about the details of the difference here.\nIn _unhandled_input, a loop is performed on the dictionary type constants inputs defined earlier. If the input is an input map action with the same name as a key in inputs (such as move_left or move_up), the value for that key (for example, Vector2.RIGHT if the key is move_right) is passed as an argument and the method move RIGHT), and calls the method named move. This method move will be defined later.\n#5: The method move is defined. When calling this method, it is necessary to pass a value for the argument action.\nThe variable destination is defined first. The value is the value for the key that matches the argument action from the dictionary type constant inputs (for example, Vector2.LEFT if action is passed move_left) multiplied by the property grid_size. In other words, if the player enters the ‚ÄúD‚Äù key, the value will be Vector2(1, 0) x 16 = Vector2(16, 0). This is a vector with a length of one grid in the right direction.\nNext, the value of the variable destination defined earlier is passed to the cast_to property of the ‚ÄúRayCast2D‚Äù node. This replaces the direction and length of the ‚ÄúRayCast2D‚Äù arrow with the key entered by the player. The method force_raycast_update is called in the next line to immediately update this replacement. This is a built-in `RayCast2D‚Äô node.\nThe next line describes the if syntax. The built-in method is_colliding of the ‚ÄúRayCast2D‚Äù node returns a Bool type (true or false) whether this node (arrow) is currently colliding with an object. Since there is a not after the if, the meaning of this if syntax is ‚Äúif the RayCast2D node is not colliding with an object‚Äù.\nIf the RayCast2D node has not collided with other objects in the above if syntax, the value of destination is added to the value of the property position of the Player node. This means that the player character will move by the value of destination. For example, if the current position of the ‚ÄúPlayer‚Äù node is Vector2(64, 32), and the player presses the ‚ÄúS‚Äù key once, the player moves Vector2(0, 16) from the current position, and the destination position is Vector2(64, 48). In other words, the position is moved one grid position down from the current position.\nNow, the grid-based movement control should be implemented.\nAdding a Player scene instance to the World scene Now that the ‚ÄúPlayer‚Äù scene is complete, let‚Äôs add an instance of it to the ‚ÄúWorld‚Äù scene and move it around on the tile map.\nOpen the ‚ÄúWorld.tscn‚Äù scene. Add an instance of the ‚ÄúPlayer.tscn‚Äù scene to the root node ‚ÄúWorld.\nIn the 2D workspace, move the ‚ÄúPlayer‚Äù node to an appropriate position around the center of the screen.\nThe work is now complete.\nChecking the operation of the grid-based movement Let‚Äôs check if the grid-based movement actually works without any problems.\nIn particular, to make it easier to check the arrow-shaped collision shapes of the ‚ÄúRayCast2D‚Äù child node of ‚ÄúPlayer,‚Äù let‚Äôs check the ‚ÄúVisible Collision Shapes‚Äù checkbox in the ‚ÄúDebug‚Äù menu and enable it first.\nNow, let‚Äôs run the project and see if the king can run around in the prairie with grid-based movement. If this is your first time executing the project, simply select ‚Äúres://World/World.tscn‚Äù for the Main Scene.\nIt can be clearly seen that a single keystroke moves the character only one tile. We can also confirm that the character cannot move in the direction of the ‚Äútree‚Äù tile.\nThis completes the grid-based moving tutorial.\nSample game We have prepared a sample game that uses this grid-based movement. The project file is located in GitHub repository , so you can download the .zip file from there and import the ‚Äúproject .godot‚Äù file in the ‚ÄúSample‚Äù folder and import it into Godot Engine.\nYour browser does not support the video tag. This sample is a so-called whack-a-mole game. In the game‚Äôs setup, the player controls a king who holds up a sacred ring to the ghosts of the kingdom‚Äôs soldiers who emerge from their graves to release their cursed souls.\nThe keyboard controls are as follows\nD: Move right A: Move left S: Move down W: Move up Space: Raise the ring to release the ghost‚Äôs soul only when facing the ghost. The ghost must be released within 1 second by the ring or the king will be cursed. If the king is cursed, his Life is reduced by one. The king is cursed to death and the game is over when all 10 lives are lost.\nThe interval between the appearance of the next ghost is gradually shortened from 2 seconds at the beginning of the game to as short as 1 second.\nBy the way, my highest score is 150. I don‚Äôt know if this is great or not.\nSupplemental Explanation Finally, I would like to add some additional information about this sample game project.\nDuring the game, when the ghost appears from the tombstone, the ‚ÄúGhost‚Äù instance with the collision shape set in the ‚ÄúKinematicBody2D‚Äù class is overlapping the tombstone tiles with the ‚ÄúTileMap‚Äù collision set. In this case, ‚ÄúRayCast2D‚Äù of the ‚ÄúPlayer‚Äù instance is slightly modified to give priority to the collision detection with the ghost over the tombstone.\nWhen creating the tombstone tiles by editing the ‚ÄúTileSet,‚Äù a collision of 1/2 the size of the tiles is set. It is easier to set the collision shape after setting ‚ÄúSnap Options‚Äù \u003e ‚ÄúStep‚Äù to (x: 4, y: 4) in the inspector first. Of course, the collision shape of ‚ÄúGhost‚Äù is (x: 16, y: 16).\nConclusion In this tutorial, we have explained the implementation of grid-based movement in 2D games. We hope you will find it useful for your puzzle games, simulation games, and other projects you are working on in the future.\nLet‚Äôs summarize the key points of grid-based movement.\nSet up the following correctly. Size of the tiles prepared in the ‚ÄúTileSet‚Äù resource (height and width) Size and position of the sprite of the object to be moved (in this case, ‚ÄúPlayer‚Äù) Size and position of the collision shape of the object to be moved Grid Step in the 2D workspace The value of the property (in this case grid_size) represents the distance to be moved by the script attached to the object‚Äôs node. Use ‚ÄúRayCast2D‚Äù to determine the collision between the object to be moved and other objects. The direction and size of ‚ÄúRayCast2D‚Äù are controlled by scripts. To move objects by player manipulation, register actions in the input map, and control the direction of movement for each input in scripts. Link KENNEY Godot Docs: RayCast2D Godot Docs: Using TileMaps Godot Docs: TileSet KidsCanCode: Grid-based movement YouTube: Grid-based movement Godot 3 demo overview YouTube: Make your first 2D grid-based game from scratch in Godot UPDATE\n2022/06/09 Translated from Japanese into English\n","wordCount":"2912","inLanguage":"en","image":"https://www.peanuts-code.com/images/tutorials/gd0010_2d_grid_based_movement/img0.gif","datePublished":"2022-06-08T00:05:00+09:00","dateModified":"2022-06-09T00:00:00Z","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/en/tutorials/gd0010_2d_grid_based_movement/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/en/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/ja/ title=Japanese aria-label=üáØüáµÊó•Êú¨Ë™û>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/en/ title=Home><span>Home</span></a></li><li><a href=https://www.peanuts-code.com/en/portfolio/ title=Works><span>Works</span></a></li><li><a href=https://www.peanuts-code.com/en/posts/ title=Blogs><span>Blogs</span></a></li><li><a href=https://www.peanuts-code.com/en/tutorials/ title=Tutorials><span>Tutorials</span></a></li><li><a href=https://www.peanuts-code.com/en/about/ title=About><span>About</span></a></li><li><a href=https://www.peanuts-code.com/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/en/>Home</a>&nbsp;¬ª&nbsp;<a href=https://www.peanuts-code.com/en/tutorials/>ü§ñ Tutorials</a></div><h1 class="post-title entry-hint-parent">ü§ñ 2D Grid-based Movement in Godot3</h1><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/gridbasedmovement/>GridBasedMovement</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ 2D Grid-based Movement in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%202D%20Grid-based%20Movement%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0010_2d_grid_based_movement%2f&amp;hashtags=GodotEngine%2cGameDev%2cGodot3%2c2D%2cGridBasedMovement"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ 2D Grid-based Movement in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0010_2d_grid_based_movement%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><div class=post-meta><span title='2022-06-08 00:05:00 +0900 +0900'>2022-06-08</span>&nbsp;¬∑&nbsp;14 min&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/ja/tutorials/gd0010_2d_grid_based_movement/>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0010_2d_grid_based_movement/img0.gif alt="2D Grid-based Movement in Godot"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#creating-a-new-project aria-label="Creating a new project">Creating a new project</a></li><li><a href=#creating-world-scene aria-label="Creating World scene">Creating World scene</a></li><li><a href=#editing-the-tilemap-node aria-label="Editing the TileMap node">Editing the TileMap node</a><ul><li><a href=#editing-the-properties-of-the-tilemap-node aria-label="Editing the properties of the TileMap node">Editing the properties of the TileMap node</a></li><li><a href=#editing-the-tileset-resource aria-label="Editing the TileSet resource">Editing the TileSet resource</a></li><li><a href=#creating-a-tilemap aria-label="Creating a TileMap">Creating a TileMap</a></li></ul></li><li><a href=#creating-player-scene aria-label="Creating Player Scene">Creating Player Scene</a><ul><li><a href=#editing-each-node-in-the-player-scene aria-label="Editing each node in the Player scene">Editing each node in the Player scene</a><ul><li><a href=#sprite-node aria-label="Sprite node">Sprite node</a></li><li><a href=#collisionshape2d-node aria-label="CollisionShape2D node">CollisionShape2D node</a></li><li><a href=#raycast2d-node aria-label="RayCast2D node">RayCast2D node</a></li></ul></li></ul></li><li><a href=#implementing-grid-based-movement-in-the-player-node aria-label="Implementing grid-based movement in the Player node">Implementing grid-based movement in the Player node</a><ul><li><a href=#configuring-the-input-map aria-label="Configuring the Input Map">Configuring the Input Map</a></li><li><a href=#attaching-and-editing-the-script aria-label="Attaching and editing the script">Attaching and editing the script</a></li></ul></li><li><a href=#adding-a-player-scene-instance-to-the-world-scene aria-label="Adding a Player scene instance to the World scene">Adding a Player scene instance to the World scene</a></li><li><a href=#checking-the-operation-of-the-grid-based-movement aria-label="Checking the operation of the grid-based movement">Checking the operation of the grid-based movement</a></li><li><a href=#sample-game aria-label="Sample game">Sample game</a></li><li><a href=#supplemental-explanation aria-label="Supplemental Explanation">Supplemental Explanation</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li><li><a href=#link aria-label=Link>Link</a></li></ul></div></details></div><div class=post-content><p>This tutorial explains how to implement &ldquo;grid-based movement&rdquo; in 2D games. Grid-based movement refers to the movement of objects such as characters on the game screen one grid at a time.</p><p>Many puzzle games such as the popular smartphone game &ldquo;Puzzle & Dragons&rdquo; and the original falling game &ldquo;Tetris,&rdquo; as well as tactical simulation games such as the &ldquo;Fire Emblem&rdquo; series and &ldquo;Tactics Ogre&rdquo; probably employ this type of movement.</p><p>On the other hand, RPGs such as the &ldquo;Final Fantasy&rdquo; series and the &ldquo;Dragon Quest&rdquo; series also use this grid-based movement when looking closely at character movement in the era of 2D graphics, when these games appeared as software for the NES and Super Nintendo.</p><p>Thus, grid-based movement is used in games of various genres, and its versatility is quite high.</p><p>In this article, we will focus as much as possible on only the implementation of grid-based movement. In addition, a sample game that uses grid-based movement will be introduced at the end of the article, so please feel free to refer to it as well.</p><p>Note that the project file that will be created at the end of this tutorial is located in the <a href=https://github.com/msnsk/GridBasedMovement.git target=_blank>GitHub repository</a>
. You can also directly check the project by downloading the .zip file and importing the &ldquo;project.godot&rdquo; file in the &ldquo;End&rdquo; folder with the Godot Engine.</p><br><blockquote><p><em><strong><span style=color:salmon>Environment</span></strong><br>This tutorial was created in the following environment</em><br>„Éª<em>Godot version: <strong>3.4.4</strong></em><br>„Éª<em>Computer OS version: <strong>macOS 11.6.5</strong></em></p></blockquote><br><blockquote><p><em><strong><span style=color:salmon>Memo:</span></strong><br>Please also use the following articles to help you start creating your game.<br><a href=https://www.peanuts-code.com/en/tutorials/gd0001_download/>Downloading Godot</a><br><a href=https://www.peanuts-code.com/en/tutorials/gd0002_project_manager/>Project Manager of Godot</a></em></p></blockquote><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-new-project>Creating a new project</h2><p>First, we would like you to start Godot Engine and create a new project. Let&rsquo;s name the project &ldquo;Grid Based Movement Tutorial&rdquo;.</p><p>When the editor appears, set the display size of the game first.</p><ol><li>Open the &ldquo;Project&rdquo; menu > &ldquo;Project Settings&rdquo;.</li><li>Search for &ldquo;window&rdquo; and select &ldquo;Display&rdquo; > &ldquo;Window&rdquo; in the sidebar.</li><li>In the &ldquo;Size&rdquo; section, change the values of the following items.<ul><li>Width: 256</li><li>Height: 160</li><li>Test Width: 1024</li><li>Test Height: 640<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.1.png alt=Display&amp;gt;Window&amp;gt;Size></li></ul></li><li>In the &ldquo;Stretch&rdquo; section, change the values of the following items.<ul><li>Mode: 2d</li><li>Aspect: keep<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.2.png alt=Display&amp;gt;Window&amp;gt;Stretch></li></ul></li></ol><br><p>Next, let&rsquo;s download the assets from KENNEY&rsquo;s site and use them. This time, We will use an asset pack called <strong><a href=https://www.kenney.nl/assets/bit-pack target=_blank>1-Bit Pack</a>
</strong>. I can&rsquo;t help but be thankful for this wonderful free material.</p><p>After downloading, drag and drop the &ldquo;colored-transparent_packed.png&rdquo; file in the &ldquo;Tilesheet&rdquo; folder into the editor&rsquo;s file system dock to import it into your project.</p><p>Immediately after importing the file, the image looks blurry. The following steps will give the image the edges characteristic of pixel art.</p><ol><li>Make the imported asset file selected in the file system dock.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.3.png alt="select the asset"></li><li>Select &ldquo;Preset&rdquo; > &ldquo;2D Pixel&rdquo; in the import dock.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.4.png alt="select 2D Pixel"></li><li>Click the &ldquo;Re-import&rdquo; button at the bottom.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img0.5.png alt="click reinport"></li></ol><br><hr><h2 id=creating-world-scene>Creating World scene</h2><p>The first scene is the game world. Let&rsquo;s create a scene named &ldquo;World&rdquo;.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;Other Node&rdquo; in &ldquo;Generate Root Node&rdquo;.</li><li>Select a node of the &ldquo;Node2D&rdquo; class as the root node.</li><li>Rename the root node to &ldquo;World&rdquo;.</li><li>Save the scene at this point. Create a folder and save the scene with the file path &ldquo;res://World/World.tscn&rdquo;.</li><li>Add a &ldquo;TileMap&rdquo; node to the root node.</li></ol><p>The scene tree should now look like this.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img1.png alt="World Scene Tree"></p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><br><hr><h2 id=editing-the-tilemap-node>Editing the TileMap node</h2><h3 id=editing-the-properties-of-the-tilemap-node>Editing the properties of the TileMap node</h3><p>Select the &ldquo;TileMap&rdquo; node in the scene tree dock and edit its properties in the inspector.</p><ol><li>Assign a &ldquo;New TileSet&rdquo; resource to the &ldquo;TileSet&rdquo; property.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img2.png alt="TileSet property"></li><li>Set the value of the &ldquo;Cell&rdquo; > &ldquo;Size&rdquo; property to (x: 16, y: 16). The size was set to match the size of the texture (16 px height and width) of the sprite sheet that will be used.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img3.png alt="Cell_size property"></li></ol><br><h3 id=editing-the-tileset-resource>Editing the TileSet resource</h3><p>Continue to edit the resource &ldquo;TileSet&rdquo; assigned to the &ldquo;TileSet&rdquo; property.</p><ol><li>Click on the resource in the inspector.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img4.png alt="Click TileSet resource"></li><li>When the &ldquo;TileSet&rdquo; panel at the bottom of the Godot editor opens, drag the sprite sheet resource &ldquo;res://colored-transparent_packed.png&rdquo; from the file system dock to the left sidebar in the panel and add it. Click on the added resource to put it in edit mode.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img5.png alt="TileSet Pannel"></li><li>Select &ldquo;New Single Tile&rdquo;.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img5.1.png alt="New Single Tile"></li><li>With the &ldquo;Region&rdquo; tab selected, activate grid snapping.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img6.png alt="Enable grid snap"></li><li>In the inspector, set &ldquo;Snap Options&rdquo; > &ldquo;Step&rdquo; to (x: 16, y: 16), which is the same size as one texture on the sprite sheet.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img7.png alt="Snap options"></li><li>select the &ldquo;grass&rdquo; and &ldquo;tree&rdquo; texture areas in order and register them as Single Tile.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img8.1.png alt=Region></li><li>For the &ldquo;Tree&rdquo; tile, select the &ldquo;Collision&rdquo; tab and set the collision shape as well.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img9.png alt="Collision tab">
<img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img10.png alt=Collision></li></ol><p>This completes the editing of the TileSet resource.</p><br><h3 id=creating-a-tilemap>Creating a TileMap</h3><p>From here, we will create a TileMap by placing tiles from the &ldquo;TileSet&rdquo; resource created earlier.</p><ol><li>Select the &ldquo;TileMap&rdquo; node in the scene tree dock.</li><li>Activate grid snap from the 2D workspace toolbar.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img11.png alt="Enable Grid Snap"></li><li>Click &ldquo;Snapping Options&rdquo; on the toolbar and select &ldquo;Configure Snap&rdquo;.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img12.png alt="Snapping options"></li><li>When the &ldquo;Configure Snap&rdquo; setting panel opens, set &ldquo;Grid Step&rdquo; to <strong>(x: 16, y: 16)</strong> and click &ldquo;OK&rdquo;.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img13.png alt="Configure Snap"></li></ol><p>You should now see a grid separated by 16px in height and width on the 2D workspace. Since &ldquo;Grid Snap&rdquo; is enabled, you should be able to easily place tiles along the grid when editing the &ldquo;TileMap&rdquo;.</p><br><p>Now we will place tiles in the 2D workspace. Let&rsquo;s simply surround the screen with &ldquo;tree&rdquo; tiles and place &ldquo;grass&rdquo; tiles inside them so that the player character, which will be placed later, will not be outside the screen.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img14.png alt=TileMap></p><br><p>This completes the editing of the &ldquo;TileMap&rdquo;.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-player-scene>Creating Player Scene</h2><p>From here, we will create a scene for the player character. This object will actually be used to move the grid base in this tutorial.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;Other Node&rdquo; under &ldquo;Generate Root Node&rdquo;.</li><li>Select a node of the &ldquo;KinematicBody2D&rdquo; class as the root node.</li><li>Rename the root node to &ldquo;Player&rdquo;.</li><li>Save the scene at this point. Create a folder and save the scene with the file path &ldquo;res://Player/Player.tscn&rdquo;.</li><li>Add a &ldquo;Sprite&rdquo; node to the root node.</li><li>Add a &ldquo;CollisionShape2D&rdquo; node to the root node.</li><li>Add a &ldquo;RayCast2D&rdquo; node to the root node.</li></ol><p>The &ldquo;Player&rdquo; scene tree should now look like this.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img15.png alt="Player Scene Tree"></p><br><h3 id=editing-each-node-in-the-player-scene>Editing each node in the Player scene</h3><h4 id=sprite-node>Sprite node</h4><p>The method of setting the texture of a sprite by specifying the range of textures you want to use from a single sprite sheet that contains many textures is used.</p><ol><li>In the Inspector, apply the resource file &ldquo;res://colored-transparent_packed.png&rdquo; to the &ldquo;Texture&rdquo; property.<br><img loading=lazy src="/images/tutorials/gd_common/node/Sprite/property/Texture=resource_set.png" alt="Sprite node Texture property"></li><li>Turn off the &ldquo;Offset&rdquo; > &ldquo;Centered&rdquo; property. This will make the position of this node (&ldquo;Position&rdquo; property) in the upper left corner of the texture instead of the center so that it just fits in the grid square.<br><img loading=lazy src="/images/tutorials/gd_common/node/Sprite/property/Offset%3eCentered=Off.png" alt="Offset &amp;gt; Centered = on"></li><li>Turn on &ldquo;Region&rdquo; > &ldquo;Enabled&rdquo;.<br><img loading=lazy src="/images/tutorials/gd_common/node/Sprite/property/Region%3eEnabled=On.png" alt="Region &amp;gt; Enabled = on"></li><li>Open the &ldquo;Texture Region&rdquo; panel at the bottom of the editor. The task here is to specify the region of the texture you want to use in the sprite sheet.<br><img loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/tab_name.png alt="Region panel"><ol><li>Expand the panel by clicking on the expand icon to make it easier to work with.<br><img loading=lazy src=/images/tutorials/gd_common/panel/TextureRegion/expand_icon.png alt="Expand Region pannel"></li><li>Select &ldquo;grid snap&rdquo; under &ldquo;snap mode&rdquo; at the top of the panel.<br><img loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/snap_mode=grid_snap.png" alt="Region pannel &amp;gt; choose grid snap"></li><li>Set the &ldquo;step&rdquo; at the top of the panel to 16px 16px. This will make the grid the same size as one texture on the sprite sheet.<br><img loading=lazy src="/images/tutorials/gd_common/panel/TextureRegion/step=16x16.png" alt="Region pannel &amp;gt; input grid step"></li><li>Select the &ldquo;king&rdquo; texture by dragging on the sprite sheet.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img16.png alt="Select region"></li></ol></li></ol><br><h4 id=collisionshape2d-node>CollisionShape2D node</h4><p>This node is used to set the collision shape for the root node &ldquo;Player&rdquo;.</p><ol><li>In the inspector, apply the &ldquo;New RectangleShape2D&rdquo; resource to the &ldquo;Shape&rdquo; property.<br><img loading=lazy src="/images/tutorials/gd_common/node/CollisionShape2D/Shape=RectangleShape2D.png" alt="Shape property"></li><li>Set the Transform > Position property to (x: 8, y: 8) to match the texture position of the Sprite node.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img17.png alt="Position property"></li><li>In the 2D workspace, match the collision shape to the size of the &ldquo;Sprite&rdquo; node texture.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img18.png alt="CollisionShape in 2D workspace"></li><li>To enter directly in the inspector, the properties of the &ldquo;RectangleShape2D&rdquo; resource should be as follows.<ul><li>Extents: (x: 8, y: 8)</li></ul></li></ol><br><h4 id=raycast2d-node>RayCast2D node</h4><p>This node is very useful for collision detection in grid-based movement, represented as an arrow-shaped collision shape in the 2D workspace. When the arrow and an object overlap, a collision is detected. This can be used to detect collisions with objects in front of the player character and prevent it from moving forward.</p><ol><li>In the Inspector, set the &ldquo;Enabled&rdquo; property to On. This will enable collision detection.<br><img loading=lazy src="/images/tutorials/gd_common/node/RayCast2D/Enabled=On.png" alt="RayCast2D Enabled=on"></li><li>Set the &ldquo;Transform&rdquo; > &ldquo;Position&rdquo; property to (x: 8, y: 8). This is to center the &ldquo;Sprite&rdquo; texture.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img17.png alt="Position property"></li><li>Set the &ldquo;Cast To&rdquo; property to (x: 16, y: 0). This is just a temporary initial value, and once the project is actually executed, the value will be changed each time the player character is moved by the script.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img19.png alt="RayCast2D Cast To">
On the 2D workspace it should now look like the following screenshot.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img20.png alt="RayCast2D 2D Workspace"></li><li>Leave &ldquo;Collide With&rdquo; as default, &ldquo;Areas&rdquo; Off, and &ldquo;Bodies&rdquo; On. The &ldquo;Tree&rdquo; panel in the tileset you just created is a physical body, so if &ldquo;Bodies&rdquo; is checked, collision will be detected.<br><img loading=lazy src="/images/tutorials/gd_common/node/RayCast2D/CollideWith%3eAreas=Off,Bodies=On.png" alt="RayCast2D Collide With - Areas: Off, Bodies: On"></li></ol><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=implementing-grid-based-movement-in-the-player-node>Implementing grid-based movement in the Player node</h2><h3 id=configuring-the-input-map>Configuring the Input Map</h3><p>First, add an action to the Input Map in the Project Settings so that the player character can be moved by keyboard keystrokes.</p><ol><li>switch to the &ldquo;Input Map&rdquo; tab after selecting &ldquo;Project&rdquo; menu > &ldquo;Project Settings&rdquo;.</li><li>add the following 4 &ldquo;Actions&rdquo;.<ul><li>move_right: D key</li><li>move_left: A key</li><li>move_down: S key</li><li>move_up: W key</li></ul></li></ol><p>*It is also OK to assign Up, down, left, and right arrow keys.<br><img loading=lazy src=/images/tutorials/gd_common/project_settings/input_map/move_actions.png alt="Project Settings - Input Map"></p><br><h3 id=attaching-and-editing-the-script>Attaching and editing the script</h3><p>Attach a script to the root node &ldquo;Player&rdquo;. Create a script file with the file path &ldquo;res://Player/Player.gd&rdquo;.</p><p>After creating the script file, open the script editor and edit the script code as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>KinematicBody2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#1</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>inputs</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=s2>&#34;move_right&#34;</span><span class=p>:</span> <span class=nc>Vector2</span><span class=o>.</span><span class=n>RIGHT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=s2>&#34;move_left&#34;</span><span class=p>:</span> <span class=nc>Vector2</span><span class=o>.</span><span class=n>LEFT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=s2>&#34;move_down&#34;</span><span class=p>:</span> <span class=nc>Vector2</span><span class=o>.</span><span class=n>DOWN</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=s2>&#34;move_up&#34;</span><span class=p>:</span> <span class=nc>Vector2</span><span class=o>.</span><span class=n>UP</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#2</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>grid_size</span> <span class=o>=</span> <span class=mi>16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#3</span>
</span></span><span class=line><span class=cl><span class=n>onready</span> <span class=kd>var</span> <span class=n>raycast</span> <span class=o>=</span> <span class=nx>$RayCast2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#4</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_unhandled_input</span><span class=p>(</span><span class=n>event</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>action</span> <span class=ow>in</span> <span class=n>inputs</span><span class=o>.</span><span class=nf>keys</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=n>event</span><span class=o>.</span><span class=nf>is_action_pressed</span><span class=p>(</span><span class=n>action</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=nf>move</span><span class=p>(</span><span class=n>action</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#5</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>move</span><span class=p>(</span><span class=n>action</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>destination</span> <span class=o>=</span> <span class=n>inputs</span><span class=p>[</span><span class=n>action</span><span class=p>]</span> <span class=o>*</span> <span class=n>grid_size</span>
</span></span><span class=line><span class=cl>	<span class=n>raycast</span><span class=o>.</span><span class=n>cast_to</span> <span class=o>=</span> <span class=n>destination</span>
</span></span><span class=line><span class=cl>	<span class=n>raycast</span><span class=o>.</span><span class=nf>force_raycast_update</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=ow>not</span> <span class=n>raycast</span><span class=o>.</span><span class=nf>is_colliding</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=n>position</span> <span class=o>+=</span> <span class=n>destination</span>
</span></span></code></pre></div><br><p>I numbered the scripts #1 ~ #5 in the comments. I will explain in this order.</p><p><strong>#1</strong>: Defined constants <code>inputs</code> of dictionary type. The value of the <code>inputs</code> is the direction vector of Vector2 type (vector of length 1) to be moved by each action. By the way, the built-in constants (<code>RIGHT</code>, <code>LEFT</code>, <code>DOWN</code> and <code>UP</code>) of the <code>Vector2</code> class have the following values.</p><ul><li>RIGHT: Vector2(1, 0)</li><li>LEFT: Vector2(-1, 0)</li><li>DOWN: Vector2(0, 1)</li><li>UP: Vector2(0, -1)</li></ul><br><p><strong>#2</strong>: Defined the property <code>grid_size</code>. The value is set to <code>16</code>, the same as the size (px) of tiles in &ldquo;TileMap&rdquo;.<br><br></p><p><strong>#3</strong>: Defined the property <code>raycast</code>. This is a property that refers to the &ldquo;RayCast2D&rdquo; node.</p><br><p><strong>#4</strong>: Override the built-in function <code>_unhandled_input</code>. This is a callback function that is called as soon as there is input from the keyboard, mouse, joystick, etc. It is similar to another function <code>_input</code>, but don&rsquo;t worry about the details of the difference here.</p><p>In <code>_unhandled_input</code>, a loop is performed on the dictionary type constants <code>inputs</code> defined earlier. If the input is an input map action with the same name as a key in <code>inputs</code> (such as <code>move_left</code> or <code>move_up</code>), the value for that key (for example, <code>Vector2.RIGHT</code> if the key is <code>move_right</code>) is passed as an argument and the method <code>move RIGHT</code>), and calls the method named <code>move</code>. This method <code>move</code> will be defined later.<br><br></p><p><strong>#5</strong>: The method <code>move</code> is defined. When calling this method, it is necessary to pass a value for the argument <code>action</code>.</p><p>The variable <code>destination</code> is defined first. The value is the value for the key that matches the argument <code>action</code> from the dictionary type constant <code>inputs</code> (for example, <code>Vector2.LEFT</code> if <code>action</code> is passed <code>move_left</code>) multiplied by the property <code>grid_size</code>. In other words, if the player enters the &ldquo;D&rdquo; key, the value will be Vector2(1, 0) x 16 = Vector2(16, 0). This is a vector with a length of one grid in the right direction.</p><p>Next, the value of the variable <code>destination</code> defined earlier is passed to the <code>cast_to</code> property of the &ldquo;RayCast2D&rdquo; node. This replaces the direction and length of the &ldquo;RayCast2D&rdquo; arrow with the key entered by the player. The method <code>force_raycast_update</code> is called in the next line to immediately update this replacement. This is a built-in `RayCast2D&rsquo; node.</p><p>The next line describes the <code>if</code> syntax. The built-in method <code>is_colliding</code> of the &ldquo;RayCast2D&rdquo; node returns a Bool type (<code>true</code> or <code>false</code>) whether this node (arrow) is currently colliding with an object. Since there is a <code>not</code> after the <code>if</code>, the meaning of this <code>if</code> syntax is &ldquo;if the RayCast2D node is not colliding with an object&rdquo;.</p><p>If the RayCast2D node has not collided with other objects in the above <code>if</code> syntax, the value of <code>destination</code> is added to the value of the property <code>position</code> of the <code>Player</code> node. This means that the player character will move by the value of <code>destination</code>. For example, if the current position of the &ldquo;Player&rdquo; node is Vector2(64, 32), and the player presses the &ldquo;S&rdquo; key once, the player moves Vector2(0, 16) from the current position, and the destination position is Vector2(64, 48). In other words, the position is moved one grid position down from the current position.</p><p>Now, the grid-based movement control should be implemented.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=adding-a-player-scene-instance-to-the-world-scene>Adding a Player scene instance to the World scene</h2><p>Now that the &ldquo;Player&rdquo; scene is complete, let&rsquo;s add an instance of it to the &ldquo;World&rdquo; scene and move it around on the tile map.</p><ol><li>Open the &ldquo;World.tscn&rdquo; scene.</li><li>Add an instance of the &ldquo;Player.tscn&rdquo; scene to the root node &ldquo;World.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img21.png alt="Instance child scene"></li><li>In the 2D workspace, move the &ldquo;Player&rdquo; node to an appropriate position around the center of the screen.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img22.png alt="Move Player node in 2D workspace"></li></ol><p>The work is now complete.</p><br><hr><h2 id=checking-the-operation-of-the-grid-based-movement>Checking the operation of the grid-based movement</h2><p>Let&rsquo;s check if the grid-based movement actually works without any problems.</p><p>In particular, to make it easier to check the arrow-shaped collision shapes of the &ldquo;RayCast2D&rdquo; child node of &ldquo;Player,&rdquo; let&rsquo;s check the &ldquo;Visible Collision Shapes&rdquo; checkbox in the &ldquo;Debug&rdquo; menu and enable it first.<br><img loading=lazy src="/images/tutorials/gd_common/menu/debug/VisibleCollisionShapes=On.png" alt="Debug menu - Visible Collision Shapes: On"></p><p>Now, let&rsquo;s run the project and see if the king can run around in the prairie with grid-based movement. If this is your first time executing the project, simply select &ldquo;res://World/World.tscn&rdquo; for the Main Scene.<br><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img23.gif alt="Run project"></p><br><p>It can be clearly seen that a single keystroke moves the character only one tile. We can also confirm that the character cannot move in the direction of the &ldquo;tree&rdquo; tile.</p><p>This completes the grid-based moving tutorial.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=sample-game>Sample game</h2><p>We have prepared a sample game that uses this grid-based movement. The project file is located in <a href=https://github.com/msnsk/GridBasedMovement.git target=_blank>GitHub repository</a>
, so you can download the .zip file from there and import the &ldquo;project .godot&rdquo; file in the &ldquo;Sample&rdquo; folder and import it into Godot Engine.</p><p><div><video controls autoplay loop muted playsinline aria-label='Sample game demo' style=width:100%;height:auto>
<source src=/images/tutorials/gd0010_2d_grid_based_movement/img26.mp4 type=video/mp4>Your browser does not support the video tag.</video></div><br><br></p><p>This sample is a so-called whack-a-mole game. In the game&rsquo;s setup, the player controls a king who holds up a sacred ring to the ghosts of the kingdom&rsquo;s soldiers who emerge from their graves to release their cursed souls.</p><p>The keyboard controls are as follows</p><ul><li>D: Move right</li><li>A: Move left</li><li>S: Move down</li><li>W: Move up</li><li>Space: Raise the ring to release the ghost&rsquo;s soul only when facing the ghost.</li></ul><p>The ghost must be released within 1 second by the ring or the king will be cursed. If the king is cursed, his Life is reduced by one. The king is cursed to death and the game is over when all 10 lives are lost.</p><p>The interval between the appearance of the next ghost is gradually shortened from 2 seconds at the beginning of the game to as short as 1 second.</p><p>By the way, my highest score is 150. I don&rsquo;t know if this is great or not.<br><br></p><h2 id=supplemental-explanation>Supplemental Explanation</h2><p>Finally, I would like to add some additional information about this sample game project.</p><p>During the game, when the ghost appears from the tombstone, the &ldquo;Ghost&rdquo; instance with the collision shape set in the &ldquo;KinematicBody2D&rdquo; class is overlapping the tombstone tiles with the &ldquo;TileMap&rdquo; collision set. In this case, &ldquo;RayCast2D&rdquo; of the &ldquo;Player&rdquo; instance is slightly modified to give priority to the collision detection with the ghost over the tombstone.</p><p>When creating the tombstone tiles by editing the &ldquo;TileSet,&rdquo; a collision of 1/2 the size of the tiles is set. It is easier to set the collision shape after setting &ldquo;Snap Options&rdquo; > &ldquo;Step&rdquo; to (x: 4, y: 4) in the inspector first. Of course, the collision shape of &ldquo;Ghost&rdquo; is (x: 16, y: 16).</p><p><img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img24.png alt="Snap Option - Step">
<img loading=lazy src=/images/tutorials/gd0010_2d_grid_based_movement/img25.png alt="Tomb collision setting in TileSet"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=conclusion>Conclusion</h2><p>In this tutorial, we have explained the implementation of grid-based movement in 2D games. We hope you will find it useful for your puzzle games, simulation games, and other projects you are working on in the future.</p><p>Let&rsquo;s summarize the key points of grid-based movement.</p><ol><li>Set up the following correctly.<ul><li>Size of the tiles prepared in the &ldquo;TileSet&rdquo; resource (height and width)</li><li>Size and position of the sprite of the object to be moved (in this case, &ldquo;Player&rdquo;)</li><li>Size and position of the collision shape of the object to be moved</li><li>Grid Step in the 2D workspace</li><li>The value of the property (in this case <code>grid_size</code>) represents the distance to be moved by the script attached to the object&rsquo;s node.</li></ul></li><li>Use &ldquo;RayCast2D&rdquo; to determine the collision between the object to be moved and other objects. The direction and size of &ldquo;RayCast2D&rdquo; are controlled by scripts.</li><li>To move objects by player manipulation, register actions in the input map, and control the direction of movement for each input in scripts.</li></ol><br><hr><h2 id=link>Link</h2><ul><li><a href=https://www.kenney.nl/assets target=_blank>KENNEY</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_raycast2d.html target=_blank>Godot Docs: RayCast2D</a></li><li><a href=https://docs.godotengine.org/en/stable/tutorials/2d/using_tilemaps.html target=_blank>Godot Docs: Using TileMaps</a></li><li><a href=https://docs.godotengine.org/en/stable/classes/class_tileset.html target=_blank>Godot Docs: TileSet</a></li><li><a href=https://kidscancode.org/godot_recipes/2d/grid_movement/ target=_blank>KidsCanCode: Grid-based movement</a></li><li><a href=https://youtu.be/9laHKHYNyXc target=_blank>YouTube: Grid-based movement Godot 3 demo overview</a></li><li><a href=https://youtu.be/HmnwNadwHWI target=_blank>YouTube: Make your first 2D grid-based game from scratch in Godot</a></li></ul><br><hr><p><strong>UPDATE</strong><br>2022/06/09 Translated from Japanese into English</p><hr></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ 2D Grid-based Movement in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%202D%20Grid-based%20Movement%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0010_2d_grid_based_movement%2f&amp;hashtags=GodotEngine%2cGameDev%2cGodot3%2c2D%2cGridBasedMovement"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ 2D Grid-based Movement in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0010_2d_grid_based_movement%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/gridbasedmovement/>GridBasedMovement</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/><span class=title>¬´ Prev</span><br><span>ü§ñ Connecting Matching Colors Puzzle Game in Godot3</span>
</a><a class=next href=https://www.peanuts-code.com/en/tutorials/gd0008_homing_missiles/><span class=title>Next ¬ª</span><br><span>ü§ñ Homing Missiles in Godot3</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/en/>Peanuts Code</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>