<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ü§ñ Bullet Hell in Godot3 | Peanuts Code</title>
<meta name=keywords content="GodotEngine,GameDev,Godot3,2D,Top-down,Shooter,BulletHell"><meta name=description content="In this time, we will create a bullet hell aka barrage for a barrage shooting game. The bullet hell is a large number of bullets (or similar long-range attacks) like a curtain. A &ldquo;bullet hell shooter&rdquo; is a game in which the player shoots at and defeats enemy characters while dodging and weaving through the gaps between the bullets. Some games specialize in simply dodging the bullets. Many games are based on the motif of spaceships and fighter planes that fit the image (in this tutorial, a ground battle between a wizard and a monster though).
In this tutorial, we will focus only on creating a bullet hell. Also, while bullet hell come in various shapes and sizes, we will focus on rotating-type bullet hell.
Environment This tutorial was created in the following environment
„ÉªGodot version: 3.4.2
„ÉªComputer OS version: macOS 11.6.5
The project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the &ldquo;project.godot&rdquo; file in the &ldquo;Start&rdquo; folder into the Godot Engine, and you will be able to start with a project that has only been prepped."><meta name=author content="gobo"><link rel=canonical href=https://www.peanuts-code.com/en/tutorials/gd0007_bullethell/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.peanuts-code.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.peanuts-code.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.peanuts-code.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.peanuts-code.com/apple-touch-icon.png><link rel=mask-icon href=https://www.peanuts-code.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://www.peanuts-code.com/ja/tutorials/gd0007_bullethell/><link rel=alternate hreflang=en href=https://www.peanuts-code.com/en/tutorials/gd0007_bullethell/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="ü§ñ Bullet Hell in Godot3"><meta property="og:description" content="In this time, we will create a bullet hell aka barrage for a barrage shooting game. The bullet hell is a large number of bullets (or similar long-range attacks) like a curtain. A &ldquo;bullet hell shooter&rdquo; is a game in which the player shoots at and defeats enemy characters while dodging and weaving through the gaps between the bullets. Some games specialize in simply dodging the bullets. Many games are based on the motif of spaceships and fighter planes that fit the image (in this tutorial, a ground battle between a wizard and a monster though).
In this tutorial, we will focus only on creating a bullet hell. Also, while bullet hell come in various shapes and sizes, we will focus on rotating-type bullet hell.
Environment This tutorial was created in the following environment
„ÉªGodot version: 3.4.2
„ÉªComputer OS version: macOS 11.6.5
The project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the &ldquo;project.godot&rdquo; file in the &ldquo;Start&rdquo; folder into the Godot Engine, and you will be able to start with a project that has only been prepped."><meta property="og:type" content="article"><meta property="og:url" content="https://www.peanuts-code.com/en/tutorials/gd0007_bullethell/"><meta property="og:image" content="https://www.peanuts-code.com/images/tutorials/gd0007_BulletHell/img20.gif"><meta property="article:section" content="tutorials"><meta property="article:published_time" content="2022-05-23T01:30:00+09:00"><meta property="article:modified_time" content="2022-05-23T01:30:00+09:00"><meta property="og:site_name" content="Peanuts Code ü•ú"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.peanuts-code.com/images/tutorials/gd0007_BulletHell/img20.gif"><meta name=twitter:title content="ü§ñ Bullet Hell in Godot3"><meta name=twitter:description content="In this time, we will create a bullet hell aka barrage for a barrage shooting game. The bullet hell is a large number of bullets (or similar long-range attacks) like a curtain. A &ldquo;bullet hell shooter&rdquo; is a game in which the player shoots at and defeats enemy characters while dodging and weaving through the gaps between the bullets. Some games specialize in simply dodging the bullets. Many games are based on the motif of spaceships and fighter planes that fit the image (in this tutorial, a ground battle between a wizard and a monster though).
In this tutorial, we will focus only on creating a bullet hell. Also, while bullet hell come in various shapes and sizes, we will focus on rotating-type bullet hell.
Environment This tutorial was created in the following environment
„ÉªGodot version: 3.4.2
„ÉªComputer OS version: macOS 11.6.5
The project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the &ldquo;project.godot&rdquo; file in the &ldquo;Start&rdquo; folder into the Godot Engine, and you will be able to start with a project that has only been prepped."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"ü§ñ Tutorials","item":"https://www.peanuts-code.com/en/tutorials/"},{"@type":"ListItem","position":2,"name":"ü§ñ Bullet Hell in Godot3","item":"https://www.peanuts-code.com/en/tutorials/gd0007_bullethell/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ü§ñ Bullet Hell in Godot3","name":"ü§ñ Bullet Hell in Godot3","description":"In this time, we will create a bullet hell aka barrage for a barrage shooting game. The bullet hell is a large number of bullets (or similar long-range attacks) like a curtain. A \u0026ldquo;bullet hell shooter\u0026rdquo; is a game in which the player shoots at and defeats enemy characters while dodging and weaving through the gaps between the bullets. Some games specialize in simply dodging the bullets. Many games are based on the motif of spaceships and fighter planes that fit the image (in this tutorial, a ground battle between a wizard and a monster though).\nIn this tutorial, we will focus only on creating a bullet hell. Also, while bullet hell come in various shapes and sizes, we will focus on rotating-type bullet hell.\nEnvironment This tutorial was created in the following environment\n„ÉªGodot version: 3.4.2\n„ÉªComputer OS version: macOS 11.6.5\nThe project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;Start\u0026rdquo; folder into the Godot Engine, and you will be able to start with a project that has only been prepped.","keywords":["GodotEngine","GameDev","Godot3","2D","Top-down","Shooter","BulletHell"],"articleBody":"In this time, we will create a bullet hell aka barrage for a barrage shooting game. The bullet hell is a large number of bullets (or similar long-range attacks) like a curtain. A ‚Äúbullet hell shooter‚Äù is a game in which the player shoots at and defeats enemy characters while dodging and weaving through the gaps between the bullets. Some games specialize in simply dodging the bullets. Many games are based on the motif of spaceships and fighter planes that fit the image (in this tutorial, a ground battle between a wizard and a monster though).\nIn this tutorial, we will focus only on creating a bullet hell. Also, while bullet hell come in various shapes and sizes, we will focus on rotating-type bullet hell.\nEnvironment This tutorial was created in the following environment\n„ÉªGodot version: 3.4.2\n„ÉªComputer OS version: macOS 11.6.5\nThe project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the ‚Äúproject.godot‚Äù file in the ‚ÄúStart‚Äù folder into the Godot Engine, and you will be able to start with a project that has only been prepped. If you would like to see the completed project in a hurry, import the ‚Äúproject.godot‚Äù file from the ‚ÄúEnd‚Äù folder.\nAll the assets imported into the project were downloaded from KENNEY website. I used an asset pack called 1-Bit Pack . I can‚Äôt help but be thankful for this wonderful free material.\nNow, when you open the project in the ‚ÄúStart‚Äù folder in Godot Engine, the following are already created.\n1.Player character (wizard) 2.\n2.Player character‚Äôs long-range attack (magic) 3.\n3.Enemy character (the monster who releases a barrage of bullets) 4.\n4.Game world (the game world in which the above objects exist)\nFirst of all, please run the project in the ‚ÄúStart‚Äù folder, where only the preliminary work has been completed, to see how it works.\nThe game is set up as follows.\nThe player character can control movement and magic long-range attacks with the keys below. move_up: W key - the player character moves up. move_down: S key ‚Äî moves the player character down. move_right: D key - moves the player character right. move_left: A key - moves the player character left. magic: Spacebar or left mouse button - Casts a spell. The player character dies after 10 hits from enemy character bullets. If the player character dies, the game is over (debug panel closes automatically). The enemy character can only move for now. The enemy character will move toward the player character every 2 seconds. Enemy character dies after 5 magic hits. Magic is ineffective while Enemy characters are flashing red and white after a hit. When an enemy character dies, the next enemy character appears within a radius of 50px from the player character. The appearance of the enemy character changes randomly each time. The player character‚Äôs magic disappears 1 second after it is released. The game world can be moved unlimitedly. Creating a bullet scene To create a bullet hell scene, we need each of the bullets that make it up. Therefore, we will start by creating the bullet scene.\nCreating a scene Create a new scene of a bullet by following the steps below.\nSelect ‚ÄúScene‚Äù menu \u003e ‚ÄúNew Scene‚Äù. Select ‚ÄúOther Node‚Äù in ‚ÄúGenerate Root Node‚Äù. Select a node of the ‚ÄúArea2D‚Äù class as a root node. Rename the root node ‚ÄúArea2D‚Äù to ‚ÄúBullet‚Äù. Save the scene here once, setting the file path to ‚Äúres://Enemy/Bullet.tscn‚Äù. Adding nodes to the scene Next, add child nodes to the root node ‚ÄúBullet.\nadd a node of the class ‚ÄúSprite‚Äù to the root node ‚ÄúBullet‚Äù. This is the appearance of a bullet. Add a node of the ‚ÄúCollisionShape2D‚Äù class to the root node ‚ÄúBullet‚Äù. This is used to detect when the bullet collides with the physical body. Add a node of the ‚ÄúVisibilityNotifier2D‚Äù class to the root node ‚ÄúBullet‚Äù. This is used to detect when a bullet goes off the screen. Official Godot Docs: VisibilityNotifier2D The scene tree should now look like this.\nEditing the properties of the nodes Continue to edit the properties of each node.\nBulletÔºàArea2DÔºânode No editing of the properties of this root node is required.\nSprite node In this case, we will use the method of setting the sprite texture by specifying the range of textures to be used from a single sprite sheet that contains a large number of textures.\nIn the inspector, apply the resource file ‚Äúres://colored-transparent_packed.png‚Äù to the ‚ÄúTexture‚Äù property of the ‚ÄúSprite‚Äù node.\nTurn on ‚ÄúRegion‚Äù \u003e ‚ÄúEnabled‚Äù\nOpen the ‚ÄúTexture Region‚Äù panel at the bottom of the editor and specify the region of the texture you want to use in the sprite sheet.\nFirst, expand the panel to the top of the editor for easy viewing, and then enlarge the sprite sheet to a size that is easy to see. Select ‚ÄúGrid Snap‚Äù in ‚ÄúSnap Mode‚Äù at the top of the ‚ÄúTexture Region‚Äù panel.\nSet the ‚ÄúStep‚Äù at the top of the panel to 16px 16px as well. This will make the grid the same size as the sprites on the sprite sheet.\nSelect the texture you want to apply to the bullet on the sprite sheet. In this tutorial, we selected a skull texture. It is a horror that a monster will release a barrage of skull bullets.\nReturn to the inspector and change the color to the bullet color of your choice in the Visibility \u003e Modulate property. Here, as a sample, we have chosen the somewhat eerie purple color #9da4d8.\nCollisionShape2D node In the inspector, apply the ‚ÄúNew CircleShape2D‚Äù resource to the ‚ÄúShape‚Äù property.\nIn the 2D workspace, match the collision shape to the size of the ‚ÄúSprite‚Äù node texture.\nIf entering directly in the inspector, set the ‚ÄúRadius‚Äù property of the ‚ÄúCircleShape2D‚Äù resource to 8.\nVisibilityNotifier2D node No editing of the properties of this root node is required.\nControlling bullets with a script Next, let‚Äôs program a script to control bullets. Let‚Äôs attach a new script to the root node ‚ÄúBullet‚Äù. Create the file path as ‚Äúres://Enemy/Bullet.gd‚Äù.\nFirst, edit the script as follows.\n### Bullet.gd ### extends Node2D # Seconds of a bullet export var speed = 150 # Physical process method called 60 times/second func _physics_process(delta): # Move the bullet every frame by adding the current bullet position to.. # the current bullet direction x the current bullet direction x.. # the speed of the bullet per second x 1 frame of time position += transform.x * speed * delta Next, since the root node ‚ÄúBullet‚Äù is an Area2D class, we will use its signal to make the bullet disappear when it hits the physical body. Select ‚ÄúBullet‚Äù in the inspector and connect the signal ‚Äúbody_entered(body)‚Äù to this ‚ÄúBullet.gd‚Äù script in the Node Dock \u003e Signal tab.\nExecute method queue_free in method _on_Bullet_body_entered generated by connecting signals.\n### Bullet.gd ### # Methods called by signals sent out when physical bodies collide func _on_Bullet_body_entered(body): # free Bullet queue_free() Similarly, use the signal of the ‚ÄúVisibilityNotifier2D‚Äù node to make the bullet disappear when it goes off the screen. Let‚Äôs connect the ‚ÄúVisibilityNotifier2D‚Äù signal ‚Äúscreen_exited()‚Äù to this ‚ÄúBullet.gd‚Äù script.\nExecute method queue_free in method _on_VisibilityNotifier2D_screen_exited generated by connecting the signal.\n### Bullet.gd ### # Method called by a signal that is sent out when Bullet go off-screen func _on_VisibilityNotifier2D_screen_exited(): # free Bullet queue_free() This completes the Bullet scene. After this, the created bullet scene instance is added to the enemy character‚Äôs scene tree so that the enemy character can fire bullets.\nCreating a bullet hell Controlling the bullet hell with a script From here, we will edit the script ‚ÄúEnemy.gd‚Äù attached to the root node ‚ÄúEnemy‚Äù in the ‚ÄúEnemy.tscn‚Äù scene of the enemy character to control the bullet hell. After opening ‚ÄúEnemy.gd‚Äù in the script editor, let‚Äôs first define the necessary properties. In the following code, please add the code where it is commented ‚Äú# Add‚Äù.\n### Enemy.gd ### extends KinematicBody2D signal died # Add: reference to preloaded Bullet.tscn const bullet_scn = preload(\"res://Enemy/Bullet.tscn\") var enemy_life = 5 var enemy_speed = 800 var delta_count = 0 # Add: Distance from the center of the Enemy to the firing position of the bullet var radius = 20 # Add: Rotation speed of the bullet's firing position around the Enemy export var rotate_speed = 40 # Add: Interval between firing bullets (seconds) export var interval = 0.4 # Add: Number of bullets fired at one time export var spawning_count = 4 It may be a little difficult to visualize from the comments in the code alone, so a diagram is attached.\nAs you can see, it is easy to imagine a circle with ‚ÄúEnemy‚Äù as its center and the value of the property radius as its radius. Of the bullets to be fired at a time specified by the property spawning_count, the first firing position should always be (x: radius, y: 0), and the second and subsequent bullets should be placed from there at equal intervals (angle difference) around the circumference of this circle. The bullets are shifted by the property rotate_speed in a clockwise direction every second specified by the property interval, and then fired.\nThen edit the _ready method, which is called the first time the scene is loaded. In the _ready method, add the code for initialization necessary to generate the bullet hell. It should be easier to understand if you can visualize the above diagram.\n### Enemy.gd ### func _ready(): anim_player.play(\"spawn\") randomize() sprite.frame = randi() % sprite.hframes ### Add all of the following ### # Define step as the interval (angle difference) between bullets fired at once # step is 180¬∞ x 2 = 360¬∞ divided by the value of the property Spawning_count var step = PI * 2 / spawning_count # Loop for the number of values in spawning_count # e.g) If spawning_count is 4, i will be filled with 0 ~ 3 in that order for i in spawning_count: # Create a new Node2D node to be used as a marker of the bullet's firing position... # and define it as spawn_point var spawn_point = Node2D.new() # Define the firing position as pos # Define pos as the position rotated by (step x i) from the base position (x: radius, y: 0) var pos = Vector2(radius, 0).rotated(step * i) # Place spawn_point at the bullet's firing position spawn_point.position = pos # Align the orientation of the spawn_point with.. # the angle from the positive x-axis to the firing position spawn_point.rotation = pos.angle() # Make spawn_point a child of the Rotater node (Node2D)... # that has been prepared in advance as a node for rotation rotater.add_child(spawn_point) # Set the wait_time property of the Timer node with the value of the interval property timer.wait_time = interval # Wait until the animation of the AnimationPlayer node is finished yield(anim_player, \"animation_finished\") # Start the timer of the Timer node timer.start() Now, every time the ‚ÄúTimer‚Äù node times out, place an instance of the ‚ÄúBullet.tscn‚Äù scene you created earlier at the same position as the child node of the ‚ÄúRotater‚Äù node (the spawn_point in the above code), and the bullets should fly automatically. Now let‚Äôs edit the _on_Timer_timeout method called by the ‚Äútimeout‚Äù signal of the ‚ÄúTimer‚Äù node. Since the signal has already been connected in the preparation, replace pass in the method with the following content.\n### Enemy.gd ### # Methods called on the timeout signal of a Timer node func _on_Timer_timeout(): # Loop over the child nodes of the Rotater node for node2d in rotater.get_children(): # Instance of Bullet.tscn var bullet = bullet_scn.instance() # make Bullet instance node a child of its parent node (World node) rather than Enemy node get_parent().add_child(bullet) # Make the Bullet instance position the same as the Rotater child node position bullet.position = node2d.global_position # set the direction of the Bullet instance to be the same as... # the direction of the child node of Rotater bullet.rotation = node2d.global_rotation The firing position still does not rotate, but for the time being, it should now fire the specified number of bullets at the specified time difference. Let‚Äôs run the project.\nNext, let‚Äôs rotate the firing position of the bullets a bit to make it more like a bullet hell. This time, we will update the code in the _physics_process method a little. Please add the comment ‚Äú# Add‚Äù in the following code.\n### Enemy.gd ### func _physics_process(delta): delta_count += delta if delta_count \u003e 2: delta_count = 0 if get_parent().has_node(\"Player\"): anim_player.stop() anim_player.play(\"move\") var direction = global_position.direction_to(get_parent().get_node(\"Player\").global_position) var velocity = direction * enemy_speed velocity = move_and_slide(velocity) # Add: define next direction (angle) as new_rotation # new_rotation is the current rotation of the Rotater node + rotate_speed x the time of 1 frame var new_rotation = rotater.rotation + rotate_speed * delta # Add: rotate the Rotater node by the remainder (angle) of new_rotation divided by 360 rotater.rotate(fmod(new_rotation, 360)) Now the bullet‚Äôs firing position should rotate every 0.4 seconds as specified in the interval property. Let‚Äôs run the project again to see if it behaves as expected.\nCustomizing the bullet hell Properties defined in scripts can be easily edited in the inspector if the export keyword is added at the beginning. Let‚Äôs change the values to create a different bullet hell than the previous one.\nSample 1\nRotate Speed: 45 Interval: 0.5 Spawning Count: 10\nSample 2\nRotate Speed: 10 Interval: 0.1 Spawning Count: 8\nSample 2 has turned out to be a very devilish game. But what a thrilling and enjoyable experience.\nAdding randomness At the preliminary stage, the appearance of the enemy character (sprite texture) is coded to be randomly determined from six different types. If the properties of the bullet hell are also randomly determined, it would be interesting because it is impossible to predict what kind of bullet hell will be unleashed each time. In fact, it is surprisingly easy to implement this script by just adding a few codes to the script described so far.\nNow, open the ‚ÄúEnemy.gd‚Äù script in the Script Editor. First, define the upper and lower limits of each property to form the bullet hell that has already been prepared in a separate property. Let‚Äôs update the lines commented ‚Äú# Add‚Äù and ‚Äú# Change‚Äù in the following code.\n### Enemy.gd ### var radius = 20 export var rotate_speed: float # Change: only define type and leave value undefined export var max_rotate_speed = 80 # Add export var min_rotate_speed = 20 # Add export var interval: float # Change: only define type and leave value undefined export var max_interval = 0.8 # Add export var min_interval = 0.2 # Add export var spawning_count: int # Change: only define type and leave value undefined export var max_spawning_count = 10 # Add export var min_spawning_count = 2 # Add Next, edit the _ready method, as we need to apply random values to each property at the time the scene is loaded. Let‚Äôs add the lines commented ‚Äú# Add‚Äù in the code below.\nfunc _ready(): anim_player.play(\"spawn\") # enable random value generation randomize() sprite.frame = randi() % sprite.hframes # int, max: 5 # Add: assign a random fraction to rotate_speed with... # min_rotate_speed as the lower limit and max_rotate_speed as the upper limit rotate_speed = rand_range(min_rotate_speed, max_rotate_speed) # Add: Assign a random fraction to interval with... # min_interval as the lower limit and max_interval as the upper limit interval = rand_range(min_interval, max_interval) # Add: The upper limit is -1 from the specified value in the subsequent calculation... # so it is adjusted by +1 first. max_spawning_count += 1 # Add: Assign a random integer to spawning_count with... # min_spawning_count as the lower limit and max_spawning_count as the upper limit spawning_count = randi() % max_spawning_count + min_spawning_count var step = PI * 2 / spawning_count for i in spawning_count: var spawn_point = Node2D.new() var pos = Vector2(radius, 0).rotated(step * i) spawn_point.position = pos spawn_point.rotation = pos.angle() rotater.add_child(spawn_point) timer.wait_time = interval yield(anim_player, \"animation_finished\") timer.start() A few additional notes on the generation of random values.\nFirst, rand_range returns a random float number with the first argument as the lower limit and the second argument as the upper limit. It is used for the properties rotate_speed and interval because these properties are defined as float types.\nNext, randi is a method that returns a random integer, but since it takes no arguments, it is not possible to specify an upper or lower limit.\nTherefore, we use the fact that the remainder when the returned value is divided by the upper limit is 0 or more and less than (upper limit -1). Since the maximum value is the specified upper limit -1, put a code max_spawning_count += 1 one line earlier to add +1.\nThe symbol % (modulo) can be used to obtain the remainder obtained by dividing a by b using a % b. If we add c to that value as a % b + c, the result cannot be smaller than c. In other words, a random integer with upper and lower bounds can be expressed as randi() % upper bound + lower bound. Remember that the maximum value returned is the upper limit -1.\nIn this case, the randomize method was written first, but without it, the result will be the same every time, so if you use methods that return a random value, it is good to remember to write it at the beginning of the _ready method.\nFinally, let‚Äôs run the project to see if each monster that appears will have a different bullet hell.\nConclusion In this tutorial, we created a bullet hell for a top-down shooter. For a rotating bullet hell like this one, the following points will be important.\nSet the radius of the circle, the rotation speed of the firing position, the time difference of firing, and the number of simultaneously fired bullets with properties Prepare a node for rotation. Calculate the firing position based on the radius of the circle and the number of rounds fired simultaneously. Add child nodes to the Rotater node to mark the firing position. Set the timer time to the time difference of the firing. In the physics process, always rotate the Rotater node according to the rotation speed When the timer times out, an instance of the bullet is created at the location of the marker node. There might be better ways to implement this, and I hope that you will experiment with various methods and finally adopt the best one.\nIn addition, actual bullet shooters are not only rotating types like this one, but are also diverse, such as wave-shaped, fan-shaped, etc. If you are interested in this, please look into it.\nLinks Godot Docs: Matrices and transforms YouTube: How to Make a Bullet Hell Projectile Pattern Generator in Godot YouTube: How to Make a Bullet Hell Game in Godot [P1] - Basic Collisions UPDATE\n2022/05/25 Added keys control settings.\n","wordCount":"3135","inLanguage":"en","image":"https://www.peanuts-code.com/images/tutorials/gd0007_BulletHell/img20.gif","datePublished":"2022-05-23T01:30:00+09:00","dateModified":"2022-05-23T01:30:00+09:00","author":{"@type":"Person","name":"gobo"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.peanuts-code.com/en/tutorials/gd0007_bullethell/"},"publisher":{"@type":"Organization","name":"Peanuts Code","logo":{"@type":"ImageObject","url":"https://www.peanuts-code.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.peanuts-code.com/en/ accesskey=h title="Peanuts Code (Alt + H)"><img src=https://www.peanuts-code.com/images/logomark.png alt aria-label=logo height=35>Peanuts Code</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://www.peanuts-code.com/ja/ title=Japanese aria-label=üáØüáµÊó•Êú¨Ë™û>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div></div><ul id=menu><li><a href=https://www.peanuts-code.com/en/ title=Home><span>Home</span></a></li><li><a href=https://www.peanuts-code.com/en/portfolio/ title=Works><span>Works</span></a></li><li><a href=https://www.peanuts-code.com/en/posts/ title=Blogs><span>Blogs</span></a></li><li><a href=https://www.peanuts-code.com/en/tutorials/ title=Tutorials><span>Tutorials</span></a></li><li><a href=https://www.peanuts-code.com/en/about/ title=About><span>About</span></a></li><li><a href=https://www.peanuts-code.com/en/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.peanuts-code.com/en/>Home</a>&nbsp;¬ª&nbsp;<a href=https://www.peanuts-code.com/en/tutorials/>ü§ñ Tutorials</a></div><h1 class="post-title entry-hint-parent">ü§ñ Bullet Hell in Godot3</h1><div class=post-meta><span title='2022-05-23 01:30:00 +0900 +0900'>2022-05-23</span>&nbsp;¬∑&nbsp;15 min&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://www.peanuts-code.com/ja/tutorials/gd0007_bullethell/>üáØüáµÊó•Êú¨Ë™û</a></li></ul></div><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Bullet Hell in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Bullet%20Hell%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0007_bullethell%2f&amp;hashtags=GodotEngine%2cGameDev%2cGodot3%2c2D%2cTop-down%2cShooter%2cBulletHell"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Bullet Hell in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0007_bullethell%2f&title=%f0%9f%a4%96%20Bullet%20Hell%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Bullet Hell in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0007_bullethell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/top-down/>Top-Down</a></li><li><a href=https://www.peanuts-code.com/en/tags/shooter/>Shooter</a></li><li><a href=https://www.peanuts-code.com/en/tags/bullethell/>BulletHell</a></li></ul></header><figure class=entry-cover><img loading=eager src=https://www.peanuts-code.com/images/tutorials/gd0007_BulletHell/img20.gif alt="Bullet Hell in Godot"></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#creating-a-bullet-scene>Creating a bullet scene</a><ul><li><a href=#creating-a-scene>Creating a scene</a></li><li><a href=#adding-nodes-to-the-scene>Adding nodes to the scene</a></li><li><a href=#editing-the-properties-of-the-nodes>Editing the properties of the nodes</a></li><li><a href=#controlling-bullets-with-a-script>Controlling bullets with a script</a></li><li><a href=#creating-a-bullet-hell>Creating a bullet hell</a></li><li><a href=#customizing-the-bullet-hell>Customizing the bullet hell</a></li></ul></li><li><a href=#adding-randomness>Adding randomness</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#links>Links</a></li></ul></nav></div></details></div><div class=post-content><p>In this time, we will create a bullet hell aka barrage for a barrage shooting game. The bullet hell is a large number of bullets (or similar long-range attacks) like a curtain. A &ldquo;bullet hell shooter&rdquo; is a game in which the player shoots at and defeats enemy characters while dodging and weaving through the gaps between the bullets. Some games specialize in simply dodging the bullets. Many games are based on the motif of spaceships and fighter planes that fit the image (in this tutorial, a ground battle between a wizard and a monster though).</p><p>In this tutorial, we will focus only on creating a bullet hell. Also, while bullet hell come in various shapes and sizes, we will focus on rotating-type bullet hell.</p><blockquote><p><em><strong><span style=color:salmon>Environment</span></strong><br>This tutorial was created in the following environment</em><br>„Éª<em>Godot version: <strong>3.4.2</strong></em><br>„Éª<em>Computer OS version: <strong>macOS 11.6.5</strong></em></p></blockquote><br><p>The project file for this tutorial is located at <strong><a href=https://github.com/msnsk/BulletHell.git target=_blank>GitHub repository</a>
</strong>. After downloading the .zip file, import the &ldquo;project.godot&rdquo; file in the &ldquo;Start&rdquo; folder into the Godot Engine, and you will be able to start with a project that has only been prepped. If you would like to see the completed project in a hurry, import the &ldquo;project.godot&rdquo; file from the &ldquo;End&rdquo; folder.</p><p>All the assets imported into the project were downloaded from <strong><a href=https://www.kenney.nl/assets target=_blank>KENNEY</a>
</strong>website. I used an asset pack called <strong><a href=https://www.kenney.nl/assets/bit-pack target=_blank>1-Bit Pack</a>
</strong>. I can&rsquo;t help but be thankful for this wonderful free material.</p><br><p>Now, when you open the project in the &ldquo;Start&rdquo; folder in Godot Engine, the following are already created.<br>1.<strong>Player character (wizard)</strong> 2.<br>2.<strong>Player character&rsquo;s long-range attack (magic)</strong> 3.<br>3.<strong>Enemy character (the monster who releases a barrage of bullets)</strong> 4.<br>4.<strong>Game world (the game world in which the above objects exist)</strong></p><br><p>First of all, please run the project in the &ldquo;Start&rdquo; folder, where only the preliminary work has been completed, to see how it works.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img1.gif alt="run project"></p><p>The game is set up as follows.</p><ul><li>The player character can control movement and magic long-range attacks with the keys below.<ul><li><strong>move_up</strong>: W key - the player character moves up.</li><li><strong>move_down</strong>: S key &mdash; moves the player character down.</li><li><strong>move_right</strong>: D key - moves the player character right.</li><li><strong>move_left</strong>: A key - moves the player character left.</li><li><strong>magic</strong>: Spacebar or left mouse button - Casts a spell.</li></ul></li><li>The player character dies after 10 hits from enemy character bullets.</li><li>If the player character dies, the game is over (debug panel closes automatically).</li><li>The enemy character can only move for now.</li><li>The enemy character will move toward the player character every 2 seconds.</li><li>Enemy character dies after 5 magic hits.</li><li>Magic is ineffective while Enemy characters are flashing red and white after a hit.</li><li>When an enemy character dies, the next enemy character appears within a radius of 50px from the player character.</li><li>The appearance of the enemy character changes randomly each time.</li><li>The player character&rsquo;s magic disappears 1 second after it is released.</li><li>The game world can be moved unlimitedly.</li></ul><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=creating-a-bullet-scene>Creating a bullet scene</h2><p>To create a bullet hell scene, we need each of the bullets that make it up. Therefore, we will start by creating the bullet scene.</p><br><h3 id=creating-a-scene>Creating a scene</h3><p>Create a new scene of a bullet by following the steps below.</p><ol><li>Select &ldquo;Scene&rdquo; menu > &ldquo;New Scene&rdquo;.</li><li>Select &ldquo;Other Node&rdquo; in &ldquo;Generate Root Node&rdquo;.</li><li>Select a node of the &ldquo;Area2D&rdquo; class as a root node.</li><li>Rename the root node &ldquo;Area2D&rdquo; to &ldquo;Bullet&rdquo;.</li><li>Save the scene here once, setting the file path to &ldquo;res://Enemy/Bullet.tscn&rdquo;.</li></ol><br><h3 id=adding-nodes-to-the-scene>Adding nodes to the scene</h3><p>Next, add child nodes to the root node &ldquo;Bullet.</p><ol><li>add a node of the class &ldquo;Sprite&rdquo; to the root node &ldquo;Bullet&rdquo;. This is the appearance of a bullet.</li><li>Add a node of the &ldquo;CollisionShape2D&rdquo; class to the root node &ldquo;Bullet&rdquo;. This is used to detect when the bullet collides with the physical body.</li><li>Add a node of the &ldquo;VisibilityNotifier2D&rdquo; class to the root node &ldquo;Bullet&rdquo;. This is used to detect when a bullet goes off the screen.</li></ol><blockquote><p><em><strong><span style=color:salmon>Official Godot Docs:</span></strong><br><a href=https://docs.godotengine.org/ja/stable/classes/class_visibilitynotifier2d.html target=_blank>VisibilityNotifier2D</a></em></p></blockquote><p>The scene tree should now look like this.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img2.png alt="Bullet Scene Tree"></p><br><h3 id=editing-the-properties-of-the-nodes>Editing the properties of the nodes</h3><p>Continue to edit the properties of each node.<br><br></p><h4 id=bulletarea2dnode>BulletÔºàArea2DÔºânode</h4><p>No editing of the properties of this root node is required.<br><br></p><h4 id=sprite-node>Sprite node</h4><p>In this case, we will use the method of setting the sprite texture by specifying the range of textures to be used from a single sprite sheet that contains a large number of textures.</p><ol><li>In the inspector, apply the resource file &ldquo;res://colored-transparent_packed.png&rdquo; to the &ldquo;Texture&rdquo; property of the &ldquo;Sprite&rdquo; node.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img3.png alt="Texture property of Sprite"></li><li>Turn on &ldquo;Region&rdquo; > &ldquo;Enabled&rdquo;<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img4.png alt="Region&amp;gt;Enabled property of Sprite"></li><li>Open the &ldquo;Texture Region&rdquo; panel at the bottom of the editor and specify the region of the texture you want to use in the sprite sheet.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img5.png alt="Region pannel"><ol><li>First, expand the panel to the top of the editor for easy viewing, and then enlarge the sprite sheet to a size that is easy to see.</li><li>Select &ldquo;Grid Snap&rdquo; in &ldquo;Snap Mode&rdquo; at the top of the &ldquo;Texture Region&rdquo; panel.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img6.png alt="Region pannel &amp;gt; choose grid snap"></li><li>Set the &ldquo;Step&rdquo; at the top of the panel to <strong>16px 16px</strong> as well. This will make the grid the same size as the sprites on the sprite sheet.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img7.png alt="Region pannel &amp;gt; input grid step"></li><li>Select the texture you want to apply to the bullet on the sprite sheet. In this tutorial, we selected a skull texture. It is a horror that a monster will release a barrage of skull bullets.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img8.png alt="Region pannel Select region"></li></ol></li><li>Return to the inspector and change the color to the bullet color of your choice in the Visibility > Modulate property. Here, as a sample, we have chosen the somewhat eerie purple color #9da4d8.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img9.png alt="Visibility&amp;gt;Modulate property"></li></ol><br><h4 id=collisionshape2d-node>CollisionShape2D node</h4><ol><li>In the inspector, apply the &ldquo;New CircleShape2D&rdquo; resource to the &ldquo;Shape&rdquo; property.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img10.png alt="Shape property"></li><li>In the 2D workspace, match the collision shape to the size of the &ldquo;Sprite&rdquo; node texture.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img11.png alt="CollisionShape in 2D workspace"></li><li>If entering directly in the inspector, set the &ldquo;Radius&rdquo; property of the &ldquo;CircleShape2D&rdquo; resource to 8.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img12.png alt="Visibility&amp;gt;Modulate property"></li></ol><br><h4 id=visibilitynotifier2d-node>VisibilityNotifier2D node</h4><p>No editing of the properties of this root node is required.</p><br><h3 id=controlling-bullets-with-a-script>Controlling bullets with a script</h3><p>Next, let&rsquo;s program a script to control bullets. Let&rsquo;s attach a new script to the root node &ldquo;Bullet&rdquo;. Create the file path as &ldquo;res://Enemy/Bullet.gd&rdquo;.</p><p>First, edit the script as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Bullet.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>Node2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Seconds of a bullet</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>speed</span> <span class=o>=</span> <span class=mi>150</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Physical process method called 60 times/second</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_physics_process</span><span class=p>(</span><span class=n>delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># Move the bullet every frame by adding the current bullet position to..</span>
</span></span><span class=line><span class=cl>	<span class=c1># the current bullet direction x the current bullet direction x..</span>
</span></span><span class=line><span class=cl>	<span class=c1># the speed of the bullet per second x 1 frame of time</span>
</span></span><span class=line><span class=cl>	<span class=n>position</span> <span class=o>+=</span> <span class=n>transform</span><span class=o>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>speed</span> <span class=o>*</span> <span class=n>delta</span>
</span></span></code></pre></div><br><p>Next, since the root node &ldquo;Bullet&rdquo; is an Area2D class, we will use its signal to make the bullet disappear when it hits the physical body. Select &ldquo;Bullet&rdquo; in the inspector and connect the signal &ldquo;body_entered(body)&rdquo; to this &ldquo;Bullet.gd&rdquo; script in the Node Dock > Signal tab.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img13.png alt="connect signal body_entered"></p><p>Execute method <code>queue_free</code> in method <code>_on_Bullet_body_entered</code> generated by connecting signals.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Bullet.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># Methods called by signals sent out when physical bodies collide</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Bullet_body_entered</span><span class=p>(</span><span class=n>body</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=c1># free Bullet</span>
</span></span><span class=line><span class=cl>	<span class=nf>queue_free</span><span class=p>()</span>
</span></span></code></pre></div><br><p>Similarly, use the signal of the &ldquo;VisibilityNotifier2D&rdquo; node to make the bullet disappear when it goes off the screen. Let&rsquo;s connect the &ldquo;VisibilityNotifier2D&rdquo; signal &ldquo;screen_exited()&rdquo; to this &ldquo;Bullet.gd&rdquo; script.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img14.png alt="connect signal screen_exited"></p><p>Execute method <code>queue_free</code> in method <code>_on_VisibilityNotifier2D_screen_exited</code> generated by connecting the signal.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Bullet.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># Method called by a signal that is sent out when Bullet go off-screen</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_VisibilityNotifier2D_screen_exited</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># free Bullet</span>
</span></span><span class=line><span class=cl>	<span class=nf>queue_free</span><span class=p>()</span>
</span></span></code></pre></div><br><p>This completes the Bullet scene. After this, the created bullet scene instance is added to the enemy character&rsquo;s scene tree so that the enemy character can fire bullets.</p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h3 id=creating-a-bullet-hell>Creating a bullet hell</h3><h4 id=controlling-the-bullet-hell-with-a-script>Controlling the bullet hell with a script</h4><p>From here, we will edit the script &ldquo;Enemy.gd&rdquo; attached to the root node &ldquo;Enemy&rdquo; in the &ldquo;Enemy.tscn&rdquo; scene of the enemy character to control the bullet hell. After opening &ldquo;Enemy.gd&rdquo; in the script editor, let&rsquo;s first define the necessary properties. In the following code, please add the code where it is commented &ldquo;# Add&rdquo;.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Enemy.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>extends</span> <span class=nc>KinematicBody2D</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>signal</span> <span class=n>died</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Add: reference to preloaded Bullet.tscn</span>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=n>bullet_scn</span> <span class=o>=</span> <span class=nb>preload</span><span class=p>(</span><span class=s2>&#34;res://Enemy/Bullet.tscn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>enemy_life</span> <span class=o>=</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>enemy_speed</span> <span class=o>=</span> <span class=mi>800</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>delta_count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Add: Distance from the center of the Enemy to the firing position of the bullet</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>radius</span> <span class=o>=</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl><span class=c1># Add: Rotation speed of the bullet&#39;s firing position around the Enemy</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>rotate_speed</span> <span class=o>=</span> <span class=mi>40</span>
</span></span><span class=line><span class=cl><span class=c1># Add: Interval between firing bullets (seconds)</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>interval</span> <span class=o>=</span> <span class=mf>0.4</span>
</span></span><span class=line><span class=cl><span class=c1># Add: Number of bullets fired at one time</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>spawning_count</span> <span class=o>=</span> <span class=mi>4</span>
</span></span></code></pre></div><p>It may be a little difficult to visualize from the comments in the code alone, so a diagram is attached.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/figure1.png alt=figure></p><p>As you can see, it is easy to imagine a circle with &ldquo;Enemy&rdquo; as its center and the value of the property <code>radius</code> as its radius. Of the bullets to be fired at a time specified by the property <code>spawning_count</code>, the first firing position should always be (x: radius, y: 0), and the second and subsequent bullets should be placed from there at equal intervals (angle difference) around the circumference of this circle. The bullets are shifted by the property <code>rotate_speed</code> in a clockwise direction every second specified by the property <code>interval</code>, and then fired.</p><br><p>Then edit the <code>_ready</code> method, which is called the first time the scene is loaded. In the <code>_ready</code> method, add the code for initialization necessary to generate the bullet hell. It should be easier to understand if you can visualize the above diagram.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Enemy.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;spawn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=nb>randomize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>sprite</span><span class=o>.</span><span class=n>frame</span> <span class=o>=</span> <span class=nb>randi</span><span class=p>()</span> <span class=o>%</span> <span class=n>sprite</span><span class=o>.</span><span class=n>hframes</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1>### Add all of the following ###</span>
</span></span><span class=line><span class=cl>	<span class=c1># Define step as the interval (angle difference) between bullets fired at once</span>
</span></span><span class=line><span class=cl>	<span class=c1># step is 180¬∞ x 2 = 360¬∞ divided by the value of the property Spawning_count</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>step</span> <span class=o>=</span> <span class=kc>PI</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>/</span> <span class=n>spawning_count</span>
</span></span><span class=line><span class=cl>	<span class=c1># Loop for the number of values in spawning_count</span>
</span></span><span class=line><span class=cl>	<span class=c1># e.g) If spawning_count is 4, i will be filled with 0 ~ 3 in that order</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>spawning_count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1># Create a new Node2D node to be used as a marker of the bullet&#39;s firing position...</span>
</span></span><span class=line><span class=cl>		<span class=c1># and define it as spawn_point</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>spawn_point</span> <span class=o>=</span> <span class=nc>Node2D</span><span class=o>.</span><span class=nf>new</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=c1># Define the firing position as pos</span>
</span></span><span class=line><span class=cl>		<span class=c1># Define pos as the position rotated by (step x i) from the base position (x: radius, y: 0)</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>pos</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>(</span><span class=n>radius</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=nf>rotated</span><span class=p>(</span><span class=n>step</span> <span class=o>*</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1># Place spawn_point at the bullet&#39;s firing position</span>
</span></span><span class=line><span class=cl>		<span class=n>spawn_point</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>pos</span>
</span></span><span class=line><span class=cl>		<span class=c1># Align the orientation of the spawn_point with..</span>
</span></span><span class=line><span class=cl>		<span class=c1># the angle from the positive x-axis to the firing position</span>
</span></span><span class=line><span class=cl>		<span class=n>spawn_point</span><span class=o>.</span><span class=n>rotation</span> <span class=o>=</span> <span class=n>pos</span><span class=o>.</span><span class=nf>angle</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=c1># Make spawn_point a child of the Rotater node (Node2D)...</span>
</span></span><span class=line><span class=cl>		<span class=c1># that has been prepared in advance as a node for rotation</span>
</span></span><span class=line><span class=cl>		<span class=n>rotater</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>spawn_point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># Set the wait_time property of the Timer node with the value of the interval property</span>
</span></span><span class=line><span class=cl>	<span class=n>timer</span><span class=o>.</span><span class=n>wait_time</span> <span class=o>=</span> <span class=n>interval</span>
</span></span><span class=line><span class=cl>	<span class=c1># Wait until the animation of the AnimationPlayer node is finished</span>
</span></span><span class=line><span class=cl>	<span class=k>yield</span><span class=p>(</span><span class=n>anim_player</span><span class=p>,</span> <span class=s2>&#34;animation_finished&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Start the timer of the Timer node</span>
</span></span><span class=line><span class=cl>	<span class=n>timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span></code></pre></div><br><p>Now, every time the &ldquo;Timer&rdquo; node times out, place an instance of the &ldquo;Bullet.tscn&rdquo; scene you created earlier at the same position as the child node of the &ldquo;Rotater&rdquo; node (the <code>spawn_point</code> in the above code), and the bullets should fly automatically. Now let&rsquo;s edit the <code>_on_Timer_timeout</code> method called by the &ldquo;timeout&rdquo; signal of the &ldquo;Timer&rdquo; node. Since the signal has already been connected in the preparation, replace <code>pass</code> in the method with the following content.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Enemy.gd ###</span>
</span></span><span class=line><span class=cl><span class=c1># Methods called on the timeout signal of a Timer node</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_on_Timer_timeout</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=c1># Loop over the child nodes of the Rotater node</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>node2d</span> <span class=ow>in</span> <span class=n>rotater</span><span class=o>.</span><span class=nf>get_children</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		<span class=c1># Instance of Bullet.tscn</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>bullet</span> <span class=o>=</span> <span class=n>bullet_scn</span><span class=o>.</span><span class=nf>instance</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=c1># make Bullet instance node a child of its parent node (World node) rather than Enemy node</span>
</span></span><span class=line><span class=cl>		<span class=nf>get_parent</span><span class=p>()</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>bullet</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1># Make the Bullet instance position the same as the Rotater child node position</span>
</span></span><span class=line><span class=cl>		<span class=n>bullet</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>node2d</span><span class=o>.</span><span class=n>global_position</span>
</span></span><span class=line><span class=cl>		<span class=c1># set the direction of the Bullet instance to be the same as...</span>
</span></span><span class=line><span class=cl>		<span class=c1># the direction of the child node of Rotater</span>
</span></span><span class=line><span class=cl>		<span class=n>bullet</span><span class=o>.</span><span class=n>rotation</span> <span class=o>=</span> <span class=n>node2d</span><span class=o>.</span><span class=n>global_rotation</span>
</span></span></code></pre></div><br><p>The firing position still does not rotate, but for the time being, it should now fire the specified number of bullets at the specified time difference. Let&rsquo;s run the project.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img15.gif alt="run project"></p><br><p>Next, let&rsquo;s rotate the firing position of the bullets a bit to make it more like a bullet hell. This time, we will update the code in the <code>_physics_process</code> method a little. Please add the comment &ldquo;# Add&rdquo; in the following code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Enemy.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_physics_process</span><span class=p>(</span><span class=n>delta</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	<span class=n>delta_count</span> <span class=o>+=</span> <span class=n>delta</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>delta_count</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=n>delta_count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=nf>get_parent</span><span class=p>()</span><span class=o>.</span><span class=nf>has_node</span><span class=p>(</span><span class=s2>&#34;Player&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>			<span class=n>anim_player</span><span class=o>.</span><span class=nf>stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;move&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=kd>var</span> <span class=n>direction</span> <span class=o>=</span> <span class=n>global_position</span><span class=o>.</span><span class=nf>direction_to</span><span class=p>(</span><span class=nf>get_parent</span><span class=p>()</span><span class=o>.</span><span class=nf>get_node</span><span class=p>(</span><span class=s2>&#34;Player&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>global_position</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=kd>var</span> <span class=n>velocity</span> <span class=o>=</span> <span class=n>direction</span> <span class=o>*</span> <span class=n>enemy_speed</span>
</span></span><span class=line><span class=cl>			<span class=n>velocity</span> <span class=o>=</span> <span class=nf>move_and_slide</span><span class=p>(</span><span class=n>velocity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>	<span class=c1># Add: define next direction (angle) as new_rotation</span>
</span></span><span class=line><span class=cl>	<span class=c1># new_rotation is the current rotation of the Rotater node + rotate_speed x the time of 1 frame</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>new_rotation</span> <span class=o>=</span> <span class=n>rotater</span><span class=o>.</span><span class=n>rotation</span> <span class=o>+</span> <span class=n>rotate_speed</span> <span class=o>*</span> <span class=n>delta</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add: rotate the Rotater node by the remainder (angle) of new_rotation divided by 360</span>
</span></span><span class=line><span class=cl>	<span class=n>rotater</span><span class=o>.</span><span class=nf>rotate</span><span class=p>(</span><span class=nb>fmod</span><span class=p>(</span><span class=n>new_rotation</span><span class=p>,</span> <span class=mi>360</span><span class=p>))</span>
</span></span></code></pre></div><br><p>Now the bullet&rsquo;s firing position should rotate every <code>0.4</code> seconds as specified in the <code>interval</code> property. Let&rsquo;s run the project again to see if it behaves as expected.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img16.gif alt="run project"></p><br><h3 id=customizing-the-bullet-hell>Customizing the bullet hell</h3><p>Properties defined in scripts can be easily edited in the inspector if the <code>export</code> keyword is added at the beginning. Let&rsquo;s change the values to create a different bullet hell than the previous one.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img17.png alt="run project"></p><br><ul><li><p>Sample 1</p><ul><li>Rotate Speed: 45</li><li>Interval: 0.5</li><li>Spawning Count: 10<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img18.gif alt="run project"></li></ul></li><li><p>Sample 2</p><ul><li>Rotate Speed: 10</li><li>Interval: 0.1</li><li>Spawning Count: 8<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img19.gif alt="run project"></li></ul></li></ul><br><p>Sample 2 has turned out to be a very devilish game. But what a thrilling and enjoyable experience.</p><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=adding-randomness>Adding randomness</h2><p>At the preliminary stage, the appearance of the enemy character (sprite texture) is coded to be randomly determined from six different types. If the properties of the bullet hell are also randomly determined, it would be interesting because it is impossible to predict what kind of bullet hell will be unleashed each time. In fact, it is surprisingly easy to implement this script by just adding a few codes to the script described so far.</p><p>Now, open the &ldquo;Enemy.gd&rdquo; script in the Script Editor. First, define the upper and lower limits of each property to form the bullet hell that has already been prepared in a separate property. Let&rsquo;s update the lines commented &ldquo;# Add&rdquo; and &ldquo;# Change&rdquo; in the following code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=c1>### Enemy.gd ###</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=n>radius</span> <span class=o>=</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>rotate_speed</span><span class=p>:</span> <span class=kt>float</span> <span class=c1># Change: only define type and leave value undefined</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>max_rotate_speed</span> <span class=o>=</span> <span class=mi>80</span> <span class=c1># Add</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>min_rotate_speed</span> <span class=o>=</span> <span class=mi>20</span> <span class=c1># Add</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>interval</span><span class=p>:</span> <span class=kt>float</span> <span class=c1># Change: only define type and leave value undefined</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>max_interval</span> <span class=o>=</span> <span class=mf>0.8</span> <span class=c1># Add</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>min_interval</span> <span class=o>=</span> <span class=mf>0.2</span> <span class=c1># Add</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>spawning_count</span><span class=p>:</span> <span class=kt>int</span> <span class=c1># Change: only define type and leave value undefined</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>max_spawning_count</span> <span class=o>=</span> <span class=mi>10</span> <span class=c1># Add</span>
</span></span><span class=line><span class=cl><span class=n>export</span> <span class=kd>var</span> <span class=n>min_spawning_count</span> <span class=o>=</span> <span class=mi>2</span> <span class=c1># Add</span>
</span></span></code></pre></div><br><p>Next, edit the <code>_ready</code> method, as we need to apply random values to each property at the time the scene is loaded. Let&rsquo;s add the lines commented &ldquo;# Add&rdquo; in the code below.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-GDScript data-lang=GDScript><span class=line><span class=cl><span class=kd>func</span> <span class=nf>_ready</span><span class=p>():</span>
</span></span><span class=line><span class=cl>	<span class=n>anim_player</span><span class=o>.</span><span class=nf>play</span><span class=p>(</span><span class=s2>&#34;spawn&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># enable random value generation</span>
</span></span><span class=line><span class=cl>	<span class=nb>randomize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=n>sprite</span><span class=o>.</span><span class=n>frame</span> <span class=o>=</span> <span class=nb>randi</span><span class=p>()</span> <span class=o>%</span> <span class=n>sprite</span><span class=o>.</span><span class=n>hframes</span> <span class=c1># int, max: 5</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1># Add: assign a random fraction to rotate_speed with...</span>
</span></span><span class=line><span class=cl>	<span class=c1># min_rotate_speed as the lower limit and max_rotate_speed as the upper limit</span>
</span></span><span class=line><span class=cl>	<span class=n>rotate_speed</span> <span class=o>=</span> <span class=nf>rand_range</span><span class=p>(</span><span class=n>min_rotate_speed</span><span class=p>,</span> <span class=n>max_rotate_speed</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add: Assign a random fraction to interval with...</span>
</span></span><span class=line><span class=cl>	<span class=c1># min_interval as the lower limit and max_interval as the upper limit</span>
</span></span><span class=line><span class=cl>	<span class=n>interval</span> <span class=o>=</span> <span class=nf>rand_range</span><span class=p>(</span><span class=n>min_interval</span><span class=p>,</span> <span class=n>max_interval</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add: The upper limit is -1 from the specified value in the subsequent calculation...</span>
</span></span><span class=line><span class=cl>	<span class=c1># so it is adjusted by +1 first.</span>
</span></span><span class=line><span class=cl>	<span class=n>max_spawning_count</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>	<span class=c1># Add: Assign a random integer to spawning_count with...</span>
</span></span><span class=line><span class=cl>	<span class=c1># min_spawning_count as the lower limit and max_spawning_count as the upper limit</span>
</span></span><span class=line><span class=cl>	<span class=n>spawning_count</span> <span class=o>=</span> <span class=nb>randi</span><span class=p>()</span> <span class=o>%</span> <span class=n>max_spawning_count</span> <span class=o>+</span> <span class=n>min_spawning_count</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=n>step</span> <span class=o>=</span> <span class=kc>PI</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>/</span> <span class=n>spawning_count</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=n>spawning_count</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>spawn_point</span> <span class=o>=</span> <span class=nc>Node2D</span><span class=o>.</span><span class=nf>new</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=kd>var</span> <span class=n>pos</span> <span class=o>=</span> <span class=nc>Vector2</span><span class=p>(</span><span class=n>radius</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=nf>rotated</span><span class=p>(</span><span class=n>step</span> <span class=o>*</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=n>spawn_point</span><span class=o>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>pos</span>
</span></span><span class=line><span class=cl>		<span class=n>spawn_point</span><span class=o>.</span><span class=n>rotation</span> <span class=o>=</span> <span class=n>pos</span><span class=o>.</span><span class=nf>angle</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=n>rotater</span><span class=o>.</span><span class=nf>add_child</span><span class=p>(</span><span class=n>spawn_point</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>timer</span><span class=o>.</span><span class=n>wait_time</span> <span class=o>=</span> <span class=n>interval</span>
</span></span><span class=line><span class=cl>	<span class=k>yield</span><span class=p>(</span><span class=n>anim_player</span><span class=p>,</span> <span class=s2>&#34;animation_finished&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>timer</span><span class=o>.</span><span class=nf>start</span><span class=p>()</span>
</span></span></code></pre></div><p>A few additional notes on the generation of random values.</p><p>First, <code>rand_range</code> returns a random float number with the first argument as the lower limit and the second argument as the upper limit. It is used for the properties <code>rotate_speed</code> and <code>interval</code> because these properties are defined as float types.</p><p>Next, <code>randi</code> is a method that returns a random integer, but since it takes no arguments, it is not possible to specify an upper or lower limit.</p><p>Therefore, we use the fact that the remainder when the returned value is divided by the upper limit is <strong>0 or more and less than (upper limit -1)</strong>. Since the maximum value is the specified upper limit -1, put a code <code>max_spawning_count += 1</code> one line earlier to add +1.</p><p>The symbol <strong>% (modulo)</strong> can be used to obtain the remainder obtained by dividing <strong>a</strong> by <strong>b</strong> using <strong>a % b</strong>. If we add <strong>c</strong> to that value as <strong>a % b + c</strong>, the result cannot be smaller than <strong>c</strong>. In other words, a random integer with upper and lower bounds can be expressed as <strong><code>randi() % upper bound + lower bound</code></strong>. Remember that the maximum value returned is the upper limit -1.</p><p>In this case, the <code>randomize</code> method was written first, but without it, the result will be the same every time, so if you use methods that return a random value, it is good to remember to write it at the beginning of the <code>_ready</code> method.</p><p>Finally, let&rsquo;s run the project to see if each monster that appears will have a different bullet hell.<br><img loading=lazy src=/images/tutorials/gd0007_BulletHell/img20.gif alt="run project"></p><br><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4952908839423901" crossorigin=anonymous></script><p><ins class=adsbygoogle style=display:block;text-align:center data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-4952908839423901 data-ad-slot=9419515863></ins></p><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><hr><h2 id=conclusion>Conclusion</h2><p>In this tutorial, we created a bullet hell for a top-down shooter. For a rotating bullet hell like this one, the following points will be important.</p><ul><li>Set the radius of the circle, the rotation speed of the firing position, the time difference of firing, and the number of simultaneously fired bullets with properties</li><li>Prepare a node for rotation.</li><li>Calculate the firing position based on the radius of the circle and the number of rounds fired simultaneously.</li><li>Add child nodes to the Rotater node to mark the firing position.</li><li>Set the timer time to the time difference of the firing.</li><li>In the physics process, always rotate the Rotater node according to the rotation speed</li><li>When the timer times out, an instance of the bullet is created at the location of the marker node.</li></ul><p>There might be better ways to implement this, and I hope that you will experiment with various methods and finally adopt the best one.</p><p>In addition, actual bullet shooters are not only rotating types like this one, but are also diverse, such as wave-shaped, fan-shaped, etc. If you are interested in this, please look into it.<br><br></p><hr><h2 id=links>Links</h2><ul><li><a href=https://docs.godotengine.org/en/stable/tutorials/math/matrices_and_transforms.html target=_blank>Godot Docs: Matrices and transforms</a></li><li><a href="https://www.youtube.com/watch?v=Z2TaFnN7cdU&amp;t=477s" target=_blank>YouTube: How to Make a Bullet Hell Projectile Pattern Generator in Godot</a></li><li><a href="https://www.youtube.com/watch?v=NMNl9Ix6ng8" target=_blank>YouTube: How to Make a Bullet Hell Game in Godot [P1] - Basic Collisions</a></li></ul><br><p><strong>UPDATE</strong><br>2022/05/25 Added keys control settings.</p><hr></div><footer class=post-footer><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Bullet Hell in Godot3 on x" href="https://x.com/intent/tweet/?text=%f0%9f%a4%96%20Bullet%20Hell%20in%20Godot3&amp;url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0007_bullethell%2f&amp;hashtags=GodotEngine%2cGameDev%2cGodot3%2c2D%2cTop-down%2cShooter%2cBulletHell"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Bullet Hell in Godot3 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0007_bullethell%2f&title=%f0%9f%a4%96%20Bullet%20Hell%20in%20Godot3"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share ü§ñ Bullet Hell in Godot3 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.peanuts-code.com%2fen%2ftutorials%2fgd0007_bullethell%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul><ul class=post-tags><li><a href=https://www.peanuts-code.com/en/tags/godotengine/>GodotEngine</a></li><li><a href=https://www.peanuts-code.com/en/tags/gamedev/>GameDev</a></li><li><a href=https://www.peanuts-code.com/en/tags/godot3/>Godot3</a></li><li><a href=https://www.peanuts-code.com/en/tags/2d/>2D</a></li><li><a href=https://www.peanuts-code.com/en/tags/top-down/>Top-Down</a></li><li><a href=https://www.peanuts-code.com/en/tags/shooter/>Shooter</a></li><li><a href=https://www.peanuts-code.com/en/tags/bullethell/>BulletHell</a></li></ul><nav class=paginav><a class=prev href=https://www.peanuts-code.com/en/tutorials/gd0008_homing_missiles/><span class=title>¬´ Prev</span><br><span>ü§ñ Homing Missiles in Godot3</span>
</a><a class=next href=https://www.peanuts-code.com/en/posts/post0002_development_starts_small/><span class=title>Next ¬ª</span><br><span>üìî Game development starting with something simple</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.peanuts-code.com/en/>Peanuts Code</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>