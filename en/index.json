[{"content":"In this tutorial, we will create an advanced match-3 puzzle game, a type of puzzle game in which one piece is moved freely on the board for a certain period of time to erase three or more pieces of the same color in a row.\nThis is easy to understand if you imagine a puzzle game like \u0026ldquo;Puzzle \u0026amp; Dragons\u0026rdquo; (a.k.a. \u0026ldquo;Puzzle Dora\u0026rdquo;), which has gained popularity as a mobile game.\nHowever, the tutorial would be too large if it included all game elements such as decks, gacha, and battles with enemy characters, so we will focus on the puzzle part of the tutorial this time.\nFor more information on how to create an standard match-3 puzzle game like \u0026ldquo;Candy Crush\u0026rdquo; or a puzzle game like \u0026ldquo;LINE Tsum Tsum\u0026rdquo;, please refer to the following tutorial.\nOther Tutorials If you want to make a game like \u0026ldquo;Candy Crush\u0026rdquo;:\nMatch 3 puzzle game in Godot If you want to make a game like \u0026ldquo;LINE: Disney Tsum Tsum\u0026rdquo;:\nConnecting matching colors puzzle game in Godot The project file that will be created at the end of this tutorial is located in the GitHub repository . You can also check the project directly by downloading the .zip file and importing the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;End\u0026rdquo; folder with the Godot Engine.\nEnvironment This tutorial was created in the following environment\n・Godot version: 3.4.4\n・Computer OS version: macOS 11.6.5\nMemo: Please also use the following articles to help you start creating your game.\nDownloading Godot Project Manager of Godot Creating a new project Start Godot Engine and create a new project. The name of the project is up to you. If you can\u0026rsquo;t think of one, let\u0026rsquo;s call it \u0026ldquo;Advanced Match3 Start\u0026rdquo;.\n###Updating project settings\nOnce the editor appears, let\u0026rsquo;s go ahead and update project settings for the entire project.\nFirst, set the display size for the game. In this case, we will assume a smartphone screen in portrait orientation and set the aspect ratio to 16 : 9.\nOpen the \u0026ldquo;Project\u0026rdquo; menu \u0026gt; \u0026ldquo;Project Settings\u0026rdquo;. In the \u0026ldquo;General\u0026rdquo; tab, search for \u0026ldquo;window\u0026rdquo; and select \u0026ldquo;Display\u0026rdquo; \u0026gt; \u0026ldquo;Window\u0026rdquo; in the sidebar. In the \u0026ldquo;Size\u0026rdquo; section, change the values of the following items Width: 630 Height: 1120 Test Width: 315 Test Height: 560\nIn the \u0026ldquo;Stretch\u0026rdquo; section, change the values of the following items Mode: 2d Aspect: keep\nWith the \u0026ldquo;Project Settings\u0026rdquo; window open as it is, configure the settings to substitute the mouse for the phone\u0026rsquo;s touch operation in the debug panel.\nSearch for \u0026ldquo;mouse\u0026rdquo; in the \u0026ldquo;General\u0026rdquo; tab and select \u0026ldquo;Input Devices\u0026rdquo; \u0026gt; \u0026ldquo;Pointing\u0026rdquo; in the sidebar. Check the On checkbox for \u0026ldquo;Emulate Touch From Mouse\u0026rdquo;.\nIn addition, with the \u0026ldquo;Project Settings\u0026rdquo; window open, let\u0026rsquo;s add an action to the input map that corresponds to a smartphone touch operation.\nSwitch to the \u0026ldquo;Input Map\u0026rdquo; tab and add \u0026ldquo;touch\u0026rdquo; to the action. Add a left mouse click to the \u0026ldquo;touch\u0026rdquo; action.\n###Downloading and importing assets\nNext, let\u0026rsquo;s download assets from KENNEY\u0026rsquo;s site and use them. This time, we will use an asset pack called \u0026ldquo;Physics Assets \u0026rdquo;. I will use the cute alien face images in this asset pack as textures for the pieces I will place on the game board. I can\u0026rsquo;t help but be thankful for this wonderful free resource.\nOnce downloaded, delete the images in the \u0026ldquo;/physicspack/PNG/Aliens\u0026rdquo; folder with the file name \u0026ldquo;~_round.png\u0026rdquo; and drag the \u0026ldquo;Aliens\u0026rdquo; folder to the file system dock of the editor to import them into your project.\nCreating a Grid scene First, let\u0026rsquo;s create a \u0026ldquo;Grid\u0026rdquo; scene as the board on which the pieces are placed in a match-3 puzzle game.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Node\u0026rdquo; in \u0026ldquo;Generate Root Node\u0026rdquo;. When the root node of the \u0026ldquo;Area2D\u0026rdquo; class is generated, rename it to \u0026ldquo;Grid\u0026rdquo;. Save the scene. Create a folder and save the scene with the file path \u0026ldquo;res://Grid/Grid.tscn\u0026rdquo;.\nAdding a node to the Grid scene Let\u0026rsquo;s add more nodes to the \u0026ldquo;Grid\u0026rdquo; root node.\nAdd a \u0026ldquo;CollisionShape2D\u0026rdquo; node to the \u0026ldquo;Grid\u0026rdquo; root node. Add a \u0026ldquo;Node2D\u0026rdquo; node to the \u0026ldquo;Grid\u0026rdquo; root node and rename it to \u0026ldquo;PiecesContainer\u0026rdquo;. Add two \u0026ldquo;Timer\u0026rdquo; nodes to the \u0026ldquo;Grid\u0026rdquo; root node and rename them \u0026ldquo;TouchTimer\u0026rdquo; and \u0026ldquo;WaitTimer\u0026rdquo; respectively. The scene tree should now look like the following.\nLet\u0026rsquo;s continue editing the nodes we have added.\nEditing a node in a Grid scene Grid (Area2D) Root node In this puzzle, you can move the pieces freely on the board, but the pieces you are moving must not extend beyond the board. Otherwise, the pieces can be moved outside of the board and replaced with pieces that are far away from the board. In this puzzle game, the pieces you are moving and the adjacent drops are exchanged one after another.\nThe root node is an Area2D class node that uses a signal to detect when a finger (the piece being moved) moves off the board. As long as detection is possible, the movable area of the piece can be restricted by scripts. We will attach the script to this scene at the end, so we will connect the signals again at that time.\nThere is no need to edit the properties of this node itself.\nCollisionShape2D node This node is used to detect when a finger (the piece you are moving) protrudes outside of the board. Edit each property in the inspector as follows\nShape: Apply a new RectangleShape2D resource. RectangleShape2D \u0026gt; Extents: (x: 225, y: 190)\nTransform \u0026gt; Position: (x: 315, y: 840)\nOn a 2D workspace, it should have looked like this.\nPiecesContainer (Node2D) node This node is used to organize the pieces that will be placed on the board. During the game, every instance of a piece that is created by the script will be added as a child of this \u0026ldquo;PiecesContainer\u0026rdquo; node. This way, no matter how many instances of a piece are created, the order of the nodes in the scene tree will be maintained.\nThere are no particular properties that need to be edited, so let\u0026rsquo;s move on.\nTouchTimer node This node of the Timer class is used to start a countdown after the player starts moving the pieces with his/her finger, so that when the time runs out, the pieces he/she was moving will automatically leave his/her finger. This gives the player a certain sense of urgency to line up the pieces within the time limit. In this case, we will set the pieces to be able to move for 5 seconds.\nLet\u0026rsquo;s edit the inspector as follows.\nWait Time: 5 One Shot: On\nWaitTimer node This node of the Timer class is used to pause for a moment between each process in the automatic process of matching pieces, deleting the matched pieces, filling the empty grid, and adding the missing pieces after the pieces leave the fingers. The node is used to pause for a moment between each process.\nEdit as follows in the inspector.\nWait Time: 0.3 One Shot: On\nThis completes the editing of the \u0026ldquo;Grid\u0026rdquo; scene.\nCreating a Piece scene Next, create a \u0026ldquo;Piece\u0026rdquo; scene for the pieces to be placed on the board. However, this \u0026ldquo;Piece\u0026rdquo; scene is only a model, and the actual pieces of each color to be used in the game will be prepared later by inheriting this \u0026ldquo;Piece\u0026rdquo; scene.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Scene\u0026rdquo; in \u0026ldquo;Generate Root Node\u0026rdquo;. When the root node of \u0026ldquo;Area2D\u0026rdquo; class is generated, rename it to \u0026ldquo;Piece\u0026rdquo;. Save the scene. Create a folder and save the scene with the file path \u0026ldquo;res://Pieces/Piece.tscn\u0026rdquo;.\nAdding nodes to the Piece scene Let\u0026rsquo;s continue adding the necessary nodes to the \u0026ldquo;Piece\u0026rdquo; scene.\nAdd a \u0026ldquo;Sprite\u0026rdquo; node to the \u0026ldquo;Piece\u0026rdquo; root node. Add a \u0026ldquo;CollisionShape2D\u0026rdquo; node to the \u0026ldquo;Piece\u0026rdquo; root node. Add a \u0026ldquo;Tween\u0026rdquo; node to the \u0026ldquo;Piece\u0026rdquo; root node.\nThe scene tree for the Piece scene should now look like this.\nEditing a node in a Piece scene Piece (Area2D) Root node The root node is an Area2D class so that we can detect when a finger hits the piece we want to move, moves away from the piece, or when the pieces collide with each other.\nThe properties of this node do not need to be edited, but one property needs to be added to the group. After selecting the \u0026ldquo;Piece\u0026rdquo; root node in the scene dock, select the Node Dock \u0026gt; Groups tab and create and add a group named \u0026ldquo;Pieces.\u0026rdquo;\nIn the \u0026ldquo;Grid\u0026rdquo; scene, the \u0026ldquo;Grid\u0026rdquo; root node has a collision shape set up to detect overhang from the board, and this is a necessary group to distinguish collisions between pieces, since it is always in contact with all pieces.\nSprite node As mentioned above, the \u0026ldquo;Piece\u0026rdquo; is only the inheritance source (template), so in this scene, no resource is applied to the \u0026ldquo;Texture\u0026rdquo; property of the \u0026ldquo;Sprite\u0026rdquo; node and it is left as it is. The plan is to apply an image that matches the color of each piece in the inherited scene.\nIn the scene of each color piece inheriting this scene, we will apply the KENNEY image imported earlier to the \u0026ldquo;Texture\u0026rdquo; property, but since the size of the image is 70 px in height and width, let\u0026rsquo;s shift the center of the image to the upper right and set the \u0026ldquo;Offset\u0026rdquo; property so that the center of the image is shifted to the upper right and the lower left corner of the image fits (x: 0, y: 0).\nOffset:\nOffset: (x: 35, y: -35)\nThe grid of the board on which the piece is to be placed should count from left to right on the x-axis and from bottom to top on the y-axis, and the size of one grid on the board should be 70 px to match the size of the texture. If the lower left corner of the piece\u0026rsquo;s texture image is aligned with (x: 0, y: 0), then when the \u0026ldquo;Piece\u0026rdquo; root node is positioned (x: 0, y: 0) on the grid, the \u0026ldquo;Sprite\u0026rdquo; image will be aligned exactly with the grid.\nCollisionShape2D node The role of this node is to give the root node a collision shape. This node is needed to detect when a piece is touched by a finger, taken off a finger, or collides with a neighboring piece.\nIf the collision shape is perfectly aligned with the 70 px Sprite texture, the collision with the neighboring piece will be detected even if the piece is moved slightly.\nOn the other hand, if the collision shape is too small, the collision will not be detected even though the user intends to touch the piece with a finger, or when moving the piece, the collision between pieces will not be detected properly and the piece will pass between pieces.\nTherefore, it is best to make the collision shape half the size of the Sprite\u0026rsquo;s Texture. The position of the collision should be adjusted so that it overlaps the Sprite texture nicely.\nShape: Apply a new CircleShape2D resource CircleShape2D: Radius: 17.5\nTransform: Position: x: 35, y: -35\nOn the 2D workspace, it should have looked like this.\nTween node This node can animate only a single property of a given node. The reason for using this node in this case is to animate the movement of the pieces when they are swapped positions or when a piece is packed in the position of a piece that has been matched and disappeared.\nHowever, since the animation is implemented in a script, there is no need to edit the properties here.\nAttaching and editing a script to the Piece node Let\u0026rsquo;s attach a new script to the \u0026ldquo;Piece\u0026rdquo; root node. Create a script file with the file path \u0026ldquo;res://Pieces/Piece.gd\u0026rdquo;.\nEdit the script as follows.\n### Piece.gd ### extends Area2D # Signal to send out if the piece collides with a piece the player is moving # (pass the piece itself as an argument) signal collided(self_piece) # Property to set the color of the piece export (String) var color # Property that flags if a match occurs var matched = false # Index assigned to the group of matched pieces var matched_index = 0 # Property that will be a flag if the player is moving the piece var held = false # Offset equal to the texture of the piece var offset = Vector2(35, -35) # Reference to the Sprite node onready var sprite = $Sprite # Reference to a Tween node onready var tween = $Tween # Built-in method called every frame in the main loop func _process(_delta): # If the player is moving a piece if held: # Shift the position of the piece by (35, -35) to follow the mouse position = get_global_mouse_position() - offset # Method to move the piece func move(destination): # Set the animation of the tween node. # Move the piece from the current position to the argument destination in 0.1 seconds tween.interpolate_property(self, \u0026#34;position\u0026#34;, position, destination, .1, Tween.TRANS_QUINT, Tween.EASE_IN) # Start the animation of the tween node tween.start() # Method called when a piece is matched func make_matched(index): # Flag a match matched = true # Assign an index (argument index) for each matched group matched_index = index # Make the piece color translucent modulate = Color(1,1,1,.5) # Method called when a player\u0026#39;s finger touches a piece func enable_held(): # Set the flag that the player is moving the piece held = true # Make the color of the piece 20% transparent modulate = Color(1, 1, 1, 0.8) # Method called when the player removes his/her finger from the piece func disable_held(): # Disable the flag that the player is moving held = false # Restore the piece\u0026#39;s color to default modulate = Color(1, 1, 1, 1) The next step is to use signals of the Area2D class. After selecting the \u0026ldquo;Piece\u0026rdquo; root node in the scene dock, go to the Node dock \u0026gt; Signal tab and connect area_entered(area: Area2D) to the \u0026ldquo;Piece.gd\u0026rdquo; script that you are currently editing.\nWhen the piece the player is moving is hit, we want to send out a custom signal collided(self_piece), so let\u0026rsquo;s write the code for that in the auto-generated method _on_Piece_area_entered(area).\n### Piece.gd ### # Method called when Area2D is hit and a signal is sent out func _on_Piece_area_entered(area): # If the Area2D hit is a \u0026#34;Pieces\u0026#34; group (i.e. an instance of Piece)... # and if it is a Piece being moved by the player if area.is_in_group(\u0026#34;Pieces\u0026#34;) and area.held: # Send a signal collided with the piece itself as argument emit_signal(\u0026#34;collided\u0026#34;, self) This completes the editing of the \u0026ldquo;Piece.gd\u0026rdquo; script.\nCreating a scene for each color that inherits from the Piece scene Now that the \u0026ldquo;Piece\u0026rdquo; scene, which will serve as a template, is complete, let\u0026rsquo;s create a scene that inherits the \u0026ldquo;Piece\u0026rdquo; scene in the number of colors of the piece. There are five piece colors: beige, blue, green, pink, and yellow. First, let\u0026rsquo;s proceed with the procedure using the \u0026ldquo;beige\u0026rdquo; drop as an example.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Inherited Scene Select \u0026ldquo;Piece.tscn\u0026rdquo; as the source scene After the inherited scene is generated, rename the root node to \u0026ldquo;PieceBeige.\n*The name of this root node should match the color of each drop. Save the scene once. Save the scene with the file path \u0026ldquo;res://Pieces/PieceBeige.tscn\u0026rdquo;. With the root node \u0026ldquo;PieceBeige\u0026rdquo; selected in the scene dock, set the value of the \u0026ldquo;Color\u0026rdquo; property of \u0026ldquo;Script Variables\u0026rdquo; to \u0026ldquo;beige\u0026rdquo; in the inspector.\nSelect the \u0026ldquo;Sprite\u0026rdquo; node in the scene dock and apply the previously imported resource \u0026ldquo;res://Aliens/alienBeige_round.png\u0026rdquo; to the \u0026ldquo;Texture\u0026rdquo; property (you can drag it from the file system dock).\nOn the 2D workspace, it should now look like the following screenshot.\n! Sprite - Texture Region The \u0026ldquo;PieceBeige\u0026rdquo; scene is now complete. Follow the same procedure to create scenes for the remaining four colored pieces. Please refer to the following for details on the different parts of each scene. Blue piece. Root node name: PieceBlue Color property: blue Sprite \u0026gt; Texture property: res://Aliens/alienBlue_round.png File path when saving the scene: res://Pieces/PieceBlue.tscn Green piece. Root node name: PieceGreen Color property: green Sprite \u0026gt; Texture property: res://Aliens/alienGreen_round.png File path when saving the scene: res://Pieces/PieceGreen.tscn Pink piece. Root node name: PiecePink Color property: green Sprite \u0026gt; Texture property: res://Aliens/alienPink_round.png File path when saving the scene: res://Pieces/PiecePink.tscn Yellow piece. Root node name: PieceYellow Color property: yellow Sprite \u0026gt; Texture property: res://Aliens/alienYellow_round.png File path when saving the scene: res://Pieces/PieceYellow.tscn When the inherited scene of all 5 colored pieces has been created, the work is complete.\nControlling a Grid scene with scripts From here on, we will code scripts to control the game. The amount of code is rather large, so do your best.\nAfter switching to the \u0026ldquo;Grid.tscn\u0026rdquo; scene in the Godot editor, attach a new script to the \u0026ldquo;Grid\u0026rdquo; root node. The file path should be \u0026ldquo;res://Grid/Grid.gd\u0026rdquo;.\nIn the comments in the script, \u0026ldquo;finger touched\u0026rdquo; or \u0026ldquo;finger released\u0026rdquo; should be replaced with \u0026ldquo;left mouse button pressed\u0026rdquo; or \u0026ldquo;left mouse button released\u0026rdquo; on the Godot debug panel.\nAlso, please note that \u0026ldquo;match\u0026rdquo; is defined as three or more of the same color.\nNow, once the script editor is open, let\u0026rsquo;s define the necessary properties.\n### Grid.gd ### extends Area2D # Signal sent out at the start of automatic matching process signal waiting_started # Array with scene files for each color piece as elements const pieces_scn = [ preload(\u0026#34;res://Pieces/PieceBeige.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceBlue.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceGreen.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PiecePink.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceYellow.tscn\u0026#34;) ] # Number of grids in x-axis var width: = 7 # Number of grids in y-axis var height: = 6 # Grid start position in x-axis direction (pixels) var x_start: = 70 # Grid start position in y-axis direction (pixel) var y_start: = 1050 # Size of one grid (should be the same as Texture of Sprite in Piece) var grid_size: = 70 # How many grid y-axis displacements to drop when the Piece is generated var y_offset: = 3 # Array representing the placement of the pieces on the board (two-dimensional array) var board = []. # Reference to the piece the player is moving var moving_piece # Last grid position of the piece the player is moving var last_pos = Vector2() # Flag for preparing at the start of the game var is_initializing = true # Flag if the player is moving the piece var is_touching = false # Flag if the player is swapping pieces var is_swapping = false # Flag during automatic match processing after the player moves the piece var is_waiting = false # Number of groups of matched pieces (to be counted up) var matched_groups = 0 # Reference to the PiecesContainer node onready var pieces_container = $PiecesContainer # Reference to the TouchTimer node onready var touch_timer = $TouchTimer # Reference the WaitTimer node onready var wait_timer = $WaitTimer Then from here on, we will be adding methods. Note that the two-dimensional array that appears in the following code is an array that stores arrays as elements, that is, an array of arrays.\nIn the case of the two-dimensional array used in this script, the first level of the array contains as many empty arrays as the number of grids in the x-axis direction of the board, and the second level of the array contains as many elements as the number of grids in the vertical direction within each array. By storing piece objects as its elements, we can manage where each piece is located on the board (how many grids in the x-axis direction and how many grids in the y-axis direction).\n### Grid.gd ### # Function called when scene is loaded func _ready(): # Call a built-in function to randomize the output result of a function that generates a random number each time randomize() # Make the board (array) into a 2d array that makes up the grid of the board board = make_2d_array() # define after this # Spawn the pieces and place them on the board and reflect the board information on the board spawn_pieces() # define after this is_initializing = false # Method to create a 2d array that makes up the grid of the board func make_2d_array() -\u0026gt; Array: # Prepare an array named array var array = [] # Fill array with an empty array with the number of grids along the x-axis for i in width: array.append([]) # Append null to each array for the number of grids along the y-axis for j in height: array[i].append(null) # Return the resulting two-dimensional array return array # Method to spawn pieces, place them on the board, and reflect the board information to the board func spawn_pieces(): # Loop for the number of grids along the x-axis for i in width: # Loop over the number of grids along the y-axis for j in height: # If no piece exists in the corresponding grid on the 2D array of all pieces # (all are null at the start of the game) if board[i][j] == null: # Select one piece at random from the scene of pieces of each color and instantiate it var index = floor(rand_range(0, pieces_scn.size())) var piece = pieces_scn[index].instance() # If the game is being prepared at the start if is_initializing: # If a match has occurred, delete the piece instance and start over while match_at(i, j, piece.color): # define after this piece.queue_free() index = floor(rand_range(0, pieces_scn.size())) piece = pieces_scn[index].instance() # Make a piece instance a child of a PiecesContainer node pieces_container.add_child(piece) # Collided signal for a piece instance... # connect to the _on_Piece_collided method (defined later) piece.connect(\u0026#34;collided\u0026#34;, self, \u0026#34;_on_Piece_collided\u0026#34;) # Place the piece instance y_offset from the placement position... # move the piece instance to the placement position from there (drop it) piece.position = grid_to_pixel(i, j + y_offset) # define after this piece.move(grid_to_pixel(i, j)) # defined after this # Add the generated piece to the element at the appropriate index of the board as board information board[i][j] = piece Let\u0026rsquo;s define the undefined match_at and grid_to_pixel methods in the above code.\n### Grid.gd ### # Method to check if 3 or more pieces of the same color are lined up at the specified grid position # Arguments column is the x-axis grid position, the row is the y-axis grid position, and color is the color of the piece func match_at(column, row, color): # If the x-axis position of the given grid is greater than or equal to 3 if column \u0026gt;= 2: # If there is a piece to the left of the specified grid position and one more to the left if board[column-1][row] ! = null \\ and board[column-2][row] ! = null: # If the left neighbor and another left neighbor have the same color as the specified piece if board[column-1][row].color == color \\ and board[column-2][row].color == color: # Return true return true # If y-axis position of the specified grid is 3 or more if row \u0026gt;= 2: # If there are pieces below the specified grid position and one more below if board[column][row-1] ! = null \\ and board[column][row-2] ! = null: # If the color of the piece below and one more piece below is the same as the color of the specified piece if board[column][row-1].color == color \\ and board[column][row-2].color == color: # Return true return true # Method to convert grid position to pixel position func grid_to_pixel(column, row) -\u0026gt; Vector2: # Define a variable of type Vector2 for pixel position output var pixel_pos = Vector2() # Pixel x-coordinate = grid start position along x-axis + grid size * grid x-coordinate pixel_pos.x = x_start + grid_size * column # Pixel y-coordinate = grid start position along y-axis - grid size x grid y-coordinate pixel_pos.y = y_start - grid_size * row # Return pixel coordinates return pixel_pos Now the pieces of each color should be randomly arranged on the board at the start of the game. Let\u0026rsquo;s run the project once to check it out. When you run the project for the first time, a dialog box for selecting the main scene will appear, so select \u0026ldquo;Grid.tscn\u0026rdquo; as the main scene.\nSince we just defined the grid_to_pixel method, let\u0026rsquo;s define the pixel_to_grid method for later use. As the name suggests, this method is the opposite of grid_to_pixel defined earlier and converts pixel positions to grid positions.\n### Grid.gd ### # Method to convert a pixel position to a grid position func pixel_to_grid(pixel_x, pixel_y) -\u0026gt; Vector2: var grid_pos = Vector2() grid_pos.x = floor((pixel_x - x_start) / grid_size) grid_pos.y = floor((pixel_y - y_start) / -grid_size) return grid_pos In addition, we define one more method is_in_grid to be used later. This method determines whether the position passed as an argument is within the range of the board grid and returns the result.\n### Grid.gd ### # Method that returns whether the specified position is within the grid of the board func is_in_grid(grid_position: Vector2) -\u0026gt; bool: if grid_position.x \u0026gt;= 0 and grid_position.x \u0026lt; width \\ and grid_position.y \u0026gt;= 0 and grid_position.y \u0026lt; height: # Return true if within the grid of the board return true else: # Return false if out of range of the board grid return false From this point on, we will write a program to process the game player\u0026rsquo;s input (screen touch operation).\n### Grid.gd ### # Function called every frame in the main loop of the game func _process(_delta): # if not in the process of matching if not is_waiting: # call a method to process the player\u0026#39;s input touch_input() # defined after this # Method for handling player input func touch_input(): # If a finger touches the screen if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # Call a method to perform processing when a piece is touched touch_piece() # defined after this # If the finger leaves the screen if Input.is_action_just_released(\u0026#34;touch\u0026#34;) and is_touching: # Call the method that executes the action when the finger leaves the piece release_piece() # defined after this # Methods to execute when a piece is touched func touch_piece(): # Get the pixel coordinates of the piece when a finger touches it var pos = get_global_mouse_position() # Convert from pixel coordinates to grid coordinates var grid_pos = pixel_to_grid(pos.x, pos.y) # If grid coordinates are within the board if is_in_grid(grid_pos): # Register the grid coordinates as the last position of the piece being moved last_pos = grid_pos # register the piece at grid coordinates as the moving piece moving_piece = board[last_pos.x][last_pos.y] # Flag the piece as moving is_touching = true # Also flag the moving piece instance itself as moving moving_piece.enable_held() # Start a timer to limit the time the piece can be moved touch_timer.start() # Method to execute when the finger leaves the piece func release_piece(): # If we find a piece we were moving among the elements of the two-dimensional array board... # Fit the moved piece exactly on the board grid for i in width: for j in height: if board[i][j] == moving_piece: moving_piece.move(grid_to_pixel(i, j)) break # Disable the moving flag of the moving piece instance itself moving_piece.disable_held() # Disable the moving flag of the moving piece is_touching = false # Stop the timer for the time limit for moving the piece touch_timer.stop() # Signal the start of automatic matching process after this emit_signal(\u0026#34;waiting_started\u0026#34;) Although we have not yet implemented the exchange of pieces, the coding up to this point should have implemented the movement of a piece that is touched by a finger, and when the finger is released, the piece that is being moved will settle exactly where it was last. Let\u0026rsquo;s run the project and check it out.\nThe next method we will define, _on_Piece_collided, has already been coded to connect a collided signal when the Piece instance is created. Recall that we coded this signal in the \u0026ldquo;Piece.gd\u0026rdquo; script to be sent out when a piece is hit by a piece being moved by the player.\nLet\u0026rsquo;s define a method to swap the location of the moving piece and the piece that hit it, and call it in _on_Piece_collided.\n### Grid.gd ### # Method called on collided signal of a Piece instance func _on_Piece_collided(self_piece): # If the piece is moving and not in the process of swapping pieces if is_touching and not is_swapping: # Flag the piece is being swapped is_swapping = true # Call a method to swap pieces swap_pieces(self_piece) # define later # Remove the flag that a piece is being swapped is_swapping = false # Method to swap the location of the piece being moved and the piece that hit it # The collided_piece argument is passed the piece that hit the piece being moved func swap_pieces(collided_piece): # Get the grid coordinates of the piece that hit it. var collided_pos = pixel_to_grid(collided_piece.position.x, collided_piece.position.y) # If the piece being moved on the two-dimensional array board matches the piece being moved if board[last_pos.x][last_pos.y] == moving_piece: # Put the piece that hit the position of the moving piece on the board board[last_pos.x][last_pos.y] = collided_piece # Move the hit piece to the last grid coordinate of the piece being moved collided_piece.move(grid_to_pixel(last_pos.x, last_pos.y)) # Put the piece being moved into the position of the hit piece on the board board[collided_pos.x][collided_pos.y] = moving_piece # Register the grid coordinates of the hit piece as the last position of the moving piece last_pos = collided_pos Now you should be able to implement the exchange of pieces. Let\u0026rsquo;s actually run the project and move the pieces. Let\u0026rsquo;s see how the pieces of the route are exchanged one after another.\nNow, at this point, there are two problems.\nBeing able to move freely outside of the board. Being able to grab the piece forever. These problems can be solved using signals.\nLet\u0026rsquo;s connect the signals of the \u0026ldquo;Grid\u0026rdquo; root node of the Area2D class to the script. Remember how we adjusted the collision shape to the size of the board? The signal that is sent out when the finger (the piece that is being moved) goes out of that area will cause the release_piece method to be called so that the piece that was being moved will also go away from the finger and return to its last position on the board.\nSelect the \u0026ldquo;Grid\u0026rdquo; root node in the Scene dock, select Node dock \u0026gt; Signals tab, and connect the erea_exited signal to this script.\nAnother signal that is sent out when the time limit for moving the piece in the \u0026ldquo;TouchTimer\u0026rdquo; node times out is also connected to the script. In this case, the release_piece method should be called by the signal as well. Let\u0026rsquo;s connect the timeout signal.\nContinuing on, let\u0026rsquo;s edit the methods generated by the connection of each signal as follows.\n### Grid.gd ### # Method called with a signal when Area2D is out of the board func _on_Grid_area_exited(area): # If the area2D that has been moved out of the grid is a piece that is being moved if area.is_in_group(\u0026#34;Pieces\u0026#34;) and area.held: # Call the method that handles when the finger leaves the piece release_piece() # Method called with a signal when the time limit for moving a piece expires func _on_TouchTimer_timeout(): # if the piece is moving if is_touching: # call a method that will do something when the finger leaves the piece release_piece() Now, if the piece is out of the board, the piece should now leave your finger and return to its last position on the board. Also, if you grabbed the piece for more than 5 seconds, the timer should now cause the piece to leave your finger and return to the last grid coordinate on the board.\nNow let\u0026rsquo;s actually run the project and see how it works.\nFrom here, we will create a program to automatically process the matched pieces. At the end of the release_piece method, we used the code emit_signal(\u0026quot;waiting_started\u0026quot;) to send out a waiting_started signal, and we will start by connecting this signal to the script.\nSelect the \u0026ldquo;Grid\u0026rdquo; root node in Scene dock and connect the waiting_started signal to the script in the Node dock \u0026gt; Signals tab. Once the _on_Grid_waiting_started method is added to the script, we will write the automatic processing of the matched piece in the method. Roughly speaking, the automatic process is as follows.\nSet the flag for automatic matching process in progress. Check if there is at least one matched piece; if there is at least one, loop through the following process. Check all pieces and flag matched pieces. Delete the flagged piece. Fill the empty space by moving a piece from the grid above in the same row or column. After the pieces are moved down, a new piece is created in the empty space at the end. When there are no more matched pieces, the automatic processing flag is cleared.\nLet\u0026rsquo;s implement the above process step by step. Let\u0026rsquo;s start with the \u0026ldquo;check all the pieces and flag the matching pieces\u0026rdquo; part.\n### Grid.gd ### # Method called with a signal sent out at the end of the release method func _on_Grid_waiting_started(): # Set a flag that automatic Matching processing is in progress. is_waiting = true # Keep looping if there is at least one matched piece in a group of people while check_matches(): # define after this # Call method to flag matched pieces find_matches(): # define after this # Start WaitTimer timer (0.3 seconds) wait_timer.start() # Wait until WaitTimer times out yield(wait_timer, \u0026#34;timeout\u0026#34;) # Clear the flag during automatic processing is_waiting = false # Method to check if there is at least one pair of matched pieces func check_matches() -\u0026gt; bool: # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of grids in y-axis of the board for j in height: # If a piece exists at that grid coordinate if board[i][j] != null: # If the piece is matched if match_at(i, j, board[i][j].color): # Return true return true # Return false if none of the pieces match return false # Method to flag matched pieces func find_matches(): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of grids in y-axis of the board for j in height: # If a piece exists at that grid coordinate if board[i][j] != null: # Define current color as the color of the piece at that grid coordinate var current_color = board[i][j].color # If its x-axis coordinates are less than the number of grids along the x-axis - 2 if i \u0026lt; width - 2: # If there are pieces to the right of that piece and further to its right if board[i+1][j] != null \\ and board[i+2][j] != null: # If the color of those pieces is the same as the current color if board[i+1][j].color == current_color \\ and board[i+2][j].color == current_color: # Define a variable for the index to assign to the matched pairs var matched_index: int # If the piece is already flagged as matched if board[i][j].matched: # Index should be the same as the index information the piece has matched_index = board[i][j].matched_index # If the piece is not flagged as matched else: # Increment the number of groups in the matched pair matched_groups += 1 # Set the index to the number of groups in the matched pairs matched_index = matched_groups # Flag the piece at those coordinates as matched, assign an index, and make it translucent board[i][j].make_matched(matched_index) # Do the same for the piece to the right of those coordinates board[i+1][j].make_matched(matched_index) # Do the same for the piece one more place to the right board[i+2][j].make_matched(matched_index) # Do the same for the y-axis direction if j \u0026lt; height - 2: if board[i][j+1] != null \\f} and board[i][j+2] != null: if board[i][j+1].color == current_color \\ and board[i][j+2].color == current_color var matched_index: int if board[i][j].matched: matched_index = board[i][j].matched_index else: matched_groups += 1 matched_index = matched_groups board[i][j].make_matched(matched_index) board[i][j+1].make_matched(matched_index) board[i][j+2].make_matched(matched_index) Of the processing of the matched pieces, we have implemented the flagging of the matched pieces. Let's run the project and see if the matched pieces become translucent. The next step is to define a method to delete pieces that are flagged for match status.\n### Grid.gd ### # Method to delete a piece that is flagged as a match # The argument index is the index of the match pair to delete func delete_matches(index): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of grids in the y-axis of the board for j in height: # If a piece exists at that grid coordinate if board[i][j] != null: # If the piece at that grid coordinate is flagged as a match if board[i][j].matched: # If the pair number of the piece at that grid coordinate matches the pair number of the piece to be deleted if board[i][j].matched_index == index: # Release the piece at those grid coordinates board[i][j].queue_free() # Set the corresponding element of the two-dimensional array board to null board[i][j] = null Now that we have defined the delete_matches method, let\u0026rsquo;s put it in the loop of the _on_Grid_waiting_started method.\n### Grid.gd ### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) # Add here # If the number of matched groups is greater than 0 if matched_groups \u0026gt; 0: # Loop over matched groups # Don\u0026#39;t delete all of them at the same time, delete each matched group for index in range(1, matched_groups + 1): # Call method to delete matched pieces delete_matches(index) # Start WaitTimer timer (0.3 seconds) wait_timer.start() # Wait until WaitTimer times out yield(wait_timer, \u0026#34;timeout\u0026#34;) # Set the number of matched groups back to 0 after all matched pieces are removed matched_groups = 0 is_waiting = false We should now be able to implement the matching piece to the point where it becomes translucent and then deleted. Let's run the project and check it out. Next, we will implement the process of filling (dropping) the top piece into the grid space vacated by the removed piece. Let\u0026rsquo;s start by defining the method.\n### Grid.gd ### # Method to collapse (drop) the top piece into the empty grid space func collapse_columns(): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of y-axis grids in the board for j in height: # If there is no piece at that grid coordinate if board[i][j] == null: # Loop over the remaining y-axis grids starting from the grid one above that y-coordinate for k in range(j + 1, height): # If the piece exists at that grid coordinate if board[i][k] ! = null: # Move the piece at that grid coordinate to an empty space board[i][k].move(grid_to_pixel(i, j)) # Replace the elements of the two-dimensional array board board[i][j] = board[i][k]. board[i][k] = null # End of loop break Now that we have defined the collapse_columns method, let\u0026rsquo;s add it to the loop of the _on_Grid_waiting_started method.\n### Grid.gd ### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) if matched_groups \u0026gt; 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) matched_groups = 0 # Add here # Call the method to collapse (drop) the top piece into the empty grid space collapse_columns() # Start timer for WaitTimer (0.3 seconds) wait_timer.start() # Wait until WaitTimer times out yield(wait_timer, \u0026#34;timeout\u0026#34;) is_waiting = false Now, after the matched and translucent piece is removed, the top piece should now be collapsed (dropped) into that empty space. Let\u0026rsquo;s run the project and check it out.\nFinally, after the piece is dropped down, the empty space above it needs to be refilled with a new piece. The method for this is the already defined spawn_pieces method, which is also executed in the _ready function. When the game play starts, the is_initializing property is false, so the block in this method that re-generates the piece if it matches is skipped. In other words, a new match may already occur when the piece is generated by executing this method. This should generate more combos than expected and make the game experience more pleasant and fun.\nLet\u0026rsquo;s add the spawn_pieces method inside the loop of the _on_Grid_waiting_started method.\n### Grid.gd ### func _on_Grid_waiting_started(): is_waiting = true while check_matches(): find_matches() wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) if matched_groups \u0026gt; 0: for index in range(1, matched_groups + 1): delete_matches(index) wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) matched_groups = 0 collapse_columns() wait_timer.start() yield(wait_timer, \u0026#34;timeout\u0026#34;) # Add here. # call a method to spawn pieces in the empty space spawn_pieces() # Start WaitTimer timer (0.3 seconds) wait_timer.start() # Wait until WaitTimer times out yield(wait_timer, \u0026#34;timeout\u0026#34;) is_waiting = false This completes the coding of the match process. This is the end of the work for this tutorial as well. Let\u0026rsquo;s finish up by running the project to make sure this puzzle game is working properly.\nSample game I have prepared a sample game that is a further brushed-up version of the project created in this tutorial.\nYour browser does not support the video tag. The project file of the sample game is located in GitHub repository . Please download the .zip file from there and import the \u0026quot; project.godot\u0026rdquo; file in the \u0026ldquo;Sample\u0026rdquo; folder and import it into Godot Engine.\nGame Rules:\nThe player can move a piece for up to 5 seconds at a time; after 5 seconds, the piece leaves his/her finger. If the piece the player is moving goes out of the board, the piece leaves his/her finger and moves only that far. The number of combos goes up by the number of matched pairs of pieces. The player can attack aliens (enemy characters) by the number of combos, and their power is also increased. Attacking an alien reduces its HP by the amount of its power, and when the alien\u0026rsquo;s HP is reduced to 0, it can be defeated. Aliens attack players at regular intervals. The player has a maximum of 10 lives, which is reduced by one when the alien attacks, and the game is over when the player is attacked 10 times. Each time an enemy is defeated, the player\u0026rsquo;s level increases by one. The player\u0026rsquo;s power increases slightly as the level increases, while the enemy characters also increase their HP and attack at slightly shorter intervals. The enemy\u0026rsquo;s time gauge pauses during the automatic processing of matched pieces (during combo counting and attacking the enemy) after the player moves a piece and releases his finger. Ultimately, the number of aliens defeated is the game\u0026rsquo;s score. Conclusion In this tutorial, I created a puzzle game in the style of Puzzle and Dragons, which I call an evolutionary Match-3 puzzle game. Unlike the standard Match-3 game, we made the pieces move freely on the board for a certain period of time, and also made each matched piece disappear in turn, just like in Puzzle and Dragons. I hope you were able to make it through to the end.\nLet me summarize the key points when creating an advanced match-3 puzzle game like this one.\nAt a minimum, you need only two scenes: the board and the pieces. Create a template piece scene and then inherit it to create a piece scene for each color. Use a two-dimensional array to manage the pieces to be placed on the board grid. Use Area2D signals to detect the following When a finger touches a piece When a finger leaves a piece When a moving piece hits a stationary piece When a moving piece moves out of the board. Provide properties for flags to manage the state of the piece. For example Whether a piece is being moved or not whether a piece is being replaced or not whether a piece is being matched or not Whether the matched piece is being automatically processed or not When a piece is being swapped, the position of the piece on the screen and the elements of the two-dimensional array must be updated, respectively. Links KidsCanCode: OBJECT HEALTHBARS KidsCanCode: HEART CONTAINERS: 3 WAYS App Store: Puzzle＆Dragons Google Play:Puzzle＆Dragons ","permalink":"https://www.peanuts-code.com/en/tutorials/gd0013_advanced_match3/","summary":"In this tutorial, we will create an advanced match-3 puzzle game, a type of puzzle game in which one piece is moved freely on the board for a certain period of time to erase three or more pieces of the same color in a row.\nThis is easy to understand if you imagine a puzzle game like \u0026ldquo;Puzzle \u0026amp; Dragons\u0026rdquo; (a.k.a. \u0026ldquo;Puzzle Dora\u0026rdquo;), which has gained popularity as a mobile game.\nHowever, the tutorial would be too large if it included all game elements such as decks, gacha, and battles with enemy characters, so we will focus on the puzzle part of the tutorial this time.","title":"Advanced match 3 puzzle game in Godot"},{"content":"When one has taken the trouble to start a personal game development project, one would like to continue it for a long and enjoyable time if possible. However, in general, game development tends to be frustrating. Let us first consider the reasons for this.\nReasons for frustration First, game development is hard work. It is sometimes referred to as a comprehensive art form. In other words, a game is a work of art that combines music, images, characters, scenarios, systems, level design, and everything else into one. There is no way it is easy. It is so difficult that it is easy to fall behind in the process.\nHowever, there is another problem that is even bigger, especially for adults who are making games as independent developers. That is the fact that you can\u0026rsquo;t make money by developing games. If there is no money to be made, they quit this hard work. Game development is hard work, but it pays off when the game sells.\nThe word \u0026ldquo;no money\u0026rdquo; may be a bit of a generalization, because there are always people who are making money. There are only a handful of people who make money, and the rest are mostly people who do not make money.\nThis is generally true in the fields of entertainment and the arts. For example, music, illustrations, and novels are all difficult to make money for. It is not the case that if you work at it long enough, you will be able to earn money. In addition, you have to be very calculating, understand what the public wants, and create something fresh while aiming for that. It is also essential to advertise your work so that as many people as possible will know about it.\nWhether it is games, music, illustrations, or novels, most people who love to enjoy these forms of entertainment start creating them with the hope that one day they, too, will create a great work of art that will move people. They are exposed to so many great works that they think they have a good understanding of what makes an interesting game, and they feel as if they have the power to create such a work of art. Therefore, when a game that they think is a masterpiece fails to sell well, or when they fail to create a game that they think is a masterpiece in the first place, they become frustrated and say, \u0026ldquo;This is not how it was supposed to be.\nWhat drives people to develop games in this way is a kind of desire for self-expression and approval, and it is precisely this impulse that drives them.\nThe situation in which new games are created but do not become a hit must amplify the somewhat selfish frustration of wondering why the world does not see the merit of one\u0026rsquo;s work, and the vague anxiety that one does not have the talent to create a good game. Without satisfying their desire for self-expression and approval, they may end up frustrated because they cannot bear these negative feelings.\nIt does not matter if the trigger is an impulse; when starting something, such a strong impact is rather necessary. But on the other hand, in order to continue something for a long time, apart from such passionate feelings, you need to have a head that understands things calmly and logically.\n3 Things to Understand to Avoid Setbacks So how can we avoid the negative emotions mentioned above? To do so, simply understand the following three things.\nThe world does not know my work. I have no talent. Failure is the source of success.\n1. Understanding that the world does not know your work First of all, it is very important to accept the obvious fact that the world does not know your work. For example, major sales platforms such as Steam, the App Store, and Google Play are filled with countless games, and many new games are being added every day. Among them, of course, are series and derivatives of very popular games, as well as new games from popular game makers. It is easy to imagine that few people will find your work without any information in such a red ocean.\nTherefore, the title, description, and screenshots displayed on the sales platform are quite important, and the promotional activities to let people know about them are even more important. This area of work may not be fun, but if it is well researched and practiced, it will certainly be reflected in the results compared to doing nothing.\nAnyway, the key to success is to acknowledge the fact that \u0026ldquo;the public doesn\u0026rsquo;t know about your work,\u0026rdquo; and then think about what to do about it and take concrete action. It is complete nonsense to think that \u0026ldquo;the world does not realize the excellence of my work\u0026rdquo; when you have done nothing to make it sell.\n2. Understanding that you have no talent Next, the understanding that one has no talent is also important. The problem is that we believe in something like a God-given gift called \u0026ldquo;talent,\u0026rdquo; which we do not know if we really have. They judge whether they have talent or not by comparing themselves with others and others\u0026rsquo; works, and based on the results, they decide whether to continue or quit. No one has talent from the beginning. There may be some innate advantages of the brain and body, but how many people are able to recognize those advantages in their lives? Until the time comes when genetic analysis becomes commonplace, we are much more certain of what we like or dislike, what we want to do or don\u0026rsquo;t want to do, rather than such things.\nFor example, if you were asked to think of a talented professional athlete or a professional musician, you would probably be able to picture several faces. Then, if you ask me if those people were able to achieve results and become famous without any effort, that would be different. Talent is, in fact, a matter of consequence. Everyone tends to think that people who achieve outstanding results have talent. However, such people must have invested more time than anyone else in improving their skills and acquiring knowledge in the process of achieving results. The use of that time should also be balanced between input and output. And rather than comparing themselves with others, they should be comparing themselves with their past selves, keeping their motivation high, and constantly striving to improve their skills through ingenuity.\nIn fact, continually making comparisons with past selves rather than with others creates a very good cycle. Especially in the beginning of game development, there are many things you can do, so you are certainly more skilled today than you were yesterday. Then you start to think, \u0026ldquo;Maybe I am suited for game development\u0026rdquo;. Your mood becomes more and more enjoyable and you start to think, \u0026ldquo;I like game development\u0026rdquo;. Then You want to be able to do more. Then you invest more time and become better than you were yesterday. This cycle allows you to invest more and more time. After six months or a year, before you know it, you have become quite proficient in game development skills. Perhaps the day will come when someone will say, \u0026ldquo;You have talent\u0026rdquo;.\nImproving your skills will not guarantee that your game will sell, but you will certainly be able to make an interesting game. Whether a game sells or not is sometimes a matter of luck. For example, if a well-known person happens to buy your game and it is interesting, he or she may spread the word on social media. However, if the game is not interesting, there is no chance of even that.\n3. Understanding that failure is the source of success \u0026ldquo;Failure is the source of success\u0026rdquo; is an overused phrase, but this understanding is crucial. If you fail, you may feel depressed by the fact. If the game you worked so hard on does not sell at all, you will certainly be shocked. However, we must not forget that looking at the facts calmly at this point will lead to the next success.\nThe reason why you feel depressed when a game does not sell is because you thought the game was perfect. There is no such thing as perfect, and there are definitely reasons why a game did not sell well. We can clarify those reasons and clear them up in the next production. For example, if the game was simply not well advertised after it was launched, then the next game should be better advertised. If the quality of the graphics was low, then you can improve the quality of the graphics. You can improve your own skills, or you can spend money to have someone else make them.\nThe quickest way to find out what was not good enough is to refer to reviews on sales platforms or do an ego search of the work on social media. Take their opinions seriously and apply them the next time. If there are no reviews at all to begin with, then it\u0026rsquo;s safe to assume that it wasn\u0026rsquo;t promoted well enough.\nConclusion If you only compare yourself with your past and maintain high motivation, you will be able to enjoy even the hardest development work and bring your game to completion. Once completed, you can sell the game. If you sell the game and promote it well, you can increase your earning potential. Even if the first game does not sell well, research the reasons why it did not sell well and make use of them in the next game. If you continue this cycle, the game will surely become better and sell more. The more the game sells, the more the hard work of development will be rewarded, and the likelihood of failure will decrease in inverse proportion.\nI would like to make one final point. Even if the development work is hard, even if the game doesn\u0026rsquo;t sell and you don\u0026rsquo;t make any money, if you enjoy it and there is nothing else you want to do, then do it. There is no other creative and enjoyable activity like it.\n","permalink":"https://www.peanuts-code.com/en/posts/post0003_how_to_avoid_frustration/","summary":"When one has taken the trouble to start a personal game development project, one would like to continue it for a long and enjoyable time if possible. However, in general, game development tends to be frustrating. Let us first consider the reasons for this. Reasons for frustration First, game development is hard work. It is sometimes referred to as a comprehensive art form. In other words, a game is a work of art that combines music, images, characters, scenarios, systems, level design, and everything else into one. There is no way it is easy. It is so difficult that it","title":"How to avoid frustration of game development"},{"content":"In this tutorial, we will create a match 3 puzzle game. Match 3 is a puzzle game in which players move multiple colorful pieces evenly arranged along a grid on the board to eliminate three or more pieces of the same color in a row. This genre is particularly popular among mobile game players because it is easy to operate and enjoyable.\nCandy Crush, Toon Blast, and Royal Match are just a few examples of popular games. Puzzle \u0026amp; Dragons and LINE Tsum Tsum are also based on Match 3, although the controls are slightly different. In this tutorial, we will create a puzzle like Candy Crush, in which the pieces are moved only one square at a time to match colors. If you want to make a game like \u0026ldquo;LINE tsum tsum\u0026rdquo;, check another tutorial, \u0026ldquo;Connecting matching colors puzzle game in Godot \u0026rdquo;.\nThe final project file for this tutorial is located at GitHub repository . If you download the .zip file and import the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;End\u0026rdquo; folder with the Godot Engine, you can check the project directly.\nEnvironment This tutorial was created in the following environment\n・Godot version: 3.4.4\n・Computer OS version: macOS 11.6.5\nMemo: Please also use the following articles to help you start creating your game.\nDownloading Godot Project Manager of Godot Creating a new project Start Godot Engine and create a new project. You can name your project as you like. If you can\u0026rsquo;t think of one, let\u0026rsquo;s call it \u0026ldquo;Match3 Start\u0026rdquo;.\nUpdating project settings When the editor appears, let\u0026rsquo;s go ahead and update project settings for the entire project.\nFirst, set the display size for the game. In this case, we will assume a smartphone screen in portrait orientation and set the aspect ratio to 16 : 9.\nOpen the \u0026ldquo;Project\u0026rdquo; menu \u0026gt; \u0026ldquo;Project Settings\u0026rdquo;. In the \u0026ldquo;General\u0026rdquo; tab, search for \u0026ldquo;window\u0026rdquo; and select \u0026ldquo;Display\u0026rdquo; \u0026gt; \u0026ldquo;Window\u0026rdquo; in the sidebar. In the \u0026ldquo;Size\u0026rdquo; section, change the values of the following items Width: 630 Height: 1120 Test Width: 315 Test Height: 560\nIn the \u0026ldquo;Stretch\u0026rdquo; section, change the values of the following items Mode: 2d Aspect: keep\nWith the \u0026ldquo;Project Settings\u0026rdquo; window open as it is, configures the settings to substitute the mouse for the phone\u0026rsquo;s touch operation in the debug panel.\nSearch for \u0026ldquo;mouse\u0026rdquo; in the \u0026ldquo;General\u0026rdquo; tab and select \u0026ldquo;Input Devices\u0026rdquo; \u0026gt; \u0026ldquo;Pointing\u0026rdquo; in the sidebar. Check \u0026ldquo;On\u0026rdquo; for \u0026ldquo;Emulate Touch From Mouse\u0026rdquo;.\nIn addition, with the \u0026ldquo;Project Settings\u0026rdquo; window open, add an action to the input map corresponding to a smartphone touch operation.\nSwitch to the \u0026ldquo;Input Map\u0026rdquo; tab and add \u0026ldquo;touch\u0026rdquo; to the action. Add a left mouse click to the \u0026ldquo;touch\u0026rdquo; action.\nDownloading and importing assets Next, let\u0026rsquo;s download assets from KENNEY\u0026rsquo;s site and use them. This time, we will use an asset pack called \u0026ldquo;Physics Assets \u0026rdquo;. I\u0026rsquo;m going to use the cute alien face images in this asset pack as textures for the pieces on the game board. I can\u0026rsquo;t help but be thankful for this wonderful free resource.\nAfter downloading, delete the images in the \u0026ldquo;/physicspack/PNG/Aliens\u0026rdquo; folder, leaving only the one with the file name \u0026ldquo;~_round.png\u0026rdquo; and drag the \u0026ldquo;Aliens\u0026rdquo; folder into the file system dock of the editor to import it into your project.\nCreating a Grid scene First, let\u0026rsquo;s create a \u0026ldquo;Grid\u0026rdquo; scene as the board on which the pieces are placed in a match 3 puzzle game.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;2D Scene\u0026rdquo; in \u0026ldquo;Generate Root Node\u0026rdquo;. When the root node of the \u0026ldquo;Node2D\u0026rdquo; class is generated, rename it to \u0026ldquo;Grid\u0026rdquo;. Save the scene. Create a folder and save the scene with the file path \u0026ldquo;res://Grid/Grid.tscn\u0026rdquo;.\nAdding a node to the Grid scene Let\u0026rsquo;s add another child node of class \u0026ldquo;Node2D\u0026rdquo; to the \u0026ldquo;Grid\u0026rdquo; root node and rename it to \u0026ldquo;PiecesContainer\u0026rdquo;. This node is used to organize the pieces placed on the board. During the game, when instances of the pieces are created by the script, they will all be added as children of this \u0026ldquo;PiecesContainer\u0026rdquo; node.\nThe scene tree dock should now look like the following.\nNote that there is no need to edit the properties of the \u0026ldquo;Grid\u0026rdquo; scene node.\nTranslated with www.DeepL.com/Translator (free version)\nCreating a Piece scene Next, create a \u0026ldquo;Piece\u0026rdquo; scene for the pieces to be placed on the board. However, this \u0026ldquo;Piece\u0026rdquo; scene is only a blueprint, and the actual pieces of each color to be used in the game will be prepared later by inheriting this \u0026ldquo;Piece\u0026rdquo; scene.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;2D Scene\u0026rdquo; in the \u0026ldquo;Create Root Node\u0026rdquo; section. When the root node of \u0026ldquo;Node2D\u0026rdquo; class is generated, rename it to \u0026ldquo;Piece\u0026rdquo;. Save the scene. Create a folder and save the scene with the file path \u0026ldquo;res://Pieces/Piece.tscn\u0026rdquo;.\nAdding a child node to the Piece node Let\u0026rsquo;s add a child node of class \u0026ldquo;Sprite\u0026rdquo; to the \u0026ldquo;Piece\u0026rdquo; root node. The scene tree dock should now look like the following.\nEditing the properties of the Sprite node Let\u0026rsquo;s edit a few properties of the \u0026ldquo;Sprite\u0026rdquo; node. As mentioned above, the \u0026ldquo;Piece\u0026rdquo; is only a blueprint, so we will leave the \u0026ldquo;Texture\u0026rdquo; property of the \u0026ldquo;Sprite\u0026rdquo; node as it is without applying any resources to it in this scene. In the inherited scene, apply an image that matches the color of each piece.\nChange the value of the \u0026ldquo;Offset\u0026rdquo; property to \u0026ldquo;(x: 35, y: -35)\u0026rdquo;. In the scene of each piece of color that inherits this scene, we will apply the KENNEY image imported earlier to the \u0026ldquo;Texture\u0026rdquo; property. Since the size of the image is 70 px in height and width, we shifted the center of the image to the upper right and set the lower left corner of the image to (x: 0, y: 0).\nThe grid of the board on which the pieces are placed is set to count from left to right on the x-axis and from bottom to top on the y-axis, and the size of one grid on the board is set to 70 px to match the size of the texture. If the lower left corner of the piece\u0026rsquo;s texture image is aligned with (x: 0, y: 0), then when the \u0026ldquo;Piece\u0026rdquo; root node is positioned (x: 0, y: 0) to the grid, the \u0026ldquo;Sprite\u0026rdquo; image will be placed exactly along the grid.\nAttaching and editing a script to the Piece node Let\u0026rsquo;s attach a new script to the \u0026ldquo;Piece\u0026rdquo; root node. Create a script file with the file path \u0026ldquo;res://Pieces/Piece.tscn\u0026rdquo;.\nEdit the script as follows.\nextends Node2D # Property to set the color of the piece as string data export (String) var color # Property to indicate matched (3 or more of the same color in a row) var matched = false # Reference to a Sprite node onready var sprite = $Sprite # Method to move a piece # Move the Piece instance to the position passed in the target argument func move(target): position = target # Method called when a match is found (3 or more of the same color in a row) # Set the matched property to true and make the color translucent func make_matched(): matched = true sprite.modulate = Color(1,1,1,.5) This completes the editing of the \u0026ldquo;Piece.gd\u0026rdquo; script.\nCreating a scene for each color that inherits from the Piece scene Now that the \u0026ldquo;Piece\u0026rdquo; scene, which will serve as a template, is complete, let\u0026rsquo;s create a scene that inherits the \u0026ldquo;Piece\u0026rdquo; scene in the number of colors of the piece. There are five Piece colors: beige, blue, green, pink, and yellow. First, let\u0026rsquo;s proceed with the steps using the \u0026ldquo;beige\u0026rdquo; drop as an example.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Inherited Scene\u0026rdquo;. Select \u0026ldquo;Piece.tscn\u0026rdquo; as the source scene. After the inherited scene is generated, rename the root node to \u0026ldquo;PieceBeige\u0026rdquo;.\n*The name of this root node should match the color of each drop. Save the scene once. Save the file path as \u0026ldquo;res://Pieces/PieceBeige.tscn\u0026rdquo;. With the root node \u0026ldquo;PieceBeige\u0026rdquo; selected in the scene tree dock, set the value of the \u0026ldquo;Color\u0026rdquo; property of \u0026ldquo;Script Variables\u0026rdquo; to \u0026ldquo;beige\u0026rdquo; in the inspector.\nSelect the \u0026ldquo;Sprite\u0026rdquo; node in the scene tree dock and apply the previously imported resource \u0026ldquo;res://Aliens/alienBeige_round.png\u0026rdquo; to the \u0026ldquo;Texture\u0026rdquo; property (you can drag it from the file system dock).\nOn the 2D workspace it should now look like the following screenshot.\nThe \u0026ldquo;PieceBeige\u0026rdquo; scene is now complete. Follow the same procedure to create scenes for the remaining four colored pieces. Please refer to the following for details on the different parts of each scene. Blue Piece Root node name: PieceBlue Color property: blue Sprite \u0026gt; Texture property: res://Aliens/alienBlue_round.png File path when saving the scene: res://Pieces/PieceBlue.tscn Green Piece Root node name: PieceGreen Color property: green Sprite \u0026gt; Texture property: res://Aliens/alienGreen_round.png File path when saving the scene: res://Pieces/PieceGreen.tscn Pink Piece Root node name: PiecePink Color property: green Sprite \u0026gt; Texture property: res://Aliens/alienPink_round.png File path when saving the scene: res://Pieces/PiecePink.tscn Yellow Piece Root node name: PieceYellow Color property: yellow Sprite \u0026gt; Texture property: res://Aliens/alienYellow_round.png File path when saving the scene: res://Pieces/PieceYellow.tscn When the inherited scenes of all 5 colored pieces have been created, the work is complete.\nControlling the Grid scene with scripts Now that we have created a scene for each color piece, we can now program and control the game. The amount of code is a bit large this time, so let\u0026rsquo;s do our best.\nAfter switching to the \u0026ldquo;Grid.tscn\u0026rdquo; scene, attach a new script to the \u0026ldquo;Grid\u0026rdquo; root node. The file path should be \u0026ldquo;res://Grid/Grid.gd\u0026rdquo;.\nIn the comments in the script, \u0026ldquo;finger touched\u0026rdquo; or \u0026ldquo;finger released\u0026rdquo; should be replaced with \u0026ldquo;left mouse button pressed\u0026rdquo; or \u0026ldquo;left mouse button released\u0026rdquo; on the Godot debug panel.\nAlso, please note that \u0026ldquo;match\u0026rdquo; is defined as three or more of the same color.\nNow, once the script editor is open, let\u0026rsquo;s define the necessary properties.\n### Grid.gd ### extends Node2D # An array with scene files for each color piece as elements const pieces_scn = [ preload(\u0026#34;res://Pieces/PieceBeige.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceBlue.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceGreen.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PiecePink.tscn\u0026#34;), preload(\u0026#34;res://Pieces/PieceYellow.tscn\u0026#34;) ] # Number of grids in x-axis direction var width: = 7 # Number of grids in y-axis direction var height: = 10 # Grid start position (pixels) in x-axis direction var x_start: = 70 # Grid start position (pixels) in y-axis direction var y_start: = 910 # Size of one grid (should be the same as Texture of Sprite in Piece) var grid_size: = 70 # A two-dimensional array (initially empty) that manages all the pieces of the board as elements and their grid coordinates var all_pieces = []. # Position where finger touches the screen var touched_pos = Vector2() # The position where the finger leaves the screen var released_pos = Vector2() # State where finger is touching the screen, touched: true / away: false var is_touching = false # State of automatic processing of matching, processing: true / stopped: false var is_waiting = false # Referencing the PiecesContainer node onready var pieces_container = $PiecesContainer Then let\u0026rsquo;s add the following method. Note that the two-dimensional array that appears in the following code is an array that stores arrays as elements.\nIn the case of the two-dimensional array used in this script, the first level of the array contains as many empty arrays as the number of grids in the x-axis direction of the board, and the second level of the array contains as many elements as the number of vertical grids in each array. By storing piece objects as elements, it is possible to manage where each piece is located on the board (how many grids along the x-axis and how many grids along the y-axis).\n### Grid.gd ### # Function called when the scene is loaded func _ready(): # Method to randomize the output result of a function that generates a random number each time randomize() # Make all_pieces a 2d array that makes up the grid of the board all_pieces = make_2d_array() # define after this # Spawn the pieces and place them on each grid spawn_pieces() # define after this # Method to create a 2d array that makes up the grid of the board func make_2d_array(): # Prepare an array named array for output var array = []. # Fill the prepared array with the number of empty arrays for the number of grids along the x-axis for i in width: array.append([]) # Add a value of null for the number of grids in the y-axis to each array for j in height: array[i].append(null) # return the two-dimensional array return array # Method to spawn pieces and place them on each grid func spawn_pieces(): # Loop for the number of grids along the x-axis for i in width: # Loop over the number of grids in the y-axis for j in height: # If no piece exists in the corresponding grid on the 2D array of all pieces # (All null at the start of the game) if all_pieces[i][j] == null: # Randomly select one from the scenes of each color and instantiate it var index = floor(rand_range(0, pieces_scn.size())) var piece = pieces_scn[index].instance() # If it matches, delete the piece instance and start over while match_at(i, j, piece.color): # define after this piece.queue_free() index = floor(rand_range(0, pieces_scn.size())) piece = pieces_scn[index].instance() # Make a piece instance a child of a PiecesContainer node pieces_container.add_child(piece) # Place the piece instance at the position converted from grid to pixels piece.position = grid_to_pixel(i, j) # define after this # Update the 2D array of all pieces all_pieces[i][j] = piece Let\u0026rsquo;s define the match_at and grid_to_pixel methods in the above code.\n### Grid.gd ### # Method to check if 3 or more pieces of the same color are lined up at the specified grid position. # column is the grid position on the x-axis, row is the grid position on the y-axis, and color is the color of the piece func match_at(column, row, color): # If the x-axis value of the specified grid coordinate is 3 or greater if column \u0026gt;= 2: # If there is a piece to the left of the specified grid coordinate and one more to the left if all_pieces[column-1][row] ! = null \\ and all_pieces[column-2][row] ! = null: # If the color of those pieces is the same as the color of the given piece if all_pieces[column-1][row].color == color \\ and all_pieces[column-2][row].color == color: # Return true return true # If the y-axis value of the specified grid coordinate is 3 or greater if row \u0026gt;= 2: # If there are pieces below the specified grid coordinates and one more below if all_pieces[column][row-1] ! = null \\frz and all_pieces[column][row-2] ! = null: # If the color of those pieces is the same as the color of the given piece if all_pieces[column][row-1].color == color \\ and all_pieces[column][row-2].color == color: # return true return true # Method to convert grid position to pixel position func grid_to_pixel(column, row): # Define a Vector2 variable pixel_pos for pixel position output var pixel_pos = Vector2() # Pixel x-coordinate = grid start position along x-axis + grid size * grid x-coordinate pixel_pos.x = x_start + grid_size * column # Pixel y-coordinate = grid start position along y-axis - grid size * grid y-coordinate pixel_pos.y = y_start - grid_size * row # Return pixel position return pixel_pos Now the pieces of each color should be randomly arranged on the board at the start of the game. Let\u0026rsquo;s run the project once to check it out. If you are running the project for the first time, select \u0026ldquo;Grid.tscn\u0026rdquo; as the main scene when the dialog for selecting the main scene appears.\nSince we have just defined the grid_to_pixel method, we should also define the pixel_to_grid method to be used later. As the name suggests, this method is the opposite of grid_to_pixel defined earlier, and converts pixel positions to grid positions.\n### Grid.gd ### # Method to convert pixel position to grid position func pixel_to_grid(pixel_x, pixel_y) -\u0026gt; Vector2: var grid_pos = Vector2() grid_pos.x = floor((pixel_x - x_start) / grid_size) grid_pos.y = floor((pixel_y - y_start) / -grid_size) return grid_pos In addition, we define one more method is_in_grid to be used later. This method determines whether the position passed as an argument is within the board grid and returns true or false.\n### Grid.gd ### # Method that returns whether the given position is in the grid or not. func is_in_grid(grid_position: Vector2): if grid_position.x \u0026gt;= 0 and grid_position.x \u0026lt; width \\ and grid_position.y \u0026gt;= 0 and grid_position.y \u0026lt; height # Return true if within the board grid return true else: # Return false if outside of the grid return false Here, we will write a program to handle the player\u0026rsquo;s input for the game.\n### Grid.gd ### # Function called every frame in the main loop of the game func _process(_delta): # If not in the process of matching if not is_waiting: # Process the player\u0026#39;s input touch_input() # define after this # Method to process player input func touch_input(): # If a finger touches the screen if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # Convert finger position from pixels to grid var start_pos = get_global_mouse_position() var start_grid = pixel_to_grid(start_pos.x, start_pos.y) # If the finger position is within the board grid if is_in_grid(start_grid): # Save the position where you touched your finger to the screen touched_pos = start_grid # Make the state with the finger touching the screen is_touching = true # If finger leaves the screen if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # Convert finger position from pixels to grid var end_pos = get_global_mouse_position() var end_grid = pixel_to_grid(end_pos.x, end_pos.y) # If finger position is within the board grid... # and the state is with the finger touching the screen if Is_in_grid(end_grid) and is_touching: # Save as released position information released_pos = end_grid # Call a method that handles the movement of the piece at the touched and released positions touch_and_release() # define after this # State is finger off the screen is_touching = false In the above code, the touch_and_release method is called to acquire the position of the finger touching the screen and the position of the finger leaving the screen within the grid of the board, and to use this information to process the movement of the pieces.\nLet\u0026rsquo;s define this method and a helper method called swap_pieces that is called further in the method. A helper method is simply a method that is called within a method and serves to keep the parent method simple.\n### Grid.gd ### # Method that handles the movement of the piece using the position of the touched finger and the position of the released finger func touch_and_release(): # Calculate the difference between the position where the finger touched and the position where the finger released var difference = released_pos - touched_pos # If the absolute value of the difference along the x-axis is greater than the absolute value of the difference along the y-axis if abs(difference.x) \u0026gt; abs(difference.y): # If difference along x-axis is greater than 0 if difference.x \u0026gt; 0: # Call helper method to swap the piece at the touched position with the adjacent piece to the right swap_pieces(touched_pos, Vector2.RIGHT) # define after this # If the difference along the x-axis is less than 0 elif difference.x \u0026lt; 0: # Call helper method to swap the piece at the touched position with the adjacent piece to the left swap_pieces(touched_pos, Vector2.LEFT) # defined after this # If the absolute difference along the x-axis is less than the absolute difference along the y-axis elif abs(difference.x) \u0026lt; abs(difference.y): # If the difference along y-axis is greater than 0 if difference.y \u0026gt; 0: # Call helper method to swap the piece at the touched position with the piece adjacent below swap_pieces(touched_pos, Vector2.DOWN) # define after this # If the difference along the y-axis is less than 0 elif difference.y \u0026lt; 0: # Call helper method to swap the piece at the touched position with the one adjacent above it swap_pieces(touched_pos, Vector2.UP) # defined after this # Helper method to swap pieces func swap_pieces(pos, dir): # Get the piece at the touched position from the 2D array of all pieces var touched_piece = all_pieces[pos.x][pos.y]. # Get the piece adjacent to the piece in the direction of finger release from the 2D array of all pieces var target_piece = all_pieces[pos.x + dir.x][pos.y + dir.y] # If both pieces exist in the 2D array of all pieces if touched_piece ! = null and target_piece ! = null: # Overwrite the piece at the touched position in the 2D array of all pieces with the piece adjacent to the one you removed your finger from all_pieces[pos.x][pos.y] = target_piece # Overwrite the piece adjacent to the finger release position with the piece at the finger release position from the two-dimensional array of all pieces all_pieces[pos.x + dir.x][pos.y + dir.y] = touched_piece # Move the piece instance at the touched position on the board by 1 grid toward the one you removed your finger from touched_piece.move(grid_to_pixel(pos.x + dir.x, pos.y + dir.y)) # move the piece instance adjacent to the one you release your finger on the board to the position touched by your finger target_piece.move(grid_to_pixel(pos.x, pos.y)) # Set auto-processing state to \u0026#34;processing in progress\u0026#34; since processing of the matched piece starts here is_waiting = true With the above code, we have implemented a process whereby a piece dragged by the player is replaced by an adjacent piece.\nLet\u0026rsquo;s run the project to see if the input operation works correctly.\nFrom here, the process that should be executed automatically after the pieces are replaced is implemented. The general flow is as follows:\nChange the automatic processing state during processing. Check if there is at least one matched piece, and if so, loop through the following process. Check all pieces and flag matched pieces. Delete the flagged piece. Fill the empty space by moving a piece from the same column. After the pieces are packed down, a new piece is created in the empty space at the end. When there are no more matched pieces, the automatic processing state is stopped. Let\u0026rsquo;s code the general flow of the above.\nFirst, let\u0026rsquo;s add a line is_waiting = true at the end of the swap_pieces method that swaps the pieces defined earlier. This changes the automatic processing state to \u0026ldquo;processing\u0026rdquo;.\n### Grid.gd ### func swap_pieces(pos, dir): var touched_piece = all_pieces[pos.x][pos.y] var target_piece = all_pieces[pos.x + dir.x][pos.y + dir.y] if touched_piece ! = null and target_piece ! = null: all_pieces[pos.x][pos.y] = target_piece all_pieces[pos.x + dir.x][pos.y + dir.y] = touched_piece touched_piece.move(grid_to_pixel(pos.x + dir.x, pos.y + dir.y)) target_piece.move(grid_to_pixel(pos.x, pos.y)) # Add the following # Set the auto-processing state to \u0026#34;processing\u0026#34; since this is where the automatic processing of the matched piece starts is_waiting = true Let\u0026rsquo;s write the if syntax \u0026ldquo;if the state is in the process of executing automatic processing\u0026rdquo; in the touch_input method, and then add the processing we want to execute automatically in the block. The position for adding is just after the finger operation is finished. After the process is complete, let\u0026rsquo;s add a line is_waiting = false to set the automatic processing state to \u0026ldquo;stopped\u0026rdquo;.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # Omit if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # Omit # Add from here # If Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # omit if is_waiting: # Check if there is at least one pair of matched pieces \u0026gt; loop as long as there are while check_matches(): # define after this pass # If no matched pieces are found and processing is complete, set autoprocessing state to waiting is_waiting = false A while loop is used to repeat the necessary process if there is at least one pair of matching pieces.\nFirst, define check_matches(), which is also the loop condition of the while loop, as follows.\n### Grid.gd ### # Method to check if there is at least one matched piece and return the result func check_matches() -\u0026gt; bool: # Loop over the x-axis grid of the board for i in width: # Loop over the y-axis grid of the board for j in height: # if piece exists at that grid coordinate if all_pieces[i][j] ! = null: # return true if the piece matches at that grid coordinate, and method also terminates if match_at(i, j, all_pieces[i][j].color): return true # Check all pieces and return false if none of them match return false Then, let\u0026rsquo;s define the find_matches method to perform the \u0026ldquo;first process in the while loop\u0026rdquo;, which is to check all the pieces and flag the matched ones, as follows. By \u0026ldquo;flagging\u0026rdquo; here, I mean changing the value of the matched property of a piece instance to true.\n### Grid.gd ### # Find matching pieces and flag method func find_matches(): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of y-axis grids on the board for j in height: # If a piece exists at the coordinates of that grid if all_pieces[i][j] ! = null: # Define the current color as the color of that piece var current_color = all_pieces[i][j].color # If its x-axis coordinates are less than the number of x-axis grids - 2 if i \u0026lt; width - 2: # If there are pieces to the right of that piece and further to its right if all_pieces[i+1][j] ! = null } and all_pieces[i+2][j] ! = null: # If the color of those pieces is the same as the current color if all_pieces[i+1][j].color == current_color \\ and all_pieces[i+2][j].color == current_color: # If the piece is not flagged if not all_pieces[i][j].matched: # Set the matched property of the piece to true to flag it # Make the piece\u0026#39;s texture color translucent at the same time all_pieces[i][j].make_matched() # If the piece\u0026#39;s right neighbor is not flagged if not all_pieces[i+1][j].matched: all_pieces[i+1][j].make_matched() # If the piece\u0026#39;s two neighbors to the right are not flagged if not all_pieces[i+2][j].matched: all_pieces[i+2][j].make_matched() # If the piece\u0026#39;s y-coordinate is less than the number of grids along the y-axis - 2 if j \u0026lt; height - 2: # If there are pieces above and further to its above that piece if all_pieces[i][j+1] ! = null \\f} and all_pieces[i][j+2] ! = null: # If the color of those pieces is the same as the current color if all_pieces[i][j+1].color == current_color \\ and all_pieces[i][j+2].color == current_color: # If the piece is not flagged if not all_pieces[i][j].matched: # Set the matched property of the piece to true to flag it # Make the piece\u0026#39;s texture color translucent at the same time all_pieces[i][j].make_matched() # If the piece above it is not flagged if not all_pieces[i][j+1].matched: all_pieces[i][j+1].make_matched() # If the piece two above it is not flagged if not all_pieces[i][j+2].matched: all_pieces[i][j+2].make_matched() We need to call this find_matches method in the while loop in the touch_input method, so let\u0026rsquo;s update it as follows.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # Omit if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # Omit if is_waiting: # Check if there is at least one pair of matched pieces \u0026gt; loop as long as there are while check_matches(): # Find matched pieces and flag them find_matches() # Wait 0.3 seconds to make the process visually clear yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) is_waiting = false Now the matched property of each matched piece instance should be true and the color of the piece should be translucent.\nLet\u0026rsquo;s run the project and check it out.\nNext, I would like you to define a delete_matches method that executes the second process \u0026ldquo;delete flagged pieces\u0026rdquo; in the while loop as follows.\n### Grid.gd ### # Method to delete matched pieces func delete_matches(): # Loop over the number of x-axis grids on the board for i in width: # Loop over the number of y-axis grids of the board for j in height: # If a piece exists at that grid coordinate if all_pieces[i][j] ! = null: # If a piece at that grid coordinate is flagged if all_pieces[i][j].matched: # Delete the piece at that grid coordinate all_pieces[i][j].queue_free() # Empty the element with that grid coordinate from the 2D array of all_pieces[i][j].queue_free() all_pieces[i][j] = null Let\u0026rsquo;s add this delete_matches method to the while loop of the touch_input method.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # Omit if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # Omit if is_waiting: # Check if there is at least one pair of matched pieces \u0026gt; loop as long as there are while check_matches(): # Find matched pieces and flag them find_matches() # Wait 0.3 seconds to make the process visually clear yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # Delete flagged pieces delete_matches() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # If no matched pieces are found and processing is complete, invalidate the in-process state is_waiting = false Now the matched pieces should become translucent and then be deleted.\nLet\u0026rsquo;s run the project and check it out.\nNext, I would like you to update the collapse_columns method that executes the third process in the while loop, \u0026ldquo;Move and pack pieces from the grid above the same column into the space vacated by the deletion\u0026rdquo;, as follows.\n### Grid.gd ### # Method to collapse a column by moving the piece above it in a space where no piece exists func collapse_columns(): # Loop over the number of x-axis grids in the board for i in width: # Loop over the number of y-axis grids in the board for j in height: # If no piece exists at that grid coordinate (null) if all_pieces[i][j] == null: # Loop from one row above the y-coordinate of that grid to the top row for k in range(j + 1, height): # If a piece exists on the grid one above if all_pieces[i][k] ! = null: # Move the piece on the grid above to an empty grid below all_pieces[i][k].move(grid_to_pixel(i, j)) # Put one piece above into the current grid coordinates of the 2D array of all_pieces all_pieces[i][j] = all_pieces[i][k]. # Empty the grid coordinate one above in the 2D array of all_pieces all_pieces[i][k] = null # Exit the loop break Let\u0026rsquo;s call this collapse_columns method inside the while loop of the touch_input method.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # Omit if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # Omit if is_waiting: # Check if there is at least one pair of matched pieces \u0026gt; loop as long as there are while check_matches(): # Find matched pieces and flag them find_matches() # Wait 0.3 seconds to make the process visually clear yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # Delete flagged pieces delete_matches() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # Move and collapse pieces on the same column into empty space collapse_columns() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # If no matched pieces are found and processing is complete, invalidate the in-process state is_waiting = false Now we have an algorithm that fills the empty space with the piece above it after the piece has been deleted. The while loop should also continuously delete the matching piece after it has been stuffed into the empty space.\nLet\u0026rsquo;s run the project and check it out.\nFinally, if the spawn_pieces method is called after the pieces are packed down, new pieces will be placed in the empty space and the board will be filled. This method is already defined and called in the _ready method to place the pieces on the board at the beginning of the game.\nNow let\u0026rsquo;s update the touch_input method as follows.\n### Grid.gd ### func touch_input(): if Input.is_action_just_pressed(\u0026#34;touch\u0026#34;): # Omit if Input.is_action_just_released(\u0026#34;touch\u0026#34;): # Omit if is_waiting: # Check if there is at least one pair of matched pieces \u0026gt; loop as long as there are while check_matches(): # Find matched pieces and flag them find_matches() # Wait 0.3 seconds to make the process visually clear yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # Delete flagged pieces delete_matches() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # Move and collapse pieces on the same column into empty space collapse_columns() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # Spawn and place a new piece in an empty space spawn_pieces() # Wait 0.3 seconds yield(get_tree().create_timer(0.3), \u0026#34;timeout\u0026#34;) # If no matched pieces are found and processing is complete, invalidate the in-process state is_waiting = false This completes the coding of the automatic processing part. This is the end of this tutorial. Finally, let\u0026rsquo;s run the project to see how it works.\nSample Game We have prepared a sample game that is a brushed-up version of the project created in this tutorial. Note that the GIF images below are played at 3x speed, so they are actually a bit calmer.\nThe project file is located in the GitHub repository . Please download the .zip file from there and import the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;Sample\u0026rdquo; folder and import it into Godot Engine.\nConclusion This time, we created a match 3 puzzle game. This is a perfect game genre for mobile games with simple controls that can be enjoyed over and over again.\nLet me summarize the key points when creating a simple match 3 puzzle game like this one.\nThere are only two minimum scenes required: the board and the pieces. Create a blueprint piece scene and then inherit it to create a piece scene for each color. Use a two-dimensional array to manage the pieces to be placed on the board grid. When replacing a piece, it is necessary to both replace the position of the piece on the screen and replace the elements of the two-dimensional array. The following are the key points of the script. The process of the player moving the pieces Get the position where the finger touches the screen and the position where the finger leaves the screen. Determine if the two positions are within the grid (valid operation). Determine the direction in which the pieces are swapped based on the difference between the two positions. Automatic processing (loop) when a match is made. Checks if there is at least one pair of matching pieces (loop condition). Flag the matched pieces. Delete flagged pieces (loop condition). Fill the space vacated by the removed piece with the piece above it. Create a new piece in the space vacated by the filling. Links KENNEY YouTube: Part 0: Why Godot? - Make a Match 3 game like Candy Crush Using Godot. Candy Crush Royal Match Toon Blast ","permalink":"https://www.peanuts-code.com/en/tutorials/gd0012_match3/","summary":"In this tutorial, we will create a match 3 puzzle game. Match 3 is a puzzle game in which players move multiple colorful pieces evenly arranged along a grid on the board to eliminate three or more pieces of the same color in a row. This genre is particularly popular among mobile game players because it is easy to operate and enjoyable. Candy Crush, Toon Blast, and Royal Match are just a few examples of popular games. Puzzle \u0026amp; Dragons and LINE Tsum Tsum are also based on Match 3, although the controls are slightly different. In this tutorial, we","title":"Match 3 puzzle game in Godot"},{"content":"In this tutorial, we will explain how to create a type of game in which you trace and erase drops of the same color, like the very popular Disney Tsum Tsum smartphone game.\nLINE: Disney Tsum Tsum Note that the final project file in this tutorial is located in the GitHub repository . You can directly check the project by downloading the .zip file and importing the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;End\u0026rdquo; folder with the Godot Engine.\nEnvironment This tutorial was created in the following environment\n・Godot version: 3.4.4\n・Computer OS version: macOS 11.6.5\nMemo: Please also use the following articles to help you start creating your game.\nDownloading Godot Project Manager of Godot Creating a new project First, we would like you to start Godot Engine and create a new project. Let\u0026rsquo;s name the project \u0026ldquo;Connect Colors Start.\nEditing project settings Once the editor appears, let\u0026rsquo;s editing the settings for the entire project.\nFirst, set the display size for the game. In this case, we set the aspect ratio to 16:9, assuming a smartphone screen in portrait orientation.\nOpen the \u0026ldquo;Project\u0026rdquo; menu \u0026gt; \u0026ldquo;Project Settings\u0026rdquo;\nIn the \u0026ldquo;General\u0026rdquo; tab, search for \u0026ldquo;window\u0026rdquo; and select \u0026ldquo;Display\u0026rdquo; \u0026gt; \u0026ldquo;Window\u0026rdquo; in the sidebar. In the \u0026ldquo;Size\u0026rdquo; section, change the values of the following items Width: 144 Height: 256 Test Width: 288 Test Height: 512\nChange the values of the following items in the \u0026ldquo;Stretch\u0026rdquo; section Mode: 2d Aspect: keep\nKeep the \u0026ldquo;Project Settings\u0026rdquo; open and configure the settings to substitute the mouse for the smartphone\u0026rsquo;s touch operation.\nSearch for \u0026ldquo;mouse\u0026rdquo; in the \u0026ldquo;General\u0026rdquo; tab and select \u0026ldquo;Input Devices\u0026rdquo; \u0026gt; \u0026ldquo;Pointing\u0026rdquo; in the sidebar. Check \u0026ldquo;On\u0026rdquo; for \u0026ldquo;Emulate Touch From Mouse\u0026rdquo;.\nWith the \u0026ldquo;Project Settings\u0026rdquo; window open, add an action to the input map that corresponds to a smartphone touch operation.\nSwitch to the \u0026ldquo;Input Map\u0026rdquo; tab and add \u0026ldquo;tap\u0026rdquo; to the action. Add a left mouse click to the \u0026ldquo;tap\u0026rdquo; action.\nDownloading and importing the assets Next, let\u0026rsquo;s download assets from KENNEY and use them. The asset pack we will be using is called Pixel Platformer . I can\u0026rsquo;t help but be thankful for this wonderful free resource.\nOnce downloaded, drag and drop the \u0026ldquo;characters_packed.png\u0026rdquo; file from the \u0026ldquo;Tilemap\u0026rdquo; folder into the editor\u0026rsquo;s file system dock to import it into your project.\nImmediately after importing the file, the image will look blurry, so follow the steps below to correct this.\nMake the imported asset file selected in the file system dock\nSelect [Presets] \u0026gt; [2D Pixel] in the import dock.\nClick the \u0026ldquo;Re-import\u0026rdquo; button at the bottom.\n! click reinport This will give the image the edgy look characteristic of pixel art.\nCreating a World Scene The first scene is to set the stage for the game. Let\u0026rsquo;s create a scene named \u0026ldquo;World\u0026rdquo;.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Node\u0026rdquo; in \u0026ldquo;Generate Root Node\u0026rdquo;. Select a node of the \u0026ldquo;Node2D\u0026rdquo; class as the root node. Rename the root node to \u0026ldquo;World\u0026rdquo;. Save the scene at this point. Create a folder and save the scene with the file path \u0026ldquo;res://World/World.tscn\u0026rdquo;.\nAdding nodes to the World scene Let\u0026rsquo;s add nodes so that the world scene will look like the following scene tree. We will edit the properties of each node in turn later, so we can leave them as they are.\nWorld (Node2D) Bin (StaticBody2D) CollisionPolygon2D SpawnPath (Path2D) Spawner (PathFollow2D) AnimationPlayer Drops (Node2D) DropsLine (Line2D) Pointer (Area2D) CollisionShape2D The scene tree dock should now look like this.\nEditing nodes in the World scene Bin (StaticBody2D) node This node does not need to be edited. StaticBody2D is used in 2D games for obstacles and walls that do not move. In this case, we will use it as a container (bin) to keep falling drops (objects to be erased by tracing) on the screen.\nCollisionPolygon2D node This node is used to add a collision shape to the parent node \u0026ldquo;Bin\u0026rdquo;. The collision shape is created by dotting in the 2D workspace.\nActivate grid snap in the 2D workspace toolbar.\nBasically, the collision shape is formed by dotting around the outside of the window frame. However, the upper part of the shape should be shifted by -64px from the y-coordinate 0 of the display size. This is to generate a drop outside the upper part of the window frame and make it fall. The lower part of the collision polygon is placed slightly inside the display size and slanted so that the drop will roll.\nSpawnPath (Path2D) node This node is used to move the position of the spawning drop along the x-axis at all times. This makes the drops fall from the different positions at the top of the screen every time. Let\u0026rsquo;s place it outside the top of the window frame.\nCreate a straight path parallel to the x-axis by hitting two points (16, -32) and (128, -32) on the 2D workspace.\nSpawner (PathFollow2D) node This node moves along the path of the \u0026ldquo;SpawnPath\u0026rdquo; node edited earlier. This node should always move back and forth along the path to generate a drop from this node\u0026rsquo;s position. This will ensure that the drop\u0026rsquo;s position when spawned always changes within the path of the \u0026ldquo;SpawnPath\u0026rdquo; node.\nTurn off the property \u0026ldquo;Rotate\u0026rdquo;.\nAnimationPlayer node This node is used to move \u0026ldquo;Spawner\u0026rdquo; back and forth along the path of \u0026ldquo;SpawnPath\u0026rdquo; at all times. The \u0026ldquo;Spawner\u0026rdquo; property \u0026ldquo;Unit Offset\u0026rdquo; represents the starting point of the parent node \u0026ldquo;SpawnPath\u0026rdquo; path as 0 and the end point as 1. In other words, by constantly changing this property between 0 and 1, it is possible to make a round trip on the path.\nCreate an animation as follows Animation name: move_spawn_pos Auto play on load: Enabled Animation length (seconds): 0.4\n*0.4 seconds to move back and forth along the path Animation looping: Enabled Track: Spawner node - unit_offset property Time: 0 / Value: 0 / Easing: 1.00 Time: 0.2 / Value: 1 / Easing: 1.00\n*Wrap from the end of the path at 0.2 seconds\nDrops (Node2D) node No property editing is required for this node. Its role is just a container for multiple instances generated from a drop scene (to be created later).\nDropLine (Line2D) node This node is used to draw a line connecting drops of the same color when they are traced. This makes it easier to visually check which drop has been traced and how many drops are connected.\nChange the property \u0026ldquo;Width\u0026rdquo; to 2. This is the thickness of the line.\nChange the properties \u0026ldquo;Capping\u0026rdquo; \u0026gt; \u0026ldquo;Joint Mode\u0026rdquo;, \u0026ldquo;Begin Cap Mode\u0026rdquo;, and \u0026ldquo;End Cap Mode\u0026rdquo; to \u0026ldquo;Round\u0026rdquo; respectively. This will make the shape of the joints, tips, and ends of the lines round.\nPointer (Area2D) node There is no need to edit this node. The purpose of this node is to follow the finger on a smartphone or the mouse cursor on a PC to detect when a drop is touched. Later, we will write code in the script to make the position of this node always the same as the position of the finger or mouse cursor.\nCollisionShape2D node This node gives the parent node \u0026ldquo;Pointer\u0026rdquo; a collision shape. Considering the operation of touching the drop with a finger or mouse cursor, the collision should be as small a shape as possible.\nApply the \u0026ldquo;New CircleShape2D\u0026rdquo; resource to the property \u0026ldquo;Shape\u0026rdquo;. Set the value of the property \u0026ldquo;Radius\u0026rdquo; of the applied resource \u0026ldquo;CircleShape2D\u0026rdquo; to 1.\nThis completes the editing of each node.\nCreating a Drop scene From here, we will create a \u0026ldquo;Drop\u0026rdquo; scene to be erased by tracing the same color.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Node\u0026rdquo; in \u0026ldquo;Generate Root Node\u0026rdquo;. Select a node of the \u0026ldquo;RigidBody2D\u0026rdquo; class as the root node. Rename the root node to \u0026ldquo;Drop\u0026rdquo;. Save the scene at this point. Create a folder and save the scene with the file path \u0026ldquo;res://Drops/Drop.tscn\u0026rdquo;. Adding nodes to the Drop scene Let\u0026rsquo;s add nodes so that the Drop scene will look like the following scene tree. We will edit the properties of each node in turn later, so we can leave them as they are.\nDrop (RigidBody2D) Sprite CollisionShape2D PointableArea (Area2D) CollisionShape2D AnimationPlayer StickableArea (Area2D) CollisionShape2D The scene tree dock should now look like this.\nEditing nodes in the Drop scene Drop (RigidBody2D) root node We want the \u0026ldquo;Drop\u0026rdquo; scene to automatically fall or bounce according to gravity when its instance is added to the \u0026ldquo;World\u0026rdquo; scene. The RigidBody2D class automatically reproduces such physics-based movements according to the node\u0026rsquo;s properties.\nIn the inspector dock, apply a new \u0026ldquo;PhysicsMaterial\u0026rdquo; resource to the \u0026ldquo;Physics Material Override\u0026rdquo; property.\nSet the property \u0026ldquo;Gravity Scale\u0026rdquo; to 2. The purpose is to make the drop fall a little faster.\nGo to Node Dock \u0026gt; Groups tab and create and add a group named \u0026ldquo;Drops\u0026rdquo;. This is important for the conditional branching process in the script.\nSprite node This node is used to give \u0026ldquo;Drop\u0026rdquo; a texture (appearance). The method of setting the texture of the sprite by specifying the range of textures you want to use from the sprite sheet that contains many textures imported at the beginning of this section is used.\nIn the inspector, drag the resource \u0026ldquo;res://characters_packed.png\u0026rdquo; from the file system to the property \u0026ldquo;Texture\u0026rdquo; and apply it.\nTurn on \u0026ldquo;Region\u0026rdquo; \u0026gt; \u0026ldquo;Enabled\u0026rdquo;.\nOpen the Texture Region panel at the bottom of the editor.\nExpand the panel by clicking on the expand icon to make it easier to work with.\nSelect \u0026ldquo;grid snap\u0026rdquo; under \u0026ldquo;snap mode\u0026rdquo; at the top of the panel.\nSet the \u0026ldquo;step\u0026rdquo; at the top of the panel to 24px 24px. This will make the grid the same size as one texture on the sprite sheet.\nDrag on the sprite sheet to select a range of two different textures with a green drop (looks like an alien).\nGo back to the inspector and change the value of the \u0026ldquo;Animation\u0026rdquo; \u0026gt; \u0026ldquo;Hframes\u0026rdquo; property to 2.\nCollisionShape2D node (child of root node Drop) This node provides a collision shape to the root node \u0026ldquo;Drop\u0026rdquo;. The root node is a \u0026ldquo;RigidBody2D\u0026rdquo; class, one of the physical bodies. The collision setting is essential to determine collisions between physical bodies. With this collision shape, it is assumed that multiple instances of the \u0026ldquo;Drop\u0026rdquo; scene will collide with each other and pile up on the screen.\nApply a new \u0026ldquo;CircleShape2D\u0026rdquo; resource to the \u0026ldquo;Shape\u0026rdquo; property. Furthermore, change the value of the property \u0026ldquo;Radius\u0026rdquo; of that resource to 12. This creates a circular collision shape with a radius of 12 px, which can be intuitively sized in the 2D workspace.\nPointableArea (Area2D) node This node is used to detect when a finger or mouse cursor touches or leaves its drop. No property editing is required, but a group needs to be added.\nGo to the Node Dock \u0026gt; Groups tab and create and add a group named \u0026ldquo;Pointable\u0026rdquo;. This is used to determine if the finger or mouse cursor is touching the drop.\nCollisionShape2D (child of PointableArea) node This node provides a collision shape to the parent \u0026ldquo;PointableArea\u0026rdquo;. It should fit slightly inside the collision shape of the root node \u0026ldquo;Drop\u0026rdquo; so that it does not react when a finger or mouse cursor touches the edge of the drop.\nApply a new \u0026ldquo;CircleShape2D\u0026rdquo; resource to the property \u0026ldquo;Shape\u0026rdquo;. In addition, change the value of the property \u0026ldquo;Radius\u0026rdquo; of the resource to 10. The collision shape is one size smaller than the collision shape of the root node \u0026ldquo;Drop\u0026rdquo;. You can intuitively adjust the size in the 2D workspace.\n*The collision shape for this node is an inner circle AnimationPlayer node The first step here is to create a waiting animation for the drop when the finger or mouse cursor is not touching it, and a blinking animation to show it after it is touched. This node will be used to play those animation resources that we have created.\nCreate a drop waiting animation as follows. Animation name: idle Auto play on load: Enabled Animation length (seconds): 1 Animation looping: Enabled Track: Sprite node - frame property Time: 0 / Value: 0 / Easing: 1.00 Time: 0.5 / Value: 1 / Easing: 1.00 Sprite node - modulate property Time: 0 / Value: #ffffff / Easing: 1.00\n*A track to ensure that after modulate is changed in a \u0026ldquo;flash\u0026rdquo; animation, it is reset to its initial value when the \u0026ldquo;idle\u0026rdquo; animation is played.\nCreate an animation of the drop in standby as follows. Animation name: flash Auto play on load: disabled Animation length (seconds): 0.2 Animation looping: Enabled Track: Sprite node - frame property Time: 0 / Value: 0 / Easing: 1.00 Time: 0.1 / Value: 1 / Easing: 1.00 Sprite node - modulate property Time: 0 / Value: #ffffff / Easing: 1.00 Time: 0.1 / Value: #64ffffff / Easing: 1.00\nStickableArea (Area2D) node This node is used to detect if a drop is in contact with another drop. No property editing is required, but a group needs to be added.\nGo to Node Dock \u0026gt; Groups tab and create and add a group named \u0026ldquo;Stickable\u0026rdquo;. This is important to determine if the drop is \u0026ldquo;adjacent\u0026rdquo; = \u0026ldquo;connectable\u0026rdquo; when you trace your finger or mouse cursor over it.\nCollisionShape2D node This node provides a collision shape for the parent \u0026ldquo;StickableArea\u0026rdquo; node. It is used to detect adjacent drops. In order to detect contact between adjacent drops, the collision shape should be slightly larger than the collision shape of the root node \u0026ldquo;Drop\u0026rdquo;.\nApply a new \u0026ldquo;CircleShape2D\u0026rdquo; resource to the property \u0026ldquo;Shape\u0026rdquo;. In addition, change the value of the property \u0026ldquo;Radius\u0026rdquo; of the resource to 18. This creates a circular collision shape with a radius of 18 px. It can also be intuitively sized in the 2D workspace.\n*The collision shape for this node is the outermost circle. This completes the editing of each node.\nControlling the Drop scene with a script Now let\u0026rsquo;s attach a new script to the root node \u0026ldquo;Drop\u0026rdquo;. Create a script file with the file path \u0026ldquo;res://Drops/Drop.gd\u0026rdquo;.\nEdit the script as follows.\n### Drop.gd ### extends RigidBody2D # Properties to assign each color name to a scene that inherits from the Drop scene export var color = \u0026#34;\u0026#34; # define stuck_drop as an array to contain adjacent drops var stuck_drops = [] # Reference to the AnimationPlayer node onready var anim_player = $AnimationPlayer Next, we will use signals from the Area2D node of the \u0026ldquo;StickableArea\u0026rdquo; node. Let\u0026rsquo;s connect the \u0026ldquo;area_entered\u0026rdquo; signal, which is sent out when a drop makes contact with an adjacent drop, and the \u0026ldquo;area_exited\u0026rdquo; signal, which is sent out when a drop that was in contact with a drop leaves the area, to the script.\nEdit the method generated when you connect each signal as follows.\n### Drop.gd ### # Method called when a StickableArea is collided by another area (Area2D) func _on_StickableArea_area_entered(area): # If the area was collided by a Stickable group node if area.is_in_group(\u0026#34;Stickable\u0026#34;): # Define its parent node as drop var drop = area.get_parent() # Add drop to the array stuck_drops stuck_drops.append(drop) # Method called when another area (Area2D) leaves StickableArea func _on_StickableArea_area_exited(area): # If the area that was exited from the collision shape is a Stickable group node if area.is_in_group(\u0026#34;Stickable\u0026#34;): # Define its parent node as drop var drop = area.get_parent() # Check the index of a drop in the array stuck_drops var index = stuck_drops.find(drop) # Remove the element (adjacent Drop) corresponding to index from the array stuck_drops stuck_drops.remove(index) This completes the editing of \u0026ldquo;Drop.gd\u0026rdquo;.\nCreating a scene that inherits from the Drop scene The \u0026ldquo;Drop\u0026rdquo; scene we just created is a template for the scene we will create. We will now create a scene that inherits the \u0026ldquo;Drop\u0026rdquo; scene in the number of drop colors. There are five drop colors: blue, green, orange, red, and yellow. Let\u0026rsquo;s start with the Blue drop as an example.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Inherited Scene. Select \u0026ldquo;Drops.tscn\u0026rdquo; as the source scene for the minor injury. After the scene is generated, rename the root node to \u0026ldquo;Blue.\n*The name of this root node should match the color of each drop. Save the scene. Save the file path as \u0026ldquo;res://Drops/BlueDrop.tscn\u0026rdquo;. With the root node \u0026ldquo;BlueDrop\u0026rdquo; selected in the scene tree dock, set the value of \u0026ldquo;Color\u0026rdquo; in Script Variables to \u0026ldquo;Blue\u0026rdquo; in the inspector.\nSelect the \u0026ldquo;Sprite\u0026rdquo; node in the scene tree dock. Open the \u0026ldquo;Texture Area\u0026rdquo; panel at the bottom of the editor and select the two blue alien textures.\nThis completes the \u0026ldquo;BlueDrop\u0026rdquo; scene. Follow the same procedure to create the remaining four color scenes. The name of the root node of the scene and its property \u0026ldquo;Color\u0026rdquo; are as follows.\nRoot node: GreenDrop / Color: Green Root node: OrangeDrop / Color: Orange Root node: RedDrop / Color: Red Root node: YellowDrop / Color: Yellow When we have created an inheritance scene with a total of five drop colors, our work is complete.\nControlling a World Scene with Scripts We are now approaching the end of this tutorial. Let\u0026rsquo;s attach a script to the root node of the \u0026ldquo;World\u0026rdquo; scene. Create the file path as \u0026ldquo;res://World/World.tscn\u0026rdquo;.\nWhen the script editor opens, first define the properties as follows\n### World.gd ### extends Node2D # Define drop_scenes as an array with 5 preloaded color drop scenes as elements const drop_scenes = [ preload(\u0026#34;res://Drops/BlueDrop.tscn\u0026#34;), preload(\u0026#34;res://Drops/GreenDrop.tscn\u0026#34;), preload(\u0026#34;res://Drops/OrangeDrop.tscn\u0026#34;), preload(\u0026#34;res://Drops/RedDrop.tscn\u0026#34;), preload(\u0026#34;res://Drops/YellowDrop.tscn\u0026#34;) ] # Minimum number of connecting drops that can be erased export (int) var min_erasable = 3 # Maximum number of drops displayed on the screen export (int) var max_drops = 50 # True if the game is currently playing var is_playing = false # True if finger on the screen or left mouse click is held down var is_holding = false # Referencing the drop where the finger or mouse cursor is currently held var pointed_drop # Color of the drops currently connected var active_color = \u0026#34;\u0026#34; # Array for list of held (traced and connected) drops var held_drops = [] # A reference to the Spawner node onready var spawner = $SpawnPath/Spawner # A reference to the Drops node onready var drops = $Drops # Reference to a DropsLine node onready var drops_line = $DropsLine # Reference to a Pointer node onready var pointer = $Pointer Next, let\u0026rsquo;s code the maximum number of drops (50) to fall from the top of the screen immediately after the game starts.\n### World.gd ### # Method called when all nodes in the World scene have been loaded func _ready(): # Built-in method that will randomize the output of random methods every time. randomize() # Loop for the number of max_drops (50) for _i in range(max_drops): # Call a method (defined later) to generate drops spawn_drop() # Wait 0.025 seconds after one drop is spawned, then spawn the next drop yield(get_tree().create_timer(0.025), \u0026#34;timeout\u0026#34;) # Method to spawn a drop func spawn_drop(): # Reference to a scene file for a randomly chosen color drop from the array drop_scenes var drop_scene = drop_scenes[randi() % drop_scenes.size()] # Instantiate a drop scene of the selected color var drop = drop_scene.instance() # Make the position of the drop instance the same as the position of the Spawner node drop.position = spawner.global_position # Add the drop instance to the World scene drops.add_child(drop) Now let\u0026rsquo;s run the project and watch the behavior of 50 drops of randomly determined colors falling at the start of the game. Note that when we run the project for the first time, we should set the main scene as \u0026ldquo;World.tscn\u0026rdquo;.\nThe position of the \u0026ldquo;Pointer (Area2D)\u0026rdquo; node will be coded to follow the position of the finger or mouse cursor, and the \u0026ldquo;PointableArea (Area2D)\u0026rdquo; of the \u0026ldquo;Drop\u0026rdquo; instance will detect when the finger or mouse cursor overlaps with it and when it leaves it. The \u0026ldquo;Pointer\u0026rdquo; node detects this and sends a signal. Let\u0026rsquo;s use this to code the process when tracing a drop.\nSelect \u0026ldquo;Pointer\u0026rdquo; in the scene tree dock and connect the signals \u0026ldquo;area_entered(area: Area2D)\u0026rdquo; and \u0026ldquo;area_exited(area: Area2D)\u0026rdquo; to the script in the Node Dock \u0026gt; Signal tab.\nEdit the automatically generated methods as follows.\n### World.gd ### # Method called when a Pointer node touches another area (Area2D object) func _on_Pointer_area_entered(area): # if area is a node in the \u0026#34;Pointable\u0026#34; group if area.is_in_group(\u0026#34;Pointable\u0026#34;): # Pass a reference to the parent node of area (Drop node) to pointed_drop pointed_drop = area.get_parent() # If drop in hold is non-zero.. # and the last drop in the hold is adjacent to pointed_drop if not held_drops.empty() and held_drops[-1] in pointed_drop.stuck_drops: # Call a method to update drop connections (defined later) update_drops_connection() # Method called when the area (Area2D object) that the Pointer node was touching leaves func _on_Pointer_area_exited(area): # If area is a node in the \u0026#34;Pointable\u0026#34; group if area.is_in_group(\u0026#34;Pointable\u0026#34;): # Set pointed_drop to null pointed_drop = null Next, use the built-in function `_process` to execute the method you want to call every frame (60FPS). ### World.gd ### # Built-in function: called at 60FPS func _process(_delta): # Update the Points property of the DropsLine node update_drops_line() # Receive finger or mouse cursor actions get_input() # Method to update the Points property of a DropsLine node.. # to change the position of a drop as it rolls or falls func update_drops_line(): # If there is at least one drop in hold if not held_drops.empty(): # Create a temporary Vector2 array var temp_array = PoolVector2Array() # Loop over held drops for drop in held_drops: # Add the position of the drop in hold to the temporary array temp_array.append(drop.position) # Update the points property of the DropsLine node to the position of the currently held drop drops_line.points = temp_array # Methods to process finger or mouse input func get_input(): # Always set the Pointer node position to the finger or mouse cursor position pointer.position = get_global_mouse_position() # If you press the screen with a finger or the left mouse button if Input.is_action_just_pressed(\u0026#34;tap\u0026#34;): # Call a method (defined later) to hold the drop hold_drop() # Call a method (to be defined later) to update the connection of drops on hold update_drops_connection() # If the finger leaves the screen or the left mouse button is up if Input.is_action_just_released(\u0026#34;tap\u0026#34;): # Call a method (defined later) to erase drops on hold erase_drops() # Call a method to release holds (to be defined later). release_drops(). The following methods, which are called in the method get_input defined in the above code, will be defined in order after this.\nhold_drop update_drops_connection erase_drops release_drops First, let\u0026rsquo;s define the methods hold_drop and update_drops_connection to be called when a drop is held down.\n### World.gd ### # Methods to hold a drop while it is being held func hold_drop(): # If finger or mouse cursor is touching the drop if pointed_drop: # Hold the drop. is_holding = true # Method to update drop connections func update_drops_connection(): # If drop is holding and .. # if finger or mouse cursor is over the drop if is_holding and pointed_drop: # If is_holding and pointed_drop: # if held_drops.empty(): # if held_drops.empty() if held_drops.empty(): # If the color of the drop to be held is currently set to the color of the finger or .. # color of the drop that the mouse cursor is currently touching active_color = pointed_drop.color # Call a method (to be defined later) to connect drops connect_drop() # If the color of the drop currently touched by the finger or mouse cursor.. # is the same as the color of the drop being connected elif pointed_drop.color == active_color: # If the number of drops in hold is greater than or equal to 2 and .. # if the current touched drop is the same as the second last drop in the hold if held_drops.size() \u0026gt;= 2 and pointed_drop == held_drops[-2]: # Call a method (defined later) to disconnect disconnect_drop() # If the drop currently touched by the finger or mouse cursor is not in the held drops elif not pointed_drop in held_drops: # Call a method (defined later) to connect the drops connect_drop() If you look inside the method update_drops_connection defined here, you will see that there are further undefined connect_drop and disconnect_drop methods called.\nLet\u0026rsquo;s continue to define these methods.\n### World.gd ### # Methods to connect drops func connect_drop(): # Play the animation \u0026#34;flash\u0026#34; on the currently touched drop pointed_drop.anim_player.play(\u0026#34;flash\u0026#34;) # Add the currently touched drop to the list of held drops held_drops.append(pointed_drop) # Add the position of the currently touched drop to the Points property of the DropsLine node drops_line.add_point(pointed_drop.position) # Methods to disconnect drops func disconnect_drop(): # Define the last drop in the list of held drops as canceled_drop var canceled_drop = held_drops.pop_back() # Stop animation (\u0026#34;flash\u0026#34;) in AnimationPlayer of canceled_drop canceled_drop.anim_player.stop() # Play the animation (\u0026#34;idle\u0026#34;) in AnimationPlayer of canceled_drop canceled_drop.anim_player.play(\u0026#34;idle\u0026#34;) # Remove the last point from the Points property of a DropsLine node drops_line.remove_point(drops_line.get_point_count() - 1) Within the get_input method, we will now define two methods, erase_drops and release_drops, which will be called when the finger leaves the screen or the left mouse button is raised.\n### World.gd ### # Methods to erase drops func erase_drops(): # If the number of held drops is less than the minimum number of drops that can be erased if held_drops.size() \u0026lt; min_erasable: # Immediately terminate the method return # Duplicate the array of held drops as the value of variable erased var erased = held_drops.duplicate() # Loop over the elements of array erased for drop in erased: # Release the drops in array erased drop.queue_free() # Create a new drop for each erased drop spawn_drop() # Wait 0.1 seconds (then next loop) yield(get_tree().create_timer(0.1), \u0026#34;timeout\u0026#34;)\t# Method to release holds from drops func release_drops(): # Release status while holding is_holding = false # Loop over the elements of the array of held drops for drop in held_drops: # Stop animation \u0026#34;flash\u0026#34; drop.anim_player.stop() # Play the animation \u0026#34;idle\u0026#34;. drop.anim_player.play(\u0026#34;idle\u0026#34;) # Empty the array of held drops held_drops.clear() # Empty the Points property of the DropsLine node drops_line.clear_points() This completes the editing of the \u0026ldquo;World.gd\u0026rdquo; script.\nExecuting the scene to check the operation Finally, let\u0026rsquo;s run a scene to see if it reproduces the movement as expected.\nHave you confirmed that the following is as expected?\nWhen the left mouse button is pressed while the mouse cursor is near the center of the drop, the drop is held and a \u0026ldquo;flash\u0026rdquo; animation is played. If you hold down the left mouse button and trace the adjacent drop, the \u0026ldquo;DropsLine\u0026rdquo; will be connected. If you return to the drop you have traced, the hold is released and the \u0026ldquo;idle\u0026rdquo; animation returns to playback. When three or more drops are traced, all drops in the hold disappear when the left mouse button is released. If less than three drops are traced, releasing the left mouse button does not erase the drops, only releases the hold. Sample Games We have prepared a sample game that further brushes up the project created in this tutorial.\nYour browser does not support the video tag. The project file is located in GitHub repository , so please download the .zip file from there and you can check it by importing the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;Sample\u0026rdquo; folder with the Godot Engine.\nConclusion In this tutorial, We created a puzzle game in which you have to trace the same color to make it disappear. It is the kind of game that one cannot help but feel addicted to. Let me summarize the key points in the creation of the game.\nUse RigidBody2D for the drop and let the engine do the physics. Add Area2D class nodes to the drop to detect fingers and cursors, and Area2D class nodes to detect adjacent drops, and use their signals. Always follow the Area2D class node to the finger or mouse cursor and use the signal of this node for contact with the drop. Links KENNEY Godot Docs: Physics introduction Godot Docs: RigidBody2D Godot Docs: Using Area2D Godot Docs: Area2D Godot Docs: CollisionShape2D Godot Docs: CollisionPolygon2D Godot Docs: Path2D Godot Docs: PathFollow2D Godot Docs: Line2D Godot Docs: Introduction to the animation features Godot Docs: AnimationPlayer ","permalink":"https://www.peanuts-code.com/en/tutorials/gd0011_connect_colors/","summary":"In this tutorial, we will explain how to create a type of game in which you trace and erase drops of the same color, like the very popular Disney Tsum Tsum smartphone game. LINE: Disney Tsum Tsum Note that the final project file in this tutorial is located in the GitHub repository . You can directly check the project by downloading the .zip file and importing the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;End\u0026rdquo; folder with the Godot Engine. Environment This tutorial was created in the following environment ・Godot version: 3.4.4 ・Compu","title":"Connecting matching colors puzzle game in Godot"},{"content":"This tutorial explains how to implement \u0026ldquo;grid-based movement\u0026rdquo; in 2D games. Grid-based movement refers to the movement of objects such as characters on the game screen one grid at a time.\nMany puzzle games such as the popular smartphone game \u0026ldquo;Puzzle \u0026amp; Dragons\u0026rdquo; and the original falling game \u0026ldquo;Tetris,\u0026rdquo; as well as tactical simulation games such as the \u0026ldquo;Fire Emblem\u0026rdquo; series and \u0026ldquo;Tactics Ogre\u0026rdquo; probably employ this type of movement.\nOn the other hand, RPGs such as the \u0026ldquo;Final Fantasy\u0026rdquo; series and the \u0026ldquo;Dragon Quest\u0026rdquo; series also use this grid-based movement when looking closely at character movement in the era of 2D graphics, when these games appeared as software for the NES and Super Nintendo.\nThus, grid-based movement is used in games of various genres, and its versatility is quite high.\nIn this article, we will focus as much as possible on only the implementation of grid-based movement. In addition, a sample game that uses grid-based movement will be introduced at the end of the article, so please feel free to refer to it as well.\nNote that the project file that will be created at the end of this tutorial is located in the GitHub repository . You can also directly check the project by downloading the .zip file and importing the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;End\u0026rdquo; folder with the Godot Engine.\nEnvironment This tutorial was created in the following environment\n・Godot version: 3.4.4\n・Computer OS version: macOS 11.6.5\nMemo: Please also use the following articles to help you start creating your game.\nDownloading Godot Project Manager of Godot Creating a new project First, we would like you to start Godot Engine and create a new project. Let\u0026rsquo;s name the project \u0026ldquo;Grid Based Movement Tutorial\u0026rdquo;.\nWhen the editor appears, set the display size of the game first.\nOpen the \u0026ldquo;Project\u0026rdquo; menu \u0026gt; \u0026ldquo;Project Settings\u0026rdquo;. Search for \u0026ldquo;window\u0026rdquo; and select \u0026ldquo;Display\u0026rdquo; \u0026gt; \u0026ldquo;Window\u0026rdquo; in the sidebar. In the \u0026ldquo;Size\u0026rdquo; section, change the values of the following items. Width: 256 Height: 160 Test Width: 1024 Test Height: 640\nIn the \u0026ldquo;Stretch\u0026rdquo; section, change the values of the following items. Mode: 2d Aspect: keep\nNext, let\u0026rsquo;s download the assets from KENNEY\u0026rsquo;s site and use them. This time, We will use an asset pack called 1-Bit Pack . I can\u0026rsquo;t help but be thankful for this wonderful free material.\nAfter downloading, drag and drop the \u0026ldquo;colored-transparent_packed.png\u0026rdquo; file in the \u0026ldquo;Tilesheet\u0026rdquo; folder into the editor\u0026rsquo;s file system dock to import it into your project.\nImmediately after importing the file, the image looks blurry. The following steps will give the image the edges characteristic of pixel art.\nMake the imported asset file selected in the file system dock.\nSelect \u0026ldquo;Preset\u0026rdquo; \u0026gt; \u0026ldquo;2D Pixel\u0026rdquo; in the import dock.\nClick the \u0026ldquo;Re-import\u0026rdquo; button at the bottom.\nCreating World scene The first scene is the game world. Let\u0026rsquo;s create a scene named \u0026ldquo;World\u0026rdquo;.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Node\u0026rdquo; in \u0026ldquo;Generate Root Node\u0026rdquo;. Select a node of the \u0026ldquo;Node2D\u0026rdquo; class as the root node. Rename the root node to \u0026ldquo;World\u0026rdquo;. Save the scene at this point. Create a folder and save the scene with the file path \u0026ldquo;res://World/World.tscn\u0026rdquo;. Add a \u0026ldquo;TileMap\u0026rdquo; node to the root node. The scene tree should now look like this.\nEditing the TileMap node Editing the properties of the TileMap node Select the \u0026ldquo;TileMap\u0026rdquo; node in the scene tree dock and edit its properties in the inspector.\nAssign a \u0026ldquo;New TileSet\u0026rdquo; resource to the \u0026ldquo;TileSet\u0026rdquo; property.\nSet the value of the \u0026ldquo;Cell\u0026rdquo; \u0026gt; \u0026ldquo;Size\u0026rdquo; property to (x: 16, y: 16). The size was set to match the size of the texture (16 px height and width) of the sprite sheet that will be used.\nEditing the TileSet resource Continue to edit the resource \u0026ldquo;TileSet\u0026rdquo; assigned to the \u0026ldquo;TileSet\u0026rdquo; property.\nClick on the resource in the inspector.\nWhen the \u0026ldquo;TileSet\u0026rdquo; panel at the bottom of the Godot editor opens, drag the sprite sheet resource \u0026ldquo;res://colored-transparent_packed.png\u0026rdquo; from the file system dock to the left sidebar in the panel and add it. Click on the added resource to put it in edit mode.\nSelect \u0026ldquo;New Single Tile\u0026rdquo;.\nWith the \u0026ldquo;Region\u0026rdquo; tab selected, activate grid snapping.\nIn the inspector, set \u0026ldquo;Snap Options\u0026rdquo; \u0026gt; \u0026ldquo;Step\u0026rdquo; to (x: 16, y: 16), which is the same size as one texture on the sprite sheet.\nselect the \u0026ldquo;grass\u0026rdquo; and \u0026ldquo;tree\u0026rdquo; texture areas in order and register them as Single Tile.\nFor the \u0026ldquo;Tree\u0026rdquo; tile, select the \u0026ldquo;Collision\u0026rdquo; tab and set the collision shape as well.\nThis completes the editing of the TileSet resource.\nCreating a TileMap From here, we will create a TileMap by placing tiles from the \u0026ldquo;TileSet\u0026rdquo; resource created earlier.\nSelect the \u0026ldquo;TileMap\u0026rdquo; node in the scene tree dock. Activate grid snap from the 2D workspace toolbar.\nClick \u0026ldquo;Snapping Options\u0026rdquo; on the toolbar and select \u0026ldquo;Configure Snap\u0026rdquo;.\nWhen the \u0026ldquo;Configure Snap\u0026rdquo; setting panel opens, set \u0026ldquo;Grid Step\u0026rdquo; to (x: 16, y: 16) and click \u0026ldquo;OK\u0026rdquo;.\nYou should now see a grid separated by 16px in height and width on the 2D workspace. Since \u0026ldquo;Grid Snap\u0026rdquo; is enabled, you should be able to easily place tiles along the grid when editing the \u0026ldquo;TileMap\u0026rdquo;.\nNow we will place tiles in the 2D workspace. Let\u0026rsquo;s simply surround the screen with \u0026ldquo;tree\u0026rdquo; tiles and place \u0026ldquo;grass\u0026rdquo; tiles inside them so that the player character, which will be placed later, will not be outside the screen.\nThis completes the editing of the \u0026ldquo;TileMap\u0026rdquo;.\nCreating Player Scene From here, we will create a scene for the player character. This object will actually be used to move the grid base in this tutorial.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Node\u0026rdquo; under \u0026ldquo;Generate Root Node\u0026rdquo;. Select a node of the \u0026ldquo;KinematicBody2D\u0026rdquo; class as the root node. Rename the root node to \u0026ldquo;Player\u0026rdquo;. Save the scene at this point. Create a folder and save the scene with the file path \u0026ldquo;res://Player/Player.tscn\u0026rdquo;. Add a \u0026ldquo;Sprite\u0026rdquo; node to the root node. Add a \u0026ldquo;CollisionShape2D\u0026rdquo; node to the root node. Add a \u0026ldquo;RayCast2D\u0026rdquo; node to the root node. The \u0026ldquo;Player\u0026rdquo; scene tree should now look like this.\nEditing each node in the Player scene Sprite node The method of setting the texture of a sprite by specifying the range of textures you want to use from a single sprite sheet that contains many textures is used.\nIn the Inspector, apply the resource file \u0026ldquo;res://colored-transparent_packed.png\u0026rdquo; to the \u0026ldquo;Texture\u0026rdquo; property.\nTurn off the \u0026ldquo;Offset\u0026rdquo; \u0026gt; \u0026ldquo;Centered\u0026rdquo; property. This will make the position of this node (\u0026ldquo;Position\u0026rdquo; property) in the upper left corner of the texture instead of the center so that it just fits in the grid square.\nTurn on \u0026ldquo;Region\u0026rdquo; \u0026gt; \u0026ldquo;Enabled\u0026rdquo;.\nOpen the \u0026ldquo;Texture Region\u0026rdquo; panel at the bottom of the editor. The task here is to specify the region of the texture you want to use in the sprite sheet.\nExpand the panel by clicking on the expand icon to make it easier to work with.\nSelect \u0026ldquo;grid snap\u0026rdquo; under \u0026ldquo;snap mode\u0026rdquo; at the top of the panel.\nSet the \u0026ldquo;step\u0026rdquo; at the top of the panel to 16px 16px. This will make the grid the same size as one texture on the sprite sheet.\nSelect the \u0026ldquo;king\u0026rdquo; texture by dragging on the sprite sheet.\nCollisionShape2D node This node is used to set the collision shape for the root node \u0026ldquo;Player\u0026rdquo;.\nIn the inspector, apply the \u0026ldquo;New RectangleShape2D\u0026rdquo; resource to the \u0026ldquo;Shape\u0026rdquo; property.\nSet the Transform \u0026gt; Position property to (x: 8, y: 8) to match the texture position of the Sprite node.\nIn the 2D workspace, match the collision shape to the size of the \u0026ldquo;Sprite\u0026rdquo; node texture.\nTo enter directly in the inspector, the properties of the \u0026ldquo;RectangleShape2D\u0026rdquo; resource should be as follows. Extents: (x: 8, y: 8) RayCast2D node This node is very useful for collision detection in grid-based movement, represented as an arrow-shaped collision shape in the 2D workspace. When the arrow and an object overlap, a collision is detected. This can be used to detect collisions with objects in front of the player character and prevent it from moving forward.\nIn the Inspector, set the \u0026ldquo;Enabled\u0026rdquo; property to On. This will enable collision detection.\nSet the \u0026ldquo;Transform\u0026rdquo; \u0026gt; \u0026ldquo;Position\u0026rdquo; property to (x: 8, y: 8). This is to center the \u0026ldquo;Sprite\u0026rdquo; texture.\nSet the \u0026ldquo;Cast To\u0026rdquo; property to (x: 16, y: 0). This is just a temporary initial value, and once the project is actually executed, the value will be changed each time the player character is moved by the script.\nOn the 2D workspace it should now look like the following screenshot.\nLeave \u0026ldquo;Collide With\u0026rdquo; as default, \u0026ldquo;Areas\u0026rdquo; Off, and \u0026ldquo;Bodies\u0026rdquo; On. The \u0026ldquo;Tree\u0026rdquo; panel in the tileset you just created is a physical body, so if \u0026ldquo;Bodies\u0026rdquo; is checked, collision will be detected.\nImplementing grid-based movement in the Player node Configuring the Input Map First, add an action to the Input Map in the Project Settings so that the player character can be moved by keyboard keystrokes.\nswitch to the \u0026ldquo;Input Map\u0026rdquo; tab after selecting \u0026ldquo;Project\u0026rdquo; menu \u0026gt; \u0026ldquo;Project Settings\u0026rdquo;. add the following 4 \u0026ldquo;Actions\u0026rdquo;. move_right: D key move_left: A key move_down: S key move_up: W key *It is also OK to assign Up, down, left, and right arrow keys.\nAttaching and editing the script Attach a script to the root node \u0026ldquo;Player\u0026rdquo;. Create a script file with the file path \u0026ldquo;res://Player/Player.gd\u0026rdquo;.\nAfter creating the script file, open the script editor and edit the script code as follows.\nextends KinematicBody2D #1 const inputs = { \u0026#34;move_right\u0026#34;: Vector2.RIGHT, \u0026#34;move_left\u0026#34;: Vector2.LEFT, \u0026#34;move_down\u0026#34;: Vector2.DOWN, \u0026#34;move_up\u0026#34;: Vector2.UP } #2 var grid_size = 16 #3 onready var raycast = $RayCast2D #4 func _unhandled_input(event): for action in inputs.keys(): if event.is_action_pressed(action): move(action) #5 func move(action): var destination = inputs[action] * grid_size raycast.cast_to = destination raycast.force_raycast_update() if not raycast.is_colliding(): position += destination I numbered the scripts #1 ~ #5 in the comments. I will explain in this order.\n#1: Defined constants inputs of dictionary type. The value of the inputs is the direction vector of Vector2 type (vector of length 1) to be moved by each action. By the way, the built-in constants (RIGHT, LEFT, DOWN and UP) of the Vector2 class have the following values.\nRIGHT: Vector2(1, 0) LEFT: Vector2(-1, 0) DOWN: Vector2(0, 1) UP: Vector2(0, -1) #2: Defined the property grid_size. The value is set to 16, the same as the size (px) of tiles in \u0026ldquo;TileMap\u0026rdquo;.\n#3: Defined the property raycast. This is a property that refers to the \u0026ldquo;RayCast2D\u0026rdquo; node.\n#4: Override the built-in function _unhandled_input. This is a callback function that is called as soon as there is input from the keyboard, mouse, joystick, etc. It is similar to another function _input, but don\u0026rsquo;t worry about the details of the difference here.\nIn _unhandled_input, a loop is performed on the dictionary type constants inputs defined earlier. If the input is an input map action with the same name as a key in inputs (such as move_left or move_up), the value for that key (for example, Vector2.RIGHT if the key is move_right) is passed as an argument and the method move RIGHT), and calls the method named move. This method move will be defined later.\n#5: The method move is defined. When calling this method, it is necessary to pass a value for the argument action.\nThe variable destination is defined first. The value is the value for the key that matches the argument action from the dictionary type constant inputs (for example, Vector2.LEFT if action is passed move_left) multiplied by the property grid_size. In other words, if the player enters the \u0026ldquo;D\u0026rdquo; key, the value will be Vector2(1, 0) x 16 = Vector2(16, 0). This is a vector with a length of one grid in the right direction.\nNext, the value of the variable destination defined earlier is passed to the cast_to property of the \u0026ldquo;RayCast2D\u0026rdquo; node. This replaces the direction and length of the \u0026ldquo;RayCast2D\u0026rdquo; arrow with the key entered by the player. The method force_raycast_update is called in the next line to immediately update this replacement. This is a built-in `RayCast2D\u0026rsquo; node.\nThe next line describes the if syntax. The built-in method is_colliding of the \u0026ldquo;RayCast2D\u0026rdquo; node returns a Bool type (true or false) whether this node (arrow) is currently colliding with an object. Since there is a not after the if, the meaning of this if syntax is \u0026ldquo;if the RayCast2D node is not colliding with an object\u0026rdquo;.\nIf the RayCast2D node has not collided with other objects in the above if syntax, the value of destination is added to the value of the property position of the Player node. This means that the player character will move by the value of destination. For example, if the current position of the \u0026ldquo;Player\u0026rdquo; node is Vector2(64, 32), and the player presses the \u0026ldquo;S\u0026rdquo; key once, the player moves Vector2(0, 16) from the current position, and the destination position is Vector2(64, 48). In other words, the position is moved one grid position down from the current position.\nNow, the grid-based movement control should be implemented.\nAdding a Player scene instance to the World scene Now that the \u0026ldquo;Player\u0026rdquo; scene is complete, let\u0026rsquo;s add an instance of it to the \u0026ldquo;World\u0026rdquo; scene and move it around on the tile map.\nOpen the \u0026ldquo;World.tscn\u0026rdquo; scene. Add an instance of the \u0026ldquo;Player.tscn\u0026rdquo; scene to the root node \u0026ldquo;World.\nIn the 2D workspace, move the \u0026ldquo;Player\u0026rdquo; node to an appropriate position around the center of the screen.\nThe work is now complete.\nChecking the operation of the grid-based movement Let\u0026rsquo;s check if the grid-based movement actually works without any problems.\nIn particular, to make it easier to check the arrow-shaped collision shapes of the \u0026ldquo;RayCast2D\u0026rdquo; child node of \u0026ldquo;Player,\u0026rdquo; let\u0026rsquo;s check the \u0026ldquo;Visible Collision Shapes\u0026rdquo; checkbox in the \u0026ldquo;Debug\u0026rdquo; menu and enable it first.\nNow, let\u0026rsquo;s run the project and see if the king can run around in the prairie with grid-based movement. If this is your first time executing the project, simply select \u0026ldquo;res://World/World.tscn\u0026rdquo; for the Main Scene.\nIt can be clearly seen that a single keystroke moves the character only one tile. We can also confirm that the character cannot move in the direction of the \u0026ldquo;tree\u0026rdquo; tile.\nThis completes the grid-based moving tutorial.\nSample game We have prepared a sample game that uses this grid-based movement. The project file is located in GitHub repository , so you can download the .zip file from there and import the \u0026ldquo;project .godot\u0026rdquo; file in the \u0026ldquo;Sample\u0026rdquo; folder and import it into Godot Engine.\nYour browser does not support the video tag. This sample is a so-called whack-a-mole game. In the game\u0026rsquo;s setup, the player controls a king who holds up a sacred ring to the ghosts of the kingdom\u0026rsquo;s soldiers who emerge from their graves to release their cursed souls.\nThe keyboard controls are as follows\nD: Move right A: Move left S: Move down W: Move up Space: Raise the ring to release the ghost\u0026rsquo;s soul only when facing the ghost. The ghost must be released within 1 second by the ring or the king will be cursed. If the king is cursed, his Life is reduced by one. The king is cursed to death and the game is over when all 10 lives are lost.\nThe interval between the appearance of the next ghost is gradually shortened from 2 seconds at the beginning of the game to as short as 1 second.\nBy the way, my highest score is 150. I don\u0026rsquo;t know if this is great or not.\nSupplemental Explanation Finally, I would like to add some additional information about this sample game project.\nDuring the game, when the ghost appears from the tombstone, the \u0026ldquo;Ghost\u0026rdquo; instance with the collision shape set in the \u0026ldquo;KinematicBody2D\u0026rdquo; class is overlapping the tombstone tiles with the \u0026ldquo;TileMap\u0026rdquo; collision set. In this case, \u0026ldquo;RayCast2D\u0026rdquo; of the \u0026ldquo;Player\u0026rdquo; instance is slightly modified to give priority to the collision detection with the ghost over the tombstone.\nWhen creating the tombstone tiles by editing the \u0026ldquo;TileSet,\u0026rdquo; a collision of 1/2 the size of the tiles is set. It is easier to set the collision shape after setting \u0026ldquo;Snap Options\u0026rdquo; \u0026gt; \u0026ldquo;Step\u0026rdquo; to (x: 4, y: 4) in the inspector first. Of course, the collision shape of \u0026ldquo;Ghost\u0026rdquo; is (x: 16, y: 16).\nConclusion In this tutorial, we have explained the implementation of grid-based movement in 2D games. We hope you will find it useful for your puzzle games, simulation games, and other projects you are working on in the future.\nLet\u0026rsquo;s summarize the key points of grid-based movement.\nSet up the following correctly. Size of the tiles prepared in the \u0026ldquo;TileSet\u0026rdquo; resource (height and width) Size and position of the sprite of the object to be moved (in this case, \u0026ldquo;Player\u0026rdquo;) Size and position of the collision shape of the object to be moved Grid Step in the 2D workspace The value of the property (in this case grid_size) represents the distance to be moved by the script attached to the object\u0026rsquo;s node. Use \u0026ldquo;RayCast2D\u0026rdquo; to determine the collision between the object to be moved and other objects. The direction and size of \u0026ldquo;RayCast2D\u0026rdquo; are controlled by scripts. To move objects by player manipulation, register actions in the input map, and control the direction of movement for each input in scripts. Link KENNEY Godot Docs: RayCast2D Godot Docs: Using TileMaps Godot Docs: TileSet KidsCanCode: Grid-based movement YouTube: Grid-based movement Godot 3 demo overview YouTube: Make your first 2D grid-based game from scratch in Godot UPDATE\n2022/06/09 Translated from Japanese into English\n","permalink":"https://www.peanuts-code.com/en/tutorials/gd0010_2d_grid_based_movement/","summary":"This tutorial explains how to implement \u0026ldquo;grid-based movement\u0026rdquo; in 2D games. Grid-based movement refers to the movement of objects such as characters on the game screen one grid at a time.\nMany puzzle games such as the popular smartphone game \u0026ldquo;Puzzle \u0026amp; Dragons\u0026rdquo; and the original falling game \u0026ldquo;Tetris,\u0026rdquo; as well as tactical simulation games such as the \u0026ldquo;Fire Emblem\u0026rdquo; series and \u0026ldquo;Tactics Ogre\u0026rdquo; probably employ this type of movement.\nOn the other hand, RPGs such as the \u0026ldquo;Final Fantasy\u0026rdquo; series and the \u0026ldquo;Dragon Quest\u0026rdquo; series also use this grid-based movement when looking closely at character movement in the era of 2D graphics, when these games appeared as software for the NES and Super Nintendo.","title":"2D grid-based movement in Godot"},{"content":"In this tutorial, we will create a homing missile in a 2D top-down shooter. A homing missile is a missile that tracks its target.\nEnvironment This tutorial was created in the following environment\n・Godot version: 3.4.2\n・Computer OS version: macOS 11.6.5\nTo focus on the creation of the homing missile, the rest of the project has been pre-created in advance.\nThe project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;Start\u0026rdquo; folder into the Godot Engine, and you can start the project with only the preliminary work completed. If you would like to see the completed project in a hurry, import the \u0026ldquo;project.godot\u0026rdquo; file from the \u0026ldquo;End\u0026rdquo; folder.\nAll the assets imported into the project were downloaded from KENNEY website. I used an asset pack called Tower Defense (top-down) . I just want to thank them for making such a great asset pack available to the public.\nPreliminary Preparation The following game specifications, except for the homing missile part, which is listed as (planned), have already been prepared as a preliminary.\nPlayer Character (Fighter): The following keys can be used. move_up: W key - the player character moves up. move_down: S key - the player character moves down. move_right: D key - moves the player character to the right. move_left: A key - moves the player character left. magic: Spacebar or left mouse button - fires the machine gun. Bullets of the machine gun disappear when they hit the enemy character\u0026rsquo;s tank and the homing missiles it fires. Bullets of the machine gun disappear when they go off-screen. Enemy characters (tanks): Up to 5 tanks appear on the game screen. When there are no tanks left, 5 new tanks will be created. They always move toward the player character. When the player gets close to a certain distance, they will fire homing missiles (planned). The homing missiles will disappear when the player character or the machine gun is hit by a bullet (planned). HUD: A simple HUD (Heads Up Display) with only Life and Score displayed in the upper left corner. Life: Number of remaining lives of the player character (up to 5). If the player\u0026rsquo;s plane is hit by a homing missile from a tank, it will be reduced by 1. When it reaches 0, the game is over (debug panel will close). Score: Enemy character\u0026rsquo;s life (max 3) is reduced by 1 when the tank is hit by a machine gun round, and 1 point is added when it reaches 0 and the tank is destroyed. Making a homing missile Creating a scene First, follow the steps below to create a scene for a homing missile.\nselect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Node\u0026rdquo; in \u0026ldquo;Generate Root Node\u0026rdquo;. Select a node of \u0026ldquo;Area2D\u0026rdquo; class as a root node. Rename the root node \u0026ldquo;Area2D\u0026rdquo; to \u0026ldquo;Missile\u0026rdquo;. Save the scene here once, and set the file path to \u0026ldquo;res://Enemy/Missile.tscn\u0026rdquo;. Next, add child nodes to the root node \u0026ldquo;Missile\u0026rdquo;.\nadd a node of \u0026ldquo;Sprite\u0026rdquo; class to the root node \u0026ldquo;Missile\u0026rdquo;. This is the appearance of a missile. Add a node of the \u0026ldquo;CollisionShape2D\u0026rdquo; class to the root node \u0026ldquo;Missile. This is used to detect the collision of the missile with the player\u0026rsquo;s plane and the machine gun projectile it fired. Add a node of the \u0026ldquo;Timer\u0026rdquo; class to the root node \u0026ldquo;Missile\u0026rdquo;. This is to release the missile instance after a certain period of time. The scene tree should now look like the following.\nEditing node properties Let\u0026rsquo;s edit the properties of each node in the scene tree in the inspector.\nMissile (Area2D) Root node Edit the \u0026ldquo;Collision\u0026rdquo; \u0026gt; \u0026ldquo;Layer\u0026rdquo; property and \u0026ldquo;Collision\u0026rdquo; \u0026gt; \u0026ldquo;Mask\u0026rdquo; property of the \u0026ldquo;CollisionObject2D\u0026rdquo; class.\nThe \u0026ldquo;Layer\u0026rdquo; property allows you to set which collision layer the object (in this case, the \u0026ldquo;Missile\u0026rdquo; node) will be assigned to.\nThe \u0026ldquo;Mask\u0026rdquo; property allows you to set which collision layer the object will enable collisions with objects in that layer. In other words, objects in layers not selected by the \u0026ldquo;Mask\u0026rdquo; property will pass through each other without colliding, even if their positions overlap.\nFor example, a homing missile will pass through without collision with an enemy character\u0026rsquo;s tank, but collisions with the player character or machine gun bullets must be detected. Since the player character\u0026rsquo;s plane is flying over the tank, collisions with the tank are ignored, while collisions with homing missiles need to be detected.\nTo make it easier to understand which object is assigned to which collision layer, I have already named the collision layers to be used by following the steps below.\nopen the \u0026ldquo;Project\u0026rdquo; menu \u0026gt; \u0026ldquo;Project Settings Select \u0026ldquo;Layer Names\u0026rdquo; \u0026gt; \u0026ldquo;2d Physics\u0026rdquo; from the sidebar. Set the names of Layers 1 to 4 as follows. Layer 1: Player Layer 2: Enemies Layer 3: PlayerBullets Layer 4: EnemyMissiles\nThe \u0026ldquo;Layer\u0026rdquo; and \u0026ldquo;Mask\u0026rdquo; properties of the player character, machine gun bullets, and enemy characters have already been set as follows, according to the collision layer names above.\nPlayer Character: Player.tscn scene \u0026gt; Player (KinematicBody2D) root node Layer properties: Layer 1 Mask property: Layer 4 (detects collisions with missiles)\nEnemy character: Enemy.tscn scene \u0026gt; Enemy (KinematicBody2D) root node Layer property: Layer 2 Mask property: Layer 2, 3 (detects collisions with other tanks and machine gun bullets)\nMachine gun bullet: Bullet.tscn scene \u0026gt; Bullet (Area2D) root node Layer property: Layer 3 Mask property: Layer 2, 4 (detects collisions between tanks and homing missiles)\nAnd I would like you to set up the homing missile you are editing now as well, as follows\nHoming missile: Missile.tscn \u0026gt; Missile (Area2D) root node Layer property: Layer 4 Mask property: Layer 1, 3 (detects collisions between planes and machine gun bullets)\nOnce we have edited the properties of the root node \u0026ldquo;Missile\u0026rdquo;, we should incidentally add this node by creating a group called \u0026ldquo;Missiles\u0026rdquo;. This is used to determine whether a missile is a missile or not when a machine gun bullet hits a missile.\nselect \u0026ldquo;Missile\u0026rdquo; in the scene tree dock open the node dock \u0026gt; group tab and add the group \u0026ldquo;Missiles\u0026rdquo;.\nSprite Node The method of setting a texture for a sprite by specifying the range of textures you want to use from a single sprite sheet that contains many textures is used.\nIn the inspector, apply the resource file \u0026ldquo;res://towerDefense_tilesheet.png\u0026rdquo; to the \u0026ldquo;Texture\u0026rdquo; property.\nTurn on \u0026ldquo;Region\u0026rdquo; \u0026gt; \u0026ldquo;Enabled\u0026rdquo;.\nopen the \u0026ldquo;Texture Region\u0026rdquo; panel at the bottom of the editor and specify the region of the texture you want to use in the sprite sheet.\nFirst, expand the panel to the top of the editor so that it is easy to see, and then enlarge the sprite sheet to a size that is easy to see.\nselect \u0026ldquo;Grid Snap\u0026rdquo; in \u0026ldquo;Snap Mode\u0026rdquo; at the top of the \u0026ldquo;Texture Region\u0026rdquo; panel.\nset the \u0026ldquo;step\u0026rdquo; at the top of the panel to 64px 64px as well. This will make the grid the same size as the sprites on the sprite sheet.\nselect the texture of the larger missile on the sprite sheet.\nReturn to the inspector and set the \u0026ldquo;Transform\u0026rdquo; \u0026gt; \u0026ldquo;Rotation\u0026rdquo; property to 90.\nThis will rotate the texture by 90°. Since the object\u0026rsquo;s normal orientation is 0° along the positive x-axis and the missile\u0026rsquo;s direction of travel is based on this, the sprite\u0026rsquo;s orientation was adjusted accordingly.\nCollisionShape2D node This node sets the collision shape of the homing missile. It is required to determine the collision between the missile and the player character, and the system will alert you if a child node that sets the collision shape has not been added to the \u0026ldquo;Area2D\u0026rdquo; class node.\nIn the inspector, apply the \u0026ldquo;New CapsuleShape2D\u0026rdquo; resource to the \u0026ldquo;Shape\u0026rdquo; property.\nIn the 2D workspace, match the collision shape to the size of the \u0026ldquo;Sprite\u0026rdquo; node texture.\nIf you want to enter directly in the inspector, set the properties of the \u0026ldquo;CapsuleShape2D\u0026rdquo; resource as follows Set the \u0026ldquo;Radius\u0026rdquo; property to 8. Set the \u0026ldquo;Height\u0026rdquo; property to 24.\nTimer node This node is a timer for homing missiles to self-destruct after a certain amount of time. If missiles continue to exist in the game indefinitely, the number of missiles will grow and the computer will run out of memory to handle them. To avoid this, the system is designed to release instances when the time expires. For missiles that fly in a straight line, it is possible to use the signal of the \u0026ldquo;VisibilityNotifier2D\u0026rdquo; node to release instances when they go off the screen, but for homing missiles that track the player character, a timer is more appropriate.\nIn the inspector, set the \u0026ldquo;Wait Time\u0026rdquo; property to 3. This is the effective time of the missile. You can tweak it to your liking, but be aware that if it is too long, there will be too many missiles at the same time, which will consume too much memory. Turn on the \u0026ldquo;One Shot\u0026rdquo; property. Turn on the \u0026ldquo;Auto Start\u0026rdquo; property.\nThis completes the property editing for each node.\nControlling it with a script Next, we will create a script to control the missile. We want you to attach a new script to the root node \u0026ldquo;Missile\u0026rdquo;. The file path should be created as \u0026ldquo;res://Enemy/Missile.gd\u0026rdquo;.\nFirst, edit the \u0026ldquo;Missile.gd\u0026rdquo; script as follows.\n### Missile.gd ### extends Node2D # Missile speed export var speed = 400 # Velocity of the missile var velocity = Vector2() # Physics process func _physics_process(delta): # velocity = current orientation x speed velocity = transform.x * speed # Update position: current position + velocity x delta (seconds per frame) position += velocity * delta # Update orientation: match current velocity rotation = velocity.angle() Now, the missile should fly straight for the time being. Let\u0026rsquo;s run the scene and check it out.\nCan you see the missile flying from left to right across the top portion of the GIF image?\nNext, we will add the motion to track the player character to the script. First, let\u0026rsquo;s define some necessary properties. In the following code, please add the commented \u0026ldquo;# Add\u0026rdquo;.\n### Missile.gd ### extends Node2D export var speed = 400 # Add: the ability to steer in the direction the player is in. # The higher the value, the quicker the direction correction export var steering_force = 20.0 var velocity = Vector2() # Add: acceleration var acceleration = Vector2() # Reference to the target Player object (as soon as detected) var target = null Next, define the method by which the missile will steer toward the player character (correct its trajectory).\n### Missile.gd ### # method to steer the missile towards the player character func steer(): # Define as velocity to steer var steering = Vector2() # Define ideal velocity (direction x speed towards player character from current position) var ideal_velocity = (target.position - position).normalized() * speed # speed to steer = direction vector obtained by ideal_velocity - current_velocity x force to steer steering = (ideal_velocity - velocity).normalized() * steering_force # output velocity to steer return steering Since it may be difficult to visualize from the comments on the code alone, I will supplement this with a diagram.\nWhen the homing missile detects the player character\u0026rsquo;s plane, it will track it as a target. The ideal velocity is the variable ideal_velocity, assuming that the missile could travel in a straight line in the direction of the target. In reality, however, the missile is flying in the direction that the property velocity has, and we want to steer it toward ideal_velocity to correct its trajectory.\nThat\u0026rsquo;s where the vector calculation comes in. If we take the vector ideal_velocity minus velocity and turn it into a direction vector (a vector of length 1) using the method normalized. Then, multiply it by the value of the property steering_force, which is the force to steer, the value of the variable steering is determined, which is the velocity to steer.\nNow, let\u0026rsquo;s use the value of the variable steering output by the method steer to modify the missile so that it flies while correcting its trajectory. Please add the comment \u0026ldquo;# Add\u0026rdquo; to the method _physics_process.\n### Missile.gd ### func _physics_process(delta): velocity = transform.x * speed # Add: add velocity to steer to acceleration acceleration += steer() # Add: add the velocity plus the acceleration x delta value to the velocity velocity += acceleration * delta # Add: limit the length of the velocity vector so that it does not exceed the speed velocity = velocity.clamped(speed) position += velocity * delta rotation = velocity.angle() This should have implemented the movement of the homing missile tracking the player character.\nLet\u0026rsquo;s continue by adding a program for when the missile hits the player character or the machine gun projectile. For this, we will use the signal of the Area2D class of the root node \u0026ldquo;Missile\u0026rdquo;.\nNow, after selecting \u0026ldquo;Missile\u0026rdquo; in the scene tree dock, go to the node dock \u0026gt; Signal tab and connect the signal \u0026ldquo;body_entered(body: Node)\u0026rdquo; to this \u0026ldquo;Missile.gd\u0026rdquo; script.\nAfter connecting, edit the automatically generated method _on_Missile_body_entered as follows.\n### Missile.gd ### # Method called by the signal sent when the physical body is hit by a missile func _on_Missile_body_entered(body): # If the physical body is the player character if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Missile hit \u0026#34;, body.name) # Play the animation \u0026#34;hit\u0026#34; of the AnimationPlayer in the Player scene body.anim_player.play(\u0026#34;hit\u0026#34;) # Emit the signal player_hit for the Player node body.emit_signal(\u0026#34;player_hit\u0026#34;) # If the Player\u0026#39;s Life is greater than 1, set it to -1 if body.life \u0026gt; 1: body.life -= 1 # if the Player\u0026#39;s Life is less than 1 else: # wait for animation hit to finish playing yield(body.anim_player, \u0026#34;animation_finished\u0026#34;) # release the Player object body.queue_free() print(\u0026#34;Game Over!\u0026#34;) # Close debug panel and exit get_tree().quit() # release the missile itself queue_free() Now, when a missile hits the player character\u0026rsquo;s plane, it animates (flashes red) and the player\u0026rsquo;s Life is reduced by one, and the game is over when there are no more than 0 planes left.\nThe next step is to create a mechanism to release the missile when the time expires using the timer in the \u0026ldquo;Timer\u0026rdquo; node. This also uses the signal of the \u0026ldquo;Timer\u0026rdquo; node. Now, select \u0026ldquo;Timer\u0026rdquo; in the scene tree dock, and connect the signal \u0026ldquo;timeout()\u0026rdquo; to the script.\nIn the block of the method _on_Timer_timeout generated by the connection, simply add the method queue_free.\n### Missile.gd ### func _on_Timer_timeout(): queue_free() The missile is now complete.\nMaking the enemy character launch a homing missile The next step is for the \u0026ldquo;Enemy.tscn\u0026rdquo; scene to create an instance of the \u0026ldquo;Missile.tscn\u0026rdquo; scene that we just created, so that the enemy character\u0026rsquo;s tank fires homing missiles.\nEditing and controlling the script Let\u0026rsquo;s open and edit the \u0026ldquo;Enemy.gd\u0026rdquo; script attached to the root node \u0026ldquo;Enemy\u0026rdquo; in the \u0026ldquo;Enemy.tscn\u0026rdquo; scene.\nFirst, let\u0026rsquo;s preload the missile scene file. At the beginning of the script, define constants for references. You will see the comment \u0026ldquo;# Add\u0026rdquo;.\n### Enemy.gd ### extends KinematicBody2D signal enemy_killed # Add: reference to preloaded Missile.tscn scene file const missile_scn = preload(\u0026#34;res://Enemy/Missile.tscn\u0026#34;) Next, since the block of the method _on_Timer_timeout contains only pass, please update it as follows. Incidentally, this method was generated by connecting the signal \u0026ldquo;timeout()\u0026rdquo; of the \u0026ldquo;LaunchTimer\u0026rdquo; node (Timer class). In other words, this method is called every time the timer times out.\n### Enemy.gd ### # Method called by a signal sent out when a LaunchTimer node times out func _on_LaunchTimer_timeout(): # If the parent node (World) has a node named Player if get_parent().has_node(\u0026#34;Player\u0026#34;): # call the method to launch the missile launch_missile() Please insert the following code defining the method launch_missile, which is described at the end of the above code, after the above _on_LaunchTimer_timeout.\n### Enemy.gd ### # Method to launch a missile func launch_missile(): # Instantiate the Missile.tscn scene var missile = missile_scn.instance() # Assign the Player object to Missile\u0026#39;s target property missile.target = get_parent().get_node(\u0026#34;Player\u0026#34;) # Add a missile instance to the parent node (World) get_parent().add_child(missile) # Align the missile with the tip of the tank\u0026#39;s cannon missile.position = muzzle.global_position # Align the direction of the missile with the direction of the tip of the tank\u0026#39;s cannon missile.rotation = muzzle.global_rotation The missile should now be able to be launched. Let\u0026rsquo;s run the project to see if the implementation so far works without problem.\nExtra: Adding visual effects For visual effect, we have prepared explosion particles when the missile hits and smoke particles coming out from behind the missile in the preliminary stage. Let\u0026rsquo;s use these by adding code to the \u0026ldquo;Missile.gd\u0026rdquo; script to give the missile a more visually appealing performance.\nAfter opening the \u0026ldquo;Missile.gd\u0026rdquo; script, add the line \u0026ldquo;# Add\u0026rdquo; to the code.\n### Missile.gd ### # Add: See preloading Smoke.tscn (scene with only smoke particles) const smoke_scn = preload(\u0026#34;res://Effect/Smoke.tscn\u0026#34;) # Add: Preload reference to Explosion.tscn (scene with only explosion particles) const explosion_scn = preload(\u0026#34;res://Effect/Explosion.tscn\u0026#34;) export var speed = 400 export var steering_force = 20.0 var velocity = Vector2() var acceleration = Vector2() var target = null # Add: count to space out the smoke var smoke_count = 0 Next, call the method that produces the smoke within the _physics_process method.\n### Missile.gd ### func _physics_process(delta): velocity = transform.x * speed acceleration += steer() velocity += acceleration * delta velocity = velocity.clamped(speed) position += velocity * delta rotation = velocity.angle() # Add the value of delta to smoke_count smoke_count += delta # If smoke_count is greater than 0.05 if smoke_count \u0026gt; 0.05: # Set smoke_count back to 0 smoke_count = 0 # Call the method that spawns the smoke spawn_smoke() And let\u0026rsquo;s define the last method spawn_smoke as follows. This code should be inserted under the steer method.\n### Missile.gd ### # spawn_smoke() method func spawn_smoke(): # Instantiate a scene of smoke particles var smoke = smoke_scn.instance() # Add instance node to parent node (World) get_parent().add_child(smoke) # Put smoke at current missile position smoke.position = global_position # Align the direction of the smoke with the direction of the current missile (doesn\u0026#39;t make much sense) smoke.rotation = global_rotation Next, we now define a method to generate explosion particles. Add it under the method spawn_smoke above.\n### Missile.gd ### # 爆発させるメソッド func explode(): # Instantiate a scene of explosion particles var explosion = explosion_scn.instance() # Add instance node to parent node (World) get_parent().add_child(explosion) # Place the explosion particle at the current missile position explosion.position = global_position # Align the orientation of the explosion particle with the orientation of the current missile (doesn\u0026#39;t make much sense) explosion.rotation = global_rotation Let\u0026rsquo;s update the code to call the method explode at the three places with the following \u0026ldquo;# Add\u0026rdquo; comments.\n### Missile.gd ### func _on_Missile_body_entered(body): if body.name == \u0026#34;Player\u0026#34;: print(\u0026#34;Missile hit \u0026#34;, body.name) body.anim_player.play(\u0026#34;hit\u0026#34;) body.emit_signal(\u0026#34;player_hit\u0026#34;) if body.life \u0026gt; 1: body.life -= 1 else: explode() # Add yield(body.anim_player, \u0026#34;animation_finished\u0026#34;) body.queue_free() print(\u0026#34;Game Over!\u0026#34;) get_tree().quit() explode() # Add queue_free() func _on_Timer_timeout(): explode() # Add queue_free() That\u0026rsquo;s all for the update. Let\u0026rsquo;s run the project one last time to see the direction we added.\nBy the way, both smoke and explosion particles use the \u0026ldquo;Particles2D\u0026rdquo; class node. macOS seems to have some performance issues with this node. I\u0026rsquo;m a macOS user, and it certainly caused a delay. You may be able to see it in the gif image above.\nIf you are using macOS, you can convert the root node (Particles2D class) to the \u0026ldquo;CPUParticles2D\u0026rdquo; class using \u0026ldquo;Convert to CPUParticles2D\u0026rdquo; from \u0026ldquo;Paricles\u0026rdquo; on the toolbar with the root node selected in the scene tree dock. It seems to be possible to convert it to the \u0026ldquo;CPUParticles2D\u0026rdquo; class.\nConclusion In this tutorial, we created a homing missile in top-down shooting. Let\u0026rsquo;s summarize the key points in creating it.\nThe missile scene should be programmed to fly by itself as soon as an instance is added. To reproduce the tracking motion of the missile, sequentially perform the following every frame in the physics process. Multiply the direction vector to the target (the \u0026ldquo;Player\u0026rdquo; in this tutorial) by the speed to obtain the ideal velocity. Normalize the vector of the difference between the ideal velocity and the actual velocity to find the direction to steer. Multiply the direction to steer by the force to steer predefined by the property to obtain the speed to steer. Add the velocity to steer to the current acceleration. Add the updated acceleration to the current velocity. When creating an instance of a missile scene, make it a child of an object that does not move, such as its parent node (\u0026ldquo;World\u0026rdquo; in this tutorial), rather than of an object that rotates or moves (\u0026ldquo;Enemy\u0026rdquo; in this tutorial), so that the missile will fly correctly. To reduce memory consumption, use Timer\u0026rsquo;s signal so that the missile instance is released at timeout. Links The YouTube videos and articles on KidsCanCode were very helpful in preparing this tutorial. I would like to take this opportunity to thank them. For a better understanding, we recommend that you also view those contents.\nGodot Docs: Matrices and transforms YouTube: Godot Recipes: Homing Missiles YouTube: Godot 3.0: Top-down Tank Battle - Part 10: Homing Missiles KidsCanCode: HOMING MISSILE ","permalink":"https://www.peanuts-code.com/en/tutorials/gd0008_homing_missiles/","summary":"In this tutorial, we will create a homing missile in a 2D top-down shooter. A homing missile is a missile that tracks its target. Environment This tutorial was created in the following environment ・Godot version: 3.4.2 ・Computer OS version: macOS 11.6.5 To focus on the creation of the homing missile, the rest of the project has been pre-created in advance. The project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;Start\u0026rdquo; folder into the","title":"Homing missiles in Godot Engine"},{"content":"In this time, we will create a bullet hell aka barrage for a barrage shooting game. The bullet hell is a large number of bullets (or similar long-range attacks) like a curtain. A \u0026ldquo;bullet hell shooter\u0026rdquo; is a game in which the player shoots at and defeats enemy characters while dodging and weaving through the gaps between the bullets. Some games specialize in simply dodging the bullets. Many games are based on the motif of spaceships and fighter planes that fit the image (in this tutorial, a ground battle between a wizard and a monster though).\nIn this tutorial, we will focus only on creating a bullet hell. Also, while bullet hell come in various shapes and sizes, we will focus on rotating-type bullet hell.\nEnvironment This tutorial was created in the following environment\n・Godot version: 3.4.2\n・Computer OS version: macOS 11.6.5\nThe project file for this tutorial is located at GitHub repository . After downloading the .zip file, import the \u0026ldquo;project.godot\u0026rdquo; file in the \u0026ldquo;Start\u0026rdquo; folder into the Godot Engine, and you will be able to start with a project that has only been prepped. If you would like to see the completed project in a hurry, import the \u0026ldquo;project.godot\u0026rdquo; file from the \u0026ldquo;End\u0026rdquo; folder.\nAll the assets imported into the project were downloaded from KENNEY website. I used an asset pack called 1-Bit Pack . I can\u0026rsquo;t help but be thankful for this wonderful free material.\nNow, when you open the project in the \u0026ldquo;Start\u0026rdquo; folder in Godot Engine, the following are already created.\n1.Player character (wizard) 2.\n2.Player character\u0026rsquo;s long-range attack (magic) 3.\n3.Enemy character (the monster who releases a barrage of bullets) 4.\n4.Game world (the game world in which the above objects exist)\nFirst of all, please run the project in the \u0026ldquo;Start\u0026rdquo; folder, where only the preliminary work has been completed, to see how it works.\nThe game is set up as follows.\nThe player character can control movement and magic long-range attacks with the keys below. move_up: W key - the player character moves up. move_down: S key \u0026mdash; moves the player character down. move_right: D key - moves the player character right. move_left: A key - moves the player character left. magic: Spacebar or left mouse button - Casts a spell. The player character dies after 10 hits from enemy character bullets. If the player character dies, the game is over (debug panel closes automatically). The enemy character can only move for now. The enemy character will move toward the player character every 2 seconds. Enemy character dies after 5 magic hits. Magic is ineffective while Enemy characters are flashing red and white after a hit. When an enemy character dies, the next enemy character appears within a radius of 50px from the player character. The appearance of the enemy character changes randomly each time. The player character\u0026rsquo;s magic disappears 1 second after it is released. The game world can be moved unlimitedly. Creating a bullet scene To create a bullet hell scene, we need each of the bullets that make it up. Therefore, we will start by creating the bullet scene.\nCreating a scene Create a new scene of a bullet by following the steps below.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Node\u0026rdquo; in \u0026ldquo;Generate Root Node\u0026rdquo;. Select a node of the \u0026ldquo;Area2D\u0026rdquo; class as a root node. Rename the root node \u0026ldquo;Area2D\u0026rdquo; to \u0026ldquo;Bullet\u0026rdquo;. Save the scene here once, setting the file path to \u0026ldquo;res://Enemy/Bullet.tscn\u0026rdquo;. Adding nodes to the scene Next, add child nodes to the root node \u0026ldquo;Bullet.\nadd a node of the class \u0026ldquo;Sprite\u0026rdquo; to the root node \u0026ldquo;Bullet\u0026rdquo;. This is the appearance of a bullet. Add a node of the \u0026ldquo;CollisionShape2D\u0026rdquo; class to the root node \u0026ldquo;Bullet\u0026rdquo;. This is used to detect when the bullet collides with the physical body. Add a node of the \u0026ldquo;VisibilityNotifier2D\u0026rdquo; class to the root node \u0026ldquo;Bullet\u0026rdquo;. This is used to detect when a bullet goes off the screen. Official Godot Docs: VisibilityNotifier2D The scene tree should now look like this.\nEditing the properties of the nodes Continue to edit the properties of each node.\nBullet（Area2D）node No editing of the properties of this root node is required.\nSprite node In this case, we will use the method of setting the sprite texture by specifying the range of textures to be used from a single sprite sheet that contains a large number of textures.\nIn the inspector, apply the resource file \u0026ldquo;res://colored-transparent_packed.png\u0026rdquo; to the \u0026ldquo;Texture\u0026rdquo; property of the \u0026ldquo;Sprite\u0026rdquo; node.\nTurn on \u0026ldquo;Region\u0026rdquo; \u0026gt; \u0026ldquo;Enabled\u0026rdquo;\nOpen the \u0026ldquo;Texture Region\u0026rdquo; panel at the bottom of the editor and specify the region of the texture you want to use in the sprite sheet.\nFirst, expand the panel to the top of the editor for easy viewing, and then enlarge the sprite sheet to a size that is easy to see. Select \u0026ldquo;Grid Snap\u0026rdquo; in \u0026ldquo;Snap Mode\u0026rdquo; at the top of the \u0026ldquo;Texture Region\u0026rdquo; panel.\nSet the \u0026ldquo;Step\u0026rdquo; at the top of the panel to 16px 16px as well. This will make the grid the same size as the sprites on the sprite sheet.\nSelect the texture you want to apply to the bullet on the sprite sheet. In this tutorial, we selected a skull texture. It is a horror that a monster will release a barrage of skull bullets.\nReturn to the inspector and change the color to the bullet color of your choice in the Visibility \u0026gt; Modulate property. Here, as a sample, we have chosen the somewhat eerie purple color #9da4d8.\nCollisionShape2D node In the inspector, apply the \u0026ldquo;New CircleShape2D\u0026rdquo; resource to the \u0026ldquo;Shape\u0026rdquo; property.\nIn the 2D workspace, match the collision shape to the size of the \u0026ldquo;Sprite\u0026rdquo; node texture.\nIf entering directly in the inspector, set the \u0026ldquo;Radius\u0026rdquo; property of the \u0026ldquo;CircleShape2D\u0026rdquo; resource to 8.\nVisibilityNotifier2D node No editing of the properties of this root node is required.\nControlling bullets with a script Next, let\u0026rsquo;s program a script to control bullets. Let\u0026rsquo;s attach a new script to the root node \u0026ldquo;Bullet\u0026rdquo;. Create the file path as \u0026ldquo;res://Enemy/Bullet.gd\u0026rdquo;.\nFirst, edit the script as follows.\n### Bullet.gd ### extends Node2D # Seconds of a bullet export var speed = 150 # Physical process method called 60 times/second func _physics_process(delta): # Move the bullet every frame by adding the current bullet position to.. # the current bullet direction x the current bullet direction x.. # the speed of the bullet per second x 1 frame of time position += transform.x * speed * delta Next, since the root node \u0026ldquo;Bullet\u0026rdquo; is an Area2D class, we will use its signal to make the bullet disappear when it hits the physical body. Select \u0026ldquo;Bullet\u0026rdquo; in the inspector and connect the signal \u0026ldquo;body_entered(body)\u0026rdquo; to this \u0026ldquo;Bullet.gd\u0026rdquo; script in the Node Dock \u0026gt; Signal tab.\nExecute method queue_free in method _on_Bullet_body_entered generated by connecting signals.\n### Bullet.gd ### # Methods called by signals sent out when physical bodies collide func _on_Bullet_body_entered(body): # free Bullet queue_free() Similarly, use the signal of the \u0026ldquo;VisibilityNotifier2D\u0026rdquo; node to make the bullet disappear when it goes off the screen. Let\u0026rsquo;s connect the \u0026ldquo;VisibilityNotifier2D\u0026rdquo; signal \u0026ldquo;screen_exited()\u0026rdquo; to this \u0026ldquo;Bullet.gd\u0026rdquo; script.\nExecute method queue_free in method _on_VisibilityNotifier2D_screen_exited generated by connecting the signal.\n### Bullet.gd ### # Method called by a signal that is sent out when Bullet go off-screen func _on_VisibilityNotifier2D_screen_exited(): # free Bullet queue_free() This completes the Bullet scene. After this, the created bullet scene instance is added to the enemy character\u0026rsquo;s scene tree so that the enemy character can fire bullets.\nCreating a bullet hell Controlling the bullet hell with a script From here, we will edit the script \u0026ldquo;Enemy.gd\u0026rdquo; attached to the root node \u0026ldquo;Enemy\u0026rdquo; in the \u0026ldquo;Enemy.tscn\u0026rdquo; scene of the enemy character to control the bullet hell. After opening \u0026ldquo;Enemy.gd\u0026rdquo; in the script editor, let\u0026rsquo;s first define the necessary properties. In the following code, please add the code where it is commented \u0026ldquo;# Add\u0026rdquo;.\n### Enemy.gd ### extends KinematicBody2D signal died # Add: reference to preloaded Bullet.tscn const bullet_scn = preload(\u0026#34;res://Enemy/Bullet.tscn\u0026#34;) var enemy_life = 5 var enemy_speed = 800 var delta_count = 0 # Add: Distance from the center of the Enemy to the firing position of the bullet var radius = 20 # Add: Rotation speed of the bullet\u0026#39;s firing position around the Enemy export var rotate_speed = 40 # Add: Interval between firing bullets (seconds) export var interval = 0.4 # Add: Number of bullets fired at one time export var spawning_count = 4 It may be a little difficult to visualize from the comments in the code alone, so a diagram is attached.\nAs you can see, it is easy to imagine a circle with \u0026ldquo;Enemy\u0026rdquo; as its center and the value of the property radius as its radius. Of the bullets to be fired at a time specified by the property spawning_count, the first firing position should always be (x: radius, y: 0), and the second and subsequent bullets should be placed from there at equal intervals (angle difference) around the circumference of this circle. The bullets are shifted by the property rotate_speed in a clockwise direction every second specified by the property interval, and then fired.\nThen edit the _ready method, which is called the first time the scene is loaded. In the _ready method, add the code for initialization necessary to generate the bullet hell. It should be easier to understand if you can visualize the above diagram.\n### Enemy.gd ### func _ready(): anim_player.play(\u0026#34;spawn\u0026#34;) randomize() sprite.frame = randi() % sprite.hframes ### Add all of the following ### # Define step as the interval (angle difference) between bullets fired at once # step is 180° x 2 = 360° divided by the value of the property Spawning_count var step = PI * 2 / spawning_count # Loop for the number of values in spawning_count # e.g) If spawning_count is 4, i will be filled with 0 ~ 3 in that order for i in spawning_count: # Create a new Node2D node to be used as a marker of the bullet\u0026#39;s firing position... # and define it as spawn_point var spawn_point = Node2D.new() # Define the firing position as pos # Define pos as the position rotated by (step x i) from the base position (x: radius, y: 0) var pos = Vector2(radius, 0).rotated(step * i) # Place spawn_point at the bullet\u0026#39;s firing position spawn_point.position = pos # Align the orientation of the spawn_point with.. # the angle from the positive x-axis to the firing position spawn_point.rotation = pos.angle() # Make spawn_point a child of the Rotater node (Node2D)... # that has been prepared in advance as a node for rotation rotater.add_child(spawn_point) # Set the wait_time property of the Timer node with the value of the interval property timer.wait_time = interval # Wait until the animation of the AnimationPlayer node is finished yield(anim_player, \u0026#34;animation_finished\u0026#34;) # Start the timer of the Timer node timer.start() Now, every time the \u0026ldquo;Timer\u0026rdquo; node times out, place an instance of the \u0026ldquo;Bullet.tscn\u0026rdquo; scene you created earlier at the same position as the child node of the \u0026ldquo;Rotater\u0026rdquo; node (the spawn_point in the above code), and the bullets should fly automatically. Now let\u0026rsquo;s edit the _on_Timer_timeout method called by the \u0026ldquo;timeout\u0026rdquo; signal of the \u0026ldquo;Timer\u0026rdquo; node. Since the signal has already been connected in the preparation, replace pass in the method with the following content.\n### Enemy.gd ### # Methods called on the timeout signal of a Timer node func _on_Timer_timeout(): # Loop over the child nodes of the Rotater node for node2d in rotater.get_children(): # Instance of Bullet.tscn var bullet = bullet_scn.instance() # make Bullet instance node a child of its parent node (World node) rather than Enemy node get_parent().add_child(bullet) # Make the Bullet instance position the same as the Rotater child node position bullet.position = node2d.global_position # set the direction of the Bullet instance to be the same as... # the direction of the child node of Rotater bullet.rotation = node2d.global_rotation The firing position still does not rotate, but for the time being, it should now fire the specified number of bullets at the specified time difference. Let\u0026rsquo;s run the project.\nNext, let\u0026rsquo;s rotate the firing position of the bullets a bit to make it more like a bullet hell. This time, we will update the code in the _physics_process method a little. Please add the comment \u0026ldquo;# Add\u0026rdquo; in the following code.\n### Enemy.gd ### func _physics_process(delta): delta_count += delta if delta_count \u0026gt; 2: delta_count = 0 if get_parent().has_node(\u0026#34;Player\u0026#34;): anim_player.stop() anim_player.play(\u0026#34;move\u0026#34;) var direction = global_position.direction_to(get_parent().get_node(\u0026#34;Player\u0026#34;).global_position) var velocity = direction * enemy_speed velocity = move_and_slide(velocity) # Add: define next direction (angle) as new_rotation # new_rotation is the current rotation of the Rotater node + rotate_speed x the time of 1 frame var new_rotation = rotater.rotation + rotate_speed * delta # Add: rotate the Rotater node by the remainder (angle) of new_rotation divided by 360 rotater.rotate(fmod(new_rotation, 360)) Now the bullet\u0026rsquo;s firing position should rotate every 0.4 seconds as specified in the interval property. Let\u0026rsquo;s run the project again to see if it behaves as expected.\nCustomizing the bullet hell Properties defined in scripts can be easily edited in the inspector if the export keyword is added at the beginning. Let\u0026rsquo;s change the values to create a different bullet hell than the previous one.\nSample 1\nRotate Speed: 45 Interval: 0.5 Spawning Count: 10\nSample 2\nRotate Speed: 10 Interval: 0.1 Spawning Count: 8\nSample 2 has turned out to be a very devilish game. But what a thrilling and enjoyable experience.\nAdding randomness At the preliminary stage, the appearance of the enemy character (sprite texture) is coded to be randomly determined from six different types. If the properties of the bullet hell are also randomly determined, it would be interesting because it is impossible to predict what kind of bullet hell will be unleashed each time. In fact, it is surprisingly easy to implement this script by just adding a few codes to the script described so far.\nNow, open the \u0026ldquo;Enemy.gd\u0026rdquo; script in the Script Editor. First, define the upper and lower limits of each property to form the bullet hell that has already been prepared in a separate property. Let\u0026rsquo;s update the lines commented \u0026ldquo;# Add\u0026rdquo; and \u0026ldquo;# Change\u0026rdquo; in the following code.\n### Enemy.gd ### var radius = 20 export var rotate_speed: float # Change: only define type and leave value undefined export var max_rotate_speed = 80 # Add export var min_rotate_speed = 20 # Add export var interval: float # Change: only define type and leave value undefined export var max_interval = 0.8 # Add export var min_interval = 0.2 # Add export var spawning_count: int # Change: only define type and leave value undefined export var max_spawning_count = 10 # Add export var min_spawning_count = 2 # Add Next, edit the _ready method, as we need to apply random values to each property at the time the scene is loaded. Let\u0026rsquo;s add the lines commented \u0026ldquo;# Add\u0026rdquo; in the code below.\nfunc _ready(): anim_player.play(\u0026#34;spawn\u0026#34;) # enable random value generation randomize() sprite.frame = randi() % sprite.hframes # int, max: 5 # Add: assign a random fraction to rotate_speed with... # min_rotate_speed as the lower limit and max_rotate_speed as the upper limit rotate_speed = rand_range(min_rotate_speed, max_rotate_speed) # Add: Assign a random fraction to interval with... # min_interval as the lower limit and max_interval as the upper limit interval = rand_range(min_interval, max_interval) # Add: The upper limit is -1 from the specified value in the subsequent calculation... # so it is adjusted by +1 first. max_spawning_count += 1 # Add: Assign a random integer to spawning_count with... # min_spawning_count as the lower limit and max_spawning_count as the upper limit spawning_count = randi() % max_spawning_count + min_spawning_count var step = PI * 2 / spawning_count for i in spawning_count: var spawn_point = Node2D.new() var pos = Vector2(radius, 0).rotated(step * i) spawn_point.position = pos spawn_point.rotation = pos.angle() rotater.add_child(spawn_point) timer.wait_time = interval yield(anim_player, \u0026#34;animation_finished\u0026#34;) timer.start() A few additional notes on the generation of random values.\nFirst, rand_range returns a random float number with the first argument as the lower limit and the second argument as the upper limit. It is used for the properties rotate_speed and interval because these properties are defined as float types.\nNext, randi is a method that returns a random integer, but since it takes no arguments, it is not possible to specify an upper or lower limit.\nTherefore, we use the fact that the remainder when the returned value is divided by the upper limit is 0 or more and less than (upper limit -1). Since the maximum value is the specified upper limit -1, put a code max_spawning_count += 1 one line earlier to add +1.\nThe symbol % (modulo) can be used to obtain the remainder obtained by dividing a by b using a % b. If we add c to that value as a % b + c, the result cannot be smaller than c. In other words, a random integer with upper and lower bounds can be expressed as randi() % upper bound + lower bound. Remember that the maximum value returned is the upper limit -1.\nIn this case, the randomize method was written first, but without it, the result will be the same every time, so if you use methods that return a random value, it is good to remember to write it at the beginning of the _ready method.\nFinally, let\u0026rsquo;s run the project to see if each monster that appears will have a different bullet hell.\nConclusion In this tutorial, we created a bullet hell for a top-down shooter. For a rotating bullet hell like this one, the following points will be important.\nSet the radius of the circle, the rotation speed of the firing position, the time difference of firing, and the number of simultaneously fired bullets with properties Prepare a node for rotation. Calculate the firing position based on the radius of the circle and the number of rounds fired simultaneously. Add child nodes to the Rotater node to mark the firing position. Set the timer time to the time difference of the firing. In the physics process, always rotate the Rotater node according to the rotation speed When the timer times out, an instance of the bullet is created at the location of the marker node. There might be better ways to implement this, and I hope that you will experiment with various methods and finally adopt the best one.\nIn addition, actual bullet shooters are not only rotating types like this one, but are also diverse, such as wave-shaped, fan-shaped, etc. If you are interested in this, please look into it.\nLinks Godot Docs: Matrices and transforms YouTube: How to Make a Bullet Hell Projectile Pattern Generator in Godot YouTube: How to Make a Bullet Hell Game in Godot [P1] - Basic Collisions UPDATE\n2022/05/25 Added keys control settings.\n","permalink":"https://www.peanuts-code.com/en/tutorials/gd0007_bullethell/","summary":"In this time, we will create a bullet hell aka barrage for a barrage shooting game. The bullet hell is a large number of bullets (or similar long-range attacks) like a curtain. A \u0026ldquo;bullet hell shooter\u0026rdquo; is a game in which the player shoots at and defeats enemy characters while dodging and weaving through the gaps between the bullets. Some games specialize in simply dodging the bullets. Many games are based on the motif of spaceships and fighter planes that fit the image (in this tutorial, a ground battle between a wizard and a monster though).\nIn this tutorial, we will focus only on creating a bullet hell.","title":"Bullet hell in Godot Engine"},{"content":"This article is especially worth reading if you are a beginner who has just started or is thinking about starting game development. We hope you will read it through to the end.\nNow, do you have a dream game that you really want to make? Many people who have started or are thinking of starting game development probably dream of such a game. And that game will have plenty of elements of games that you have played and been influenced by in your life.\nAs you can probably guess, this article is now going to make the claim that you should save your dream game for the future. However, this assertion is not brand new, but rather a rather common piece of advice for novice game developers. Let me explain why you should save your dream game for the future.\nElements that tend to be included in the dream game What elements tend to be included in a dream game? By the way, the elements here are the specifications and functions of the game. The following is a list of those that come to mind as examples.\nmultiplayer support online play open world high-resolution 3D game character animation with motion capture AR / VR AI using machine learning game world, historical background, and character setting with an ultra-heavy storyline multiple endings that branch by player choice huge number of characters, monsters, and items huge amount of character dialogue full voice of all characters Did any of the elements in the list above apply to your dream game? Developing a game that includes the elements on the list is very hard for beginners. If your dream game does not fit into the above list, it may be a relatively easy game to develop. For example, if you want to make a game in the so-called \u0026ldquo;casual game\u0026rdquo; genre, you can start developing it even if you are a beginner because it falls outside the definition of dream game in this article.\nTwo major barriers stand in the way of developing a game that includes the elements listed above. One is the \u0026ldquo;skill barrier\u0026rdquo; and the other is the \u0026ldquo;workload barrier.\nSkill barriers In particular, creating a game that includes elements 1 ~ 7 on the list requires advanced skills, and learning those skills is necessary to begin development.\nIt is rather common for engineers of all kinds, not just game developers, to develop while learning the necessary skills, but if you try to learn advanced skills without mastering the basics, you will first be overwhelmed by the level of difficulty. Since it is difficult to master the skills, development naturally does not progress as expected. The stress caused by the high level of difficulty and poor development progress will ultimately lead to an abandonment of the game project. This is one of the reasons why dream games should be saved for the future.\nYou can learn more efficiently if you learn the fundamentals and develop your skills diligently. Knowing your current abilities (but not underestimating them) and gradually increasing what you can do while building the games within your reach is very important to stay motivated. Until you gain some experience and improve your skills, put your dream game to bed.\nOn the other hand, even if you have some experience in game development, you still think you don\u0026rsquo;t have all the skills you need and never start working on your dream game, which is also a problem. It is rather common for people to understand the basics and then proceed with development while investigating what they don\u0026rsquo;t understand. So, if you have enough skills, you should be able to start developing your dream game already.\nWorkload barriers Next, games that include 8 to 12 elements in the above list are more of a workload problem than a technical one. Of course, even for games that are not included in the above list, the overall workload will be enormous if one tries to include many elements in the game. In this case, it is almost impossible to manage on one\u0026rsquo;s own. For the individual developer, this is a frustrating fact, though.\nImagine a recent AAA (Triple-A) game. Think of the latest numbered title in a series such as \u0026ldquo;Final Fantasy,\u0026rdquo; \u0026ldquo;Uncharted,\u0026rdquo; or \u0026ldquo;Monster Hunter,\u0026rdquo; for example. Hundreds of developers working intensively in their respective areas of expertise (game design, graphics, programming, music, etc.) and still developing the game for a year or two, or even longer. By simple arithmetic, a game that takes 100 people one year to make by one person would take 100 years. In other words, even if you devote your entire life to the game, you will not be able to complete it. If the game you want to make is such a large-scale game, you will probably have to get a job at a game company or start a company and gather a group of friends. Even if you get a job, your technical skills will be tested, so in that sense, you will probably prioritize self-improvement and save your dream game for after you get a job.\nHowever, I must add that the development of AAA titles is often extremely demanding, especially in the pre-launch period. The idea that \u0026ldquo;games are a comprehensive art form and the developer is an artist\u0026rdquo; seems to be distorted, and the value system that \u0026ldquo;it\u0026rsquo;s not labor, it\u0026rsquo;s just passionate immersion in art\u0026rdquo; permeates, leading to a situation that is far removed from the way labor is usually done.\nIn order to give form to a dream game through individual development, we must examine carefully what elements are truly necessary for a game and constantly consider drastically cutting out all other elements. How energy-efficiently you can develop and how simple and interesting you can make the game is where your game design skills are put to the test. We should always have a subtractive mindset.\nMake from simple games By the way, how can a game development novice improve his/her game development skills without becoming frustrated? The first step is to start with simple games which are easy to make.\nThis logic is not limited to games. For example, learning to draw, play a musical instrument, or anything else should start from the easiest part. To draw a beautiful picture, you must first develop your drawing skills and learn the theory of composition, perspective, and so on, or you will not be able to draw a convincing picture. With guitar, one should learn hand form and the placement of notes on the fingerboard, and gradually become able to play at a high level after understanding the theory of chords, chord progressions, etc. No one can start out painting like Gogh or playing the guitar like Clapton.\nSo, what is a relatively easy game for beginners to make? It is, of course, a breakout. Just by searching the Internet, you will see that it is often used as a subject for tutorials for beginners.\nThis site also has a tutorial on a breakout with Godot Engine (English version in preparation). It is packed with the basics of game making, so I recommend it to anyone who is not sure where to start. I started with a breakout and learned a lot of the basics. Specifically, the breakout requires three main types of objects: paddles, balls, and blocks, and the different ways of controlling each of these objects - paddles that are moved by player input, balls that are moved by physics, and blocks that do not move - are easy to understand and different, which is ideal for beginners. The different ways of controlling each of these objects are easy to understand, making them ideal for beginners. Then, when you combine them into a single game, you realize that the whole game is a collection of small parts. This experience will be important for creating larger games in the future.\nTutorials\u0026#39; links [Godot Tutorial] Basic Breakout! [P1] Creating a Breakout clone in Godot in 10 minutes! Another game often seen in tutorials for beginners is the pong game. This game is played by bouncing a ball back and forth with paddles on both sides, much like ping pong (table tennis). It is very similar to the breakout games, so it is relatively easy to start playing.\nTutorials\u0026#39; links Learn Godot by creating Pong Although a little more challenging, a space asteroids game, which also has many tutorials for beginners, is also good for beginners. In this game, you control a fighter jet in outer space, shooting meteorites to destroy them and avoid collisions, while shooting down enemy aircraft before they shoot you down. I had a little experience with GameMaker before I started using Godot Engine, and the first game I tried was the tutorial of a space asteroid game.\nTutorials\u0026#39; links Space Asteroid Arcade Shooter Godot Tutorial - CodingKaiju My First Game - Intro to GameMaker - Space Rocks (Part 1) Finally, if you choose Godot as your game engine, a beginner\u0026rsquo;s tutorial is available on the official Godot website. This is a so-called avoidance game. Enemy characters appear from all directions from outside the screen, and you simply dodge them. You can see that the game is designed so that you can learn the basics of the game. It does not take much time and is easy to start, so it is highly recommended.\nTutorials\u0026#39; links Your first 2D game Your first 3D game Once you have a basic understanding of game development, such as the breakout games, the next step would be to try a sample-like tutorial that is similar to your dream game.\nFor example, if you want to make a side-scrolling, exploratory action game in the Metroidvania genre, you should go through the basic platformer tutorials. A platformer is a side-scrolling action game that mainly consists of jumping action, like the Super Mario Bros. series from the NES and Super Nintendo era.\nWe have a tutorial on this site, and you can find many other easy-to-understand tutorials on the Internet.\nTutorials\u0026#39; links How to Make a Complete Game with Godot Godot 2D Platformer tutorial : Ultimate Guide To Make Games Godot Engine 3 - Platform Game Tutorial Make Your First 2D Game with Godot: Player and Enemy (beginner tutorial part 1) Decompose the dream game into individual games When you have reached the stage of developing your dream game, it is quite difficult to concentrate on it and continue development for a long period. Passion is something that sometimes seems to disappear in the middle of a project.\nTherefore, if the dream game you want to create contains multiple elements, it is a good idea to break up the elements and structure each one as a stand-alone game. The smaller the scale, the less likely you are to fail.\nFor example, let\u0026rsquo;s say you want to make a game in which you battle monsters with puzzles, and when you win, you can turn the monsters into pets and raise them. In this case, first, create a game with only puzzle elements and release it. Next, you make and release another game with only the nurturing element. Then, after that, combine these two games into a new game.\nOf course, you will need to update the UI, character design, sound, etc. so that the game does not appear to be \u0026ldquo;just a combination of two existing games,\u0026rdquo; but since the core game system is already in place, we can complete the game relatively quickly. In this way, you can release new games in a short period and gradually get closer and closer to completing your dream game.\nThe advantage of continuing to release games in a short period is to maintain motivation for development. For an individual developer, developing a single game over a year is difficult, to say the least, because of the various uncertainties and boredom that can arise. If you give up halfway through, all the time and effort you put into it will have been wasted. However, if you consistently complete and release even small games, you can enjoy a sense of accomplishment at the right time, and it is easy to maintain motivation. Also, user feedback on individual games can be utilized for future dream games. For an individual developer, this would be a huge advantage.\nConclusion In this article, I have shared the following important things to keep you from giving up on your dream game.\nGame development, which requires difficult technology, tends to fail if it is not accompanied by skills. Large-scale games cannot be developed by an individual, so you need to get a job at a company or gather a group of friends to form a company. If you start by making simple games, you can maintain your motivation and gradually learn the necessary skills. If you break down the elements of your dream game and release them as individual games in a short period of time, you can maintain your motivation and gradually bring your dream game closer to completion. It is natural to want to jump right into what you want to do, to want to skip the tedious learning of the basics, and to want to achieve results right away. However, if you try simple game development while watching a tutorial, you will discover new things and feel personal growth, and it is a lot of fun. I sincerely hope that you will not be averse to learning the basics. Also, there is no problem at all to challenge advanced game development with the intention of \u0026ldquo;going back to the easy part if it is difficult. If you don\u0026rsquo;t lose heart, you can get back up again and again.\n","permalink":"https://www.peanuts-code.com/en/posts/post0002_development_starts_small/","summary":"This article is especially worth reading if you are a beginner who has just started or is thinking about starting game development. We hope you will read it through to the end.\nNow, do you have a dream game that you really want to make? Many people who have started or are thinking of starting game development probably dream of such a game. And that game will have plenty of elements of games that you have played and been influenced by in your life.\nAs you can probably guess, this article is now going to make the claim that you should save your dream game for the future.","title":"Game development starting with something simple"},{"content":"In this tutorial, we are going to make four types of guns that commonly appear in 2D top-down shooters. Specifically, they are as follows.\nHandgun Shotgun Machine gun Laser Gun Environment This tutorial was created in the following environment\n・Godot version: 3.4.2\n・Computer OS version: macOS 11.6.5\nSince this tutorial will focus on gun creation, the following has been prepared in advance.\n1. Game world A scene called \u0026ldquo;World.tscn\u0026rdquo; was prepared, and the appearance was simply created by adding a \u0026ldquo;TileMap\u0026rdquo; node. In addition to the \u0026ldquo;TileMap\u0026rdquo; node, a \u0026ldquo;Player\u0026rdquo; node and several \u0026ldquo;Obstacle\u0026rdquo; nodes were added. For these, we created individual scenes and added the instances.\n2. Player Character Created as \u0026ldquo;Player.tscn\u0026rdquo; scene. The root node is the \u0026ldquo;KinematicBody2D\u0026rdquo; class, and the \u0026ldquo;Sprite\u0026rdquo; and the \u0026ldquo;CollisionShape2D\u0026rdquo; were added as child nodes. The texture of the \u0026ldquo;Sprite\u0026rdquo; node is a hitman with a gun. A node named \u0026ldquo;Muzzle\u0026rdquo; of the \u0026ldquo;Position2D\u0026rdquo; class was placed at the tip of the image of the gun held by the hitman. This will be used later to specify the position where the bullet instance is generated when the gun is fired.\nThe following actions have already been added to the input map. Used to move the player character, shoot, and switch guns.\n- up: W key - used to move the player character forward\n- down: S key - used to move the player character backward.\n- fire: Left mouse button - fires the gun.\n- switch: Right mouse button: Switches between gun types.\nNote that, for the sake of brevity in the tutorial, the player character\u0026rsquo;s sprite remains the same, even if the gun type is changed. Let\u0026rsquo;s say it looks like a handgun, but it can be a machine gun, a laser gun, or anything else.\n3. Obstacle We created a scene called \u0026ldquo;Obstacle.tscn\u0026rdquo;. All the brown crate objects on the screen are instances of this scene. The root node is the \u0026ldquo;StaticBody2D\u0026rdquo; class, and the \u0026ldquo;Sprite\u0026rdquo; and the \u0026ldquo;CollisionShape2D\u0026rdquo; were added as its child nodes.\nWith these preparations, when the project is executed, the world, hitman, and obstacles are drawn as shown below, and the hitman is currently only capable of movement operations.\nThe project files for this tutorial are located at GitHub repository . If you download the .zip file and import the \u0026ldquo;Start\u0026rdquo; folder into Godot Engine, you can start from the project with only the above preparations completed. If you want to check the completed project immediately, you can import the \u0026ldquo;End\u0026rdquo; folder.\nIn addition, all of the assets that have been imported into this project were downloaded from the KENNEY website. We would like to thank KENNEY for providing us with a wide variety of very easy-to-use assets with the license CC0. The following asset packs were used this time.\nTopdown Shooter Particle Pack Now let\u0026rsquo;s proceed with the implementation of the gun.\nCreating a bullet scene First, let\u0026rsquo;s create the bullet scene. Since the bullet scene can be used for all three types of guns (handgun, shotgun, and machine gun), let\u0026rsquo;s create the bullet scene first.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Node\u0026rdquo; for \u0026ldquo;Create Root Node\u0026rdquo;. Select the \u0026ldquo;Area2D\u0026rdquo; class as the root node and rename it to \u0026ldquo;Bullet\u0026rdquo;. Add a child node of the \u0026ldquo;Line2D\u0026rdquo; class to the root node. The only use of this node in this tutorial is to create the appearance of a bullet. Of course, you may prepare a texture image for the bullet and make it the \u0026ldquo;Sprite\u0026rdquo; instead of the \u0026ldquo;Line2D\u0026rdquo;. Add a child node of the \u0026ldquo;CollisionShape2D\u0026rdquo; class to the root node. Add a child node of the \u0026ldquo;VisibilityNotifier2D\u0026rdquo; class to the root node. This is used to signal when a bullet fired by a gun goes off the screen and to release the bullet instance. save the scene once. The destination folder is provided, so save the scene so that the file path is \u0026ldquo;res://Bullet/Bullet.tscn\u0026rdquo;. The scene tree should now look like the following.\nThen, edit each node.\nDraw a path for the \u0026ldquo;Line2D\u0026rdquo; node in the 2D workspace. Draw a straight line path by first hitting the first point at (-5, 0) and then the second point at (5, 0). You can also type directly in the inspector.\nIn the inspector, set the value of the \u0026ldquo;Width\u0026rdquo; property of the \u0026ldquo;Line2D\u0026rdquo; node to 16.\nSpecify the bullet color with the \u0026ldquo;Default Color\u0026rdquo; property. Of course, you can set the color to your own preference. In this tutorial, I specified a bluish-gray color #708293 as a sample.\nSet the \u0026ldquo;Capping\u0026rdquo; \u0026gt; \u0026ldquo;End Cap Mode\u0026rdquo; property to \u0026ldquo;Round\u0026rdquo;. The end of the path (the second point) should now be rounded. This is much more bullet-like, isn\u0026rsquo;t it?\nOn the 2D workspace, the \u0026ldquo;Line2D\u0026rdquo; should now look like this.\nAssign a \u0026ldquo;new RectangleShape2D\u0026rdquo; resource to the \u0026ldquo;Shape\u0026rdquo; property of the \u0026ldquo;CollisionShape2D\u0026rdquo; node. Adjust the collision shape to match the bullet shape created by the \u0026ldquo;Line2D\u0026rdquo; in the 2D workspace. You can make it exactly the same size as the bullet, or you can make it slightly smaller than the bullet size. In this sample, the value of the \u0026ldquo;Extents\u0026rdquo; property of the resource \u0026ldquo;RectangleShape2D\u0026rdquo; is (5, 2).\nAdjust the shape of the \u0026ldquo;VisibilityNotifier2D\u0026rdquo; node in the 2D workspace. We will use the signal that is emitted when this shape goes off the screen. The length in the y-axis is the same. The size of the shape can be approximate. In this sample, the \u0026ldquo;Scale\u0026rdquo; property value is (0.5, 0.1).\nThat\u0026rsquo;s it for adding nodes and editing the properties of each node.\nNow we will attach the script to the root node and start coding.\nAttach the script to the root node. Create the file path as \u0026ldquo;res://Bullet/Bullet.gd\u0026rdquo;. Edit the \u0026ldquo;Bullet.gd\u0026rdquo; script as follows. ### Bullet.gd ### extends Area2D # Bullet speed per second var speed = 1500 # Direction vector of bullet flying: once (0, 0) var direction = Vector2.ZERO # physics process: built-in method called 60 times/second func _physics_process(delta): # Get the x value of the direction vector from which the bullet will be fired by cosine function from the bullet\u0026#39;s current rotation angle direction.x = cos(global_rotation) # Get the y value of the direction vector from which the bullet will be fired by as a sine function from the current rotation angle of the bullet direction.y = sin(global_rotation) # Move the bullet every frame by direction * speed translate(direction * speed * delta) Next, let\u0026rsquo;s connect the signal that is sent out when the bullet hits the physics body to this script. Since the root node \u0026ldquo;Bullet\u0026rdquo; is an \u0026ldquo;Area2D\u0026rdquo; class, select the root node \u0026ldquo;Bullet\u0026rdquo; in the scene tree dock, select the \u0026ldquo;body_entered(body)\u0026rdquo; signal in the node dock \u0026gt; Signal tab, and click \u0026ldquo;Connect\u0026rdquo; button to connect it (or double-click the signal name).\nbody_entered signal connected Once connected, edit the automatically added method _on_Bullet_body_entered as follows.\n### Bullet.gd ### # Method called by the signal emitted when the bullet hits the physics body func _on_Bullet_body_entered(body): # if the body hit is an obstacle if body.is_in_group(\u0026#34;Obstacles\u0026#34;): # free the obstacle object body.queue_free() # free the bullet instance queue_free() Note that I have already added the root node of the \u0026ldquo;Obstacle\u0026rdquo; scene to the group \u0026ldquo;Obstacles\u0026rdquo; in advance.\nNow, if it hits an outer wall, only the bullets will be freed, and if it hits an obstacle, the obstacle and the bullets will be freed.\nWe will add one more signal. Let\u0026rsquo;s connect the \u0026ldquo;screen_exited()\u0026rdquo; signal, which is emitted when the \u0026ldquo;VisibilityNotifier2D\u0026rdquo; node disappears from the screen, to the \u0026ldquo;Bullet.gd\u0026rdquo; script. The procedure is the same as the previous signal connection, just select the \u0026ldquo;VisibilityNotifier2D\u0026rdquo; node in the scene tree dock and connect the \u0026ldquo;screen_exited()\u0026rdquo; signal in the Node Dock \u0026gt; Signal tab.\nOnce connected, edit the automatically added method _on_VisibilityNotifier2D_screen_exited as follows.\n### Bullet.gd ### # Method called by the signal emitted when a VisibilityNotifier2D node goes off-screen func _on_VisibilityNotifier2D_screen_exited(): # free the bullet instance queue_free() The bullet will now be freed when it goes off-screen.\nThe bullet scene is now complete.\nImplementing the handgun Let\u0026rsquo;s start with the simplest handgun (pistol) to shoot. The script to be edited is the \u0026ldquo;Player.gd,\u0026rdquo; but since some code has already been prepared in the preliminary stage, let\u0026rsquo;s check that first.\nSee the prep part of the Player.gd code ### Player.gd ### extends KinematicBody2D # Preloaded bullet scene reference const bullet_scn = preload(\u0026#34;res://Bullet/Bullet.tscn\u0026#34;) # Guns currently in use (comment below for index and gun type var gun = 0 # 0: hand # 1: shot # 2: machine # 3: lazer # Speed of player character var speed = 200 # Speed with direction of player character var velocity = Vector2() # Referencing the Muzzle node onready var muzzle = $Muzzle # Method called when the scene is loaded func _ready(): rotation_degrees = 270 # Make the player look up at the start of the game # Physics process: method called 60 times/sec by default func _physics_process(delta): move()　# call method to move player character switch_gun() # call method to switch gun type fire() # call method to fire the gun # Method to move player character func move(): look_at(get_global_mouse_position()) # make the character look towards the mouse cursor velocity = Vector2() # initialize velocity to (0, 0) if Input.is_action_pressed(\u0026#34;down\u0026#34;): # if S key is pressed... velocity = Vector2(-speed, 0).rotated(rotation) # set velocity backwards if Input.is_action_pressed(\u0026#34;up\u0026#34;): # if W key is pressed... velocity = Vector2(speed, 0).rotated(rotation) # set velocity forward velocity = move_and_slide(velocity) # move according to velocity # Method to switch gun type func switch_gun(): if Input.is_action_just_pressed(\u0026#34;switch\u0026#34;): # if mouse right button click... if gun \u0026lt; 3: # if gun assignment number is less than 3... gun += 1 # increment the assigned number by 1 else: # if gun assignment number is 3 (last number)... gun = 0 # set the gun\u0026#39;s assigned number to 0 print(\u0026#34;Switched to \u0026#34;, gun) # Display in output panel for debugging # Method to fire the gun func fire(): pass So the fire method is currently empty. Update it as follows.\n### Player.gd ### # Method to fire the gun func fire(): # If the gun type is handgun (0) and the left mouse button is clicked if gun == 0 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): # Call a method to create and fire a bullet instance put_bullet() The method put_bullet appears here, which is the method we are going to define. Let\u0026rsquo;s define it by adding the following code under the fire method.\n### Player.gd ### # Method to create and fire a bullet instance func put_bullet(): # reference to a bullet scene instance var bullet = bullet_scn.instance() # make the position of the bullet instance the same as the muzzle position bullet.global_position = muzzle.global_position # set the orientation of the bullet instance to be the same as the Player\u0026#39;s orientation bullet.rotation_degrees = rotation_degrees # Make it a child of its parent node (World node) instead of Player node get_parent().add_child(bullet) # make it the second child of World (front from the tile map, back from the player character) get_parent().move_child(bullet, 1) You should now have a handgun implementation. Let\u0026rsquo;s run the project and check it out.\nImplementing the shotgun The next step is to implement a shotgun. A shotgun in a top-down shooter would generally be designed to have multiple bullets each flying forward at a slightly different angle. This is a powerful gun that can wipe out multiple objects over a wide area in a single shot.\nLet\u0026rsquo;s start by updating the fire method.\n### Player.gd ### func fire(): if gun == 0 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): put_bullet() # If the gun type is shotgun (1) and the left mouse button is clicked if gun == 1 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): # 5 loops for n in 5: # Call the method that creates an instance of the bullet and fires it, passing a value as an argument. put_bullet(n) Added a second if block to the fire method. If the property gun has a value of 1 (the assigned number of the shotgun), the shotgun can be fired with a left mouse click. The content of the if block calls put_bullet 5 times in a for loop, but unlike the previous handgun, the argument is passed n, the number of times around the loop. We will see how this method handles the arguments it receives as we update the put_bullet method later.\nfunc put_bullet(dir_offset = 2): # Added argument dir_offset, default value is 2 var bullet = bullet_scn.instance() bullet.global_position = muzzle.global_position bullet.rotation_degrees = rotation_degrees + (20 - 10 * dir_offset) # 更新 get_parent().add_child(bullet) get_parent().move_child(bullet, 1) It is a little complicated, but if the argument dir_offset is not entered when the method is called, the default value of 2 is automatically passed as an argument. The third line in the method block specifies the rotation angle (direction) of the bullet, but in the case of a handgun, for example, the method is called without specifying an argument, so the default value of 2 is passed as the argument, the 20 - 10 * dir_offset part becomes 0, and the bullet\u0026rsquo;s angle is the same as the player character is facing.\nOn the other hand, in the case of a shotgun, this put_bullet method is called 5 times in the for loop in the fire method, and the number of loop laps n (counting from 0 to 4) is passed as the argument dir_offset. Therefore, the angle of the bullet changes as follows, depending on how many times the loop has looped.\nLoop 0: The angle the player character is facing + 20° Loop 1: The angle the player character is facing + 10° Loop 2: The angle the player character is facinge + 0° Loop 3, The angle the player character is facing + -10° Loop 4, The angle the player character is facing + -20. With the above code, five bullets are fired simultaneously at different angles of 10° in the range from -20° to +20° relative to the direction the Player is facing, completing a gun that can fire a wide range of bullets at once. The computer processes a loop of about five times in an instant, so the bullets will be fired at different angles at about the same time.\nYou should now have a shotgun implementation. When you run the project to check it out, click the right mouse button once to switch to shotgun and then try firing it.\nImplementing the machine guns Next, let\u0026rsquo;s look at machine guns. Unlike guns that require a single pull of the trigger to fire, machine guns can fire automatically and continuously as long as the trigger is pulled. Although machine guns cannot fire over a wide area in a single shot as shotguns can, they fire automatically at high speed and can wipe out a wide range of objects as soon as the player character himself turns.\nNow let\u0026rsquo;s add the code for the machine gun to the \u0026ldquo;Player.gd\u0026rdquo; script.\nFirst, we added the property interval.\n### Player.gd ### var speed = 200 var velocity = Vector2() # Count until the next bullet of the machine gun is fired var interval: int = 0 # 追加 The specification of the machine gun is to automatically fire bullets continuously if the left mouse button is held down, but if the fire method is called every frame in the _physics_process method, the interval between bullets is too short and the bullets appear to stop (see GIF image below).\nThe frame rate of 60 FPS for the physical process is quite fast. So this time, we will add +1 to the interval property every frame so that a bullet is fired when the count exceeds 5. In other words, the bullet will be fired once every 5 frames.\nSo let\u0026rsquo;s add an if block for the machine gun to the fire method.\nfunc fire(): if gun == 0 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): put_bullet() if gun == 1 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): for n in 5: put_bullet(n) # If the gun type is machine gun (2) and the left mouse button is pressed if gun == 2 and Input.is_action_pressed(\u0026#34;fire\u0026#34;): # +1 count to the next bullet interval += 1 # If the count is greater than 5 if interval \u0026gt;= 5: # Set count back to 0. interval = 0 # Call a method that creates and fires a bullet instance with no arguments put_bullet() Note that the handgun and shotgun use the is_action_just_pressed method of the Input class for the if condition, but this method does not continuously detect the input even if the left button is pressed continuously. On the other hand, the machine gun uses the is_action_pressed method. This method has a similar name only without \u0026ldquo;just,\u0026rdquo; but this one is suitable for use in \u0026ldquo;press-and-hold\u0026rdquo; operations, since input is detected every frame even if the button is kept pressed.\nYou should now have a machine gun implemented. When you run the project to check it, click the right mouse button twice to switch to machine gun and then try to fire it.\nCreate a laser scene The last step is to implement the laser gun. A laser gun fires lasers, not bullets, so let\u0026rsquo;s start by creating the scene of the laser being fired. Add particles and animations to give it a minimal effect.\nSelect \u0026ldquo;Scene\u0026rdquo; menu \u0026gt; \u0026ldquo;New Scene\u0026rdquo;. Select \u0026ldquo;Other Node\u0026rdquo; for \u0026ldquo;Generate Root Node\u0026rdquo;. Select the \u0026ldquo;RayCast2D\u0026rdquo; class as the root node and rename it to \u0026ldquo;Laser\u0026rdquo;. Add a child node of the \u0026ldquo;Line2D\u0026rdquo; class to the root node. It will be used to create the look of the laser as well as the bullet scene. Of course, there is a way to prepare a texture image for the laser and make it the \u0026ldquo;Sprite\u0026rdquo; instead of the \u0026ldquo;Line2D,\u0026rdquo; but we did not use it this time. Add a child node of the \u0026ldquo;Particle2D\u0026rdquo; class to the root node. This is used to add the effect of bubbling particles when the laser hits the object. Add a child node of the \u0026ldquo;Tween\u0026rdquo; class to the root node. This will be used to slowly increase the width of the laser from 0 to a certain width when the laser is fired, and vice versa when the laser ends. Save the scene. The destination folder is already prepared, so save the scene so that the file path is \u0026ldquo;res://Laser/Laser.tscn\u0026rdquo;. The scene tree should now look like the following.\nNext, edit each node.\nIn the Inspector, turn on the \u0026ldquo;Enabled\u0026rdquo; property of the root \u0026ldquo;Laser\u0026rdquo; node and set the \u0026ldquo;Cast To\u0026rdquo; property to (2000, 0).\nIt should now look like the following screenshot on the 2D workspace.\nDraw the path of the \u0026ldquo;Line2D\u0026rdquo; node in the 2D workspace. Draw a straight-line path by hitting the first point at (0, 0) and then the second point at (200, 0). You can also type directly in the inspector. The second point is controlled by a script, so if the y value is 0, the x value can be any value that is easy to see in the 2D workspace.\nIn the inspector, set the \u0026ldquo;Width\u0026rdquo; property of the \u0026ldquo;Line2D\u0026rdquo; node to 16.\nSpecify the color of the laser with the \u0026ldquo;Default Color\u0026rdquo; property. Of course, you can set the color of the laser to your image. In this tutorial, we use #00b1ff blue as a sample.\nOn the 2D workspace, the \u0026ldquo;Line2D\u0026rdquo; should now look roughly like this.\nfrom here, edit the properties of the \u0026ldquo;Particle2D\u0026rdquo; node as follows. It is going to be hard work because there are many properties to be edited, but let\u0026rsquo;s do our best. First, apply the resource \u0026ldquo;res://Assets/circle_05.png\u0026rdquo; to the \u0026ldquo;Textures\u0026rdquo; \u0026gt; \u0026ldquo;Texture\u0026rdquo; property.\nTurn on the \u0026ldquo;Emitting\u0026rdquo; property.\nSet the value of the \u0026ldquo;Drawing\u0026rdquo; \u0026gt; \u0026ldquo;Visibility Rect\u0026rdquo; property to (x: -50, y: -50, w: 100, h: 100).\nSet the \u0026ldquo;Transform\u0026rdquo; \u0026gt; \u0026ldquo;Position\u0026rdquo; property to (x: 200, y: 0) and \u0026ldquo;Transform\u0026rdquo; \u0026gt; \u0026ldquo;Scale\u0026rdquo; property to (x: 0.1, y: 0.1)\nAssign a \u0026ldquo;New ParticleMaterial\u0026rdquo; to the \u0026ldquo;Process Material\u0026rdquo; property.\nFrom here, we will edit the properties of the \u0026ldquo;ParticleMaterial\u0026rdquo; resource we have just assigned.\n\u0026ldquo;Emission Shape\u0026rdquo; ＞\nChange the \u0026ldquo;Shape\u0026rdquo; property to \u0026ldquo;Box\u0026rdquo;.\n\u0026ldquo;Direction\u0026rdquo; ＞\nSet the \u0026ldquo;Direction\u0026rdquo; property to (x: -1, y: 0, z: 0), which is the negative direction of the x axis. Set the \u0026ldquo;Spread\u0026rdquo; property to 60 in order to spread particles with a width of 60°.\n\u0026ldquo;Gravity\u0026rdquo; ＞\nSet the \u0026ldquo;Gravity\u0026rdquo; property to (x: -300, y: 0, z: 0). This will add gravity in the negative direction of the x axis.\n\u0026ldquo;Initial Velocity\u0026rdquo; ＞\nSet the \u0026ldquo;Velocity\u0026rdquo; property to 800. This is probably the speed per second.\n\u0026ldquo;Scale\u0026rdquo; ＞\nAssign the resource \u0026ldquo;New CurveTexture\u0026rdquo; to the \u0026ldquo;Scale Curve\u0026rdquo; property.\nNext, edit the properties of the assigned resource. \u0026ldquo;CurveTexture\u0026rdquo; ＞ Assign the \u0026ldquo;New Curve\u0026rdquo; property to the \u0026ldquo;Curve\u0026rdquo; property and hit two points as shown in the screenshot below to create a curve and set the change in value. Now, each particle will gradually become smaller as time passes.\n\u0026ldquo;Color\u0026quot;＞\nAssign the resource \u0026ldquo;New GradientTexture\u0026rdquo; to the \u0026ldquo;Color Ramp\u0026rdquo; property. This is for the purpose of gradually changing the color of the particles from the time they are created to the time they disappear.\nAssign the resource \u0026ldquo;New Gradient\u0026rdquo; to the \u0026ldquo;GradientTexture\u0026rdquo; resource property assigned above.\nEdit the properties of the \u0026ldquo;Gradient\u0026rdquo; resource. In the inspector, intuitively specify three colors as the basis for the gradient.\nLeftmost: #001096 (deep blue) Slightly left of center: #2780ff (light blue) Rightmost: #00ffffff (white with opacity 0)\nThis would result in the following resource properties.\nThis completes the process of adding nodes and editing the properties of each node.\nFrom here, attach the script to the root node \u0026ldquo;Laser\u0026rdquo; and start coding.\nAttach the script to the root node \u0026ldquo;Laser\u0026rdquo; and create the file path as \u0026ldquo;res://Laser/Laser.gd Edit the \u0026ldquo;Laser.gd\u0026rdquo; script as follows. ### Laser.gd ### extends RayCast2D # Reference to the Line2D node onready var line = $Line2D # Reference to the Particle2D node onready var particle = $Particles2D # Reference to the Tween node onready var tween = $Tween # Methods called when the scene is loaded func _ready(): # Turn off the Emitting property of the Particle2D node... # ...to prevent it from being left on in the inspector particle.emitting = false # Set up the animation of the tween node... # ...change the Width property of the Line2D from 0 to 10 over 0.5 seconds tween.interpolate_property(line, \u0026#34;width\u0026#34;, 0, 10.0, 0.5) # Start the animation of the tween node tween.start() # Physics process: Method called at 60FPS func _physics_process(delta): # if RayCast2D (root node) is colliding with the physics body... if is_colliding(): # set the position of the second point (endpoint) of the Line2D node to the position where RayCast2D collides with the physics body line.set_point_position(1, to_local(get_collision_point()))) # if the object collided with was an obstacle... if get_collider().is_in_group(\u0026#34;Obstacles\u0026#34;): # Referencing an obstacle instance var obstacle = get_collider() # Add the value of delta to the laser irradiation time of the obstacle instance obstacle.irradiated_time += delta # If the laser irradiation time exceeds the maximum irradiation time... if obstacle.irradiated_time \u0026gt; obstacle.max_irradiation: # Free the obstacle instance obstacle.queue_free() # If RayCast2D (root node) does not collide with the physical body... else: # Set the position of the second point (end) of the Line2D node to be the same as the position of the tip of the RayCast2D (root node) line.set_point_position(1, cast_to) # Set the position of the Particle2D node to be the same as the end position of the path of the Line2D node particle.position = line.points[1]. # Turn on the Emitting property of the Particle2D node (start particle animation) particle.emitting = true # If the finger is released from the left mouse button... if Input.is_action_just_released(\u0026#34;fire\u0026#34;): # Call the method to stop the laser stop_laser() # Define a method to stop the laser func stop_laser(): # Set up the animation of a tween node: change the Width property of the Line2D node from 10 to 0 over 0.5 seconds tween.interpolate_property(line, \u0026#34;width\u0026#34;, 10.0, 0, 0.5) # Start the animation of the tween node tween.start() # Wait for the tween node to finish animating yield(tween, \u0026#34;tween_completed\u0026#34;) # Free the tween node queue_free() A few additional notes on this code. In the script \u0026ldquo;Obstacle.gd\u0026rdquo; attached to the root node of the obstacle scene \u0026ldquo;Obstacle.tscn\u0026rdquo; that has been created as a preliminary step, two properties, irradiated_time and max_irradiation, are defined. The former is the irradiation time of the laser, and the latter is the maximum irradiation time of the laser. This system was created based on the idea that rather than destroying obstacles immediately after the laser strikes them, it would be more laser-like if the obstacles were destroyed after a certain amount of time (maximum irradiation time: 0.2 seconds).\nThe laser scene is now ready. The next step is to update the \u0026ldquo;Player\u0026rdquo; scene so that it can fire the laser.\nImplementing the laser gun Now that we have a laser scene, let\u0026rsquo;s implement the laser gun. The first specification for the laser gun is to add an instance of \u0026ldquo;Laser.tscn\u0026rdquo; created earlier to the \u0026ldquo;Player\u0026rdquo; scene when it fires. The player\u0026rsquo;s control should be the same as that of the machine gun, so that the gun will continue to fire as long as the left mouse button is held down. On the other hand, when the finger is released from the button, the \u0026ldquo;Laser.gd\u0026rdquo; script coded earlier will make the laser disappear and the instance will be released.\nNow let\u0026rsquo;s edit the \u0026ldquo;Player.gd\u0026rdquo; script in concrete terms. First, I want you to add the fourth if block in the fire method as follows.\n### Player.gd ### func fire(): if gun == 0 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): put_bullet() if gun == 1 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): for n in 5: put_bullet(n) if gun == 2 and Input.is_action_pressed(\u0026#34;fire\u0026#34;): interval += 1 if interval \u0026gt;= 5: interval = 0 put_bullet() # If the gun-type is laser gun (3) and the left mouse button is pressed if gun == 3 and Input.is_action_just_pressed(\u0026#34;fire\u0026#34;): # Call a method to create and fire a laser instance load_laser() The fourth if block I added calls the load_laser method as long as the left mouse button is held down when the gun is the laser. This method is just about to be defined. Let\u0026rsquo;s add the following code under the put_bullet method.\n### Player.gd ### # Methods to create and fire laser instances func load_laser(): # Referencing instances of Laser.tscn var laser = laser_scn.instance() # Position the Laser instance at the same location as the muzzle laser.position = muzzle.position # Adds a Laser instance as a child node to the Player root node add_child(laser) # Move the Laser instance node to the 0th (backmost) of the Player root node\u0026#39;s child nodes move_child(laser, 0) After the \u0026ldquo;Laser\u0026rdquo; instance is created by pressing the left mouse button, the \u0026ldquo;Laser.gd\u0026rdquo; script controls the position, direction, length, and width of the laser, as well as the position of the particle at the tip. This includes freeing the \u0026ldquo;Laser\u0026rdquo; instance when the finger leaves.\nThat completes the implementation of the laser gun. When executing and checking the project, click the right mouse button three times to switch to the laser gun before firing.\nAfter it was completed, I realized that the laser might have been better in another color. It looks like a water gun or a high water pressure washer.\nLet\u0026rsquo;s run the project one last time, switching between the four guns as we play.\nConclusion This time, we implemented four types of guns that are often implemented in top-down shooter games. If you want to make them more detailed, it might be more interesting to add the following elements, for example\nChange the appearance and speed of bullets depending on the gun type. When switching guns, the sprite of the player character should also be changed. Add animations and pauses for reloading bullets and filling the laser with energy. Add particles like smoke and debris when bullets hit objects and are released. Set the damage to objects hit by each type of gun, and set a certain life value on the object side, such as HP, so that the object can be destroyed when its life reaches 0. Links KENNEY Godot online documentation: 2D Move Overview Godot online documentation: Line2D Godot online documentation: RayCast2D Godot online documentation: Particle System (2D) Godot online documentation: Particles2D Godot online documentation: ParticlesMaterial ","permalink":"https://www.peanuts-code.com/en/tutorials/gd0006_guns_of_topdown_shooter/","summary":"In this tutorial, we are going to make four types of guns that commonly appear in 2D top-down shooters. Specifically, they are as follows. Handgun Shotgun Machine gun Laser Gun Environment This tutorial was created in the following environment ・Godot version: 3.4.2 ・Computer OS version: macOS 11.6.5 Since this tutorial will focus on gun creation, the following has been prepared in advance. 1. Game world A scene called \u0026ldquo;World.tscn\u0026rdquo; was prepared, and the appearance was simply created by adding a \u0026ldquo;TileMap\u0026rdquo; node. In addition to the \u0026ldquo;TileMap\u0026rdquo;","title":"Four types of guns for top-down shooting in Godot Engine"},{"content":"When we develop a game, especially a big one, sometimes it may often happen that we can never find the scene which we want to edit or we cannot remember where the script file is, which we are going to edit.\nIn this article, I am going to introduce some so powerful and useful search features with keyboard shortcuts. Once you know those, you can reduce the huge amount of time looking for something which may be the most uninteresting in the game development. In addition, you can use the search features in a much faster way instead of looking for a script file and clicking it in the file system dock, for example.\nBy the way, we can see all default shortcuts in the official online documents of Godot. Be careful about that it says Alt as Option on macOS.\nGODOT DOCS Default editor shortcuts Anyway, why do not you try to use the searches because it is sure to improve work efficiency.\nI will introduce ones in order of the widest range of searches first.\nQuick Open To use Quick Open, perform the following keyboard shortcut on Godot editor. Be careful, it does not work on script editor so you need to switch to 2D or 3D Workspace if you use it.\nWindows: Shift \u0026#43; Alt \u0026#43; O macOS: Shift \u0026#43; Option \u0026#43; O For example, we rarely memorize the names of all the imported files so it must be faster to use Quick Open than to look for a file visually to find one from them.\nThe range of Quick Open search is all files. This means it includes sound files, texture files, font files, scene files, and script files. We can search them with the keyword of the　files\u0026rsquo; extensions or the part of the files\u0026rsquo; names.\nWe can also use this search feature to access a specific file quickly instead of directly finding and clicking it in the file system dock.\nQuick Open Scene To use Quick Open Scene, perform the following keyboard shortcut on Godot editor.\nWindows: Ctrl \u0026#43; Shift \u0026#43; O macOS: Cmd \u0026#43; Shift \u0026#43; O Quick Open Scene is very similar to Quick Open which I introduced firstly. The difference is the range of search of Quick Open Scene is narrower than Quick Open. It means the range is limited to scene files.\nQuick Open Script To use Quick Open Script, perform the following keyboard shortcut on Godot editor.\nWindows: Ctrl \u0026#43; Alt \u0026#43; O macOS: Cmd \u0026#43; Option \u0026#43; O The UI of Quick Open Script is also similar to Quick Open. The range of search of Quick Open Script is limited to script files.\nIt is really hard to find a script file from the sidebar of the script editor section in Godot editor after we made a lot of files. In addition, the situation tends to get much worse if we open many official documents there. It is a pain to find one visually even if the files are sorted in the alphabet. Therefore it would be better to use Quick Open Script.\nFind in Files To use Find in Files, perform the following keyboard shortcut on the Godot editor while you open the script editor.\nWindows: Ctrl \u0026#43; Shift \u0026#43; F macOS: Cmd \u0026#43; Shift \u0026#43; F This is a feature of the script editor. You can find a keyword in multiple script files at once. The search results will be shown in the \u0026ldquo;Search Results\u0026rdquo; panel which is placed at the bottom of the Godot editor. You can, then jump to the exact place of the word in the script which you choose if you click one from the list of the result of hits in the panel.\nYou can also search with filtering by a folder name. To do so, you just type the folder path in the box below the box of the keyword.\nIn addition, we can replace all the hit items with another word at once.\nFirstly, input a keyword and then click the replace button.\nAfter that, just do the following steps in the Search Result panel.\nTick some of the search results which you want to replace. Input the word with which you want to replace. Click Replace all button. Just make sure that this operation has no undo. Find To use Find feature, perform the following keyboard shortcut on the Godot editor while you open the script editor.\nWindows: Ctrl \u0026#43; F macOS: Cmd \u0026#43; F This is the narrowest search feature. We can search a keyword in a script. It might be a more common way of using this to move to the specific variable or function in a script, instead of looking for a word that is hard to be found.\nFind and Replace To find a word and replace with another word, perform the following keyboard shortcut on the Godot editor while you open the script editor.\nWindows: Ctrl \u0026#43; Alt \u0026#43; F macOS: Cmd \u0026#43; Option \u0026#43; F We can find a word and replace it with another word just by changing the key combination of the shortcut. It is useful for replacing a word such as a variable name or a function name that is only used in a specific script.\nConclusion In this article, we introduced the Godot editor\u0026rsquo;s convenient search function. All of the shortcut operations require some getting used to at first, but once your hands learn the key combinations, you will be able to work at high speed. We encourage you to use them.\nUPDATE\n2022/05/29 Transfered this article from \u0026ldquo;Posts\u0026rdquo; to \u0026ldquo;Tutorials\u0026rdquo;\n","permalink":"https://www.peanuts-code.com/en/tutorials/gd0009_various_searches/","summary":"When we develop a game, especially a big one, sometimes it may often happen that we can never find the scene which we want to edit or we cannot remember where the script file is, which we are going to edit.\nIn this article, I am going to introduce some so powerful and useful search features with keyboard shortcuts. Once you know those, you can reduce the huge amount of time looking for something which may be the most uninteresting in the game development. In addition, you can use the search features in a much faster way instead of looking for a script file and clicking it in the file system dock, for example.","title":"Powerful search features in Godot"},{"content":"Many people want to start game development but tend to give up because of their age. No, this is not limited to game development but can be applied to anything from playing the piano to being a YouTuber.\nFor some reason, it is a common perception that when you reach middle age, your physical and mental strength declines somehow. However, this is not true. There is no evidence that this socially accepted notion applies to you. It doesn\u0026rsquo;t matter if you are a middle-aged businessman, a first-grader, or a 90-year-old. The moment you decide you want to do something is the youngest time to start doing it.\nIn the end, life is about doing or not doing. At the age of 100 years of life, there are few cases where it is too late to start doing something. It would be a shame to make a decision based only on a vague impression that game development sounds too difficult for you. You will never know the truth until you try it.\nIt is a fact that game development is often thought of as a hurdle for the average person. When inexperienced people hear the word \u0026ldquo;game development,\u0026rdquo; they tend to imagine that they have to learn to program, that they don\u0026rsquo;t have a sense of design, that they can\u0026rsquo;t compose music, and so on. This impression of \u0026ldquo;difficult\u0026rdquo; gets stronger with age.\nBut again, age has nothing to do with it. If it seems difficult, it probably means that you will not be able to acquire the necessary skills. Why do they think that? It\u0026rsquo;s because they believe that at their age, their brain has deteriorated and they don\u0026rsquo;t have the energy or stamina to learn new things. Is it because they are comparing themselves to their younger days or the young people around them? What nonsense. If you can\u0026rsquo;t compare yourself with people who are living completely the same life as you, the difference will not be significant.\nBy the way, have you ever heard of Ms. Masako Wakamiya? She became a household name with \u0026ldquo;hinadan,\u0026rdquo; a game for seniors in which you have to arrange dolls. As the \u0026ldquo;oldest app creator\u0026rdquo; at the time, she was even approached directly by Apple CEO Tim Cook to meet with him. She too has been taking on various challenges because she thought it would be interesting, and I am very proud of her. She is proving that age does not matter.\nI\u0026rsquo;m about to turn 40, but I started programming two years ago in 2020, and I\u0026rsquo;ve also started developing games. I feel that I am in the best physical and mental shape of my life right now. I have the feeling that I can learn all kinds of new things as long as I am interested.\nHere, I have listed what exactly is needed to start game development. Anyone can start game development as long as the following three conditions are met.\nHave an interest in game development (feeling) Able to devote an hour or more to game development every day (time) Have a PC and an internet connection (environment) That\u0026rsquo;s it. What do you think? Even if you feel that it is difficult, don\u0026rsquo;t you think that anyone can start just by starting?\nFor those of you who have not yet decided to start game development, let\u0026rsquo;s get started right now. There\u0026rsquo;s no need to read the rest of this article. Let\u0026rsquo;s download the game engine right away.\nThe Official Web pages of Game Engines Godot Unity Unreal Engine GameMaker Studio 2 Cocos2d-x RPG Maker If you\u0026rsquo;re still hesitant after all this, you may be wondering why you should download a game engine. You might be thinking that it\u0026rsquo;s impossible to learn skills such as programming, graphic design, and music composition.\nIt is true that a long time ago, personal game development may have been a real hurdle to overcome.\nThis was because it was hard to set up a development environment and acquire the necessary skills. However, this is not the case now. The Internet is full of free know-how on how to make games, so it costs very little to learn. Furthermore, in this day and age, it is common to develop games using a tool called a game engine. The game engine takes care of all the complicated things, such as rendering graphics, physics calculations, camera adjustments, and so on. In other words, developers can concentrate on developing the game itself.\nEven the computers used for development can be of basic specifications, as long as they are connected to the Internet. Most game engines are multi-platform, so it doesn\u0026rsquo;t matter if you have a Windows or Mac computer.\nEven if you don\u0026rsquo;t have any design or composition skills, you can buy materials from the Asset Store. I have almost no composition skills either.\nFurthermore, some game engines do not require programming.\nFor example, a relatively popular game engine called \u0026ldquo;GameMaker Studio 2\u0026rdquo; has a feature called visual scripting. It is like visually laying out the necessary commands and connecting them. There are also other tools called the Tucool series, such as \u0026ldquo;RPG Maker\u0026rdquo; developed by ASCII. The company has developed many Maker-based applications that specialize in specific genres. These should be easy to use even if you have no programming knowledge. There are many different types of game engines available, so it is a good idea to check them out.\nThe first step is to use an engine that can be developed without programming. Then, when you want to make a more complex game, you can try programming. Even if you want to make an open-world online MMO game, you should keep the project in mind. Imagine what would happen if a boy who just started playing baseball went to a professional baseball game. It is almost certain that you will end up feeling depressed and quit, thinking \u0026ldquo;Oh, I can\u0026rsquo;t do that\u0026rdquo; or \u0026ldquo;I can\u0026rsquo;t be like that.\nTo tell you the truth, up until two years ago, I thought that programming was something completely different from what I was used to. However, when I started programming, I found that I was able to use programming to some extent even though I was self-taught, as I repeatedly googled and googled and googled. Each day\u0026rsquo;s progress is just a little bit different. But after a week, a month, or a year, I was surprised to find that before I knew it, I had acquired sufficient skills. The most important thing is to build up your skills little by little, every day. And personal development, for better or worse, can be done at your own pace. So you don\u0026rsquo;t have to suffer from unnecessary stress and pressure. It\u0026rsquo;s very important to build up your learning every day.\nNow that I\u0026rsquo;ve explained this, I think you understand the following.\nThe fact that game development seems difficult is just an impression. The hurdles to game development are not high If you have interest, time, and a PC with an Internet connection, you can start developing games right away. Let\u0026rsquo;s try again. If you are interested in starting game development, let\u0026rsquo;s start right this moment. Let\u0026rsquo;s download a game engine right away.\nThe Official Web pages of Game Engines Godot Unity Unreal Engine GameMaker Studio 2 Cocos2d-x RPG Maker ","permalink":"https://www.peanuts-code.com/en/posts/post0001_no_matter_how_old/","summary":"Many people want to start game development but tend to give up because of their age. No, this is not limited to game development but can be applied to anything from playing the piano to being a YouTuber.\nFor some reason, it is a common perception that when you reach middle age, your physical and mental strength declines somehow. However, this is not true. There is no evidence that this socially accepted notion applies to you. It doesn\u0026rsquo;t matter if you are a middle-aged businessman, a first-grader, or a 90-year-old. The moment you decide you want to do something is the youngest time to start doing it.","title":"Age Doesn't Matter When You Start Game Development"},{"content":" headless = true\n+++\n","permalink":"https://www.peanuts-code.com/en/homepage/","summary":"headless = true\n+++","title":""}]